<?xml version="1.0" encoding="UTF-8" standalone="yes"?>


<module description="I2C" id="I2C">
  
  
  <register acronym="I2C_REVNB_LO" description="This read-only register contains the hard-coded revision number of the module. A write to this register has no effect. I2C controller with interrupt using interrupt vector register (I2C_IV) is revision 1.x. I2C controller with interrupt using status register bits (I2C_IRQSTATUS_RAW) is revision 2.x." id="I2C_REVNB_LO" offset="0x0" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="RTL version." end="11" id="RTL" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="10" description="Major Revision. This field changes when there is a major feature change. This field does not change due to bug fix, or minor feature change." end="8" id="MAJOR" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="7" description="Indicates a special version for a particular device. Consequence of use may avoid use of standard Chip Support Library (CSL) / Drivers. 0 if non-custom." end="6" id="CUSTOM" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="Minor Revision This field changes when features are scaled up or down. This field does not change due to bug fix, or major feature change." end="0" id="MINOR" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="I2C_REVNB_HI" description="A reset has no effect on the value returned." id="I2C_REVNB_HI" offset="0x4" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Used to distinguish between old Scheme and current. Spare bit to encode future schemes." end="14" id="SCHEME" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="" end="12" id="Reserved2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="Function: Indicates a software compatible module family" end="0" id="FUNC" rwaccess="R" width="12"></bitfield>
  </register>
  
  
  <register acronym="I2C_SYSC" description="This register allows controlling various parameters of the peripheral interface." id="I2C_SYSC" offset="0x10" width="32">
    
  <bitfield begin="31" description="" end="10" id="Reserved_1" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="Clock Activity selection bits. Those bits (one bit for each clock signal present on the boundary of the module) are set to 1 to disable external clock gating mechanism in Idle Mode. Values after reset are low (for both 2 bits). Note: If the System (functional) Clock is cut-off, the module will assert a WakeUp event when it asynchronously detects a Start Condition on the I2C Bus. Note that in this case the first transfer will not be taken into account by the module (NACK will be detected by the external master)." end="8" id="CLKACTIVITY" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="7" description="" end="5" id="Reserved_2" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="4" description="Idle Mode selection bits. These two bits are used to select one of the idle mode operation mechanisms. Value after reset is 00 (Force Idle)." end="3" id="IDLEMODE" rwaccess="RW" width="2">
    <bitenum description="" id="Reserved" token="Reserved" value="0x3"></bitenum>
    <bitenum description="" id="Smart Idle mode" token="Smart Idle mode" value="0x2"></bitenum>
    <bitenum description="" id="No Idle mode" token="No Idle mode" value="0x1"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description="Enable Wakeup control bit. When this bit is set to 1, the module enables its own wakeup mechanism. Value after reset is low." end="2" id="ENAWAKEUP" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="SoftReset bit. When this bit is set to 1, entire module is reset as for the hardware reset. This bit is automatically cleared to 0 by the core and it is only reset by the hardware reset. During reads, it always returns 0. Value after reset is low. " end="1" id="SRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Autoidle bit. When this bit is set to 1, the module activates its own idle mode mechanism. By evaluating its internal state, the module can decide to gate part of his internal clock tree in order to improve the overall power consumption. Value after reset is high." end="0" id="AUTOIDLE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_IRQSTATUS_RAW" description="This register provides core status information for interrupt handling, showing all active events (enabled and not enabled). The fields are read-write. Writing a 1 to a bit will set it to 1, that is, trigger the IRQ (mostly for debug). Writing a 0 will have no effect, that is, the register value will not be modified. Only enabled, active events will trigger an actual interrupt request on the IRQ output line. " id="I2C_IRQSTATUS_RAW" offset="0x24" width="32">
    
  <bitfield begin="31" description="" end="15" id="Reserved_1" rwaccess="R" width="17"></bitfield>
    
  <bitfield begin="14" description="Transmit draining IRQ status. I2C Master Transmit mode only. This read/clear only bit is set to 1 when the module is configured as a master transmitter, the TX FIFO level is below the configured threshold (TXTRSH) and the amount of data still to be transferred is less than TXTRSH. When this bit is set to 1 by the core, CPU must read the I2C_BUFSTAT.TXSTAT register in order to check the amount of data that need to be written in the TX FIFO. Then, according to the mode set (DMA or interrupt), the CPU can enable the DMA draining feature of the DMA controller with the number of data bytes to be transferred (I2C_BUFSTAT.TXSTAT), or generate write data accesses according to this value (IRQ mode). The interrupt needs to be cleared after the DMA controller was reconfigured (if DMA mode enabled), or before generating data accesses to the FIFO (if IRQ mode enabled). If the corresponding interrupt was enabled, an interrupt is signaled to the local host. The CPU can also poll this bit. For more details about TDR generation, refer to the FIFO Management subsection. The CPU can only clear this bit by writing a 1 into this register. A write 0 has no effect. Value after reset is low. " end="14" id="XDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Receive draining IRQ status. I2C Receive mode only. This read/clear only bit is set to 1 when the module is configured as a receiver, a stop condition was received on the bus and the RX FIFO level is below the configured threshold (RXTRSH). When this bit is set to 1 by the core, CPU must read the I2C_BUFSTAT.RXSTAT register in order to check the amount of data left to be transferred from the FIFO. Then, according to the mode set (DMA or interrupt), the CPU needs to enable the draining feature of the DMA controller with the number of data bytes to be transferred (I2C_BUFSTAT.RXSTAT), or generate read data accesses according to this value (IRQ mode). The interrupt needs to be cleared after the DMA controller was reconfigured (if DMA mode enabled), or before generating data accesses to the FIFO (if IRQ mode enabled). If the corresponding interrupt was enabled, an interrupt is signaled to the local host. The CPU can also poll this bit. For more details about RDR generation, refer to the FIFO Management subsection. The CPU can only clear this bit by writing a 1 into this register. A write 0 has no effect. Value after reset is low. " end="13" id="RDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="This read-only bit indicates the state of the serial bus. In slave mode, on reception of a start condition, the device sets BB to 1. BB is cleared to 0 after reception of a stop condition. In master mode, the software controls BB. To start a transmission with a start condition, MST, TRX, and STT must be set to 1 in the I2C_CON register. To end a transmission with a stop condition, STP must be set to 1 in the I2C_CON register. When BB = 1 and STT = 1, a restart condition is generated. Value after reset is low. " end="12" id="BB" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="11" description="Receive overrun status. Writing into this bit has no effect. I2C receive mode only. This read-only bit indicates whether the receiver has experienced overrun. Overrun occurs when the shift register is full and the receive FIFO is full. An overrun condition does not result in a data loss; the peripheral is just holding the bus (low on SCL) and prevents other bytes from being received. ROVR is set to 1 when the I2C has recognized an overrun. ROVR is clear when reading I2C_DATA register, or when resetting the I2C (I2C_CON:I2C_EN = 0). Value after reset is low. " end="11" id="ROVR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Transmit underflow status. Writing into this bit has no effect. I2C transmit mode only. This read-only bit indicates whether the transmitter has experienced underflow. In master transmit mode, underflow occurs when the shift register is empty, the transmit FIFO is empty, and there are still some bytes to transmit (DCOUNT 0). In slave transmit mode, underflow occurs when the shift register is empty, the transmit FIFO is empty, and there are still some bytes to transmit (read request from external I2C master). XUDF is set to 1 when the I2C has recognized an underflow. The core holds the line till the underflow cause has disappeared. XUDF is clear when writing I2C_DATA register or resetting the I2C (I2C_CON:I2C_EN = 0). Value after reset is low." end="10" id="XUDF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="Address recognized as slave IRQ status. I2C mode only. This read only bit is set to 1 by the device when it has recognized its own slave address (or one of the alternative own addresses), or an address of all zeros (8 bits). When this bit is set to 1 by the core, an interrupt is signaled to the local host if the interrupt was enabled. This bit can be cleared in 2 ways: One way is if the interrupt was enabled, it will be cleared by writing 1 into this register (writing 0 has no effect). The other way is if the interrupt was not enabled, the AAS bit is reset to 0 by restart or stop. Value after reset is low." end="9" id="AAS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="I2C mode only. This read only bit is set to 1 by the device when the I2C bus became free (after a transfer is ended on the bus stop condition detected). This interrupt informs the Local Host that it can initiate its own I2C transfer on the bus. When this bit is set to 1 by the core, an interrupt is signaled to the local host if the interrupt was enabled. The CPU can only clear this bit by writing a 1 into this register. Writing 0 has no effect. Value after reset is low." end="8" id="BF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Access Error IRQ status. I2C mode only. This read/clear only bit is set to 1 by the device if an Interface/OCP write access is performed to I2C_DATA while the TX FIFO is full or if an Interface/OCP read access is performed to the I2C_DATA while the RX FIFO is empty. Note that, when the RX FIFO is empty, a read access will return to the previous read data value. When the TX FIFO is full, a write access is ignored. In both events, the FIFO pointers will not be updated. When this bit is set to 1 by the core, an interrupt is signaled to the local host if the interrupt was enabled. The CPU can only clear this bit by writing a 1 into this register. Writing 0 has no effect. Value after reset is low. " end="7" id="AERR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="Start Condition IRQ status. I2C mode only. This read/clear only bit is set to 1 by the device if previously the module was in idle mode and a start condition was asynchronously detected on the I2C Bus and signalized with an Wakeup (if the I2C_SYSC.ClockActivity allows the system clock to be cut-off). When the Active Mode will be restored and the interrupt generated, this bit will indicate the reason of the wakeup. Note 1: The corresponding interrupt for this bit should be enabled only if the module was configured to allow the possibility of cutting-off the system clock while in Idle State (I2C_SYSC.ClockActivity = 00 or 01). Note 2: The first transfer (corresponding to the detected start condition) will be lost (not taken into account by the module) and it will be used only for generating the WakeUp enable for restoring the Active Mode of the module. On the I2C line, the external master which generated the transfer will detect this behavior as a not acknowledge to the address phase and will possibly restart the transfer. The CPU can only clear this bit by writing a 1 into this register. Writing 0 has no effect. Value after reset is low." end="6" id="STC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="General call IRQ status. Set to '1' by core when General call address detected and interrupt signaled to MPUSS. Write '1' to clear. I2C mode only. This read/clear only bit is set to 1 by the device if it detects the address of all zeros (8 bits) (general call). When this bit is set to 1 by the core, an interrupt is signaled to the local host if the interrupt was enabled. The CPU can only clear this bit by writing a 1 into this register. Writing 0 has no effect. Note: When this bit is set to 1, AAS also reads as 1. Value after reset is low. " end="5" id="GC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="Transmit data ready IRQ status. Set to '1' by core when transmitter and when new data is requested. When set to '1' by core, an interrupt is signaled to MPUSS. Write '1' to clear. Transmit mode only (I2C mode). This read/clear only bit (XRDY) is set to 1 when the I2C peripheral is a master or slave transmitter, the CPU needs to send data through the I2C bus, and the module (transmitter) requires new data to be served. Note that a master transmitter requests new data if the FIFO TX level is below the threshold (TXTRSH) and the required amount of data remained to be transmitted (I2C_BUFSTAT.TXSTAT) is greater than the threshold. A slave transmitter requests new data when the FIFO TX level is below the threshold (if TXTRSH > 1), or anytime there is a read request from external master (for each acknowledge received from the master), if TXTRSH = 1. When this bit is set to 1 by the core, an interrupt is signaled to the local host if the interrupt was enabled. The CPU can also poll this bit (refer to the FIFO Management subsection for details about XRDY generation). The CPU can only clear this bit by writing a 1 into this register. Writing 0 has no effect. Note: If the DMA transmit mode is enabled (I2C_BUF.XDMA_EN is set, together with I2C_DMATXENABLE_SET), this bit is forced to 0 and no interrupt will be generated; instead, a DMA TX request to the main DMA controller of the system is generated. Value after reset is low. " end="4" id="XRDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="Receive mode only (I2C mode). This read/clear only RRDY is set to 1 when the RX FIFO level is above the configured threshold (RXTRSH). When this bit is set to 1 by the core, CPU is able to read new data from the I2C_DATA register. If the corresponding interrupt was enabled, an interrupt is signaled to the local host. The CPU to read the received data in I2C_DATA register can also poll this bit (refer to the FIFO Management subsection for details about RRDY generation). The CPU can only clear this bit by writing a 1 into this register. A write 0 has no effect. If the DMA receive mode is enabled (I2C_BUF.RDMA_EN is set, together with I2C_DMARXENABLE_SET), this bit is forced to 0 and no interrupt will be generated; instead a DMA RX request to the main DMA controller of the system is generated. Value after reset is low. " end="3" id="RRDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="I2C mode only. This read/clear only bit, when set to 1, indicates that the previously programmed data and command (receive or transmit, master or slave) has been performed and status bit has been updated. The CPU uses this flag to let it know that the I2C registers are ready to be accessed again. The CPU can only clear this bit by writing a 1 into this register. A write 0 has no effect. Mode: I2C Master transmit, Others: STP = 1, ARDY Set Condition: DCOUNT = 0. Mode: I2C Master receive, Others: STP = 1, ARDY Set Condition: DCOUNT = 0 and receiver FIFO empty Mode: I2C Master transmit, Others: STP = 0, ARDY Set Condition: DCOUNT passed 0 Mode: I2C Master receive, Others: STP = 0, ARDY Set Condition: DCOUNT passed 0 and receiver FIFO empty Mode: I2C Master transmit, Others: n/a, ARDY Set Condition: Stop or restart condition received from master Mode: I2C Slave receive, Others: n/a, ARDY Set Condition: Stop or restart condition and receiver FIFO empty Value after reset is low. " end="2" id="ARDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="No acknowledgment IRQ status. Bit is set when No Acknowledge has been received, an interrupt is signaled to MPUSS. Write '1' to clear this bit. I2C mode only. The read/clear only No Acknowledge flag bit is set when the hardware detects No Acknowledge has been received. When a NACK event occurs on the bus, this bit is set to 1, the core automatically ends the transfer and clears the MST/STP bits in the I2C_CON register and the I2C becomes a slave. Clearing the FIFOs from remaining data might be required. The CPU can only clear this bit by writing a 1 into this register. Writing 0 has no effect. Value after reset is low." end="1" id="NACK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Arbitration lost IRQ status. This bit is automatically set by the hardware when it loses the Arbitration in master transmit mode, an interrupt is signaled to MPUSS. During reads, it always returns 0. I2C mode only. The read/clear only Arbitration Lost flag bit is set to 1 when the device (configured in master mode) detects it has lost an arbitration (in Address Phase). This happens when two or more masters initiate a transfer on the I2C bus almost simultaneously or when the I2C attempts to start a transfer while BB (bus busy) is 1. When this is set to 1 due to arbitration lost, the core automatically clears the MST/STP bits in the I2C_CON register and the I2C becomes a slave receiver. The CPU can only clear this bit by writing a 1 to this register. Writing 0 has no effect. Value after reset is low. " end="0" id="AL" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_IRQSTATUS" description="This register provides core status information for interrupt handling, showing all active and enabled events and masking the others. The fields are read-write. Writing a 1 to a bit will clear it to 0, that is, clear the IRQ. Writing a 0 will have no effect, that is, the register value will not be modified. Only enabled, active events will trigger an actual interrupt request on the IRQ output line. For all the internal fields of the I2C_IRQSTATUS register, the descriptions given in the I2C_IRQSTATUS_RAW subsection are valid." id="I2C_IRQSTATUS" offset="0x28" width="32">
    
  <bitfield begin="31" description="" end="15" id="Reserved_1" rwaccess="R" width="17"></bitfield>
    
  <bitfield begin="14" description="Transmit draining IRQ enabled status." end="14" id="XDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Receive draining IRQ enabled status." end="13" id="RDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="Bus busy enabled status. Writing into this bit has no effect." end="12" id="BB" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="11" description="Receive overrun enabled status. Writing into this bit has no effect." end="11" id="ROVR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Transmit underflow enabled status. Writing into this bit has no effect." end="10" id="XUDF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="Address recognized as slave IRQ enabled status." end="9" id="AAS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Bus Free IRQ enabled status." end="8" id="BF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Access Error IRQ enabled status." end="7" id="AERR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="Start Condition IRQ enabled status." end="6" id="STC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="General call IRQ enabled status. Set to '1' by core when General call address detected and interrupt signaled to MPUSS. Write '1' to clear." end="5" id="GC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="Transmit data ready IRQ enabled status. Set to '1' by core when transmitter and when new data is requested. When set to '1' by core, an interrupt is signaled to MPUSS. Write '1' to clear. " end="4" id="XRDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="Receive data ready IRQ enabled status. Set to '1' by core when receiver mode, a new data is able to be read. When set to '1' by core, an interrupt is signaled to MPUSS. Write '1' to clear. " end="3" id="RRDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Register access ready IRQ enabled status. When set to '1' it indicates that previous access has been performed and registers are ready to be accessed again. An interrupt is signaled to MPUSS. Write '1' to clear. " end="2" id="ARDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="No acknowledgment IRQ enabled status. Bit is set when No Acknowledge has been received, an interrupt is signaled to MPUSS. Write '1' to clear this bit." end="1" id="NACK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Arbitration lost IRQ enabled status. This bit is automatically set by the hardware when it loses the Arbitration in master transmit mode, an interrupt is signaled to MPUSS. During reads, it always returns 0. " end="0" id="AL" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_IRQENABLE_SET" description="All 1-bit fields enable a specific interrupt event to trigger an interrupt request. Writing a 1 to a bit will enable the field. Writing a 0 will have no effect, that is, the register value will not be modified. For all the internal fields of the I2C_IRQENABLE_SET register, the descriptions given in the I2C_IRQSTATUS_RAW subsection are valid. " id="I2C_IRQENABLE_SET" offset="0x2C" width="32">
    
  <bitfield begin="31" description="" end="15" id="Reserved_1" rwaccess="R" width="17"></bitfield>
    
  <bitfield begin="14" description="Transmit draining interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[XDR]." end="14" id="XDR_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Receive draining interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[RDR]." end="13" id="RDR_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="" end="12" id="Reserved_2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="11" description="Receive overrun enable set." end="11" id="ROVR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Transmit underflow enable set." end="10" id="XUDF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="Addressed as slave interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[AAS]." end="9" id="AAS_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Bus free interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[BF]." end="8" id="BF_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Access error interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[AERR]." end="7" id="AERR_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="Start condition interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[STC]." end="6" id="STC_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="General call interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[GC]." end="5" id="GC_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="Transmit data ready interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[XRDY]." end="4" id="XRDY_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="Receive data ready interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[RRDY]." end="3" id="RRDY_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Register access ready interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[ARDY]." end="2" id="ARDY_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="No acknowledgment interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[NACK]." end="1" id="NACK_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Arbitration lost interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[AL]." end="0" id="AL_IE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_IRQENABLE_CLR" description="All 1-bit fields clear a specific interrupt event. Writing a 1 to a bit will disable the interrupt field. Writing a 0 will have no effect, that is, the register value will not be modified. For all the internal fields of the I2C_IRQENABLE_CLR register, the descriptions given in the I2C_IRQSTATUS_RAW subsection are valid." id="I2C_IRQENABLE_CLR" offset="0x30" width="32">
    
  <bitfield begin="31" description="" end="15" id="Reserved_1" rwaccess="R" width="17"></bitfield>
    
  <bitfield begin="14" description="Transmit draining interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[XDR]." end="14" id="XDR_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Receive draining interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[RDR]." end="13" id="RDR_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="" end="12" id="Reserved_2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="11" description="Receive overrun enable clear." end="11" id="ROVR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Transmit underflow enable clear." end="10" id="XUDF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="Addressed as slave interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[AAS]." end="9" id="AAS_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Bus Free interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[BF]." end="8" id="BF_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Access error interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[AERR]." end="7" id="AERR_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="Start condition interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[STC]." end="6" id="STC_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="General call interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[GC]." end="5" id="GC_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="Transmit data ready interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[XRDY]." end="4" id="XRDY_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="Receive data ready interrupt enable set. Mask or unmask the interrupt signaled by bit in I2C_STAT[RRDY]" end="3" id="RRDY_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Register access ready interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[ARDY]." end="2" id="ARDY_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="No acknowledgment interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[NACK]." end="1" id="NACK_IE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Arbitration lost interrupt enable clear. Mask or unmask the interrupt signaled by bit in I2C_STAT[AL]." end="0" id="AL_IE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_WE" description="Every 1-bit field in the I2C_WE register enables a specific (synchronous) IRQ request source to generate an asynchronous wakeup (on the appropriate swakeup line). When a bit location is set to 1 by the local host, a wakeup is signaled to the local host if the corresponding event is captured by the core of the I2C controller. Value after reset is low (all bits). There is no need for an Access Error WakeUp event, since this event occurs only when the module is in Active Mode (for Interface/OCP accesses to FIFO) and is signaled by an interrupt. With the exception of Start Condition WakeUp, which is asynchronously detected when the Functional clock is turned-off, all the other WakeUp events require the Functional (System) clock to be enabled." id="I2C_WE" offset="0x34" width="32">
    
  <bitfield begin="31" description="" end="15" id="Reserved1" rwaccess="R" width="17"></bitfield>
    
  <bitfield begin="14" description="Transmit draining wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C module is in idle mode, the TX FIFO level is below the threshold and the amount of data left to be transferred is less than TXTRSH value. This allows for the module to inform the CPU that it can check the amount of data to be written to the FIFO." end="14" id="XDR_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Receive draining wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C is in idle mode, configured as a receiver, and it has detected a stop condition on the bus but the RX FIFO threshold is not reached (but the FIFO is not empty). This allows for the module to inform the CPU that it can check the amount of data to be transferred from the FIFO." end="13" id="RDR_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="" end="12" id="Reserved2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="11" description="Receive overrun wakeup enable" end="11" id="ROVR_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Transmit underflow wakeup enable" end="10" id="XUDF_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="Address as slave IRQ wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C module is in idle mode, and external master addresses the I2C module as a slave. This allows for the module to inform the CPU that it can check which of the own addresses was used by the external master to access the I2C core." end="9" id="AAS_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Bus free IRQ wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C module is in idle mode and the I2C bus became free. This allows for the module to inform the CPU that it can initiate its own transfer on the I2C line." end="8" id="BF_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="" end="7" id="Reserved3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="Start condition IRQ wakeup set. This read/write bit is used to enable or disable wakeup signal generation when I2C module is in idle mode (with the functional clock inactive) and a possible start condition is detected on the I2C line. The STC WakeUp is generated only if the I2C_SYSC.ClockActivity field indicates that the functional clock can be disabled. Note that if the functional clock is not active, the start condition is asynchronously detected (no filtering and synchronization is used). For this reason, it is possible that the signalized start condition to be a glitch. If the functional clock cannot be disabled (I2C_SYSC.ClockActivity = 10 or 11), the programmer should not enable this wakeup, since the module has other synchronously detected WakeUp event that might be used to exit from idle mode, only if the detected transfer is accessing the I2C module." end="6" id="STC_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="General call IRQ wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C module is in idle mode and a general call is received on I2C line." end="5" id="GC_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="" end="4" id="Reserved4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="3" description="Receive/Transmit data ready IRQ wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C module is involved into a long transfer and no more registers accesses are performed on the interface (for example module are set in F/S I2C master transmitter mode and FIFO is full). If in the middle of such a transaction, the FIFO buffer needs more data to be transferred, CPU must be informed to write (in case of transmitter mode) or read (if receiver mode) in/from the FIFO." end="3" id="DRDY_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Register access ready IRQ wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C module is involved into a long transfer and no more registers accesses are performed on the interface (for example the module is set in F/S I2C master transmitter mode and FIFO is full). If the current transaction is finished, the module needs to inform CPU about transmission completion." end="2" id="ARDY_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="No acknowledgment IRQ wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C module is involved into a long transfer and no more registers accesses are performed on the interface (for example the module is set in F/S I2C master transmitter mode and FIFO is full). If in the middle of such of a transaction a Not Acknowledgment event is raised, the module needs to inform CPU about transmission error." end="1" id="NACK_WE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Arbitration lost IRQ wakeup enable. This read/write bit is used to enable or disable wakeup signal generation when I2C module is configured as a master and it loses the arbitration. This wake up is very useful when the module is configured as a master transmitter, all the necessary data is provided in the FIFO Tx, STT is enabled and the module enters in Idle Mode. If the module loses the arbitration, an Arbitration Lost event is raised and the module needs to inform CPU about transmission error. Note: The AL wakeup must be enabled only for multimaster communication. If the AL_WE is not enabled and the scenario described above occurs, the module will not be able to inform the CPU about the state of the transfer and it will be blocked in an undetermined state." end="0" id="AL_WE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_DMARXENABLE_SET" description="The 1-bit field enables a receive DMA request. Writing a 1 to this field will set it to 1. Writing a 0 will have no effect, that is, the register value is not modified. Note that the I2C_BUF.RDMA_EN field is the global (slave) DMA enabler, and that it is disabled by default. The I2C_BUF.RDMA_EN field should also be set to 1 to enable a receive DMA request." id="I2C_DMARXENABLE_SET" offset="0x38" width="32">
    
  <bitfield begin="31" description="" end="1" id="Reserved1" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="Receive DMA channel enable set." end="0" id="DMARX_ENABLE_SET" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_DMATXENABLE_SET" description="The 1-bit field enables a transmit DMA request. Writing a 1 to this field will set it to 1. Writing a 0 will have no effect, that is, the register value is not modified. Note that the I2C_BUF.XDMA_EN field is the global (slave) DMA enabler, and that it is disabled by default. The I2C_BUF.XDMA_EN field should also be set to 1 to enable a transmit DMA request." id="I2C_DMATXENABLE_SET" offset="0x3C" width="32">
    
  <bitfield begin="31" description="" end="1" id="Reserved1" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="Transmit DMA channel enable set." end="0" id="DMATX_TRANSMIT_SET" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_DMARXENABLE_CLR" description="The 1-bit field disables a receive DMA request. Writing a 1 to a bit will clear it to 0. Another result of setting to 1 the DMARX_ENABLE_CLEAR field, is the reset of the DMA RX request and wakeup lines. Writing a 0 will have no effect, that is, the register value is not modified." id="I2C_DMARXENABLE_CLR" offset="0x40" width="32">
    
  <bitfield begin="31" description="" end="1" id="Reserved1" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="Receive DMA channel enable clear." end="0" id="DMARX_ENABLE_CLEAR" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_DMATXENABLE_CLR" description="The 1-bit field disables a transmit DMA request. Writing a 1 to a bit will clear it to 0. Another result of setting to 1 the DMATX_ENABLE_CLEAR field, is the reset of the DMA TX request and wakeup lines. Writing a 0 will have no effect, that is, the register value is not modified." id="I2C_DMATXENABLE_CLR" offset="0x44" width="32">
    
  <bitfield begin="31" description="" end="1" id="Reserved1" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="Receive DMA channel enable clear." end="0" id="DMARX_ENABLE_CLEAR" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_DMARXWAKE_EN" description="All 1-bit fields enable a specific (synchronous) DMA request source to generate an asynchronous wakeup (on the appropriate swakeup line). Note that the I2C_SYSC.ENAWAKEUP field is the global (slave) wakeup enabler, and that it is disabled by default." id="I2C_DMARXWAKE_EN" offset="0x48" width="32">
    
  <bitfield begin="31" description="" end="15" id="Reserved_1" rwaccess="R" width="17"></bitfield>
    
  <bitfield begin="14" description="Transmit draining wakeup set." end="14" id="XDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Receive draining wakeup set." end="13" id="RDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="" end="12" id="Reserved_2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="11" description="Receive overrun wakeup set." end="11" id="ROVR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Transmit underflow wakeup set." end="10" id="XUDF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="Address as slave IRQ wakeup set." end="9" id="AAS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Bus free IRQ wakeup set." end="8" id="BF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="" end="7" id="Reserved3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="Start condition IRQ wakeup set." end="6" id="STC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="General call IRQ wakeup set." end="5" id="GC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="" end="4" id="Reserved_4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="3" description="Receive/transmit data ready IRQ wakeup set." end="3" id="DRDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Register access ready IRQ wakeup set." end="2" id="ARDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="No acknowledgment IRQ wakeup set." end="1" id="NACK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Arbitration lost IRQ wakeup set." end="0" id="AL" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_DMATXWAKE_EN" description="All 1-bit fields enable a specific (synchronous) DMA request source to generate an asynchronous wakeup (on the appropriate swakeup line). Note that the I2C_SYSC.ENAWAKEUP field is the global (slave) wakeup enabler, and that it is disabled by default." id="I2C_DMATXWAKE_EN" offset="0x4C" width="32">
    
  <bitfield begin="31" description="" end="15" id="Reserved_1" rwaccess="R" width="17"></bitfield>
    
  <bitfield begin="14" description="Transmit draining wakeup set." end="14" id="XDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Receive draining wakeup set." end="13" id="RDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="" end="12" id="Reserved_2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="11" description="Receive overrun wakeup set." end="11" id="ROVR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Transmit underflow wakeup set." end="10" id="XUDF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="Address as slave IRQ wakeup set." end="9" id="AAS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Bus free IRQ wakeup set." end="8" id="BF" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="" end="7" id="Reserved3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="Start condition IRQ wakeup set." end="6" id="STC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="General call IRQ wakeup set." end="5" id="GC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="" end="4" id="Reserved_4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="3" description="Receive/transmit data ready IRQ wakeup set." end="3" id="DRDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Register access ready IRQ wakeup set." end="2" id="ARDY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="No acknowledgment IRQ wakeup set." end="1" id="NACK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Arbitration lost IRQ wakeup set." end="0" id="AL" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_SYSS" description="" id="I2C_SYSS" offset="0x90" width="32">
    
  <bitfield begin="31" description="" end="1" id="Reserved1" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="Reset done bit. This read-only bit indicates the state of the reset in case of hardware reset, global software reset (I2C_SYSC.SRST) or partial software reset (I2C_CON.I2C_EN). The module must receive all its clocks before it can grant a reset-completed status. Value after reset is low." end="0" id="RDONE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_BUF" description="This read/write register enables DMA transfers and allows the configuration of FIFO thresholds for the FIFO management (see the FIFO Management subsection)." id="I2C_BUF" offset="0x94" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Receive DMA channel enable. When this bit is set to 1, the receive DMA channel is enabled and the receive data ready status bit (I2C_IRQSTATUS_RAW: RRDY) is forced to 0 by the core. Value after reset is low." end="15" id="RDMA_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="Receive FIFO clear. When set, receive FIFO is cleared (hardware reset for RX FIFO generated). This bit is automatically reset by the hardware. During reads, it always returns 0. Value after reset is low." end="14" id="RXFIFO_CLR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Threshold value for FIFO buffer in RX mode. The receive threshold value is used to specify the trigger level for data receive transfers. The value is specified from the Interface/OCP point of view. Value after reset is 00h. For the FIFO management description, see the FIFO Management subsection. Note 1: programmed threshold cannot exceed the actual depth of the FIFO. Note 2: the threshold must not be changed while a transfer is in progress (after STT was configured or after the module was addressed as a slave). " end="8" id="RXTRSH" rwaccess="RW" width="6"></bitfield>
    
  <bitfield begin="7" description="Transmit DMA channel enable. When this bit is set to 1, the transmit DMA channel is enabled and the transmit data ready status (I2C_IRQSTATUS_RAW: XRDY) bit is forced to 0 by the core. Value after reset is low. " end="7" id="XDMA_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="Transmit FIFO clear. When set, transmit FIFO is cleared (hardware reset for TX FIFO). This bit is automatically reset by the hardware. During reads, it always returns 0. Value after reset is low. " end="6" id="TXFIFO_CLR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="Threshold value for FIFO buffer in TX mode. The Transmit Threshold value is used to specify the trigger level for data transfers. The value is specified from the OCP point of view. Value after reset is 00h Note 1: programmed threshold cannot exceed the actual depth of the FIFO. Note 2: the threshold must not be changed while a transfer is in progress (after STT was configured or after the module was addressed as a slave). " end="0" id="TXTRSH" rwaccess="RW" width="6"></bitfield>
  </register>
  
  
  <register acronym="I2C_CNT" description="CAUTION: During an active transfer phase (between STT having been set to 1 and reception of ARDY), no modification must be done in this register. Changing it may result in an unpredictable behavior. This read/write register is used to control the numbers of bytes in the I2C data payload. " id="I2C_CNT" offset="0x98" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Data count. I2C Master Mode only (receive or transmit; F/S). This 16-bit countdown counter decrements by 1 for every byte received or sent through the I2C interface. A write initializes DCOUNT to a saved initial value. A read returns the number of bytes that are yet to be received or sent. A read into DCOUNT returns the initial value only before a start condition and after a stop condition. When DCOUNT reaches 0, the core generates a stop condition if a stop condition was specified (I2C_CON.STP = 1) and the ARDY status flag is set to 1 in the I2C_IRQSTATUS_RAW register. Note that DCOUNT must not be reconfigured after I2C_CON.STT was enabled and before ARDY is received. Note 1: In case of I2C mode of operation, if I2C_CON.STP = 0, then the I2C asserts SCL = 0 when DCOUNT reaches 0. The CPU can then reprogram DCOUNT to a new value and resume sending or receiving data with a new start condition (restart). This process repeats until the CPU sets to 1 the I2C_CON.STP bit. The ARDY flag is set each time DCOUNT reaches 0 and DCOUNT is reloaded to its initial value. Values after reset are low (all 16 bits). Note 2: Since for DCOUNT = 0, the transfer length is 65536, the module does not allow the possibility to initiate zero data bytes transfers. " end="0" id="DCOUNT" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="I2C_DATA" description="This register is the entry point for the local host to read data from or write data to the FIFO buffer." id="I2C_DATA" offset="0x9C" width="32">
    
  <bitfield begin="31" description="" end="8" id="Reserved1" rwaccess="R" width="24"></bitfield>
    
  <bitfield begin="7" description="Transmit/Receive data FIFO endpoint. When read, this register contains the received I2C data. When written, this register contains the byte value to transmit over the I2C data. In SYSTEST loop back mode (I2C_SYSTEST: TMODE = 11), this register is also the entry/receive point for the data. Values after reset are unknown (all 8-bits). Note: A read access, when the buffer is empty, returns the previous read data value. A write access, when the buffer is full, is ignored. In both events, the FIFO pointers are not updated and an Access Error (AERR) Interrupt is generated. " end="0" id="DATA" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="I2C_CON" description="During an active transfer phase (between STT having been set to 1 and reception of ARDY), no modification must be done in this register (except STP enable). Changing it may result in an unpredictable behavior. " id="I2C_CON" offset="0xA4" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="I2C module enable. When this bit is cleared to 0, the I2C controller is not enabled and reset. When 0, receive and transmit FIFOs are cleared and all status bits are set to their default values. All configuration registers (I2C_IRQENABLE_SET, I2C_IRQWAKE_SET, I2C_BUF, I2C_CNT, I2C_CON, I2C_OA, I2C_SA, I2C_PSC, I2C_SCLL and I2C_SCLH) are not reset, they keep their initial values and can be accessed. The CPU must set this bit to 1 for normal operation. Value after reset is low. " end="15" id="I2C_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="" end="14" id="Reserved_2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="13" description="Operation mode selection. These two bits select module operation mode. Value after reset is 00." end="12" id="OPMODE" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="11" description="Start byte mode (I2C master mode only). The start byte mode bit is set to 1 by the CPU to configure the I2C in start byte mode (I2C_SA = 0000 0001). See the Philips I2C spec for more details [1]. Value after reset is low." end="11" id="STB" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Master/slave mode (I2C mode only). When this bit is cleared, the I2C controller is in the slave mode and the serial clock (SCL) is received from the master device. When this bit is set, the I2C controller is in the master mode and generates the serial clock. Note: This bit is automatically cleared at the end of the transfer on a detected stop condition, in case of arbitration lost or when the module is configured as a master but addressed as a slave by an external master. Value after reset is low. " end="10" id="MST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="Transmitter/receiver mode (i2C master mode only). When this bit is cleared, the I2C controller is in the receiver mode and data on data line SDA is shifted into the receiver FIFO and can be read from I2C_DATA register. When this bit is set, the I2C controller is in the transmitter mode and the data written in the transmitter FIFO via I2C_DATA is shifted out on data line SDA. Value after reset is low. The operating modes are defined as follows: MST = 0, TRX = x, Operating Mode = Slave receiver. MST = 0, TRX = x, Operating Mode = Slave transmitter. MST = 1, TRX = 0, Operating Modes = Master receiver. MST = 1, TRX = 0, Operating Modes = Master transmitter." end="9" id="TRX" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Expand slave address. (I2C mode only). When set, this bit expands the slave address to 10-bit. Value after reset is low." end="8" id="XSA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Expand own address 0. (I2C mode only). When set, this bit expands the base own address (OA0) to 10-bit. Value after reset is low." end="7" id="XOA0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="Expand own address 1. (I2C mode only). When set, this bit expands the first alternative own address (OA1) to 10-bit. Value after reset is low." end="6" id="XOA1" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="Expand own address 2. (I2C mode only). When set, this bit expands the second alternative own address (OA2) to 10-bit. Value after reset is low." end="5" id="XOA2" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="Expand own address 3. When set, this bit expands the third alternative own address (OA3) to 10-bit. Value after reset is low." end="4" id="XOA3" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="" end="2" id="Reserved_3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="Stop condition (I2C master mode only). This bit can be set to a 1 by the CPU to generate a stop condition. It is reset to 0 by the hardware after the stop condition has been generated. The stop condition is generated when DCOUNT passes 0. When this bit is not set to 1 before the end of the transfer (DCOUNT = 0), the stop condition is not generated and the SCL line is hold to 0 by the master, which can re-start a new transfer by setting the STT bit to 1. Value after reset is low" end="1" id="STP" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Start condition (I2C master mode only). This bit can be set to a 1 by the CPU to generate a start condition. It is reset to 0 by the hardware after the start condition has been generated. The start/stop bits can be configured to generate different transfer formats. Value after reset is low. Note: DCOUNT is data count value in I2C_CNT register. STT = 1, STP = 0, Conditions = Start, Bus Activities = S-A-D. STT = 0, STP = 1, Conditions = Stop, Bus Activities = P. STT = 1, STP = 1, Conditions = Start-Stop (DCOUNT=n), Bus Activities = S-A-D..(n)..D-P. STT = 1, STP = 0, Conditions = Start (DCOUNT=n), Bus Activities = S-A-D..(n)..D." end="0" id="STT" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_OA" description="CAUTION: During an active transfer phase (between STT having been set to 1 and reception of ARDY), no modification must be done in this register. Changing it may result in an unpredictable behavior. This register is used to specify the module s base I2C 7-bit or 10-bit address (base own address). " id="I2C_OA" offset="0xA8" width="32">
    
  <bitfield begin="31" description="" end="10" id="Reserved1" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="Own address. This field specifies either: A 10-bit address coded on OA [9:0] when XOA (Expand Own Address, I2C_CON[7]) is set to 1. or A 7-bit address coded on OA [6:0] when XOA (Expand Own Address, I2C_CON[7]) is cleared to 0. In this case, OA [9:7] bits must be cleared to 000 by application software. Value after reset is low (all 10 bits). " end="0" id="OA" rwaccess="RW" width="10"></bitfield>
  </register>
  
  
  <register acronym="I2C_SA" description="CAUTION: During an active transfer phase (between STT having been set to 1 and reception of ARDY), no modification must be done in this register. Changing it may result in an unpredictable behavior. This register is used to specify the addressed I2C module 7-bit or 10-bit address (slave address). " id="I2C_SA" offset="0xAC" width="32">
    
  <bitfield begin="31" description="" end="10" id="Reserved1" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="Slave address. This field specifies either: A 10-bit address coded on SA [9:0] when XSA (Expand Slave Address, I2C_CON[8]) is set to 1. or A 7-bit address coded on SA [6:0] when XSA (Expand Slave Address, I2C_CON[8]) is cleared to 0. In this case, SA [9:7] bits must be cleared to 000 by application software. Value after reset is low (all 10 bits). " end="0" id="SA" rwaccess="RW" width="10"></bitfield>
  </register>
  
  
  <register acronym="I2C_PSC" description="CAUTION: During an active mode (I2C_EN bit in I2C_CON register is set to 1), no modification must be done in this register. Changing it may result in an unpredictable behavior. This register is used to specify the internal clocking of the I2C peripheral core. " id="I2C_PSC" offset="0xB0" width="32">
    
  <bitfield begin="31" description="" end="8" id="Reserved1" rwaccess="R" width="24"></bitfield>
    
  <bitfield begin="7" description="Fast/Standard mode prescale sampling clock divider value. The core uses this 8-bit value to divide the system clock (SCLK) and generates its own internal sampling clock (ICLK) for Fast and Standard operation modes. The core logic is sampled at the clock rate of the system clock for the module divided by (PSC + 1). Value after reset is low (all 8 bits). " end="0" id="PSC" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="I2C_SCLL" description="CAUTION: During an active mode (I2C_EN bit in I2C_CON register is set to 1), no modification must be done in this register. Changing it may result in an unpredictable behavior. This register is used to determine the SCL low time value when master. " id="I2C_SCLL" offset="0xB4" width="32">
    
  <bitfield begin="31" description="" end="8" id="Reserved1" rwaccess="R" width="24"></bitfield>
    
  <bitfield begin="7" description="Fast/Standard mode SCL low time. I2C master mode only, (FS). This 8-bit value is used to generate the SCL low time value (tLOW) when the peripheral is operated in master mode. tLOW = (SCLL + 7) * ICLK time period, Value after reset is low (all 8 bits)." end="0" id="SCLL" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="I2C_SCLH" description="CAUTION: During an active mode (I2C_EN bit in I2C_CON register is set to 1), no modification must be done in this register. Changing it may result in an unpredictable behavior. This register is used to determine the SCL high time value when master. " id="I2C_SCLH" offset="0xB8" width="32">
    
  <bitfield begin="31" description="" end="8" id="Reserved1" rwaccess="R" width="24"></bitfield>
    
  <bitfield begin="7" description="Fast/Standard mode SCL low time. I2C master mode only, (FS). This 8-bit value is used to generate the SCL high time value (tHIGH) when the peripheral is operated in master mode. - tHIGH = (SCLH + 5) * ICLK time period. Value after reset is low (all 8 bits)." end="0" id="SCLH" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="I2C_SYSTEST" description="CAUTION: Never enable this register for normal I2C operation This register is used to facilitate system-level tests by overriding some of the standard functional features of the peripheral. It allows testing of SCL counters, controlling the signals that connect to I/O pins, or creating digital loop-back for self-test when the module is configured in system test (SYSTEST) mode. It also provides stop/non-stop functionality in the debug mode. " id="I2C_SYSTEST" offset="0xBC" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="System test enable. This bit must be set to 1 to permit other system test registers bits to be set. Value after reset is low." end="15" id="ST_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="Free running mode (on breakpoint). This bit is used to determine the state of the I2C controller when a breakpoint is encountered in the HLL debugger. Note: This bit can be set independently of ST_EN value. FREE = 0: the I2C controller stops immediately after completion of the on-going bit transfer. Stopping the transfer is achieved by forcing the SCL line low. Note that in this case there will be no status register updates. FREE = 1: the I2C interface runs free. When Suspend indication will be asserted, there will be no accesses on the OCP Interface (the CPU is in debug mode) and consequently the FIFOs will reach full/empty state (according to RX or TX modes) and the I2C SDA line will be kept low. Note that the status registers will be updated, but no DMA, IRQ or WakeUp will be generated. The status registers likely to be updated in this mode are: I2C_IRQSTATUS_RAW.XRDY, I2C_IRQSTATUS_RAW.RRDY, I2C_IRQSTATUS_RAW.XUDF, I2C_IRQSTATUS_RAW.ROVR, I2C_IRQSTATUS_RAW.ARDY and I2C_IRQSTATUS_RAW.NACK. Value after reset is low. " end="14" id="FREE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Test mode select. In normal functional mode (ST_EN = 0), these bits are don't care. They are always read as 00 and a write is ignored. In system test mode (ST_EN = 1), these bits can be set according to the following table to permit various system tests. Values after reset are low (2 bits). SCL counter test mode: in this mode, the SCL pin is driven with a permanent clock as if mastered with the parameters set in the I2C_PSC, I2C_SCLL, and I2C_SCLH registers. Loop back mode: in the master transmit mode only, data transmitted out of the I2C_DATA register (write action) is received in the same I2C_DATA register via an internal path through the FIFO buffer. The DMA and interrupt requests are normally generated if enabled. SDA/SCL IO mode: in this mode, the SCL IO and SDA IO are controlled via the I2C_SYSTEST [5:0] register bits. " end="12" id="TMODE" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="11" description="Set status bits. Writing 1 into this bit also sets the 6 read/clear-only status bits contained in I2C_IRQSTATUS_RAW register (bits 5:0) to 1. Writing 0 into this bit doesn't clear status bits that are already set; only writing 1 into a set status bit can clear it (see I2C_IRQSTATUS_RAW operation). This bit must be cleared prior attempting to clear a status bit. Value after reset is low. " end="11" id="SSB" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="" end="9" id="Reserved_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="8" description="SCL line input value (functional mode). This read-only bit returns the logical state taken by the SCL line (either 1 or 0). It is active both in functional and test mode. Value after reset is low. " end="8" id="SCL_I_FUNC" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="7" description="SCL line output value (functional mode). This read-only bit returns the value driven by the module on the SCL line (either 1 or 0). It is active both in functional and test mode. Value after reset is low. " end="7" id="SCL_O_FUNC" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="SDA line input value (functional mode). This read-only bit returns the logical state taken by the SDA line (either 1 or 0). It is active both in functional and test mode. Value after reset is low. " end="6" id="SDA_I_FUNC" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="5" description="SDA line output value (functional mode). This read-only bit returns the value driven by the module on the SDA line (either 1 or 0). It is active both in functional and test mode. Value after reset is low. " end="5" id="SDA_O_FUNC" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="4" description="" end="4" id="Reserved_3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="3" description="SCL line sense input value. In normal functional mode (ST_EN = 0), this read-only bit always reads 0. In system test mode (ST_EN = 1 and TMODE = 11), this read-only bit returns the logical state taken by the SCL line (either 1 or 0). Value after reset is low. " end="3" id="SCL_I" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="2" description="SCL line drive output value. In normal functional mode (ST_EN = 0), this bit is don't care. It always reads 0 and a write is ignored. In system test mode (ST_EN = 1 and TMODE = 11), a 0 forces a low level on the SCL line and a 1 puts the I2C output driver to a high-impedance state. Value after reset is low. " end="2" id="SCL_O" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="1" description="SDA line sense input value. In normal functional mode (ST_EN = 0), this read-only bit always reads 0. In system test mode (ST_EN = 1 and TMODE = 11), this read-only bit returns the logical state taken by the SDA line (either 1 or 0). Value after reset is low. " end="1" id="SDA_I" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="0" description="SDA line drive output value. In normal functional mode (ST_EN = 0), this bit is don't care. It reads as 0 and a write is ignored. In system test mode (ST_EN = 1 and TMODE = 11), a 0 forces a low level on the SDA line and a 1 puts the I2C output driver to a high-impedance state. Value after reset is low. " end="0" id="SDA_O" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_BUFSTAT" description="This read-only register reflects the status of the internal buffers for the FIFO management (see the FIFO Management subsection)." id="I2C_BUFSTAT" offset="0xC0" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Internal FIFO buffers depth. This read-only bit indicates the internal FIFO buffer depth. Value after reset is given by the boundary module generic parameter." end="14" id="FIFODEPTH" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="RX buffer status. This read-only field indicates the number of bytes to be transferred from the FIFO at the end of the I2C transfer (when RDR is asserted). It corresponds to the level indication of the RX FIFO (number of written locations). Value after reset is 0." end="8" id="RXSTAT" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="7" description="" end="6" id="Reserved_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="TX buffer status. This read-only field indicates the number of data bytes still left to be written in the TX FIFO (it s equal with the initial value of I2C_CNT.DCOUNT minus the number of data bytes already written in the TX FIFO through the OCP Interface). Value after reset is equal with 0." end="0" id="TXSTAT" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="I2C_OA1" description="CAUTION: During an active transfer phase (between STT has been set to 1 and receiving of ARDY), no modification must be done in this register. Changing it may result in an unpredictable behavior. This register is used to specify the first alternative I2C 7-bit or 10-bit address (own address 1 - OA1). " id="I2C_OA1" offset="0xC4" width="32">
    
  <bitfield begin="31" description="" end="10" id="Reserved1" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="Own address 1. This field specifies either: A 10-bit address coded on OA1 [9:0] when XOA1 (Expand Own Address 1 - XOA1, I2C_CON[6]) is set to 1. A 7-bit address coded on OA1 [6:0] when XOA1 (Expand Own Address 1 XOA1, I2C_CON[6]) is cleared to 0. In this case, OA1 [9:7] bits must be cleared to 000 by application software. Value after reset is low (all 10 bits). " end="0" id="OA1" rwaccess="RW" width="10"></bitfield>
  </register>
  
  
  <register acronym="I2C_OA2" description="CAUTION: During an active transfer phase (between STT has been set to 1 and receiving of ARDY), no modification must be done in this register. Changing it may result in an unpredictable behavior. This register is used to specify the first alternative I2C 7-bit or 10-bit address (own address 2 - OA2). " id="I2C_OA2" offset="0xC8" width="32">
    
  <bitfield begin="31" description="" end="10" id="Reserved1" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="Own address 2. This field specifies either: A 10-bit address coded on OA2 [9:0] when XOA1 (Expand Own Address 2 - XOA2, I2C_CON[5]) is set to 1. A 7-bit address coded on OA2 [6:0] when XOA2 (Expand Own Address 2 XOA2, I2C_CON[5]) is cleared to 0. In this case, OA2 [9:7] bits must be cleared to 000 by application software. Value after reset is low (all 10 bits). " end="0" id="OA2" rwaccess="RW" width="10"></bitfield>
  </register>
  
  
  <register acronym="I2C_OA3" description="CAUTION: During an active transfer phase (between STT has been set to 1 and receiving of ARDY), no modification must be done in this register. Changing it may result in an unpredictable behavior. This register is used to specify the first alternative I2C 7-bit or 10-bit address (own address 3 - OA3). " id="I2C_OA3" offset="0xCC" width="32">
    
  <bitfield begin="31" description="" end="10" id="Reserved1" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="Own address 2. This field specifies either: A 10-bit address coded on OA3 [9:0] when XOA3 (Expand Own Address 3 - XOA3, I2C_CON[4]) is set to 1. A 7-bit address coded on OA3 [6:0] when XOA1 (Expand Own Address 3 XOA3, I2C_CON[4]) is cleared to 0. In this case, OA3 [9:7] bits must be cleared to 000 by application software. Value after reset is low (all 10 bits). " end="0" id="OA3" rwaccess="RW" width="10"></bitfield>
  </register>
  
  
  <register acronym="I2C_ACTOA" description="This read-only register is used to indicate which one of the module s four own addresses the external master used when addressing the module. The CPU can read this register when the AAS indication was activated. The indication is cleared at the end of the transfer. " id="I2C_ACTOA" offset="0xD0" width="32">
    
  <bitfield begin="31" description="" end="4" id="Reserved1" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="Own address 3 active. When a bit location is set to 1 by the core, it signalizes to the Local Host that an external master using the corresponding own address addressed the module. Value after reset is low. " end="3" id="OA3_ACT" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="2" description="Own address 2 active. When a bit location is set to 1 by the core, it signalizes to the Local Host that an external master using the corresponding own address addressed the module. Value after reset is low. " end="2" id="OA2_ACT" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="1" description="Own address 1 active. When a bit location is set to 1 by the core, it signalizes to the Local Host that an external master using the corresponding own address addressed the module. Value after reset is low. " end="1" id="OA1_ACT" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="0" description="Own address 0 active. When a bit location is set to 1 by the core, it signalizes to the Local Host that an external master using the corresponding own address addressed the module. Value after reset is low. " end="0" id="OA0_ACT" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="I2C_SBLOCK" description="This read/write register controls the automatic blocking of I2C clock feature in slave mode. It is used for the Local Host to configure for which of the 4 own addresses, the core must block the I2C clock (keep SCL line low) right after the Address Phase, when it is addressed as a slave. " id="I2C_SBLOCK" offset="0xD4" width="32">
    
  <bitfield begin="31" description="" end="4" id="Reserved1" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="Enable I2C clock blocking for own address 3. When the CPU sets a bit location to 1, if an external master using the corresponding own address addresses the core, the core will block the I2C clock right after the address phase. For releasing the I2C clock the CPU must write 0 in the corresponding field. Value after reset is low. " end="3" id="OA3_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Enable I2C clock blocking for own address 2. When the CPU sets a bit location to 1, if an external master using the corresponding own address addresses the core, the core will block the I2C clock right after the address phase. For releasing the I2C clock the CPU must write 0 in the corresponding field. Value after reset is low. " end="2" id="OA2_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="Enable I2C clock blocking for own address 1. When the CPU sets a bit location to 1, if an external master using the corresponding own address addresses the core, the core will block the I2C clock right after the address phase. For releasing the I2C clock the CPU must write 0 in the corresponding field. Value after reset is low. " end="1" id="OA1_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Enable I2C clock blocking for own address 0. When the CPU sets a bit location to 1, if an external master using the corresponding own address addresses the core, the core will block the I2C clock right after the address phase. For releasing the I2C clock the CPU must write 0 in the corresponding field. Value after reset is low. " end="0" id="OA0_EN" rwaccess="RW" width="1"></bitfield>
  </register>
</module>
