<?xml version="1.0" encoding="UTF-8" standalone="yes"?>


<module description="DCAN" id="DCAN">
  
  
  <register acronym="CTL" description="The Bus-Off recovery sequence (refer to CAN specification) cannot be shortened by setting or resetting Init bit. If the module goes Bus-Off, it will automatically set the Init bit and stop all bus activities. When the Init bit is cleared by the application again, the module will then wait for 129 occurrences of Bus Idle (129 * 11 consecutive recessive bits) before resuming normal operation. At the end of the bus-off recovery sequence, the error counters will be reset. After the Init bit is reset, each time when a sequence of 11 recessive bits is monitored, a Bit0 error code is written to the error and status register, enabling the CPU to check whether the CAN bus is stuck at dominant or continuously disturbed, and to monitor the proceeding of the bus-off recovery sequence." id="CTL" offset="0x0" width="32">
    
  <bitfield begin="31" description="" end="26" id="Reserved1" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="25" description="Automatic wake up on bus activity when in local power-down mode. Note: The CAN message, which initiates the bus activity, cannot be received. This means that the first message received in power down and automatic wake-up mode, will be lost." end="25" id="WUBA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="24" description="Request for local low power-down mode" end="24" id="PDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="23" description="" end="21" id="Reserved2" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="20" description="Enable DMA request line for IF3. Note: A pending DMA request for IF3 remains active until first access to one of the IF3 registers." end="20" id="DE3" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="19" description="Enable DMA request line for IF2. Note: A pending DMA request for IF2 remains active until first access to one of the IF2 registers." end="19" id="DE2" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="18" description="Enable DMA request line for IF1. Note: A pending DMA request for IF1 remains active until first access to one of the IF1 registers." end="18" id="DE1" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="Interrupt line 1 enable" end="17" id="IE1" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="16" description="Internal init state while debug access" end="16" id="InitDbg" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="15" description="SW reset enable. Note: To execute software reset, the following procedure is necessary: (a) Set Init bit to shut down CAN communication and (b) Set SWR bit additionally to Init bit." end="15" id="SWR" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="14" description="" end="14" id="Reserved3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="13" description="Parity on/off. 5 = Parity function disabled. Others = Parity function enabled." end="10" id="PMD" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="9" description="Auto-Bus-On enable" end="9" id="ABO" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Interruption debug support enable" end="8" id="IDS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Test mode enable" end="7" id="Test" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="Configuration change enable" end="6" id="CCE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="Disable automatic retransmission" end="5" id="DAR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="" end="4" id="Reserved4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="3" description="Error interrupt enable" end="3" id="EIE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Status change interrupt enable" end="2" id="SIE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="Interrupt line 0 enable" end="1" id="IE0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Initialization" end="0" id="Init" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="ES" description="Interrupts are generated by bits PER, BOff and EWarn (if EIE bit in CAN control register is set) and by bits WakeUpPnd, RxOk, TxOk, and LEC (if SIE bit in CAN control register is set). A change of bit EPass will not generate an interrupt. Reading the error and status register clears the WakeUpPnd, PER, RxOk and TxOk bits and set the LEC to value '7.' Additionally, the status interrupt value (0x8000) in the interrupt register will be replaced by the next lower priority interrupt value. The EOI for all other interrupts (DCANINT0 and DCANINT1) are automatically handled by hardware. For debug support, the auto clear functionality of error and status register (clear of status flags by read) is disabled when in debug/suspend mode." id="ES" offset="0x4" width="32">
    
  <bitfield begin="31" description="" end="11" id="Reserved1" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Local power-down mode acknowledge" end="10" id="PDA" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="9" description="Wake up pending. This bit can be used by the CPU to identify the DCAN as the source to wake up the system. This bit will be reset if error and status register is read." end="9" id="WakeUp_Pnd" rwaccess="R/C" width="1"></bitfield>
    
  <bitfield begin="8" description="Parity error detected. This bit will be reset if error and status register is read." end="8" id="PER" rwaccess="R/C" width="1"></bitfield>
    
  <bitfield begin="7" description="Bus-Off state" end="7" id="BOff" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="Warning state" end="6" id="EWarn" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="5" description="Error passive state" end="5" id="EPass" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="4" description="Received a message successfully. This bit will be reset if error and status register is read." end="4" id="RxOk" rwaccess="R/C" width="1"></bitfield>
    
  <bitfield begin="3" description="Transmitted a message successfully. This bit will be reset if error and status register is read." end="3" id="TxOk" rwaccess="R/C" width="1"></bitfield>
    
  <bitfield begin="2" description="Last error code. The LEC field indicates the type of the last error on the CAN bus. This field will be cleared to '0' when a message has been transferred (reception or transmission) without error." end="0" id="LEC" rwaccess="R/S" width="3"></bitfield>
  </register>
  
  
  <register acronym="ERRC" description="" id="ERRC" offset="0x8" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Receive error passive" end="15" id="RP" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="14" description="Receive error counter. Actual state of the receive error counter (values from 0 to 255)." end="8" id="REC_6_0" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="7" description="Transmit error counter. Actual state of the transmit error counter (values from 0 to 255)." end="0" id="TEC_7_0" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="BTR" description="This register is only writable if CCE and Init bits in the CAN control register are set. The CAN bit time may be programmed in the range of 8 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to1024 CAN_CLK periods. With a CAN_CLK of 8 MHz and BRPE = 0x00, the reset value of 0x00002301 configures the DCAN for a bit rate of 500kBit/s." id="BTR" offset="0xC" width="32">
    
  <bitfield begin="31" description="" end="20" id="Reserved1" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="19" description="Baud rate prescaler extension. Valid programmed values are 0 to 15. By programming BRPE the baud rate prescaler can be extended to values up to 1024." end="16" id="BRPE" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="15" description="" end="15" id="Reserved2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="14" description="Time segment after the sample point. Valid programmed values are 0 to 7. The actual TSeg2 value which is interpreted for the bit timing will be the programmed TSeg2 value + 1." end="12" id="TSeg2" rwaccess="R/WP" width="3"></bitfield>
    
  <bitfield begin="11" description="Time segment before the sample point. Valid programmed values are 1 to 15. The actual TSeg1 value interpreted for the bit timing will be the programmed TSeg1 value + 1." end="8" id="TSeg1" rwaccess="R/WP" width="4"></bitfield>
    
  <bitfield begin="7" description="Synchronization Jump Width. Valid programmed values are 0 to 3. The actual SJW value interpreted for the synchronization will be the programmed SJW value + 1." end="6" id="SJW" rwaccess="R/WP" width="2"></bitfield>
    
  <bitfield begin="5" description="Baud rate prescaler. Value by which the CAN_CLK frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid programmed values are 0 to 63. The actual BRP value interpreted for the bit timing will be the programmed BRP value + 1." end="0" id="BRP" rwaccess="R/WP" width="6"></bitfield>
  </register>
  
  
  <register acronym="INT" description="" id="INT" offset="0x10" width="32">
    
  <bitfield begin="31" description="" end="24" id="Reserved1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Interrupt 1 Identifier (indicates the message object with the highest pending interrupt). If several interrupts are pending, the CAN interrupt register will point to the pending interrupt with the highest priority. The DCAN1INT interrupt line remains active until Int1ID reaches value 0 (the cause of the interrupt is reset) or until IE1 is cleared. A message interrupt is cleared by clearing the message object's IntPnd bit. Among the message interrupts, the message object's interrupt priority decreases with increasing message number." end="16" id="Int1ID_23_16" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="Interrupt Identifier (the number here indicates the source of the interrupt). If several interrupts are pending, the CAN interrupt register will point to the pending interrupt with the highest priority. The DCAN0INT interrupt line remains active until Int0ID reaches value 0 (the cause of the interrupt is reset) or until IE0 is cleared. The Status interrupt has the highest priority. Among the message interrupts, the message object's interrupt priority decreases with increasing message number." end="0" id="Int0ID_15_0" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="TEST" description="For all test modes, the test bit in CAN control register needs to be set to one. If test bit is set, the RDA, EXL, Tx1, Tx0, LBack and Silent bits are writable. Bit Rx monitors the state of pin CAN_RX and therefore is only readable. All test register functions are disabled when test bit is cleared. The test register is only writable if test bit in CAN control register is set. Setting Tx[1:0] other than '00' will disturb message transfer. When the internal loop-back mode is active (bit LBack is set), bit EXL will be ignored." id="TEST" offset="0x14" width="32">
    
  <bitfield begin="31" description="" end="10" id="Reserved1" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="RAM direct access enable" end="9" id="RDA" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="8" description="External loopback mode" end="8" id="EXL" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="7" description="Receive pin. Monitors the actual value of the CAN_RX pin" end="7" id="Rx" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="Control of CAN_TX pin." end="5" id="Tx_1_0" rwaccess="R/WP" width="2"></bitfield>
    
  <bitfield begin="4" description="Loopback mode" end="4" id="LBack" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="3" description="Silent mode" end="3" id="Silent" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="2" description="" end="0" id="Reserved2" rwaccess="R" width="3"></bitfield>
  </register>
  
  
  <register acronym="PERR" description="If a parity error is detected, the PER flag will be set in the error and status register. This bit is not reset by the parity check mechanism; it must be reset by reading the error and status register. In addition to the PER flag, the parity error code register will indicate the memory area where the parity error has been detected (message number and word number). If more than one word with a parity error was detected, the highest word number with a parity error will be displayed. After a parity error has been detected, the register will hold the last error code until power is removed." id="PERR" offset="0x1C" width="32">
    
  <bitfield begin="31" description="" end="11" id="Reserved1" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Word number where parity error has been detected." end="8" id="Word_Number" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="7" description="Message number." end="0" id="Message_Number" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="ABOTR" description="On write access to the CAN control register while Auto-Bus-On timer is running, the Auto-Bus-On procedure will be aborted. During Debug/Suspend mode, running Auto-Bus-On timer will be paused." id="ABOTR" offset="0x80" width="32">
    
  <bitfield begin="31" description="Number of OCP clock cycles before a Bus-Off recovery sequence is started by clearing the Init bit. This function has to be enabled by setting bit ABO in CAN control register. The Auto-Bus-On timer is realized by a 32 bit counter that starts to count down to zero when the module goes Bus-Off. The counter will be reloaded with the preload value of the ABO time register after this phase." end="0" id="ABO_Time" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TXRQ_X" description="Example 1. Bit 0 of the transmission request X register represents byte 0 of the transmission request 1 register. If one or more bits in this byte are set, bit 0 of the transmission request X register will be set." id="TXRQ_X" offset="0x84" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="TxRqstReg8" end="14" id="TxRqstReg8" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="TxRqstReg7" end="12" id="TxRqstReg7" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="TxRqstReg6" end="10" id="TxRqstReg6" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description="TxRqstReg5" end="8" id="TxRqstReg5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="7" description="TxRqstReg4" end="6" id="TxRqstReg4" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="TxRqstReg3" end="4" id="TxRqstReg3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="3" description="TxRqstReg2" end="2" id="TxRqstReg2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="TxRqstReg1" end="0" id="TxRqstReg1" rwaccess="R" width="2"></bitfield>
  </register>
  
  
  <register acronym="TXRQ12" description="The TXRQ12 to TXRQ78 registers hold the TxRqst bits of the implemented message objects. By reading out these bits, the CPU can check for pending transmission requests. The TxRqst bit in a specific message object can be set/reset by the CPU via the IF1/IF2 message interface registers, or by the message handler after reception of a remote frame or after a successful transmission." id="TXRQ12" offset="0x88" width="32">
    
  <bitfield begin="31" description="Transmission request bits (for all message objects)" end="16" id="TxRqs_32_17" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Transmission request bits (for all message objects)" end="0" id="TxRqs_16_1" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="TXRQ34" description="The TXRQ12 to TXRQ78 registers hold the TxRqst bits of the implemented message objects. By reading out these bits, the CPU can check for pending transmission requests. The TxRqst bit in a specific message object can be set/reset by the CPU via the IF1/IF2 message interface registers, or by the message handler after reception of a remote frame or after a successful transmission." id="TXRQ34" offset="0x8C" width="32">
    
  <bitfield begin="31" description="Transmission request bits (for all message objects)" end="16" id="TxRqs_64_49" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Transmission request bits (for all message objects)" end="0" id="TxRqs_48_33" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="TXRQ56" description="The TXRQ12 to TXRQ78 registers hold the TxRqst bits of the implemented message objects. By reading out these bits, the CPU can check for pending transmission requests. The TxRqst bit in a specific message object can be set/reset by the CPU via the IF1/IF2 message interface registers, or by the message handler after reception of a remote frame or after a successful transmission." id="TXRQ56" offset="0x90" width="32">
    
  <bitfield begin="31" description="Transmission request bits (for all message objects)" end="16" id="TxRqs_96_81" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Transmission request bits (for all message objects)" end="0" id="TxRqs_80_65" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="TXRQ78" description="The TXRQ12 to TXRQ78 registers hold the TxRqst bits of the implemented message objects. By reading out these bits, the CPU can check for pending transmission requests. The TxRqst bit in a specific message object can be set/reset by the CPU via the IF1/IF2 message interface registers, or by the message handler after reception of a remote frame or after a successful transmission." id="TXRQ78" offset="0x94" width="32">
    
  <bitfield begin="31" description="Transmission request bits (for all message objects)" end="16" id="TxRqs_128_113" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Transmission request bits (for all message objects)" end="0" id="TxRqs_112_97" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="NWDAT_X" description="With the new data X register, the CPU can detect if one or more bits in the different new data registers are set. Each register bit represents a group of eight message objects. If at least on of the NewDat bits of these message objects are set, the corresponding bit in the new data X register will be set. Example 1. Bit 0 of the new data X register represents byte 0 of the new data 1 register. If one or more bits in this byte are set, bit 0 of the new data X register will be set." id="NWDAT_X" offset="0x98" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="NewDatReg8" end="14" id="NewDatReg8" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="NewDatReg7" end="12" id="NewDatReg7" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="NewDatReg6" end="10" id="NewDatReg6" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description="NewDatReg5" end="8" id="NewDatReg5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="7" description="NewDatReg4" end="6" id="NewDatReg4" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="NewDatReg3" end="4" id="NewDatReg3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="3" description="NewDatReg2" end="2" id="NewDatReg2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="NewDatReg1" end="0" id="NewDatReg1" rwaccess="R" width="2"></bitfield>
  </register>
  
  
  <register acronym="NWDAT12" description="These registers hold the NewDat bits of the implemented message objects. By reading out these bits, the CPU can check for new data in the message objects. The NewDat bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after reception of a data frame or after a successful transmission." id="NWDAT12" offset="0x9C" width="32">
    
  <bitfield begin="31" description="New Data Bits (for all message objects)" end="16" id="NewDat_32_17" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="New Data Bits (for all message objects)" end="0" id="NewDat_16_1" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="NWDAT34" description="These registers hold the NewDat bits of the implemented message objects. By reading out these bits, the CPU can check for new data in the message objects. The NewDat bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after reception of a data frame or after a successful transmission." id="NWDAT34" offset="0xA0" width="32">
    
  <bitfield begin="31" description="New Data Bits (for all message objects)" end="16" id="NewDat_64_49" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="New Data Bits (for all message objects)" end="0" id="NewDat_48_33" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="NWDAT56" description="These registers hold the NewDat bits of the implemented message objects. By reading out these bits, the CPU can check for new data in the message objects. The NewDat bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after reception of a data frame or after a successful transmission." id="NWDAT56" offset="0xA4" width="32">
    
  <bitfield begin="31" description="New Data Bits (for all message objects)" end="16" id="NewDat_96_81" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="New Data Bits (for all message objects)" end="0" id="NewDat_80_65" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="NWDAT78" description="These registers hold the NewDat bits of the implemented message objects. By reading out these bits, the CPU can check for new data in the message objects. The NewDat bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after reception of a data frame or after a successful transmission." id="NWDAT78" offset="0xA8" width="32">
    
  <bitfield begin="31" description="New Data Bits (for all message objects)" end="16" id="NewDat_128_113" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="New Data Bits (for all message objects)" end="0" id="NewDat_112_97" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="INTPND_X" description="With the interrupt pending X register, the CPU can detect if one or more bits in the different interrupt pending registers are set. Each bit of this register represents a group of eight message objects. If at least one of the IntPnd bits of these message objects are set, the corresponding bit in the interrupt pending X register will be set. Example 2. Bit 0 of the interrupt pending X register represents byte 0 of the interrupt pending 1 register. If one or more bits in this byte are set, bit 0 of the interrupt pending X register will be set." id="INTPND_X" offset="0xAC" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="IntPndReg8" end="14" id="IntPndReg8" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="IntPndReg7" end="12" id="IntPndReg7" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="IntPndReg6" end="10" id="IntPndReg6" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description="IntPndReg5" end="8" id="IntPndReg5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="7" description="IntPndReg4" end="6" id="IntPndReg4" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="IntPndReg3" end="4" id="IntPndReg3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="3" description="IntPndReg2" end="2" id="IntPndReg2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="IntPndReg1" end="0" id="IntPndReg1" rwaccess="R" width="2"></bitfield>
  </register>
  
  
  <register acronym="INTPND12" description="These registers hold the IntPnd bits of the implemented message objects. By reading out these bits, the CPU can check for pending interrupts in the message objects. The IntPnd bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="INTPND12" offset="0xB0" width="32">
    
  <bitfield begin="31" description="Interrupt Pending Bits (for all message objects)" end="16" id="IntPnd_32_17" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Interrupt Pending Bits (for all message objects)" end="0" id="IntPnd_16_1" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="INTPND34" description="These registers hold the IntPnd bits of the implemented message objects. By reading out these bits, the CPU can check for pending interrupts in the message objects. The IntPnd bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="INTPND34" offset="0xB4" width="32">
    
  <bitfield begin="31" description="Interrupt Pending Bits (for all message objects)" end="16" id="IntPnd_64_49" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Interrupt Pending Bits (for all message objects)" end="0" id="IntPnd_48_33" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="INTPND56" description="These registers hold the IntPnd bits of the implemented message objects. By reading out these bits, the CPU can check for pending interrupts in the message objects. The IntPnd bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="INTPND56" offset="0xB8" width="32">
    
  <bitfield begin="31" description="Interrupt Pending Bits (for all message objects)" end="16" id="IntPnd_96_81" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Interrupt Pending Bits (for all message objects)" end="0" id="IntPnd_80_65" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="INTPND78" description="These registers hold the IntPnd bits of the implemented message objects. By reading out these bits, the CPU can check for pending interrupts in the message objects. The IntPnd bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="INTPND78" offset="0xBC" width="32">
    
  <bitfield begin="31" description="Interrupt Pending Bits (for all message objects)" end="16" id="IntPnd_128_113" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Interrupt Pending Bits (for all message objects)" end="0" id="IntPnd_112_97" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="MSGVAL_X" description="With the message valid X register, the CPU can detect if one or more bits in the different message valid registers are set. Each bit of this register represents a group of eight message objects. If at least one of the MsgVal bits of these message objects are set, the corresponding bit in the message valid X register will be set. Example 3. Bit 0 of the message valid X register represents byte 0 of the message valid 1 register. If one or more bits in this byte are set, bit 0 of the message valid X register will be set." id="MSGVAL_X" offset="0xC0" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="MsgValReg8" end="14" id="MsgValReg8" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="MsgValReg7" end="12" id="MsgValReg7" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="MsgValReg6" end="10" id="MsgValReg6" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description="MsgValReg5" end="8" id="MsgValReg5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="7" description="MsgValReg4" end="6" id="MsgValReg4" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="MsgValReg3" end="4" id="MsgValReg3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="3" description="MsgValReg2" end="2" id="MsgValReg2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="MsgValReg1" end="0" id="MsgValReg1" rwaccess="R" width="2"></bitfield>
  </register>
  
  
  <register acronym="MSGVAL12" description="These registers hold the MsgVal bits of the implemented message objects. By reading out these bits, the CPU can check which message objects are valid. The MsgVal bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="MSGVAL12" offset="0xC4" width="32">
    
  <bitfield begin="31" description="Message valid bits (for all message objects)" end="16" id="MsgVal_32_17" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Message valid bits (for all message objects)" end="0" id="MsgVal_16_1" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="MSGVAL34" description="These registers hold the MsgVal bits of the implemented message objects. By reading out these bits, the CPU can check which message objects are valid. The MsgVal bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="MSGVAL34" offset="0xC8" width="32">
    
  <bitfield begin="31" description="Message valid bits (for all message objects)" end="16" id="MsgVal_64_49" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Message valid bits (for all message objects)" end="0" id="MsgVal_48_33" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="MSGVAL56" description="These registers hold the MsgVal bits of the implemented message objects. By reading out these bits, the CPU can check which message objects are valid. The MsgVal bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="MSGVAL56" offset="0xCC" width="32">
    
  <bitfield begin="31" description="Message valid bits (for all message objects)" end="16" id="MsgVal_96_81" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Message valid bits (for all message objects)" end="0" id="MsgVal_80_65" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="MSGVAL78" description="These registers hold the MsgVal bits of the implemented message objects. By reading out these bits, the CPU can check which message objects are valid. The MsgVal bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="MSGVAL78" offset="0xD0" width="32">
    
  <bitfield begin="31" description="Message valid bits (for all message objects)" end="16" id="MsgVal_128_113" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Message valid bits (for all message objects)" end="0" id="MsgVal_112_97" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="INTMUX12" description="The IntMux flag determine for each message object, which of the two interrupt lines (DCAN0INT or DCAN1INT) will be asserted when the IntPnd of this message object is set. Both interrupt lines can be globally enabled or disabled by setting or clearing IE0 and IE1 bits in CAN control register. The IntPnd bit of a specific message object can be set or reset by the CPU via the IF1/IF2 interface register sets, or by message handler after reception or successful transmission of a frame. This will also affect the Int0ID resp Int1ID flags in the interrupt register." id="INTMUX12" offset="0xD8" width="32">
    
  <bitfield begin="31" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="16" id="IntMux_32_17" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="0" id="IntMux_16_1" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="INTMUX34" description="The IntMux flag determine for each message object, which of the two interrupt lines (DCAN0INT or DCAN1INT) will be asserted when the IntPnd of this message object is set. Both interrupt lines can be globally enabled or disabled by setting or clearing IE0 and IE1 bits in CAN control register. The IntPnd bit of a specific message object can be set or reset by the CPU via the IF1/IF2 interface register sets, or by message handler after reception or successful transmission of a frame. This will also affect the Int0ID resp Int1ID flags in the interrupt register." id="INTMUX34" offset="0xDC" width="32">
    
  <bitfield begin="31" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="16" id="IntMux_64_49" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="0" id="IntMux_48_33" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="INTMUX56" description="The IntMux flag determine for each message object, which of the two interrupt lines (DCAN0INT or DCAN1INT) will be asserted when the IntPnd of this message object is set. Both interrupt lines can be globally enabled or disabled by setting or clearing IE0 and IE1 bits in CAN control register. The IntPnd bit of a specific message object can be set or reset by the CPU via the IF1/IF2 interface register sets, or by message handler after reception or successful transmission of a frame. This will also affect the Int0ID resp Int1ID flags in the interrupt register." id="INTMUX56" offset="0xE0" width="32">
    
  <bitfield begin="31" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="16" id="IntMux_96_81" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="0" id="IntMux_80_65" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="INTMUX78" description="The IntMux flag determine for each message object, which of the two interrupt lines (DCAN0INT or DCAN1INT) will be asserted when the IntPnd of this message object is set. Both interrupt lines can be globally enabled or disabled by setting or clearing IE0 and IE1 bits in CAN control register. The IntPnd bit of a specific message object can be set or reset by the CPU via the IF1/IF2 interface register sets, or by message handler after reception or successful transmission of a frame. This will also affect the Int0ID resp Int1ID flags in the interrupt register." id="INTMUX78" offset="0xE4" width="32">
    
  <bitfield begin="31" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="16" id="IntMux_128_113" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="0" id="IntMux_112_97" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="IF1CMD" description="The IF1 Command Register (IF1CMD) configures and initiates the transfer between the IF1 register sets and the message RAM. It is configurable which portions of the message object should be transferred. A transfer is started when the CPU writes the message number to bits [7:0] of the IF1 command register. With this write operation, the Busy bit is automatically set to '1' to indicate that a transfer is in progress. After 4 to 14 OCP clock cycles, the transfer between the interface register and the message RAM will be completed and the Busy bit is cleared. The maximum number of cycles is needed when the message transfer concurs with a CAN message transmission, acceptance filtering, or message storage. If the CPU writes to both IF1 command registers consecutively (request of a second transfer while first transfer is still in progress), the second transfer will start after the first one has been completed. While Busy bit is one, IF1 register sets are write protected. For debug support, the auto clear functionality of the IF1 command registers (clear of DMAactive flag by r/w) is disabled during Debug/Suspend mode. If an invalid Message Number is written to bits [7:0] of the IF1 command register, the message handler may access an implemented (valid) message object instead." id="IF1CMD" offset="0x100" width="32">
    
  <bitfield begin="31" description="" end="24" id="Reserved1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Write/Read" end="23" id="WR_RD" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="22" description="Access mask bits" end="22" id="Mask" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="21" description="Access arbitration bits" end="21" id="Arb" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="20" description="Access control bits. If the TxRqst/NewDat bit in this register(Bit [18]) is set, the TxRqst/ NewDat bit in the IF1 message control register will be ignored." end="20" id="Control" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="19" description="Clear interrupt pending bit" end="19" id="ClrIntPnd" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="18" description="Access transmission request bit. Note: If a CAN transmission is requested by setting TxRqst/NewDat in this register, the TxRqst/NewDat bits in the message object will be set to one independent of the values in IF1 message control Register. Note: A read access to a message object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IF1 message control register always reflect the status before resetting them." end="18" id="TxRqst_NewDat" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="17" description="Access Data Bytes 0 to 3." end="17" id="Data_A" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="16" description="Access Data Bytes 4 to 7." end="16" id="Data_B" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="15" description="Busy flag. This bit is set to one after the message number has been written to bits 7 to 0. IF1 register set will be write protected. The bit is cleared after read/write action has been finished." end="15" id="Busy" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="14" description="Activation of DMA feature for subsequent internal IF1 update. Note: Due to the auto reset feature of the DMAactive bit, this bit has to be set for each subsequent DMA cycle separately." end="14" id="DMAactive" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="13" description="" end="8" id="Reserved2" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="7" description="Number of message object in message RAM which is used for data transfer." end="0" id="Message_Number" rwaccess="R/WP" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF1MSK" description="The bits of the IF1 mask registers mirror the mask bits of a message object. While Busy bit of IF1 command register is one, IF1 register set is write protected." id="IF1MSK" offset="0x104" width="32">
    
  <bitfield begin="31" description="Mask Extended Identifier. When 11 bit (standard) identifiers are used for a message object, the identifiers of received data frames are written into bits ID28 to ID18. For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 are considered." end="31" id="MXtd" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="30" description="Mask Message Direction" end="30" id="MDir" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="29" description="" end="29" id="Reserved1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Identifier Mask" end="0" id="Msk_28_0" rwaccess="R/WP" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF1ARB" description="The bits of the IF1 arbitration registers mirror the arbitration bits of a message object. While Busy bit of IF1 command register is one, IF1 register set is write protected." id="IF1ARB" offset="0x108" width="32">
    
  <bitfield begin="31" description="Message valid. The CPU should reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init in the CAN control register. This bit must also be reset before the identifier ID28 to ID0, the control bits Xtd, Dir or DLC3 to DLC0 are modified, or if the messages object is no longer required." end="31" id="MsgVal" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="30" description="Extended identifier" end="30" id="Xtd" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="29" description="Message direction" end="29" id="Dir" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="28" description="Message identifier. ID28 to ID0 is equal to 29 bit identifier (extended frame) ID28 to ID18 is equal to 11 bit identifier (standard frame)" end="0" id="ID28_to_ID0" rwaccess="R/WP" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF1MCTL" description="The bits of the IF1 message control registers mirror the message control bits of a message object. While Busy bit of IF1 command register is one, IF1 register set is write protected." id="IF1MCTL" offset="0x10C" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R/WP" width="16"></bitfield>
    
  <bitfield begin="15" description="New data" end="15" id="NewDat" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="14" description="Message lost (only valid for message objects with direction = receive)" end="14" id="MsgLst" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="13" description="Interrupt pending" end="13" id="IntPnd" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="12" description="Use acceptance mask. If the UMask bit is set to one, the message object's mask bits have to be programmed during initialization of the message object before MsgVal is set to one." end="12" id="UMask" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="11" description="Transmit interrupt enable" end="11" id="TxIE" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="10" description="Receive interrupt enable" end="10" id="RxIE" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="9" description="Remote enable" end="9" id="RmtEn" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="8" description="Transmit request" end="8" id="TxRqst" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="7" description="Data frame has 0 to 8 data bits. Note: This bit is used to concatenate multiple message objects to build a FIFO Buffer. For single message objects (not belonging to a FIFO Buffer), this bit must always be set to one." end="7" id="EoB" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="6" description="" end="4" id="Reserved2" rwaccess="R/WP" width="3"></bitfield>
    
  <bitfield begin="3" description="Data length code. Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." end="0" id="DLC" rwaccess="R/WP" width="4"></bitfield>
  </register>
  
  
  <register acronym="IF1DATA" description="The data bytes of CAN messages are stored in the IF1 registers in the following order: (1) In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. (2) In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF1DATA" offset="0x110" width="32">
    
  <bitfield begin="31" description="Data 3." end="24" id="Data_3" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 2." end="16" id="Data_2" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 1." end="8" id="Data_1" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 0." end="0" id="Data_0" rwaccess="R/WP" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF1DATB" description="The data bytes of CAN messages are stored in the IF1 registers in the following order: (1) In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. (2) In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF1DATB" offset="0x114" width="32">
    
  <bitfield begin="31" description="Data 7." end="24" id="Data_7" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 6." end="16" id="Data_6" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 5." end="8" id="Data_5" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 4." end="0" id="Data_4" rwaccess="R/WP" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF2CMD" description="The IF2 Command Register (IF1CMD) configures and initiates the transfer between the IF2 register sets and the message RAM. It is configurable which portions of the message object should be transferred. A transfer is started when the CPU writes the message number to bits [7:0] of the IF2 command register. With this write operation, the Busy bit is automatically set to '1' to indicate that a transfer is in progress. After 4 to 14 OCP clock cycles, the transfer between the interface register and the message RAM will be completed and the Busy bit is cleared. The maximum number of cycles is needed when the message transfer concurs with a CAN message transmission, acceptance filtering, or message storage. If the CPU writes to both IF2 command registers consecutively (request of a second transfer while first transfer is still in progress), the second transfer will start after the first one has been completed. While Busy bit is one, IF2 register sets are write protected. For debug support, the auto clear functionality of the IF2 command registers (clear of DMAactive flag by r/w) is disabled during Debug/Suspend mode. If an invalid Message Number is written to bits [7:0] of the IF2 command register, the message handler may access an implemented (valid) message object instead." id="IF2CMD" offset="0x120" width="32">
    
  <bitfield begin="31" description="" end="24" id="Reserved1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Write/Read" end="23" id="WR_RD" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="22" description="Access mask bits" end="22" id="Mask" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="21" description="Access arbitration bits" end="21" id="Arb" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="20" description="Access control bits. If the TxRqst/NewDat bit in this register(Bit [18]) is set, the TxRqst/ NewDat bit in the IF2 message control register will be ignored." end="20" id="Control" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="19" description="Clear interrupt pending bit" end="19" id="ClrIntPnd" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="18" description="Access transmission request bit. Note: If a CAN transmission is requested by setting TxRqst/NewDat in this register, the TxRqst/NewDat bits in the message object will be set to one independent of the values in IF2 message control Register. Note: A read access to a message object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IF2 message control register always reflect the status before resetting them." end="18" id="TxRqst_NewDat" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="17" description="Access Data Bytes 0 to 3." end="17" id="Data_A" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="16" description="Access Data Bytes 4 to 7." end="16" id="Data_B" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="15" description="Busy flag. This bit is set to one after the message number has been written to bits 7 to 0. IF2 register set will be write protected. The bit is cleared after read/write action has been finished." end="15" id="Busy" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="14" description="Activation of DMA feature for subsequent internal IF2 update. Note: Due to the auto reset feature of the DMAactive bit, this bit has to be set for each subsequent DMA cycle separately." end="14" id="DMAactive" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="13" description="" end="8" id="Reserved2" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="7" description="Number of message object in message RAM which is used for data transfer." end="0" id="Message_Number" rwaccess="R/WP" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF2MSK" description="The bits of the IF2 mask registers mirror the mask bits of a message object. While Busy bit of IF2 command register is one, IF2 register set is write protected." id="IF2MSK" offset="0x124" width="32">
    
  <bitfield begin="31" description="Mask Extended Identifier. When 11 bit (standard) identifiers are used for a message object, the identifiers of received data frames are written into bits ID28 to ID18. For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 are considered." end="31" id="MXtd" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="30" description="Mask Message Direction" end="30" id="MDir" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="29" description="" end="29" id="Reserved1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Identifier Mask" end="0" id="Msk_28_0" rwaccess="R/WP" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF2ARB" description="The bits of the IF2 arbitration registers mirror the arbitration bits of a message object. While Busy bit of IF2 command register is one, IF2 register set is write protected." id="IF2ARB" offset="0x128" width="32">
    
  <bitfield begin="31" description="Message valid. The CPU should reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init in the CAN control register. This bit must also be reset before the identifier ID28 to ID0, the control bits Xtd, Dir or DLC3 to DLC0 are modified, or if the messages object is no longer required." end="31" id="MsgVal" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="30" description="Extended identifier" end="30" id="Xtd" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="29" description="Message direction" end="29" id="Dir" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="28" description="Message identifier. ID28 to ID0 is equal to 29-bit identifier (extended frame) ID28 to ID18 is equal to 11-bit identifier (standard frame)" end="0" id="ID28_to_ID0" rwaccess="R/WP" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF2MCTL" description="The bits of the IF2 message control registers mirror the message control bits of a message object. While Busy bit of IF2 command register is one, IF2 register set is write protected." id="IF2MCTL" offset="0x12C" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R/WP" width="16"></bitfield>
    
  <bitfield begin="15" description="New data" end="15" id="NewDat" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="14" description="Message lost (only valid for message objects with direction = receive)" end="14" id="MsgLst" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="13" description="Interrupt pending" end="13" id="IntPnd" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="12" description="Use acceptance mask. If the UMask bit is set to one, the message object's mask bits have to be programmed during initialization of the message object before MsgVal is set to one." end="12" id="UMask" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="11" description="Transmit interrupt enable" end="11" id="TxIE" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="10" description="Receive interrupt enable" end="10" id="RxIE" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="9" description="Remote enable" end="9" id="RmtEn" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="8" description="Transmit request" end="8" id="TxRqst" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="7" description="Data frame has 0 to 8 data bits. Note: This bit is used to concatenate multiple message objects to build a FIFO Buffer. For single message objects (not belonging to a FIFO Buffer), this bit must always be set to one." end="7" id="EoB" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="6" description="" end="4" id="Reserved2" rwaccess="R/WP" width="3"></bitfield>
    
  <bitfield begin="3" description="Data length code. Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." end="0" id="DLC" rwaccess="R/WP" width="4"></bitfield>
  </register>
  
  
  <register acronym="IF2DATA" description="The data bytes of CAN messages are stored in the IF2 registers in the following order: (1) In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. (2) In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF2DATA" offset="0x130" width="32">
    
  <bitfield begin="31" description="Data 3." end="24" id="Data_3" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 2." end="16" id="Data_2" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 1." end="8" id="Data_1" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 0." end="0" id="Data_0" rwaccess="R/WP" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF2DATB" description="The data bytes of CAN messages are stored in the IF2 registers in the following order: (1) In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. (2) In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF2DATB" offset="0x134" width="32">
    
  <bitfield begin="31" description="Data 7." end="24" id="Data_7" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 6." end="16" id="Data_6" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 5." end="8" id="Data_5" rwaccess="R/WP" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 4." end="0" id="Data_4" rwaccess="R/WP" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF3OBS" description="The IF3 register set can automatically be updated with received message objects without the need to initiate the transfer from message RAM by CPU. The observation flags (Bits [4:0]) in the IF3 observation register are used to determine, which data sections of the IF3 interface register set have to be read in order to complete a DMA read cycle. After all marked data sections are read, the DCAN is enabled to update the IF3 interface register set with new data. Any access order of single bytes or half-words is supported. When using byte or half-word accesses, a data section is marked as completed, if all bytes are read. Note: If IF3 Update Enable is used and no Observation flag is set, the corresponding message objects will be copied to IF3 without activating the DMA request line and without waiting for DMA read accesses. A write access to this register aborts a pending DMA cycle by resetting the DMA line and enables updating of IF3 interface register set with new data. To avoid data inconsistency, the DMA controller should be disabled before reconfiguring IF3 observation register. The status of the current read-cycle can be observed via status flags (Bits [12:8]). If an interrupt line is available for IF3, an interrupt will be generated by IF3Upd flag. See the device-specific data sheet for the availability of this interrupt source. With this interrupt, the observation status bits and the IF3Upd bit could be used by the application to realize the notification about new IF3 content in polling or interrupt mode." id="IF3OBS" offset="0x140" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="IF3 Update Data" end="15" id="IF3_Upd" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="14" description="" end="13" id="Reserved2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="12" description="IF3 Status of Data B read access" end="12" id="IF3_SDB" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="11" description="IF3 Status of Data A read access" end="11" id="IF3_SDA" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="10" description="IF3 Status of control bits read access" end="10" id="IF3_SC" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="9" description="IF3 Status of Arbitration data read access" end="9" id="IF3_SA" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="8" description="IF3 Status of Mask data read access" end="8" id="IF3_SM" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="7" description="" end="5" id="Reserved3" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="4" description="Data B read observation" end="4" id="DataB" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="Data A read observation" end="3" id="DataA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Ctrl read observation" end="2" id="Ctrl" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="Arbitration data read observation" end="1" id="Arb" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Mask data read observation" end="0" id="Mask" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="IF3MSK" description="" id="IF3MSK" offset="0x144" width="32">
    
  <bitfield begin="31" description="Mask Extended Identifier. When 11 bit (standard) identifiers are used for a message object, the identifiers of received data frames are written into bits ID28 to ID18. For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 are considered." end="31" id="MXtd" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="30" description="Mask Message Direction" end="30" id="MDir" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="29" description="" end="29" id="Reserved1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Identifier Mask" end="0" id="Msk_28_0" rwaccess="R/WP" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF3ARB" description="" id="IF3ARB" offset="0x148" width="32">
    
  <bitfield begin="31" description="Message Valid. The CPU should reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init in the CAN control register. This bit must also be reset before the identifier ID28 to ID0, the control bits Xtd, Dir or DLC3 to DLC0 are modified, or if the messages object is no longer required." end="31" id="MsgVal" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="30" description="Extended Identifier" end="30" id="Xtd" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="29" description="Message Direction" end="29" id="Dir" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Message Identifier. ID28 to ID0 is equal to 29 bit Identifier (extended frame). ID28 to ID18 is equal to 11 bit Identifier (standard frame)." end="0" id="ID28_to_ID0" rwaccess="R" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF3MCTL" description="" id="IF3MCTL" offset="0x14C" width="32">
    
  <bitfield begin="31" description="" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="New Data" end="15" id="NewDat" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="14" description="Message Lost (only valid for message objects with direction = receive)" end="14" id="MsgLst" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="13" description="Interrupt Pending" end="13" id="IntPnd" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="12" description="Use Acceptance Mask" end="12" id="UMask" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="11" description="Transmit Interrupt enable" end="11" id="TxIE" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="10" description="Receive Interrupt enable" end="10" id="RxIE" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="9" description="Remote enable" end="9" id="RmtEn" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="8" description="Transmit Request" end="8" id="TxRqst" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="7" description="Data frame has 0 to 8 data bits. Note: This bit is used to concatenate multiple message objects to build a FIFO Buffer. For single message objects (not belonging to a FIFO Buffer), this bit must always be set to one." end="7" id="EoB" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="" end="4" id="Reserved2" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="3" description="Data Length Code. Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." end="0" id="DLC" rwaccess="R" width="4"></bitfield>
  </register>
  
  
  <register acronym="IF3DATA" description="The data bytes of CAN messages are stored in the IF3 registers in the following order. In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF3DATA" offset="0x150" width="32">
    
  <bitfield begin="31" description="Data 3." end="24" id="Data_3" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 2." end="16" id="Data_2" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 1." end="8" id="Data_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 0." end="0" id="Data_0" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF3DATB" description="The data bytes of CAN messages are stored in the IF3 registers in the following order. In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF3DATB" offset="0x154" width="32">
    
  <bitfield begin="31" description="Data 7." end="24" id="Data_7" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 6." end="16" id="Data_6" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 5." end="8" id="Data_5" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 4." end="0" id="Data_4" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF3UPD12" description="The automatic update functionality of the IF3 register set can be configured for each message object. A message object is enabled for automatic IF3 update, if the dedicated IF3UpdEn flag is set. This means that an active NewDat flag of this message object (e.g due to reception of a CAN frame) will trigger an automatic copy of the whole message object to IF3 register set. IF3 Update enable should not be set for transmit objects." id="IF3UPD12" offset="0x160" width="32">
    
  <bitfield begin="31" description="IF3 Update Enabled (for all message objects)" end="16" id="IF3UpdEn_32_17" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="IF3 Update Enabled (for all message objects)" end="0" id="IF3UpdEn_16_1" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="IF3UPD34" description="The automatic update functionality of the IF3 register set can be configured for each message object. A message object is enabled for automatic IF3 update, if the dedicated IF3UpdEn flag is set. This means that an active NewDat flag of this message object (e.g due to reception of a CAN frame) will trigger an automatic copy of the whole message object to IF3 register set. IF3 Update enable should not be set for transmit objects." id="IF3UPD34" offset="0x164" width="32">
    
  <bitfield begin="31" description="IF3 Update Enabled (for all message objects)" end="16" id="IF3UpdEn_64_49" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="IF3 Update Enabled (for all message objects)" end="0" id="IF3UpdEn_48_33" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="IF3UPD56" description="The automatic update functionality of the IF3 register set can be configured for each message object. A message object is enabled for automatic IF3 update, if the dedicated IF3UpdEn flag is set. This means that an active NewDat flag of this message object (e.g due to reception of a CAN frame) will trigger an automatic copy of the whole message object to IF3 register set. IF3 Update enable should not be set for transmit objects." id="IF3UPD56" offset="0x168" width="32">
    
  <bitfield begin="31" description="IF3 Update Enabled (for all message objects)" end="16" id="IF3UpdEn_96_81" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="IF3 Update Enabled (for all message objects)" end="0" id="IF3UpdEn_80_65" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="IF3UPD78" description="The automatic update functionality of the IF3 register set can be configured for each message object. A message object is enabled for automatic IF3 update, if the dedicated IF3UpdEn flag is set. This means that an active NewDat flag of this message object (e.g due to reception of a CAN frame) will trigger an automatic copy of the whole message object to IF3 register set. IF3 Update enable should not be set for transmit objects." id="IF3UPD78" offset="0x16C" width="32">
    
  <bitfield begin="31" description="IF3 Update Enabled (for all message objects)" end="16" id="IF3UpdEn_128_113" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="IF3 Update Enabled (for all message objects)" end="0" id="IF3UpdEn_112_97" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="TIOC" description="The CAN_TX pin of the DCAN module can be used as general purpose IO pin if CAN function is not needed. The values of the IO control registers are only writable if Init bit of the CAN control register is set. The OD, Func, Dir and Out bits of the CAN TX IO control register are forced to certain values when Init bit of CAN control register is reset (see bit descriptions)." id="TIOC" offset="0x1E0" width="32">
    
  <bitfield begin="31" description="" end="19" id="Reserved1" rwaccess="R" width="13"></bitfield>
    
  <bitfield begin="18" description="CAN_TX pull up/pull down select. This bit is only active when CAN_TX is configured to be an input." end="18" id="PU" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="CAN_TX pull disable. This bit is only active when CAN_TX is configured to be an input." end="17" id="PD" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="16" description="CAN_TX open drain enable. This bit is only active when CAN_TX is configured to be in GIO mode (TIOC.Func=0). Forced to '0' if Init bit of CAN control register is reset." end="16" id="OD" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="15" description="" end="4" id="Reserved2" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="3" description="CAN_TX function. This bit changes the function of the CAN_TX pin. Forced to '1' if Init bit of CAN control register is reset." end="3" id="Func" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="2" description="CAN_TX data direction. This bit controls the direction of the CAN_TX pin when it is configured to be in GIO mode only (TIOC.Func=0). Forced to '1' if Init bit of CAN control register is reset." end="2" id="Dir" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="1" description="CAN_TX data out write. This bit is only active when CAN_TX pin is configured to be in GIO mode (TIOC.Func = 0) and configured to be an output pin (TIOC.Dir = 1). The value of this bit indicates the value to be output to the CAN_TX pin. Forced to Tx output of the CAN core, if Init bit of CAN control register is reset." end="1" id="Out" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="0" description="CAN_TX data in. Note: When CAN_TX pin is connected to a CAN transceiver, an external pullup resistor has to be used to ensure that the CAN bus will not be disturbed (e.g. while reset of the DCAN module)." end="0" id="In" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="RIOC" description="The CAN_RX pin of the DCAN module can be used as general purpose IO pin if CAN function is not needed. The values of the IO control registers are writable only if Init bit of CAN control register is set. The OD, Func and Dir bits of the CAN RX IO control register are forced to certain values when the Init bit of CAN control register is reset (see bit descriptions)." id="RIOC" offset="0x1E4" width="32">
    
  <bitfield begin="31" description="" end="19" id="Reserved1" rwaccess="R" width="13"></bitfield>
    
  <bitfield begin="18" description="CAN_RX pull up/pull down select. This bit is only active when CAN_RX is configured to be an input." end="18" id="PU" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="CAN_RX pull disable. This bit is only active when CAN_TX is configured to be an input." end="17" id="PD" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="16" description="CAN_RX open drain enable. This bit is only active when CAN_RX is configured to be in GIO mode (TIOC.Func=0). Forced to '0' if Init bit of CAN control register is reset." end="16" id="OD" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="15" description="" end="4" id="Reserved2" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="3" description="CAN_RX function. This bit changes the function of the CAN_RX pin. Forced to '1' if Init bit of CAN control register is reset." end="3" id="Func" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="2" description="CAN_RX data direction. This bit controls the direction of the CAN_RX pin when it is configured to be in GIO mode only (TIOC.Func=0). Forced to '1' if Init bit of CAN control register is reset." end="2" id="Dir" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="1" description="CAN_RX data out write. This bit is only active when CAN_RX pin is configured to be in GIO mode (TIOC.Func = 0) and configured to be an output pin (TIOC.Dir = 1). The value of this bit indicates the value to be output to the CAN_RX pin. Forced to Tx output of the CAN core, if Init bit of CAN control register is reset." end="1" id="Out" rwaccess="R/WP" width="1"></bitfield>
    
  <bitfield begin="0" description="CAN_RX data in. Note: When CAN_RX pin is connected to a CAN transceiver, an external pullup resistor has to be used to ensure that the CAN bus will not be disturbed (for example, while reset of the DCAN module)." end="0" id="In" rwaccess="R" width="1"></bitfield>
  </register>
</module>
