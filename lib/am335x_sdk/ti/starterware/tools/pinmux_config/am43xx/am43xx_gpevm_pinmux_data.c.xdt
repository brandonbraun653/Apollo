% var date = new Date();
/**
 * Note: This file was auto-generated by TI PinMux on `date.toLocaleDateString()` at `date.toLocaleTimeString()`.
 *
 * \file  am43xx_gpevm_pinmux_data.c
 *
 * \brief  This file contains the pin mux configurations for the boards.
 *         These are prepared based on how the peripherals are extended on
 *         the boards.
 *
 * \copyright Copyright (CU) `date.getFullYear()` Texas Instruments Incorporated -
 *             http://www.ti.com/
 */

/**
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */
#include "types.h"
#include "pinmux.h"
#include "am43xx_pinmux.h"

/** Peripheral Pin Configurations */

%%{
var capitalizeFirstLetterOnly = function( name ) {
	return name[0].toUpperCase() + name.substring( 1, name.length ).toLowerCase();
};

var getMappedInterface = function( assignment ) {
	// The PRUSS is named along with the sub module name. Eg: MII0_PRUSS1,
	// ECAT_PRUSS1, eCAP0_PRUSS1 etc… So where ever you have “PRUSS” as
	// substring the module is PRUSS (PRU_ICSS)

	if( -1 !== assignment.interfaceName.indexOf( "PRUSS" ) ) {
		return "PRU_ICSS";
	}

	// The PWMSS is named only with sub-module names (unlike PRUSS case).
	// Eg: eCAP0, eQEP2, eHRPWM2 etc…. So where ever you are seeing eCAP, eQEP,
	// eHRPWM without PRUSS substring they belong to PWMSS.

	switch( assignment.interfaceName ) {
		case "eCAP":
		case "eQEP":
		case "eHRPWM":
			return "PWMSS";

		case "RGMII":
		case "RGMII1":
		case "RGMII2":
		case "RMII":
		case "RMII1":
		case "RMII2":
		case "MII":
		case "MII1":
		case "MII2":
		case "MDIO":
			return "CPSW";

		case "MMC":
			return "MMCSD";

		case "CAM":
			return "VPFE";

		default:
			return assignment.interfaceName;
	}
};

var getPeripheralNum = function( assignment ) {
	// MII1_PRUSS is currently an exception.  We probably should have a
	// MII_PRUSS interface with two peripherals.

	if( assignment.interfaceName == "MII1_PRUSS" ) {
		return 1;
	}

	// Otherwise, look at the last character in the peripheral name.  If it's a
	// number, then we use that.  Otherwise, use 0

	var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
	if( isNaN( lastChar ) ) {
		return 0;
	}
	return lastChar;
};

var getMappedPeripheral = function( assignment ) {

	switch( assignment.interfaceName ) {
		case "RGMII":
		case "RGMII1":
		case "RGMII2":
		case "RMII":
		case "RMII1":
		case "RMII2":
		case "MII":
		case "MII1":
		case "MII2":
		case "MDIO":
			return getMappedInterface( assignment ) + "0";

		default:
			return getMappedInterface( assignment ) + getPeripheralNum( assignment );
	}
};

var getPeripheralInstNum = function( assignment ) {
	// MII1_PRUSS is currently an exception.  We probably should have a
	// MII_PRUSS interface with two peripherals.

	if( assignment.interfaceName == "MII1_PRUSS" ) {
		return 1;
	}

	var optionalParameters = getMappedPeripheral(assignment);

	// Otherwise, look at the last character in the peripheral name.  If it's a
	// number, then we use that.  Otherwise, use 0
	if(optionalParameters == assignment.interfaceName)
	{
		var lastChar = parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] );
	}
	else
	{
		var lastChar = parseInt( optionalParameters[ optionalParameters.length - 1 ] );
	}
	if( isNaN( lastChar ) ) {
		return 0;
	}
	return lastChar;
};

var OPT_PARAM = function( assignment ) {

	// If the peripheral is one of the following, then use the macro specified

	var optionalParameters = {
		PRU0_PRUSS0 : "PINMUX_SS_PRU_ICSS_PRU0",
		PRU1_PRUSS0 : "PINMUX_SS_PRU_ICSS_PRU1",
		PRU0_PRUSS1 : "PINMUX_SS_PRU_ICSS_PRU0",
		eCAP0_PRUSS1 : "PINMUX_SS_PRU_ICSS_ECAP0",
		UART0_PRUSS0 : "PINMUX_SS_PRU_ICSS_UART0",
		UART0_PRUSS1 : "PINMUX_SS_PRU_ICSS_UART0",
		MII0_PRUSS1 : "PINMUX_SS_PRU_ICSS_MII0",
		MII1_PRUSS1 : "PINMUX_SS_PRU_ICSS_MII1",
		ECAT_PRUSS1 : "PINMUX_SS_PRU_ICSS_ECAT",
		MDIO_PRUSS1 : "PINMUX_SS_PRU_ICSS_MDIO",
		eCAP0 : "PINMUX_SS_PWMSS_ECAP0",
		eCAP1 : "PINMUX_SS_PWMSS_ECAP1",
		eCAP2 : "PINMUX_SS_PWMSS_ECAP2",
		eQEP0 : "PINMUX_SS_PWMSS_EQEP0",
		eQEP1 : "PINMUX_SS_PWMSS_EQEP1",
		eQEP2 : "PINMUX_SS_PWMSS_EQEP2",
		eHRPWM0 : "PINMUX_SS_PWMSS_EHRPWM0",
		eHRPWM1 : "PINMUX_SS_PWMSS_EHRPWM1",
		eHRPWM2 : "PINMUX_SS_PWMSS_EHRPWM2",
		eHRPWM3 : "PINMUX_SS_PWMSS_EHRPWM3",
		eHRPWM4 : "PINMUX_SS_PWMSS_EHRPWM4",
		eHRPWM5 : "PINMUX_SS_PWMSS_EHRPWM5"
	}

	if( assignment.peripheral.name in optionalParameters ) {
		return "(uint16_t)" + optionalParameters[ assignment.peripheral.name ];
	}

	// Sanity check that we got every PRU_ICSS and PWMSS at this point

	if( assignment.interfaceName !== getMappedInterface( assignment )
		&&  "CPSW" !== getMappedInterface( assignment )
		&&  "VPFE" !== getMappedInterface( assignment )
		&&  "MMCSD" !== getMappedInterface( assignment )
	) {
		console.log( "Template failed to find an optional parameter for " + assignment.peripheral.name );
		throw new Error( "Template failed to find an optional parameter for " + assignment.peripheral.name );
	}

	// If this is a GPIO pin, extract the pin number and use that

	if( "GPIO" === assignment.interfaceName ) {
		return /\[([0-9]+)\]/.exec( assignment.peripheralPin.name )[1];
	}

	// For everything else, return 0

	return 0;
}

var PinOptions = function( assignment ) {
	var options = [];
	var notOptions = [];

	var addOption = function( option ) {
		if( option[0] === '~' ) {
			notOptions.push( option );
		} else {
			options.push( option );
		}
	};

	var IS_PULL_ENABLED = function() {
		if( assignment.pu || assignment.pd ) {
			return "~PIN_PULL_UD_DIS";
		}
		return "PIN_PULL_UD_DIS";
	};

	var PULL_TYPE = function() {
		if( assignment.pd ) {
			return "~PIN_PULL_UP_EN";
		}
		return "PIN_PULL_UP_EN";
	};

	var IS_RX_ACTIVE = function() {
		if( assignment.rx ) {
			return "PIN_RX_ACTIVE";
		}
		return "~PIN_RX_ACTIVE";
	};

	addOption( IS_PULL_ENABLED() );
	addOption( PULL_TYPE() );
	addOption( IS_RX_ACTIVE() );
	addOption( "PIN_DS_VALUE_OVERRIDE_EN" );
	addOption( "PIN_DS_OP_DIS" );
	addOption( "~PIN_DS_OP_VAL_1" );
	addOption( "~PIN_DS_PULL_UD_EN" );
	addOption( "PIN_DS_PULL_UP_EN" );
	addOption( "~PIN_WAKE_UP_EN" );

	var formatOptions = function( optionsList, operator ) {
		var result = "(";
		for( var i = 0; i < optionsList.length; ++i ) {
			result += optionsList[i];
			if( i != optionsList.length - 1 ) {
				result += operator;
			}
		}
		result += ")";
		return result;
	};

	this.getOptions = function() {
		return formatOptions( options, " | " );
	}

	this.getNotOptions = function() {
		return formatOptions( notOptions, " & " );
	}
}

// First, we need to sort all pin assigments into their mapped interfaces/
// peripherals.  This mapping isn't what pinmux knows, so we have to do it

var mappedAssignments = {};
for( var i = 0; i < assignments.length; ++i ) {
	var interfaceName = getMappedInterface( assignments[i] );
	var peripheralName = getMappedPeripheral( assignments[i] );
	mappedAssignments[ interfaceName ] = mappedAssignments[ interfaceName ] || {};
	mappedAssignments[ interfaceName ][ peripheralName ] = mappedAssignments[ interfaceName ][ peripheralName ] || [];
	mappedAssignments[ interfaceName ][ peripheralName ].push( assignments[i] );
}

%%}
% _.each( mappedAssignments, function( peripherals, interfaceName ) {
#define BUILDCFG_MOD_`interfaceName.toUpperCase()`
% } );

% _.each( mappedAssignments, function( peripherals, interfaceName ) {
#if defined(BUILDCFG_MOD_`interfaceName.toUpperCase()`)

% 	_.each( peripherals, function( pins, peripheralName ) {
static pinmuxPerCfg_t g`capitalizeFirstLetterOnly( peripheralName )`PinCfg[] =
{
%%{
	var enumStatements = [];
		for( var i = 0; i < pins.length; ++i ) {
			if( undefined == pins[i].devicePin.controlRegisterOffset || "NOT FOUND" == pins[i].devicePin.controlRegisterOffset ) {
			}
			else {
				var pinOptions = new PinOptions( pins[i] );
	enumStatements.push({line1 : "{",
		line2 : "	/* " + pins[i].requirementName + " -> " + pins[i].peripheralPin.name + " -> " + pins[i].devicePin.ball + " */",
		line3 : "	PIN_" + pins[i].devicePin.designSignalName.toUpperCase() + ", " + OPT_PARAM( pins[i] ) + ", \\",
		line4 : "	( \\",
		line5 : "		PIN_MODE(" + pins[i].muxMode + ") | \\",
		line6 : "		(" + pinOptions.getOptions() + " & \\",
		line7 : "		" + pinOptions.getNotOptions() + ")",
		line8 : "	) \\",
		line9 :	"},"});
			}
%%}
% 		}
%	for( var i = 0; i < enumStatements.length; ++i ) {
	`enumStatements[i].line1`
	`enumStatements[i].line2`
	`enumStatements[i].line3`
	`enumStatements[i].line4`
	`enumStatements[i].line5`
	`enumStatements[i].line6`
	`enumStatements[i].line7`
	`enumStatements[i].line8`
	`enumStatements[i].line9`
%	}
	{PINMUX_INVALID_PIN}
};

% 	} );
static pinmuxModuleCfg_t g`capitalizeFirstLetterOnly( interfaceName )`PinCfg[] =
{
% 	_.each( peripherals, function( pins, peripheralName ) {
    {`getPeripheralInstNum( pins[0] )`, TRUE, g`capitalizeFirstLetterOnly( peripheralName )`PinCfg},
% 	} );
    {CHIPDB_INVALID_INSTANCE_NUM}
};

#endif /* if defined(BUILDCFG_MOD_`interfaceName.toUpperCase()`) */

% } );
/** EVM pin configurations for EVM */

pinmuxBoardCfg_t gGpevmPinmuxData[] =
{
% _.each( mappedAssignments, function( iface, interfaceName ) {
#if defined(BUILDCFG_MOD_`interfaceName.toUpperCase()`)
	{CHIPDB_MOD_ID_`interfaceName.toUpperCase()`, g`capitalizeFirstLetterOnly(interfaceName)`PinCfg},
#endif /* if defined(BUILDCFG_MOD_`interfaceName.toUpperCase()`) */
% } );
    {CHIPDB_MOD_ID_INVALID}
};
