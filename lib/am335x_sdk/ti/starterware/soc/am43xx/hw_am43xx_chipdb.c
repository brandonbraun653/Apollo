/**
 * \file    hw_chipdb.c
 *
 * \brief   Chip DB API Implementation
 *
 *          Chip DB API uses the pair (moduleID, instance) to uniquely
 *          identify a resource. The moduleID is unique across multiple SOCs.
 *          To make the implementation straight forward, the above pair is
 *          converted into a unique Resource ID to query the database.
 *
 *   WARNING: THIS IS AN AUTOGENERATED FILE. DO NOT MODIFY !!!
 *
 *
 * \version 0.0 (Aug 2013) : [AE] First version
 *
 */

/*
 * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
 */

/*
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */
#include <types.h>
#include <hw_types.h>
#include "hw_am43xx_chipdb.h"


/* ========================================================================== */
/*                           Macros & Typedefs                                */
/* ========================================================================== */


/* ========================================================================== */
/*                            Global Variables                                */
/* ========================================================================== */

/**
 *
 * \brief Resource ID Map
 *
 *        The ResourceIDMap is used to map the pair (moduleID, instance) to
 *        unique resource ID. For this mapping, the number of instances of
 *        each module (IP) in a given SOC is needed. This array is defined
 *        as below:
 *
 *        gChipDBResourceIDMap[i] =    0                            when i == 0
 *                                     gChipDBResourceIDMap[i-1] +
 *                                       num_instance_of_module(i)  when i > 0
 *
 *        So, this array has the resource ID of the first instance of the
 *        module. For example, say modules 0 and 1 have 3 and 2 instances
 *        respectively then the array has the following values:
 *            gChipDBResourceIDMap[0] = 0;
 *            gChipDBResourceIDMap[1] = 3;
 *            gChipDBResourceIDMap[2] = 5;
 *
 *        The mapping of the pair (moduleID, instance) to the unique resource
 *        ID is done as follows:
 *            Resource ID = gChipDBResourceIDMap[moduleID] + instance;
 *
 *        This table can also be used to get the number of instances of a
 *        module in the SOC:
 *            Number of instance = gChipDBResourceIDMap[moduleID + 1] -
 *                                   gChipDBResourceIDMap[moduleID]
 *
 *        To make the above calculation seamless for all values of moduleID,
 *        this array has the last entry as below:
 *           gChipDBResourceIDMap[CHIPDB_MOD_ID_COUNT] = CHIPDB_RESOURCE_COUNT;
 *
 *        Note that if a module is not in an SOC the instance is zero. Also,
 *        the Module ID may not be contiguous as there could be holes for
 *        IPs not relevant for a SOC. Yet these holes are represented in this
 *        table with instance = 0.
 *
 *        This Table is auto-generated.
 *
 */

const uint32_t gChipDBResourceIDMap[CHIPDB_MOD_ID_COUNT + 1] =
{
    /*
     * The table values are to be auto-generated
     */

    /*
    0,
    prev_entry + mod0_ninst,
    prev_entry + mod1_ninst,
    ...
    CHIPDB_RESOURCE_COUNT
    */
    0U, /* MPU_CORE */
    1U, /* DSP */
    1U, /* IVA */
    1U, /* IPU_CORE */
    1U, /* EVE */
    1U, /* GPU */
    1U, /* L3 */
    1U, /* DDR */
    1U, /* MPU */
    2U, /* IPU */
    2U, /* BB2D */
    2U, /* ATL */
    2U, /* VCP */
    2U, /* PRUSS */
    2U, /* VIP */
    2U, /* VIP_VINA */
    2U, /* VIP_VINB */
    2U, /* VPE */
    2U, /* DSS */
    3U, /* DSS_VIDEO */
    3U, /* DSS_HDMI */
    3U, /* OCMC_RAM */
    3U, /* EMIF */
    4U, /* GPMC */
    5U, /* DMM */
    5U, /* SYSTEM_DMA */
    5U, /* CRYPTO_DMA */
    5U, /* EDMA */
    5U, /* DCAN */
    7U, /* GMAC_SW */
    7U, /* GMAC_SW_PORT */
    7U, /* GMAC_SW_SWITCH */
    7U, /* GPIO */
    13U, /* I2C */
    16U, /* MCASP */
    18U, /* PCIE */
    18U, /* USB */
    20U, /* SATA */
    20U, /* MMC */
    20U, /* MLB */
    20U, /* MCSPI */
    25U, /* QSPI */
    26U, /* UART */
    32U, /* PWMSS */
    38U, /* RTC_SS */
    38U, /* TIMER */
    38U, /* COUNTER_32K */
    38U, /* WD_TIMER */
    38U, /* SPINLOCK */
    39U, /* HDQ1W */
    40U, /* KDB */
    40U, /* DES3DES */
    40U, /* SHAMD5 */
    40U, /* AES */
    41U, /* RNG */
    42U, /* FPKA */
    42U, /* PKA */
    43U, /* MPU_SCU */
    44U, /* CRYPTODMA */
    45U, /* DES */
    46U, /* SHA */
    47U, /* ADC1 */
    48U, /* GFX */
    49U, /* EDMA3CC */
    50U, /* EDMA3TC */
    53U, /* OTFA */
    54U, /* TPMSS */
    55U, /* VPFE */
    57U, /* CPSW */
    58U, /* USIM */
    60U, /* ADC0 */
    61U, /* MMCSD */
    64U, /* DMTIMER */
    76U, /* DMTIMER1_1MS */
    77U, /* WDT */
    79U, /* L3F_CFG */
    80U, /* L3S_CFG */
    81U, /* MAILBOX */
    82U, /* OCP_WP_NOC */
    83U, /* PRCM */
    84U, /* SMARTREFLEX */
    86U, /* RTCSS */
    87U, /* PRU_ICSS */
    89U, /* CONTROL_MODULE */
    90U, /* DEBUGSS */
    91U, /* OCMCRAM */
    92U, /* RTC */
    93U, /* SYNCTIMER */
    94U, /* ERMC */
    95U, /* ELM */
    96U, /* EMIF_FW */
    97U, /* GPMC_FW */
    98U, /* OCMCRAM_FW */
    99U, /* GFX_FW */
    100U, /* MMCSD2_FW */
    101U, /* MCASP0_FW */
    102U, /* MCASP1_FW */
    103U, /* EDMA3TC_FW */
    104U, /* QSPI_FW */
    105U, /* PRU_ICSS_FW */
    106U, /* EDMA3CC_FW */
    107U, /* DEBUGSS_FW */
    108U, /* AES_FW */
    109U, /* DES_FW */
    110U, /* SHA_FW */
    111U, /* ADC0_FW */
    112U, /* ADC1_FW */
    113U, /* MPU_L2_CACHE_FW */
    114U, /* MPU_CMU */
    115U, /* MPU_AXI2OCP */
    116U, /* P1500 */
    117U, /* WKUP_PROC */
    118U, /* WKUP_PROC_UMEM */
    119U, /* WKUP_PROC_DMEM */
    120U, /* WKUP_PROC_BIT_BAND_REG */
    121U, /* WKUP_PROC_NVIC */
    122U, /* WKUP_PROC_ROM_TAB */
    123U, /* MPU_ROM_SECURE */
    124U, /* MPU_ROM_PUBLIC */
    125U, /* MPU_SRAM */
    126U, /* MPU_L2_CACHE */
    127U, /* MPU_INTC */
    128U, /* MPU_SS_CFG */
    129U, /* MPU_PL310 */
    130U, /* MPU_SCM */
    131U, /* MPU_WAKEUP_GEN */
    132U, /* PRUSS(N)_DATARAM0*/
    134U, /* PRUSS(N)_DATARAM1*/
    136U, /* PRUSS(N)_SHARED_RAM */
    138U, /* PRUSS(N)_IEP_REG */
    140U, /* PRUSS(N)_MII_MDIO */
    142U, /* PRUSS(N)_INTC_REG */
    144U, /* PRUSS(N)_PRU0_CTRL */
    146U, /* PRUSS(N)_PRU1_CTRL */
    148U, /* PRUSS(N)_PRU0_DBG */
    150U, /* PRUSS(N)_PRU1_DBG */
    152U, /* PRUSS(N)_CFG_REG */
    154U, /* PRUSS(N)_UART_REG */
    156U, /* PRUSS(N)_ECAP_REG */
    158U, /* PRUSS(N)_MIIRT_REG */
    160U, /* USB_PHY_OCP2SCP */
    162U, /* USB_OTG_SS */
    CHIPDB_RESOURCE_COUNT
};

/**
 *
 * \brief Resource Table
 *
 *        The ResourceTable encodes the device definition. It is a bitmap that
 *        encodes if a resource is present or not. The bitmap is indexed using
 *        the SOC specific unique resource id.
 *
 *        The Table is auto-generated. The sample below assumes 4-words which
 *        can encode a maximum of 128 resources.
 *
 *        This Table is auto-generated.
 *
 */
const uint32_t
gChipDBResourceTable[CHIPDB_DEVICE_COUNT][CHIPDB_RESOURCE_RECORD_SIZE] =
{
    /*
     * The table values are to be auto-generated
     */
    /*
    {part0_bit_enc_31_0, part0_bit_enc_63_32, part0_bit_enc_95_64,
     part0_bit_enc_127_96},

    {part1_bit_enc_31_0, part1_bit_enc_63_32, part1_bit_enc_95_64,
       part1_bit_enc_127_96},

    {part63_bit_enc_31_0, part63_bit_enc_63_32, part63_bit_enc_95_64,
       Part63_bit_enc_127_96}
   */
    {
        0xFFFFFFFFU,
        0xF39F08FFU,
        0xFFFFDFFDU,
        0xF00C0000U,
        0xFFFFFFFFU,
        0xFFFFFFFFU,
    },
    {
        0xFFFFFFFFU,
        0xF3DF6BFFU,
        0xFFFFDFFDU,
        0xF80C0000U,
        0xFFFFFFFFU,
        0xFFFFFFFFU,
    },
    {
        0xFFFFFF9FU,
        0xFFFFFFFFU,
        0xFE7FFFFDU,
        0xF80DFFFFU,
        0xFFFFFFFFU,
        0xFFFFFFFFU,
    },
    {
        0xFFFFFF9FU,
        0xFFFFFFFFU,
        0xFE7FFFFDU,
        0xF82DFFFFU,
        0xFFFFFFFFU,
        0xFFFFFFFFU,
    },
    {
        0xFFFFFFFFU,
        0xF39F7BFFU,
        0xFFFFDFFDU,
        0xF00C0000U,
        0xFFFFFFFFU,
        0xFFFFFFFFU,
    }
};

/**
 * \brief Speed Grade Table
 *
 *        The SpeedGrade encodes the maximum frequency allowed for a processing
 *        unit.
 *
 *        This Table is auto-generated.
 *
 */

const uint32_t gChipDBSpeedGrade[CHIPDB_SG_COUNT][CHIPDB_SG_MODULE_COUNT] =
{
    /*
   {sg0_mpu_freq, sg0_dsp_freq, sg0_iva_freq, sg0_ipu_freq,
    sg0_eve_freq, sg0_gpu_freq, sg0_l3_freq, sg0_ddr_freq},
   {sg1_mpu_freq, sg1_dsp_freq, sg1_iva_freq, sg1_ipu_freq,
    Sg1_eve_freq, sg1_gpu_freq, sg1_l3_freq, sg1_ddr_freq},
       ...
   {sg26_mpu_freq, sg26_dsp_freq, sg26_iva_freq, sg26_ipu_freq,
    Sg26_eve_freq, sg26_gpu_freq, sg26_l3_freq, sg26_ddr_freq},
    */
};

/* ========================================================================== */
/*                          Function Definitions                              */
/* ========================================================================== */

/**
 *
 * \brief   Map the moduleID to the processor ID used to lookup speed grade.
 *
 *          This function is auto-generated
 *
 * \param   moduleID    Unique ID that identifies a Module (IP)
 *
 * \return  The processor ID
 *
 */
uint32_t CHIPDBSpeedGradeProcID(const chipdbModuleID_t moduleID)
{
    /*
     * There is a 1-1 mapping of moduleID to SpeedGrade ProcID so just
     * return the moduleID for Vayu. If there is a change to this mapping
     * later or for other SoC, the function should comprehend the mapping.
     */
    return moduleID;
}

/**
 *
 * \brief   Is the given ModuleID is a secure IP
 *
 *          This function is auto-generated
 *
 * \param   moduleID    Unique ID that identifies a Module (IP)
 *
 * \return  Return TRUE if the given moduleID is a secure IP; FALSE
 *          otherwise.
 *
 */
uint32_t CHIPDBIsSecureModule(const chipdbModuleID_t moduleID)
{
    switch (moduleID)
    {
        case CHIPDB_MOD_ID_CRYPTODMA:
        case CHIPDB_MOD_ID_DES:
        case CHIPDB_MOD_ID_SHA:
        case CHIPDB_MOD_ID_AES:
        case CHIPDB_MOD_ID_ADC1:
        case CHIPDB_MOD_ID_RNG:
        case CHIPDB_MOD_ID_PKA:
            return TRUE;
        default:
            return FALSE;
    }

    return FALSE;
}
