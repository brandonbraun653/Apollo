<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Project Profiling in CCS</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Processor SDK Utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Project Profiling in CCS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This guide steps through the manual profiling pipeline using the TI Utils library and CCS </p><h2>Introduction</h2>
<p>These instructions are for manually compiling and benchmarking the included LLD example projects in the TI Processor Development Kit. This benchmark tool uses the hardware clock of the PMU to measure the length of each task in processor cycles with minimal overhead. This guide and scripts were written for the AM5728 RTOS platform, but use standard C programming hooks that may be adapted for any platform and/or processor architecture.</p>
<p>Notes:</p><ul>
<li>Functions with more than one entry point may not always map correctly with their symbols and in the trace. This does not affect their child or parent functions.</li>
<li>Functions that are still on the stack at the breakpoint will be considered closed at the last recorded timestamp for continuity.</li>
<li>BIOS functions that are not referenced in the project or its library are not accounted for by instrumentation and will not appear in the report.</li>
<li>The python script used to tabulate the instrumentation logs depends on the file readelf.py, which must be in the same directory.</li>
<li>Depending on your optimization level, some functions may be optimized out and/or may not appear on certain platforms, including:<ul>
<li>Empty or single-line functions</li>
<li>ti_sysbios_* functions</li>
<li>SemaphoreP_* functions</li>
</ul>
</li>
</ul>
<h3>Part I: Project Setup</h3>
<ol type="1">
<li>Download and install the TI RTOS Processor SDK for AM572x or the desired product.<ul>
<li>The installer for the AM572x can be found at: <a href="http://www.ti.com/tool/PROCESSOR-SDK-AM572X">http://www.ti.com/tool/PROCESSOR-SDK-AM572X</a>. All other platform SDKs can be found at: <a href="http://www.ti.com/lsds/ti/tools-software/sw_portal.page">http://www.ti.com/lsds/ti/tools-software/sw_portal.page</a></li>
</ul>
</li>
<li>In CCS. select the desired project in the Project Explorer, and open its .cfg file in a text editor.</li>
<li>Any LLDs in use must have be set to enable profiling in order to be profiled at runtime. This is done by setting enableProfiling to true in the LLD package. For example, in GPIO, this would be: <div class="fragment"><div class="line"><span class="comment">/* Load the GPIO package */</span></div>
<div class="line">var Gpio = xdc.loadPackage(<span class="stringliteral">&#39;ti.drv.gpio&#39;</span>);</div>
<div class="line">Gpio.Settings.enableProfiling = <span class="keyword">true</span>;</div>
</div><!-- fragment --> Otherwise the time elapsed by their functions will count against the caller.</li>
<li>In the same file, add the following line so that the profiling library is included in your project as well: <div class="fragment"><div class="line">var Profiling = xdc.loadPackage(<span class="stringliteral">&#39;ti.utils.profiling&#39;</span>);</div>
</div><!-- fragment --></li>
<li>Under the Project Explorer, right-click the desired project and select Properties &gt; CCS Build &gt; "Set Additional Flags..." and add the flags for the desired platform:<ul>
<li>ARM: <code>-finstrument-functions -gdwarf-3 -g</code></li>
<li>DSP: <code>--entry_parm=address --exit_hook=ti_utils_exit --exit_parm=address --entry_hook=ti_utils_entry -g</code></li>
<li>M4: <code>--entry_parm=address --exit_hook=ti_utils_exit --exit_parm=address --entry_hook=ti_utils_entry -g</code></li>
</ul>
</li>
<li>Also ensure that the optimization flags (-O1, -O2, -O3...) reflect the flags set in the desired program so that functions are instrumented consistently. By default, example projects and new CCS projects are set to no optimization.</li>
<li>Close the project properties and right-click the project and select "Rebuild Project" to compile.</li>
</ol>
<h3>Part II: Profiling Project Runtime</h3>
<ol type="1">
<li>Load the compiled program onto the desired target platform and run the program to a desired breakpoint or time interval.</li>
<li>While the program is at the break, open the Memory Browser (View &gt; Memory Browser).</li>
<li>(Optional) In the search field, search for "elemlog" and ensure that the log array has been populated (consists of sets of four values that begin with either 00000000, 00000001, or 00000002).</li>
<li>Save a memory snapshot by clicking "Save", and in the popup, choosing a filename and location, and setting the start address to "elemlog" and length to "log_idx*4".</li>
</ol>
<h3>Part III: Post-processing the Profiling Log</h3>
<ol type="1">
<li>Open a command prompt window set to the directory of the "decodeProfileDump.py" Python script (typically under utils/profiling/scripts)</li>
<li>Assemble the processing command in the following format: <div class="fragment"><div class="line">python <a class="code" href="namespacedecode_profile_dump.html">decodeProfileDump</a>.py [log 1] [executable 1] [log 2] [executable 2] ...</div>
</div><!-- fragment --> where the log is the profiling log memory dump created in Part II and the executable is the *.out program.</li>
<li>Append any desired flags:<ul>
<li>-v Display verbose output</li>
<li>-t Breakdown function totals by their reference sites</li>
<li>-x Print the tabulated results into a report.xlsx Excel file</li>
<li>-csv Print the tabulated results into a report.csv file</li>
<li>-h Print a histogram of the results (shown in the rightmost columns of the output)</li>
<li>-off N Manual instrumentation offset of N cycles, subtracted from each function. Note: The instrumentation program already generates an offset from itself that is subtracted from the function times. Use this flag only if there is an additional offset you would like to subtract.</li>
</ul>
</li>
</ol>
<h3>Part IV: Understanding the Output</h3>
<table class="doxtable">
<tr>
<th>Term </th><th>Meaning  </th></tr>
<tr>
<td>Function </td><td>The name of the function that was instrumented </td></tr>
<tr>
<td>Referenced_By </td><td>The call site of the function instrumented </td></tr>
<tr>
<td>Total_Cycles </td><td>The number of processor cycles elapsed for the function instrumented, both inclusively (inc), including the cycles of its child functions within, and exclusively (exc), excluding the cycles of its child functions </td></tr>
<tr>
<td>Average_Cycles </td><td>The number of processor cycles elapsed for the function instrumented per reference, both inclusively and exclusively </td></tr>
<tr>
<td>Total_Calls </td><td>The number of internal, child functions referenced by the function that are part of the program or its library </td></tr>
<tr>
<td>Average_Calls </td><td>The number of internal, child functions referenced by the function per reference </td></tr>
<tr>
<td>Iterations </td><td>The number of times the function instrumented was referenced </td></tr>
</table>
<ol type="1">
<li>If the histogram flag was set, the histogram is written in the ten columns following the measurements. These columns account for every iteration of the instrumented function, and are followed by its high, low, and bin size values, in processor cycles.</li>
<li>If the histogram flag was set, the last column includes the high outlying reference that used an disproportionate number of processor cycles compared to the other function references, including its file location.</li>
<li>The text file (generated by default) will also contain a visual trace of the results below the table, for each function reference and its measured cycle count. </li>
</ol>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
