<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Automated Profiling with DSS</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Processor SDK Utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Automated Profiling with DSS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This guide steps through the automated profiling pipeline using the TI Utils library and DSS, using the loadti script</p>
<h2>Introduction</h2>
<p>These instructions are for benchmarking the included LLD example projects in the TI Processor Development Kit using the loadti script. This benchmark tool uses the hardware clock of the PMU to measure the length of each task in processor cycles with minimal overhead. This guide and scripts were written for the AM5728 RTOS platform, but use standard C programming hooks that may be adapted for any platform and/or processor architecture.</p>
<p>Notes:</p><ul>
<li>Functions with more than one entry point may not always map correctly with their symbols and in the trace. This does not affect their child or parent functions.</li>
<li>Functions that are still on the stack at the breakpoint will be considered closed at the last recorded timestamp for continuity.</li>
<li>BIOS functions that are not referenced in the project or its library are not accounted for by instrumentation and will not appear in the report.</li>
<li>The python script used to tabulate the instrumentation logs depends on the file readelf.py, which must be in the same directory.</li>
<li>Depending on your optimization level, some functions may be optimized out and/or may not appear on certain platforms, including:<ul>
<li>Empty or single-line functions</li>
<li>ti_sysbios_* functions</li>
<li>SemaphoreP_* functions</li>
</ul>
</li>
</ul>
<h3>Part I: Project Setup</h3>
<ol type="1">
<li>Download and install the TI RTOS Processor SDK for AM572x or the desired product.<ul>
<li>The installer for the AM572x can be found at: <a href="http://www.ti.com/tool/PROCESSOR-SDK-AM572X">http://www.ti.com/tool/PROCESSOR-SDK-AM572X</a>. All other platform SDKs can be found at: <a href="http://www.ti.com/lsds/ti/tools-software/sw_portal.page">http://www.ti.com/lsds/ti/tools-software/sw_portal.page</a></li>
</ul>
</li>
<li>In the desired project directory, open the project's *.cfg file in a text editor.</li>
<li>Any LLDs in use must have be set to enable profiling in order to be profiled at runtime. This is done by setting enableProfiling to true in the LLD package. For example, in GPIO, this would be: <div class="fragment"><div class="line"><span class="comment">/* Load the GPIO package */</span></div>
<div class="line">var Gpio = xdc.loadPackage(<span class="stringliteral">&#39;ti.drv.gpio&#39;</span>);</div>
<div class="line">Gpio.Settings.enableProfiling = <span class="keyword">true</span>;</div>
</div><!-- fragment --> Otherwise the time elapsed by their functions will count against the caller.</li>
<li>In the same file, add the following line so that the profiling library is included in your project as well: <div class="fragment"><div class="line">var Profiling = xdc.loadPackage(<span class="stringliteral">&#39;ti.utils.profiling&#39;</span>);</div>
</div><!-- fragment --></li>
<li>Locate the configuration file for your project (typically a *.text file) and add the flags for the desired platform:<ul>
<li>ARM: <code>-finstrument-functions -gdwarf-3 -g</code></li>
<li>DSP: <code>--entry_parm=address --exit_hook=ti_utils_exit --exit_parm=address --entry_hook=ti_utils_entry -g</code></li>
<li>M4: <code>--entry_parm=address --exit_hook=ti_utils_exit --exit_parm=address --entry_hook=ti_utils_entry -g</code></li>
</ul>
</li>
<li>Also ensure that the optimization flags (-O1, -O2, -O3...) reflect the flags set in the desired program so that functions are instrumented consistently. By default, example projects and new CCS projects are set to no optimization.</li>
<li>Save these files and recompile your project.</li>
</ol>
<h3>Part II: Profiling Project Runtime</h3>
<ol type="1">
<li>If you have not already, locate the loadti directory. This is typically located under: <div class="fragment"><div class="line">C:\ti\ccsv6\ccs_base\scripting\examples\loadti</div>
</div><!-- fragment --></li>
<li>Depending on the version of CCS installed, loadti may need to be patched so that its saveData function can evaluate expressions as well as static integer addresses.<ul>
<li>If this is the case, a patched version of the memXfer.js script is included in the utils/profiling/scripts directory</li>
<li>Simply replace the memXfer.js file in the loadti directory with the patched memXfer.js file in the profiling library</li>
<li>Note: This will not break existing applications that use static integer addresses</li>
</ul>
</li>
<li>Load the desired program onto the desired target platform and run the program to a desired breakpoint or time interval using this format: <div class="fragment"><div class="line">loadti -v -c=[config *.ccxml] -t [time interval] -msd=<span class="stringliteral">&quot;0,elemlog,[output *.txt],4*log_idx,1,false&quot;</span> [executable *.out]</div>
</div><!-- fragment --></li>
<li>This will automatically run the run the program and dump the profiling log into a specified text file for post-processing.</li>
</ol>
<h3>Part III: Post-processing the Profiling Log</h3>
<ol type="1">
<li>Open a command prompt window set to the directory of the "decodeProfileDump.py" Python script (typically under utils/profiling/scripts)</li>
<li>Assemble the processing command in the following format: <div class="fragment"><div class="line">python <a class="code" href="namespacedecode_profile_dump.html">decodeProfileDump</a>.py [log 1] [executable 1] [log 2] [executable 2] ...</div>
</div><!-- fragment --> where the log is the profiling log memory dump created in Part II and the executable is the *.out program.</li>
<li>Append any desired flags:<ul>
<li>-v Display verbose output</li>
<li>-t Breakdown function totals by their reference sites</li>
<li>-x Print the tabulated results into a report.xlsx Excel file</li>
<li>-csv Print the tabulated results into a report.csv file</li>
<li>-h Print a histogram of the results (shown in the rightmost columns of the output)</li>
<li>-off N Manual instrumentation offset of N cycles, subtracted from each function. Note: The instrumentation program already generates an offset from itself that is subtracted from the function times. Use this flag only if there is an additional offset you would like to subtract.</li>
</ul>
</li>
</ol>
<h3>Part IV: Understanding the Output</h3>
<table class="doxtable">
<tr>
<th>Term </th><th>Meaning  </th></tr>
<tr>
<td>Function </td><td>The name of the function that was instrumented </td></tr>
<tr>
<td>Referenced_By </td><td>The call site of the function instrumented </td></tr>
<tr>
<td>Total_Cycles </td><td>The number of processor cycles elapsed for the function instrumented, both inclusively (inc), including the cycles of its child functions within, and exclusively (exc), excluding the cycles of its child functions </td></tr>
<tr>
<td>Average_Cycles </td><td>The number of processor cycles elapsed for the function instrumented per reference, both inclusively and exclusively </td></tr>
<tr>
<td>Total_Calls </td><td>The number of internal, child functions referenced by the function that are part of the program or its library </td></tr>
<tr>
<td>Average_Calls </td><td>The number of internal, child functions referenced by the function per reference </td></tr>
<tr>
<td>Iterations </td><td>The number of times the function instrumented was referenced </td></tr>
</table>
<ol type="1">
<li>If the histogram flag was set, the histogram is written in the ten columns following the measurements. These columns account for every iteration of the instrumented function, and are followed by its high, low, and bin size values, in processor cycles.</li>
<li>If the histogram flag was set, the last column includes the high outlying reference that used an disproportionate number of processor cycles compared to the other function references, including its file location.</li>
<li>The text file (generated by default) will also contain a visual trace of the results below the table, for each function reference and its measured cycle count. </li>
</ol>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
