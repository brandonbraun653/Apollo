;Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
;
; Redistributions of source code must retain the above copyright
; notice, this list of conditions and the following disclaimer.
;
; Redistributions in binary form must reproduce the above copyright
; notice, this list of conditions and the following disclaimer in the
; documentation and/or other materials provided with the
; distribution.
;
; Neither the name of Texas Instruments Incorporated nor the names of
; its contributors may be used to endorse or promote products derived
; from this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
; 	brief: contains the line delay measurement of the synchronization state implementation
;
;	Version		Description								Author
; 	0.1     	Created									Thomas Mauer
;include section
	.include "../include/macros/macros.inc"
	.include "../include/icss/icss_regs.inc"
	.include "../include/protocol/sorte_pru_slave_register.inc"
	.include "../include/protocol/sorte_host_interface.inc"
	.include "../include/protocol/sorte_packet_definition.inc"
	.include "../include/protocol/sorte_slave_cfg.inc"
	.include "../include/protocol/sorte_state_define.inc"
	.global FN_LINE_DELAY_MASTER
	.global FN_LINE_DELAY_SLAVE
	.global STATE_MACHINE_RETURN

;****************************
; line delay master function
;****************************
; entry point called by main state machine for LINE DELAY state
; MASTER in this context is originator of the LINE DELAY measurement frame
FN_LINE_DELAY_MASTER:
	; Check to see if the PRU received a line delay trigger via scratch register
	ldi	R0.b0, SHIFT_LINE_DELAY_TRIGGER
	xin	SCRATCH_BANK0, &TEMP_REG_1.b0, 1
	qbeq	FN_LINE_DELAY_DONE, TEMP_REG_1.b0, 0

	; send LINE DELAY measurment frame
	; pre-amble
	; send 8 byte PA (preamble)
	.if $defined(FULL_PREAMBLE)
	ldi		TX_DATA_WORD, 0x5555
	NOP
	M_PUSH_WORD
	ldi		TX_DATA_WORD, 0x5555
	NOP
	M_PUSH_WORD
	.endif

	; send 4 byte pre-amble
	ldi		TX_DATA_WORD, 0x5555
	NOP
	M_PUSH_WORD
	ldi		TX_DATA_WORD, 0xd555
	NOP
	M_PUSH_WORD

	; 4 bytes header
	ldi32 	TEMP_REG_2, DELAY_REQ_P
	mov    	TX_DATA_WORD, TEMP_REG_2.w0
	NOP
	M_PUSH_WORD
	; state change bit?
	qbne	LINE_DELAY_MASTER_LAST, TEMP_REG_1.b0, 2
	; set
	set		TEMP_REG_2.b3, TEMP_REG_2.b3, 3	;ST_STATE_CHANGE
	; initiate state change
	set		DEVICE_STATUS, DEVICE_STATUS, SWITCH_PORT_CONFIG
	ldi		PROTOCOL_STATE, SYNC_STATE

LINE_DELAY_MASTER_LAST:
	mov		TX_DATA_WORD, TEMP_REG_2.w2
	NOP
	M_PUSH_WORD
	; end packet with crc generated by PRU
    M_CMD16 D_PUSH_CRC_MSWORD_CMD | D_PUSH_CRC_LSWORD_CMD | D_TX_EOF
	; clear scratch register
	ldi		TEMP_REG_1.b0, 0
	xout	SCRATCH_BANK0, &TEMP_REG_1.b0, 1

; receive DELAY_RESP packet
LINE_DELAY_MASTER_WAIT_BANK0:
	xin		RXL2_BANK0, &R18.b0, 1
    qbeq	LINE_DELAY_MASTER_WAIT_BANK0, R18.b0, 0

	; read rx and tx time stamp - sof based
	.if $defined (PRU0)
	lbco	&R2,ICSS_IEP_CONST, ICSS_IEP_CAPR0_REG, 4
	lbco	&R6,ICSS_IEP_CONST, ICSS_IEP_CAPR4_REG, 4
	; use port 0, caculate difference between RX_SOF and TX_SOF
	sub		TEMP_REG_1, R2, R6
	.else
	lbco	&R2,ICSS_IEP_CONST, ICSS_IEP_CAPR2_REG, 4
	lbco	&R6,ICSS_IEP_CONST, ICSS_IEP_CAPR5_REG, 4
	; use port 1, caculate difference between RX_SOF and TX_SOF
	sub		TEMP_REG_1, R4, R7
	.endif
	lbco	&TEMP_REG_2, ICSS_SHARED_RAM_CONST, PORT_DELAY, 4
	; divide by n --> measurement results complete the measurement.
	lsr		TEMP_REG_1, TEMP_REG_1, LD_SHIFT_16
	add		TEMP_REG_2,TEMP_REG_2, TEMP_REG_1
	sbco	&TEMP_REG_2, ICSS_SHARED_RAM_CONST, PORT_DELAY, 4

	set		DEVICE_STATUS, DEVICE_STATUS, RX_IGNORE_TO_EOF

LINE_DELAY_MASTER_DONE:
	jmp		STATE_MACHINE_RETURN

;***************************
; line delay slave function
;***************************
; SLAVE in this context is the responder to the LINE DELAY measurement frame
FN_LINE_DELAY_SLAVE:
	M_XIN_L2_BANK0	LD_SLAVE_FRAME_PROCESS, 4
LD_SLAVE_FRAME_PROCESS:
	; Check to see if the PRU received a line delay trigger
	qbne	LINE_DELAY_IGNORE_FRAME, R2.b2, T_LD_REQ_P2P
	; trigger line delay measurement on other PRU via scratch register
	ldi		R0.b0, SHIFT_LINE_DELAY_TRIGGER
	ldi		TEMP_REG_1.b0, 1	; trigger line delay w/o state change
	qbbc	LD_SLAVE_TRIGGER_LD, R2.b3, 3		; ST_STATE_CHANGE
	ldi		TEMP_REG_1.b0, 2	; trigger line delay with state change (last line delay measurement)
	; state change
	ldi		PROTOCOL_STATE, SYNC_STATE
	set		DEVICE_STATUS, DEVICE_STATUS, SWITCH_PORT_CONFIG
	; last slave needs to initiate state and port switch here
	qbbs	LD_SLAVE_TRIGGER_LD, DEVICE_STATUS, PRU_MASTER_PORT_FLAG
	; initiate port switching for last slave
	; clear scratch pad
	LDI		TEMP_REG_1.b0, 0
LD_SLAVE_TRIGGER_LD:
	xout	SCRATCH_BANK0, &TEMP_REG_1.b0, 1
LINE_DELAY_IGNORE_FRAME:
	set		DEVICE_STATUS, DEVICE_STATUS, RX_IGNORE_TO_EOF

FN_LINE_DELAY_DONE:
	jmp		STATE_MACHINE_RETURN
