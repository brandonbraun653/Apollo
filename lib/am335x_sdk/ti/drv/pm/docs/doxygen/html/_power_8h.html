<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Power.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Power.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Power manager interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_list_8h.html">src/pmrtos/common/List.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_power___notify_obj.html">Power_NotifyObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power notify object structure.  <a href="struct_power___notify_obj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa5e33b10202cc5a261c1800b4ae1de3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#aa5e33b10202cc5a261c1800b4ae1de3e">Power_TOTAL</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa5e33b10202cc5a261c1800b4ae1de3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7343f6504f2df361dca3760a97584371"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a7343f6504f2df361dca3760a97584371">Power_RESUME</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a7343f6504f2df361dca3760a97584371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c91c03b469de0cf4f53b89a867ee19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a98c91c03b469de0cf4f53b89a867ee19">Power_NOTIFYDONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a98c91c03b469de0cf4f53b89a867ee19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98066f45fce59fd38d8edcb6f2ac96fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a98066f45fce59fd38d8edcb6f2ac96fd">Power_NOTIFYERROR</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a98066f45fce59fd38d8edcb6f2ac96fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92eed670a5d7e3d43f612ca0da9d3fe2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a92eed670a5d7e3d43f612ca0da9d3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2f92a8c72bfa183e14d10a2e35789f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#aed2f92a8c72bfa183e14d10a2e35789f">Power_EFAIL</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aed2f92a8c72bfa183e14d10a2e35789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d24bacb087e8282be2e4394503a429a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a0d24bacb087e8282be2e4394503a429a">Power_EINVALIDPOINTER</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a0d24bacb087e8282be2e4394503a429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e7b580b1c9c026036bf53befe5723b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#aa4e7b580b1c9c026036bf53befe5723b">Power_ECHANGE_NOT_ALLOWED</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:aa4e7b580b1c9c026036bf53befe5723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132904395c5631392bd6301d9a2181e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a3132904395c5631392bd6301d9a2181e">Power_EBUSY</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a3132904395c5631392bd6301d9a2181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915df6d5472d4e31f0cd58fbd1d7c1b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a915df6d5472d4e31f0cd58fbd1d7c1b9">Power_NOTSUPPORTED</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a915df6d5472d4e31f0cd58fbd1d7c1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01074d8221d330077fbe040b9143e183"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a01074d8221d330077fbe040b9143e183">Power_ACTIVE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a01074d8221d330077fbe040b9143e183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6038b3877b09c908834af7d46595b989"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a6038b3877b09c908834af7d46595b989">Power_ENTERING_SLEEP</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a6038b3877b09c908834af7d46595b989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea41cdfb6fb053eaed2792c4edf886d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a1ea41cdfb6fb053eaed2792c4edf886d">Power_EXITING_SLEEP</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a1ea41cdfb6fb053eaed2792c4edf886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09d75dfaa5d799c4f044df9814db485"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#ad09d75dfaa5d799c4f044df9814db485">Power_ENTERING_SHUTDOWN</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ad09d75dfaa5d799c4f044df9814db485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7d4ba49a9418af10c84132a8cbf108"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a2b7d4ba49a9418af10c84132a8cbf108">Power_CHANGING_PERF_LEVEL</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a2b7d4ba49a9418af10c84132a8cbf108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a435fdeb71d13ea6be86f599c9b6a0d78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a435fdeb71d13ea6be86f599c9b6a0d78"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a435fdeb71d13ea6be86f599c9b6a0d78">Power_PolicyInitFxn</a>) (void)</td></tr>
<tr class="memdesc:a435fdeb71d13ea6be86f599c9b6a0d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power policy initialization function pointer. <br /></td></tr>
<tr class="separator:a435fdeb71d13ea6be86f599c9b6a0d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333038d1e9cd5f93dda7b83f8a1afa8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a333038d1e9cd5f93dda7b83f8a1afa8b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a333038d1e9cd5f93dda7b83f8a1afa8b">Power_PolicyFxn</a>) (void)</td></tr>
<tr class="memdesc:a333038d1e9cd5f93dda7b83f8a1afa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power policy function pointer. <br /></td></tr>
<tr class="separator:a333038d1e9cd5f93dda7b83f8a1afa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91335240b2081eeefec80d043030c857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91335240b2081eeefec80d043030c857"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a91335240b2081eeefec80d043030c857">Power_NotifyFxn</a>) (unsigned int eventType, uintptr_t eventArg, uintptr_t clientArg)</td></tr>
<tr class="memdesc:a91335240b2081eeefec80d043030c857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power notify function pointer. <br /></td></tr>
<tr class="separator:a91335240b2081eeefec80d043030c857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27497a9f3e7d41b6a0c12aa96c2dc766"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_power___notify_obj.html">Power_NotifyObj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a27497a9f3e7d41b6a0c12aa96c2dc766">Power_NotifyObj</a></td></tr>
<tr class="memdesc:a27497a9f3e7d41b6a0c12aa96c2dc766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power notify object structure.  <a href="#a27497a9f3e7d41b6a0c12aa96c2dc766">More...</a><br /></td></tr>
<tr class="separator:a27497a9f3e7d41b6a0c12aa96c2dc766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8d6092a8fb35b6db52a69a35fcc327f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#ae8d6092a8fb35b6db52a69a35fcc327f">Power_enablePolicy</a> (void)</td></tr>
<tr class="memdesc:ae8d6092a8fb35b6db52a69a35fcc327f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the configured power policy to run when the CPU is idle.  <a href="#ae8d6092a8fb35b6db52a69a35fcc327f">More...</a><br /></td></tr>
<tr class="separator:ae8d6092a8fb35b6db52a69a35fcc327f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5382aa1050fdf893b55d14041ca0b09"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#ac5382aa1050fdf893b55d14041ca0b09">Power_getConstraintMask</a> (void)</td></tr>
<tr class="memdesc:ac5382aa1050fdf893b55d14041ca0b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constraints that have been declared with Power.  <a href="#ac5382aa1050fdf893b55d14041ca0b09">More...</a><br /></td></tr>
<tr class="separator:ac5382aa1050fdf893b55d14041ca0b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0ed212807eebbed776dbbde19b9567"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#aee0ed212807eebbed776dbbde19b9567">Power_getDependencyCount</a> (unsigned int resourceId)</td></tr>
<tr class="memdesc:aee0ed212807eebbed776dbbde19b9567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current dependency count for a resource.  <a href="#aee0ed212807eebbed776dbbde19b9567">More...</a><br /></td></tr>
<tr class="separator:aee0ed212807eebbed776dbbde19b9567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992dabafbcd2ed75308dd3e166d9e658"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a992dabafbcd2ed75308dd3e166d9e658">Power_getPerformanceLevel</a> (void)</td></tr>
<tr class="memdesc:a992dabafbcd2ed75308dd3e166d9e658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current performance level.  <a href="#a992dabafbcd2ed75308dd3e166d9e658">More...</a><br /></td></tr>
<tr class="separator:a992dabafbcd2ed75308dd3e166d9e658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ec5a7a238ddc7e7d2c04db9d46206e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#ad2ec5a7a238ddc7e7d2c04db9d46206e">Power_getTransitionLatency</a> (unsigned int sleepState, unsigned int type)</td></tr>
<tr class="memdesc:ad2ec5a7a238ddc7e7d2c04db9d46206e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hardware transition latency for a sleep state.  <a href="#ad2ec5a7a238ddc7e7d2c04db9d46206e">More...</a><br /></td></tr>
<tr class="separator:ad2ec5a7a238ddc7e7d2c04db9d46206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be3927156b139cf59cd4bec912f62f6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a6be3927156b139cf59cd4bec912f62f6">Power_getTransitionState</a> (void)</td></tr>
<tr class="memdesc:a6be3927156b139cf59cd4bec912f62f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current transition state of the Power manager.  <a href="#a6be3927156b139cf59cd4bec912f62f6">More...</a><br /></td></tr>
<tr class="separator:a6be3927156b139cf59cd4bec912f62f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873219012923300f3b3b958b951a4ea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a873219012923300f3b3b958b951a4ea1">Power_idleFunc</a> (void)</td></tr>
<tr class="memdesc:a873219012923300f3b3b958b951a4ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power function to be added to the application idle loop.  <a href="#a873219012923300f3b3b958b951a4ea1">More...</a><br /></td></tr>
<tr class="separator:a873219012923300f3b3b958b951a4ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab5142b5194bd19d8a6d583bfed7651"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a3ab5142b5194bd19d8a6d583bfed7651">Power_init</a> (void)</td></tr>
<tr class="memdesc:a3ab5142b5194bd19d8a6d583bfed7651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power initialization function.  <a href="#a3ab5142b5194bd19d8a6d583bfed7651">More...</a><br /></td></tr>
<tr class="separator:a3ab5142b5194bd19d8a6d583bfed7651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e73c431e3d1aab1a31181513ceb8adb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a8e73c431e3d1aab1a31181513ceb8adb">Power_registerNotify</a> (<a class="el" href="struct_power___notify_obj.html">Power_NotifyObj</a> *pNotifyObj, unsigned int eventTypes, <a class="el" href="_power_8h.html#a91335240b2081eeefec80d043030c857">Power_NotifyFxn</a> notifyFxn, uintptr_t clientArg)</td></tr>
<tr class="memdesc:a8e73c431e3d1aab1a31181513ceb8adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to be called upon a specific power event.  <a href="#a8e73c431e3d1aab1a31181513ceb8adb">More...</a><br /></td></tr>
<tr class="separator:a8e73c431e3d1aab1a31181513ceb8adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f983063be6c25765e94664e506652a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#aa8f983063be6c25765e94664e506652a">Power_releaseConstraint</a> (unsigned int constraintId)</td></tr>
<tr class="memdesc:aa8f983063be6c25765e94664e506652a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously declared constraint.  <a href="#aa8f983063be6c25765e94664e506652a">More...</a><br /></td></tr>
<tr class="separator:aa8f983063be6c25765e94664e506652a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c740b8432f2539229f262ef7e85692"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a64c740b8432f2539229f262ef7e85692">Power_releaseDependency</a> (unsigned int resourceId)</td></tr>
<tr class="memdesc:a64c740b8432f2539229f262ef7e85692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously declared dependency.  <a href="#a64c740b8432f2539229f262ef7e85692">More...</a><br /></td></tr>
<tr class="separator:a64c740b8432f2539229f262ef7e85692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe334c2cc079241cea000d434b9e73d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a0fe334c2cc079241cea000d434b9e73d">Power_setConstraint</a> (unsigned int constraintId)</td></tr>
<tr class="memdesc:a0fe334c2cc079241cea000d434b9e73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare an operational constraint.  <a href="#a0fe334c2cc079241cea000d434b9e73d">More...</a><br /></td></tr>
<tr class="separator:a0fe334c2cc079241cea000d434b9e73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d2bfc91eedb7e3a158f12bc670a83e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#a12d2bfc91eedb7e3a158f12bc670a83e">Power_setDependency</a> (unsigned int resourceId)</td></tr>
<tr class="memdesc:a12d2bfc91eedb7e3a158f12bc670a83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a dependency upon a resource.  <a href="#a12d2bfc91eedb7e3a158f12bc670a83e">More...</a><br /></td></tr>
<tr class="separator:a12d2bfc91eedb7e3a158f12bc670a83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9f8442c59deb341f6f5da729e90635"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#ade9f8442c59deb341f6f5da729e90635">Power_setPerformanceLevel</a> (unsigned int level)</td></tr>
<tr class="memdesc:ade9f8442c59deb341f6f5da729e90635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MCU performance level.  <a href="#ade9f8442c59deb341f6f5da729e90635">More...</a><br /></td></tr>
<tr class="separator:ade9f8442c59deb341f6f5da729e90635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ec2fa95cca7f0ffdcdd9e1d4ef80ce"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#af1ec2fa95cca7f0ffdcdd9e1d4ef80ce">Power_shutdown</a> (unsigned int shutdownState, unsigned int shutdownTime)</td></tr>
<tr class="memdesc:af1ec2fa95cca7f0ffdcdd9e1d4ef80ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device into a shutdown state.  <a href="#af1ec2fa95cca7f0ffdcdd9e1d4ef80ce">More...</a><br /></td></tr>
<tr class="separator:af1ec2fa95cca7f0ffdcdd9e1d4ef80ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26ff0368295bc388f8cbcaa289fb4b2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#ad26ff0368295bc388f8cbcaa289fb4b2">Power_sleep</a> (unsigned int sleepState)</td></tr>
<tr class="memdesc:ad26ff0368295bc388f8cbcaa289fb4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition the device into a sleep state.  <a href="#ad26ff0368295bc388f8cbcaa289fb4b2">More...</a><br /></td></tr>
<tr class="separator:ad26ff0368295bc388f8cbcaa289fb4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32c17ce6da099da97957f08ddb000b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_power_8h.html#ac32c17ce6da099da97957f08ddb000b4">Power_unregisterNotify</a> (<a class="el" href="struct_power___notify_obj.html">Power_NotifyObj</a> *pNotifyObj)</td></tr>
<tr class="memdesc:ac32c17ce6da099da97957f08ddb000b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister previously registered notifications.  <a href="#ac32c17ce6da099da97957f08ddb000b4">More...</a><br /></td></tr>
<tr class="separator:ac32c17ce6da099da97957f08ddb000b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Power manager interface. </p>
<p>============================================================================</p>
<p>The Power header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_power_8h.html">ti/drv/pm/Power.h</a>&gt;</span></div>
</div><!-- fragment --><h1>Operation</h1>
<p>The Power manager facilitates the transition of the CPU from active state to one of the sleep states and vice versa. It provides drivers the ability to set and release dependencies on hardware resources and keeps a reference count on each resource to know when to enable or disable the peripheral clock to the resource. It provides drivers the ability to register a callback function upon a specific power event. In addition, drivers and apps can set or release constraints to prevent the CPU from transitioning into a particular sleep state. </p><hr/>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a01074d8221d330077fbe040b9143e183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_ACTIVE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>normal active state </p>

</div>
</div>
<a class="anchor" id="a2b7d4ba49a9418af10c84132a8cbf108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_CHANGING_PERF_LEVEL&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>moving to new performance level </p>

</div>
</div>
<a class="anchor" id="a3132904395c5631392bd6301d9a2181e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_EBUSY&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>busy with another transition </p>

</div>
</div>
<a class="anchor" id="aa4e7b580b1c9c026036bf53befe5723b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_ECHANGE_NOT_ALLOWED&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>change is not allowed </p>

</div>
</div>
<a class="anchor" id="aed2f92a8c72bfa183e14d10a2e35789f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_EFAIL&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>general failure </p>

</div>
</div>
<a class="anchor" id="a0d24bacb087e8282be2e4394503a429a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_EINVALIDPOINTER&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>invalid pointer </p>

</div>
</div>
<a class="anchor" id="ad09d75dfaa5d799c4f044df9814db485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_ENTERING_SHUTDOWN&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>entering a shutdown state </p>

</div>
</div>
<a class="anchor" id="a6038b3877b09c908834af7d46595b989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_ENTERING_SLEEP&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>entering a sleep state </p>

</div>
</div>
<a class="anchor" id="a1ea41cdfb6fb053eaed2792c4edf886d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_EXITING_SLEEP&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>exiting a sleep state </p>

</div>
</div>
<a class="anchor" id="a98c91c03b469de0cf4f53b89a867ee19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_NOTIFYDONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OK, notify completed </p>

</div>
</div>
<a class="anchor" id="a98066f45fce59fd38d8edcb6f2ac96fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_NOTIFYERROR&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>an error occurred during notify </p>

</div>
</div>
<a class="anchor" id="a915df6d5472d4e31f0cd58fbd1d7c1b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_NOTSUPPORTED&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>API not supported for device </p>

</div>
</div>
<a class="anchor" id="a7343f6504f2df361dca3760a97584371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_RESUME&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>resume latency </p>

</div>
</div>
<a class="anchor" id="a92eed670a5d7e3d43f612ca0da9d3fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_SOK&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OK, operation succeeded </p>

</div>
</div>
<a class="anchor" id="aa5e33b10202cc5a261c1800b4ae1de3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Power_TOTAL&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>total latency </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a27497a9f3e7d41b6a0c12aa96c2dc766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_power___notify_obj.html">Power_NotifyObj</a>  <a class="el" href="struct_power___notify_obj.html">Power_NotifyObj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power notify object structure. </p>
<p>This struct specification is for internal use. Notification clients must pre-allocate a notify object when registering for a notification; <a class="el" href="_power_8h.html#a8e73c431e3d1aab1a31181513ceb8adb" title="Register a function to be called upon a specific power event. ">Power_registerNotify()</a> will take care initializing the internal elements appropriately. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae8d6092a8fb35b6db52a69a35fcc327f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_enablePolicy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the configured power policy to run when the CPU is idle. </p>
<p>Calling this function sets a flag that will cause the configured power policy function to be invoked on each pass through the Idle loop. This runtime function call will essentially override a 'false' setting of the "enablePolicy" setting in the Power manager configuration object.</p>
<p>For some processor families automatic power transitions are at odds with the debugger, and having the policy running by default makes application debug difficult. This convenience function allows an application to be initially configured, built, and debugged, without automatic power transitions during idle time. When the application is found to be working, this function can be called (typically in main()) to enable the policy to run, without having to change the application configuration. Note that there is no comparable 'disable' policy function; once the policy has been enabled to run, it will always run until the applicaiton is rebooted. </p>

</div>
</div>
<a class="anchor" id="ac5382aa1050fdf893b55d14041ca0b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_getConstraintMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the constraints that have been declared with Power. </p>
<p>This function returns a bitmask indicating the constraints that are currently declared to the Power manager (via previous calls to <a class="el" href="_power_8h.html#a0fe334c2cc079241cea000d434b9e73d" title="Declare an operational constraint. ">Power_setConstraint()</a>). For each constraint that is currently declared, the corresponding bit in the bitmask will be set. For example, if two clients have independently declared two different constraints, the returned bitmask will have two bits set.</p>
<p>Constraint identifiers are device specific, and defined in the device-specific Power include file. For example, the constraints for PRCM are defined in PowerPRCM.h. The corresponding bit in the bitmask returned by this function can be derived by a left-shift using the constraint identifier. For example, for PRCM, for the corresponding bit for the PowerPRCM_DISALLOW_SLEEP constraint, the bit position is determined by the operation: (1 &lt;&lt; PowerPRCM_DISALLOW_SLEEP)</p>
<dl class="section return"><dt>Returns</dt><dd>A bitmask of the currently declared constraints.</dd>
<dd>
Power_SOK</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#a0fe334c2cc079241cea000d434b9e73d" title="Declare an operational constraint. ">Power_setConstraint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aee0ed212807eebbed776dbbde19b9567"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_getDependencyCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>resourceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current dependency count for a resource. </p>
<p>This function returns the number of dependencies that are currently declared upon a resource.</p>
<p>Resource identifiers are device specific, and defined in the device-specific Power include file. For example, the resources for PRCM are defined in PowerPRCM.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resourceId</td><td>resource id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dependencies declared upon the resource.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#a12d2bfc91eedb7e3a158f12bc670a83e" title="Declare a dependency upon a resource. ">Power_setDependency</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a992dabafbcd2ed75308dd3e166d9e658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_getPerformanceLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current performance level. </p>
<p>This function returns the current device performance level in effect.</p>
<p>If performance scaling is not supported for the device, this function will always indicate a performance level of zero.</p>
<dl class="section return"><dt>Returns</dt><dd>The current performance level.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#ade9f8442c59deb341f6f5da729e90635" title="Set the MCU performance level. ">Power_setPerformanceLevel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2ec5a7a238ddc7e7d2c04db9d46206e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_getTransitionLatency </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sleepState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the hardware transition latency for a sleep state. </p>
<p>This function reports the minimal hardware transition latency for a specific sleep state. The reported latency is that for a direct transition, and does not include any additional latency that might occur due to software-based notifications.</p>
<p>Sleep states are device specific, and defined in the device-specific Power include file. For example, the sleep states for PRCM are defined in PowerPRCM.h.</p>
<p>This function is typically called by the power policy function. The latency is reported in units of microseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleepState</td><td>the sleep state</td></tr>
    <tr><td class="paramname">type</td><td>the latency type (Power_TOTAL or Power_RESUME)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The latency value, in units of microseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a6be3927156b139cf59cd4bec912f62f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_getTransitionState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current transition state of the Power manager. </p>
<p>This function returns the current transition state for the Power manager. For example, when no transitions are in progress, a status of Power_ACTIVE is returned. Power_ENTERING_SLEEP is returned during the transition to sleep, before sleep has occurred. And Power_EXITING_SLEEP will be returned after wakeup, as the device is being transtioned back to Power_ACTIVE.</p>
<dl class="section return"><dt>Returns</dt><dd>The current Power manager transition state. </dd></dl>

</div>
</div>
<a class="anchor" id="a873219012923300f3b3b958b951a4ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_idleFunc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power function to be added to the application idle loop. </p>
<p>This function should be added to the application idle loop. (The method to do this depends upon the operating system being used.) This function will invoke the configured power policy function when appropriate. The specific policy function to be invoked is configured as the 'policyFxn' in the application-defined Power configuration object. </p>

</div>
</div>
<a class="anchor" id="a3ab5142b5194bd19d8a6d583bfed7651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power initialization function. </p>
<p>This function initializes Power manager internal state. It must be called prior to any other Power API. This function is normally called as part of TI-RTOS board initialization, for example, from within the the &lt;board name&gt;_initGeneral() function.</p>
<dl class="section return"><dt>Returns</dt><dd>Power_SOK </dd></dl>

</div>
</div>
<a class="anchor" id="a8e73c431e3d1aab1a31181513ceb8adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_registerNotify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_power___notify_obj.html">Power_NotifyObj</a> *&#160;</td>
          <td class="paramname"><em>pNotifyObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eventTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_power_8h.html#a91335240b2081eeefec80d043030c857">Power_NotifyFxn</a>&#160;</td>
          <td class="paramname"><em>notifyFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>clientArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function to be called upon a specific power event. </p>
<p>This function registers a function to be called when a Power event occurs. Registrations and the corresponding notifications are processed in first-in-first-out (FIFO) order. The function registered must behave as described later, below.</p>
<p>The pNotifyObj parameter is a pointer to a pre-allocated, opaque object that will be used by Power to support the notification. This object could be dynamically allocated, or declared as a global object. This function will properly initialized the object's fields as appropriate; the caller just needs to provide a pointer to this pre-existing object.</p>
<p>The eventTypes parameter identifies the type of power event(s) for which the notify function being registered is to be called. (Event identifiers are device specific, and defined in the device-specific Power include file. For example, the events for PRCM are defined in PowerPRCM.h.) The eventTypes parameter for this function call is treated as a bitmask, so multiple event types can be registered at once, using a common callback function. For example, to call the specified notifyFxn when both the entering deepsleep and awake from deepsleep events occur, eventTypes should be specified as: PowerPRCM_ENTERING_DEEPSLEEP | PowerPRCM_AWAKE_DEEPSLEEP</p>
<p>The notifyFxn parameter specifies a callback function to be called when the specified Power event occurs. The notifyFxn must implement the following signature: status = notifyFxn(eventType, eventArg, clientArg);</p>
<p>Where: eventType identifies the event being signalled, eventArg is an optional event-specific argument, and clientArg is an abitrary argument specified by the client at registration. Note that multipe types of events can be specified when registering the notification callback function, but when the callback function is actually called by Power, only a single eventType will be specified for the callback (i.e., the current event). The status returned by the client notification function must be one of the following constants: Power_NOTIFYDONE if the client processed the notification successfully, or Power_NOTIFYERROR if an error occurred during notification.</p>
<p>The clientArg parameter is an arbitrary, client-defined argument to be passed back to the client upon notification. This argument may allow one notify function to be used by multiple instances of a driver (that is, the clientArg can be used to identify the instance of the driver that is being notified).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNotifyObj</td><td>notification object (preallocated by caller)</td></tr>
    <tr><td class="paramname">eventTypes</td><td>event type or types</td></tr>
    <tr><td class="paramname">notifyFxn</td><td>client's callback function</td></tr>
    <tr><td class="paramname">clientArg</td><td>client-specified argument to pass with notification</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Power_SOK</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#ac32c17ce6da099da97957f08ddb000b4" title="Unregister previously registered notifications. ">Power_unregisterNotify</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa8f983063be6c25765e94664e506652a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_releaseConstraint </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>constraintId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously declared constraint. </p>
<p>This function releases a constraint that was previously declared with <a class="el" href="_power_8h.html#a0fe334c2cc079241cea000d434b9e73d" title="Declare an operational constraint. ">Power_setConstraint()</a>. For example, if a device driver is starting an I/O transaction and wants to prohibit activation of a sleep state during the transaction, it uses <a class="el" href="_power_8h.html#a0fe334c2cc079241cea000d434b9e73d" title="Declare an operational constraint. ">Power_setConstraint()</a> to declare the constraint, before starting the transaction. When the transaction completes, the driver calls this function to release the constraint, to allow the Power manager to once again allow transitions to sleep.</p>
<p>Constraint identifiers are device specific, and defined in the device-specific Power include file. For example, the constraints for PRCM are defined in PowerPRCM.h.</p>
<p>Only one constraint can be specified with each call to this function; to release multiple constraints this function must be called multiple times.</p>
<p>It is critical that clients call <a class="el" href="_power_8h.html#aa8f983063be6c25765e94664e506652a" title="Release a previously declared constraint. ">Power_releaseConstraint()</a> when operational constraints no longer exists. Otherwise, Power may be left unnecessarily restricted from activating power savings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraintId</td><td>constraint id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Power_SOK</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#a0fe334c2cc079241cea000d434b9e73d" title="Declare an operational constraint. ">Power_setConstraint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a64c740b8432f2539229f262ef7e85692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Power_releaseDependency </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>resourceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously declared dependency. </p>
<p>This function releases a dependency that had been previously declared upon a resource (by a call to <a class="el" href="_power_8h.html#a12d2bfc91eedb7e3a158f12bc670a83e" title="Declare a dependency upon a resource. ">Power_setDependency()</a>).</p>
<p>Resource identifiers are device specific, and defined in the device-specific Power include file. For example, the resources for PRCM are defined in PowerPRCM.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resourceId</td><td>resource id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Power_SOK on success. Power_INVALIDINPUT if the resourceId passed is incorrect. Power_EFAIL if desired power state is not allowed by the module.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#a12d2bfc91eedb7e3a158f12bc670a83e" title="Declare a dependency upon a resource. ">Power_setDependency</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0fe334c2cc079241cea000d434b9e73d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_setConstraint </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>constraintId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare an operational constraint. </p>
<p>Before taking certain actions, the Power manager checks to see if the requested action would conflict with a client-declared constraint. If the action does conflict, Power will not proceed with the request. This is the function that allows clients to declare their constraints with Power.</p>
<p>Constraint identifiers are device specific, and defined in the device-specific Power include file. For example, the constraints for PRCM are defined in PowerPRCM.h.</p>
<p>Only one constraint can be specified with each call to this function; to declare multiple constraints this function must be called multiple times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraintId</td><td>constraint id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Power_SOK</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#aa8f983063be6c25765e94664e506652a" title="Release a previously declared constraint. ">Power_releaseConstraint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a12d2bfc91eedb7e3a158f12bc670a83e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Power_setDependency </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>resourceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a dependency upon a resource. </p>
<p>This function declares a dependency upon a resource. For example, if a UART driver needs a specific UART peripheral, it uses this function to declare this to the Power manager. If the resource had been inactive, then Power will activate the peripheral during this function call.</p>
<p>What is needed to make a peripheral resource 'active' will vary by device family. For some devices this may be a simple enable of a clock to the specified peripheral. For others it may also require a power on of a power domain. In either case, the Power manager will take care of these details, and will also implement reference counting for resources and their interdependencies. For example, if multiple UART peripherals reside in a shared serial power domain, the Power manager will power up the serial domain when it is first needed, and then automatically power the domain off later, when all related dependencies for the relevant peripherals are released.</p>
<p>Resource identifiers are device specific, and defined in the device-specific Power include file. For example, the resources for PRCM are defined in PowerPRCM.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resourceId</td><td>resource id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Power_SOK on success. Power_INVALIDINPUT if the resourceId passed is incorrect. Power_EFAIL if desired power state is not allowed by the module.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#a64c740b8432f2539229f262ef7e85692" title="Release a previously declared dependency. ">Power_releaseDependency</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade9f8442c59deb341f6f5da729e90635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_setPerformanceLevel </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MCU performance level. </p>
<p>This function manages a transition to a new device performance level. Before the actual transition is initiated, notifications will be sent to any clients who've registered (with <a class="el" href="_power_8h.html#a8e73c431e3d1aab1a31181513ceb8adb" title="Register a function to be called upon a specific power event. ">Power_registerNotify()</a>) for a 'start change performance level' notification. The event name is device specific, and defined in the device-specific Power include file. For example, for PRCM, the event is "PowerPRCM_START_CHANGE_PERF_LEVEL", which is defined in PowerPRCM.h. Once notifications have been completed, the change to the performance level is initiated. After the level change is completed, there is a comparable event that can be used to signal a client that the change has completed. For example, on PRCM the "PowerPRCM_DONE_CHANGE_PERF_LEVEL" event can be used to signal completion.</p>
<p>This function will not return until the new performance level is in effect. If performance scaling is not supported for the device, or is prohibited by an active constraint, or if the specified level is invalid, then an error status will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>the new performance level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Power_SOK on success. Power_EFAIL if: performance scaling is not supported, or if the scaling routines encountered an error during initialization, or if the specified performance level is out of range of valid levels. Power_EBUSY is returned if the Power manager is already busy with another transition, or if a single constraint that locks any performance level changes has been declared. Power_ECHANGE_NOT_ALLOWED is returned if the requested level has been explicitly prohibited by a level-specific constraint.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#a992dabafbcd2ed75308dd3e166d9e658" title="Get the current performance level. ">Power_getPerformanceLevel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af1ec2fa95cca7f0ffdcdd9e1d4ef80ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_shutdown </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>shutdownState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>shutdownTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the device into a shutdown state. </p>
<p>This function will transition the device into a shutdown state. Before the actual transition is initiated, notifications will be sent to any clients who've registered (with <a class="el" href="_power_8h.html#a8e73c431e3d1aab1a31181513ceb8adb" title="Register a function to be called upon a specific power event. ">Power_registerNotify()</a>) for an 'entering shutdown' event. The event name is device specific, and defined in the device-specific Power include file. For example, for PRCM, the event is "PowerPRCM_ENTERING_SHUTDOWN", which is defined in PowerPRCM.h. Once notifications have been completed, the device shutdown will commmence.</p>
<p>If the device is successfully transitioned to shutdown, this function call will never return. Upon wakeup, the device and application will be rebooted (through a device reset). If the transition is not successful, one of the error codes listed below will be returned.</p>
<p>On some devices a timed wakeup from shutdown can be specified, using the shutdownTime parameter. This enables an autonomous application reboot at a future time. For example, an application can go to shutdown, and then automatically reboot at a future time to do some work. And once that work is done, the application can shutdown again, for another timed interval. The time interval is specified via the shutdownTime parameter. (On devices that do not support this feature, any value specified for shutdownTime will be ignored.) If the specified shutdownTime is less than the total shutdown latency for the device, then shutdownTime will be ignored. The shutdown latency for the device can be found in the device-specific Power include file. For example, for the PRCM, this latency is defined in PowerPRCM.h, as "PowerPRCM_TOTALTIMESHUTDOWN".)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shutdownState</td><td>the device-specific shutdown state</td></tr>
    <tr><td class="paramname">shutdownTime</td><td>the amount of time (in milliseconds) to keep the the device in the shutdown state; this parameter is not supported on all device families</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error status if the transition did not occur: Power_ECHANGE_NOT_ALLOWED if the transition is prohibited by a constraint; Power_EBUSY if the Power manager is already busy with another transition. </dd></dl>

</div>
</div>
<a class="anchor" id="ad26ff0368295bc388f8cbcaa289fb4b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Power_sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sleepState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition the device into a sleep state. </p>
<p>This function is called from the power policy when it has made a decision to put the device in a specific sleep state. This function returns to the caller (the policy function) once the device has awoken from sleep.</p>
<p>This function must be called with interrupts disabled, and should not be called directly by the application, or by any drivers. This function does not check declared constraints; the policy function must check constraints before calling this function to initiate sleep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleepState</td><td>the sleep state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating success or failure: Power_SOK if the device was put to sleep and then awoken; Power_EFAIL if a failure occurred during client notifications; or Power_EBUSY if the Power manager is already busy with another transition. </dd></dl>

</div>
</div>
<a class="anchor" id="ac32c17ce6da099da97957f08ddb000b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_unregisterNotify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_power___notify_obj.html">Power_NotifyObj</a> *&#160;</td>
          <td class="paramname"><em>pNotifyObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister previously registered notifications. </p>
<p>This function unregisters for event notifications that were previously registered with <a class="el" href="_power_8h.html#a8e73c431e3d1aab1a31181513ceb8adb" title="Register a function to be called upon a specific power event. ">Power_registerNotify()</a>. The caller must specify a pointer to the same notification object used during registration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNotifyObj</td><td>notify object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_power_8h.html#a8e73c431e3d1aab1a31181513ceb8adb" title="Register a function to be called upon a specific power event. ">Power_registerNotify</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
