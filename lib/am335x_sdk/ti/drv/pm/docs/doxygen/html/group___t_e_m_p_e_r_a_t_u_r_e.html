<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Temperature Configuration</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Temperature Configuration</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:pmhal__bgap_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmhal__bgap_8h.html">pmhal_bgap.h</a></td></tr>
<tr class="memdesc:pmhal__bgap_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains the interface declaration for the Temperature HAL. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmhal_bgap_range.html">pmhalBgapRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature Range for a given ADC value.  <a href="structpmhal_bgap_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpmhal_bgap_fifo_entry.html">pmhalBgapFifoEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature Sensor FIFO Entry.  <a href="structpmhal_bgap_fifo_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5324e9c0c57f3e5b04d1a026bccea505"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5324e9c0c57f3e5b04d1a026bccea505"></a>
typedef enum <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga9e3be6b83f17c6136b5d9135350a5aa8">pmhalBgapBandgapCntDelay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga5324e9c0c57f3e5b04d1a026bccea505">pmhalBgapBandgapCntDelay_t</a></td></tr>
<tr class="memdesc:ga5324e9c0c57f3e5b04d1a026bccea505"><td class="mdescLeft">&#160;</td><td class="mdescRight">FSM delay counter (COUNTER_DELAY) valid values. <br /></td></tr>
<tr class="separator:ga5324e9c0c57f3e5b04d1a026bccea505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6aa72909c0201bfec7528cdcf14a0de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf6aa72909c0201bfec7528cdcf14a0de"></a>
typedef enum <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga39b75f077139eb5b30a41163646e1919">pmhalBgapBandgapSIdleMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gaf6aa72909c0201bfec7528cdcf14a0de">pmhalBgapBandgapSIdleMode_t</a></td></tr>
<tr class="memdesc:gaf6aa72909c0201bfec7528cdcf14a0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Band Gap Sensor valid SIDLE modes. The SIDLE modes for BGAP sensor is different than the other modules on the basis of the actual value to be programmed in the register. Hence use this enumeration and not the module mode SIDLE. <br /></td></tr>
<tr class="separator:gaf6aa72909c0201bfec7528cdcf14a0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6518098bfa81255b15a8fe40168dafd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6518098bfa81255b15a8fe40168dafd"></a>
typedef struct <a class="el" href="structpmhal_bgap_range.html">pmhalBgapRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gae6518098bfa81255b15a8fe40168dafd">pmhalBgapRange_t</a></td></tr>
<tr class="memdesc:gae6518098bfa81255b15a8fe40168dafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature Range for a given ADC value. <br /></td></tr>
<tr class="separator:gae6518098bfa81255b15a8fe40168dafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038837b8add4e9e48cf7f9cbc12bd45d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga038837b8add4e9e48cf7f9cbc12bd45d"></a>
typedef struct <a class="el" href="structpmhal_bgap_fifo_entry.html">pmhalBgapFifoEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga038837b8add4e9e48cf7f9cbc12bd45d">pmhalBgapFifoEntry_t</a></td></tr>
<tr class="memdesc:ga038837b8add4e9e48cf7f9cbc12bd45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature Sensor FIFO Entry. <br /></td></tr>
<tr class="separator:ga038837b8add4e9e48cf7f9cbc12bd45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9e3be6b83f17c6136b5d9135350a5aa8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga9e3be6b83f17c6136b5d9135350a5aa8">pmhalBgapBandgapCntDelay</a> { <br />
&#160;&#160;<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga9e3be6b83f17c6136b5d9135350a5aa8af8bed8e38775fa4ff3a6c7f8fc3433fc">PMHAL_BGAP_BAND_GAP_IMMEDIATE</a> = 0x0U, 
<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga9e3be6b83f17c6136b5d9135350a5aa8a37e43a400d43c354a5c1086abba8b047">PMHAL_BGAP_BAND_GAP_1_MS</a> = 0x1U, 
<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga9e3be6b83f17c6136b5d9135350a5aa8ae082342e7c11991a57eba07340d94d67">PMHAL_BGAP_BAND_GAP_10_MS</a> = 0x2U, 
<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga9e3be6b83f17c6136b5d9135350a5aa8a8d1d38ba000f830b4d85d84d23327c26">PMHAL_BGAP_BAND_GAP_100_MS</a> = 0x3U, 
<br />
&#160;&#160;<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga9e3be6b83f17c6136b5d9135350a5aa8a3fa11a01ef805538a2b95ea295bc43da">PMHAL_BGAP_BAND_GAP_250_MS</a> = 0x4U, 
<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga9e3be6b83f17c6136b5d9135350a5aa8ae92a60d1b3359c93d4f0284b0f4dbc26">PMHAL_BGAP_BAND_GAP_500_MS</a> = 0x5U, 
<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga9e3be6b83f17c6136b5d9135350a5aa8abe6df2cbc555b1b1297ee0ba9ed0bfd4">PMHAL_BGAP_BAND_GAP_MAX</a> = PMHAL_BGAP_BAND_GAP_500_MS + 1U
<br />
 }</td></tr>
<tr class="memdesc:ga9e3be6b83f17c6136b5d9135350a5aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">FSM delay counter (COUNTER_DELAY) valid values.  <a href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga9e3be6b83f17c6136b5d9135350a5aa8">More...</a><br /></td></tr>
<tr class="separator:ga9e3be6b83f17c6136b5d9135350a5aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b75f077139eb5b30a41163646e1919"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga39b75f077139eb5b30a41163646e1919">pmhalBgapBandgapSIdleMode</a> { <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga39b75f077139eb5b30a41163646e1919a56c18e1fdc91c61beef6350a36ae209d">PMHAL_BGAP_BAND_GAP_NO_IDLE</a> = 0x0U, 
<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga39b75f077139eb5b30a41163646e1919a75bd2e8f674bd98abcb6c49c03a955cc">PMHAL_BGAP_BAND_GAP_FORCE_IDLE</a> = 0x1U, 
<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga39b75f077139eb5b30a41163646e1919ae32601226d741d85c27b13e3453b15ad">PMHAL_BGAP_BAND_GAP_SMART_IDLE</a> = 0x2U, 
<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gga39b75f077139eb5b30a41163646e1919a0828a15d784925006329b25c54012093">PMHAL_BGAP_BAND_GAP_MAX_SIDLE</a>
 }</td></tr>
<tr class="memdesc:ga39b75f077139eb5b30a41163646e1919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Band Gap Sensor valid SIDLE modes. The SIDLE modes for BGAP sensor is different than the other modules on the basis of the actual value to be programmed in the register. Hence use this enumeration and not the module mode SIDLE.  <a href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga39b75f077139eb5b30a41163646e1919">More...</a><br /></td></tr>
<tr class="separator:ga39b75f077139eb5b30a41163646e1919"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaea55de58be4108aa2cc7a4452170cb75"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gaea55de58be4108aa2cc7a4452170cb75">PMHALBgapGetCurrTemperature</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId, <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gae6518098bfa81255b15a8fe40168dafd">pmhalBgapRange_t</a> *currTempRange)</td></tr>
<tr class="memdesc:gaea55de58be4108aa2cc7a4452170cb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Band gap Temperature Sensor value for a given voltage domain.  <a href="#gaea55de58be4108aa2cc7a4452170cb75">More...</a><br /></td></tr>
<tr class="separator:gaea55de58be4108aa2cc7a4452170cb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc4212896dcc937bfd5ab5d3b2c83a1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga7dc4212896dcc937bfd5ab5d3b2c83a1">PMHALBgapClearState</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId)</td></tr>
<tr class="memdesc:ga7dc4212896dcc937bfd5ab5d3b2c83a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the accumulator and the FIFO entries of the band gap temperature sensors.  <a href="#ga7dc4212896dcc937bfd5ab5d3b2c83a1">More...</a><br /></td></tr>
<tr class="separator:ga7dc4212896dcc937bfd5ab5d3b2c83a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c1b48d06c0970bad3b206a5ba307d5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gaf0c1b48d06c0970bad3b206a5ba307d5">PMHALBgapEnableHotEvent</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId)</td></tr>
<tr class="memdesc:gaf0c1b48d06c0970bad3b206a5ba307d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a Hot alert event for the threshold temperature set by the API PMHALBgapSetHotThreshold.  <a href="#gaf0c1b48d06c0970bad3b206a5ba307d5">More...</a><br /></td></tr>
<tr class="separator:gaf0c1b48d06c0970bad3b206a5ba307d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb1fd3328e3f7044b04a718516a1a10"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga2bb1fd3328e3f7044b04a718516a1a10">PMHALBgapDisableHotEvent</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId)</td></tr>
<tr class="memdesc:ga2bb1fd3328e3f7044b04a718516a1a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a Hot alert event for the threshold temperature set by the API PMHALBgapSetHotThreshold.  <a href="#ga2bb1fd3328e3f7044b04a718516a1a10">More...</a><br /></td></tr>
<tr class="separator:ga2bb1fd3328e3f7044b04a718516a1a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9cd65ae02b50b4a4842b9832f86dc8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gabe9cd65ae02b50b4a4842b9832f86dc8">PMHALBgapEnableColdEvent</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId)</td></tr>
<tr class="memdesc:gabe9cd65ae02b50b4a4842b9832f86dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a Cold alert event for the threshold temperature set by the API PMHALBgapSetColdThreshold.  <a href="#gabe9cd65ae02b50b4a4842b9832f86dc8">More...</a><br /></td></tr>
<tr class="separator:gabe9cd65ae02b50b4a4842b9832f86dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c705fcc954ffc186f2cdf1e9f865ab6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga8c705fcc954ffc186f2cdf1e9f865ab6">PMHALBgapDisableColdEvent</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId)</td></tr>
<tr class="memdesc:ga8c705fcc954ffc186f2cdf1e9f865ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a Cold alert event for the threshold temperature set by the API PMHALBgapSetColdThreshold.  <a href="#ga8c705fcc954ffc186f2cdf1e9f865ab6">More...</a><br /></td></tr>
<tr class="separator:ga8c705fcc954ffc186f2cdf1e9f865ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78064ce17403eac1a21f56d15a351bcb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga78064ce17403eac1a21f56d15a351bcb">PMHALBgapSetMeasureDelay</a> (<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga5324e9c0c57f3e5b04d1a026bccea505">pmhalBgapBandgapCntDelay_t</a> delay)</td></tr>
<tr class="memdesc:ga78064ce17403eac1a21f56d15a351bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The start of temperature measurement is initiated automatically by each FSM after it goes out of reset state. To control the main delay between two measurements the CTRL_CORE_BANDGAP_MASK_1[29:27] COUNTER_DELAY bit field is used. This API sets this field.  <a href="#ga78064ce17403eac1a21f56d15a351bcb">More...</a><br /></td></tr>
<tr class="separator:ga78064ce17403eac1a21f56d15a351bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932fc6f7cf6844e736d22abbef0872ac"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga932fc6f7cf6844e736d22abbef0872ac">PMHALBgapSetSIldeMode</a> (<a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gaf6aa72909c0201bfec7528cdcf14a0de">pmhalBgapBandgapSIdleMode_t</a> mode)</td></tr>
<tr class="memdesc:ga932fc6f7cf6844e736d22abbef0872ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Temperature Sensors FSMs comply with the PRCM slave idle protocol. They share common functional clock (L3INSTR_TS_GCLK), which is automatically gated by PRCM depending on the value of the CTRL_CORE_BANDGAP_MASK_1[31:30] SIDLEMODE bit field. This field is set by this API.  <a href="#ga932fc6f7cf6844e736d22abbef0872ac">More...</a><br /></td></tr>
<tr class="separator:ga932fc6f7cf6844e736d22abbef0872ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadabacd5b54c117985daa4185fb93b40b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gadabacd5b54c117985daa4185fb93b40b">PMHALBgapSetHotThreshold</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId, int32_t tempInMilliDegree)</td></tr>
<tr class="memdesc:gadabacd5b54c117985daa4185fb93b40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the high temperature threshold for generating thermal alerts through programming the CTRL_CORE_BANDGAP_THRESHOLD_x[25:16] THOLD_HOT_x bit fields.  <a href="#gadabacd5b54c117985daa4185fb93b40b">More...</a><br /></td></tr>
<tr class="separator:gadabacd5b54c117985daa4185fb93b40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a8b2fbbe397127b7f5a0a27b21e864"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga98a8b2fbbe397127b7f5a0a27b21e864">PMHALBgapSetColdThreshold</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId, int32_t tempInMilliDegree)</td></tr>
<tr class="memdesc:ga98a8b2fbbe397127b7f5a0a27b21e864"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the Low temperature threshold for generating thermal alerts through programming the CTRL_CORE_BANDGAP_THRESHOLD_x[25:16] THOLD_COLD_x bit fields.  <a href="#ga98a8b2fbbe397127b7f5a0a27b21e864">More...</a><br /></td></tr>
<tr class="separator:ga98a8b2fbbe397127b7f5a0a27b21e864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b239aeba842db476998a6a48b44c30"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga59b239aeba842db476998a6a48b44c30">PMHALBgapGetHotThreshold</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId, <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gae6518098bfa81255b15a8fe40168dafd">pmhalBgapRange_t</a> *thresholdTempRange)</td></tr>
<tr class="memdesc:ga59b239aeba842db476998a6a48b44c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the configured high temperature threshold range programmed into the CTRL_CORE_BANDGAP_THRESHOLD_x[25:16] THOLD_HOT_x bit fields.  <a href="#ga59b239aeba842db476998a6a48b44c30">More...</a><br /></td></tr>
<tr class="separator:ga59b239aeba842db476998a6a48b44c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c39efb43c585749884c5623387d17f3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga1c39efb43c585749884c5623387d17f3">PMHALBgapGetColdThreshold</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId, <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gae6518098bfa81255b15a8fe40168dafd">pmhalBgapRange_t</a> *thresholdTempRange)</td></tr>
<tr class="memdesc:ga1c39efb43c585749884c5623387d17f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the configured low temperature threshold range programmed into the CTRL_CORE_BANDGAP_THRESHOLD_x[25:16] THOLD_COLD_x bit fields.  <a href="#ga1c39efb43c585749884c5623387d17f3">More...</a><br /></td></tr>
<tr class="separator:ga1c39efb43c585749884c5623387d17f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7177b00e8082cbf21d9306b8bd20b6cf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga7177b00e8082cbf21d9306b8bd20b6cf">PMHALBgapGetHotAlertStatus</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId, uint32_t *hotStatus)</td></tr>
<tr class="memdesc:ga7177b00e8082cbf21d9306b8bd20b6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The non masked (raw) comparator outputs are available for reading through the corresponding bits in the CTRL_CORE_BANDGAP_STATUS_1 and CTRL_CORE_BANDGAP_STATUS_2 registers. The high temperature threshold comparator outputs are read through the HOT_x bits using this API.  <a href="#ga7177b00e8082cbf21d9306b8bd20b6cf">More...</a><br /></td></tr>
<tr class="separator:ga7177b00e8082cbf21d9306b8bd20b6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954fa4f56710232125fa5212764bc743"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga954fa4f56710232125fa5212764bc743">PMHALBgapGetColdAlertStatus</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId, uint32_t *coldStatus)</td></tr>
<tr class="memdesc:ga954fa4f56710232125fa5212764bc743"><td class="mdescLeft">&#160;</td><td class="mdescRight">The non masked (raw) comparator outputs are available for reading through the corresponding bits in the CTRL_CORE_BANDGAP_STATUS_1 and CTRL_CORE_BANDGAP_STATUS_2 registers. The low temperature threshold comparator outputs are read through the COLD_x bits using this API.  <a href="#ga954fa4f56710232125fa5212764bc743">More...</a><br /></td></tr>
<tr class="separator:ga954fa4f56710232125fa5212764bc743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df6b35b7d55ef4c0ad4a29a301df3ed"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga0df6b35b7d55ef4c0ad4a29a301df3ed">PMHALBgapWaitForAlertClear</a> (uint32_t timeOut)</td></tr>
<tr class="memdesc:ga0df6b35b7d55ef4c0ad4a29a301df3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CTRL_MODULE_CORE_IRQ_THERMAL_ALERT signal is also routed to the CTRL_CORE_BANDGAP_STATUS_1[31] ALERT bit. Value of 0x1 indicates that the CTRL_MODULE_CORE_IRQ_THERMAL_ALERT signal is asserted. Software can use this interrupt to implement the device thermal management policy. This API can be used to wait for the clearing of the alert signal as the temperature of the voltage domains drop below their threshold.  <a href="#ga0df6b35b7d55ef4c0ad4a29a301df3ed">More...</a><br /></td></tr>
<tr class="separator:ga0df6b35b7d55ef4c0ad4a29a301df3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3091af8301b9bb88988f1d6ae29d8f1a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga3091af8301b9bb88988f1d6ae29d8f1a">PMHALBgapGetFifoEntry</a> (<a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a> voltId, uint32_t entryNum, <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga038837b8add4e9e48cf7f9cbc12bd45d">pmhalBgapFifoEntry_t</a> *fifoEntry)</td></tr>
<tr class="memdesc:ga3091af8301b9bb88988f1d6ae29d8f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each time one of the CTRL_CORE_TEMP_SENSOR_x[9:0] BGAP_DTEMP_x bit fields is updated with new temperature value, this value is also automatically stored into a 5-level deep FIFO and a time stamp is registered too. This API helps read the value for a given entry number.  <a href="#ga3091af8301b9bb88988f1d6ae29d8f1a">More...</a><br /></td></tr>
<tr class="separator:ga3091af8301b9bb88988f1d6ae29d8f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Temperature (BGAP) HAL Configuration provides API to read the junction temperature of the different BGAP temperature sensors available in the SoC. This HAL allows setting of the right threshold values for the Temperature hot and cold interrupts. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga9e3be6b83f17c6136b5d9135350a5aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga9e3be6b83f17c6136b5d9135350a5aa8">pmhalBgapBandgapCntDelay</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FSM delay counter (COUNTER_DELAY) valid values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9e3be6b83f17c6136b5d9135350a5aa8af8bed8e38775fa4ff3a6c7f8fc3433fc"></a>PMHAL_BGAP_BAND_GAP_IMMEDIATE&#160;</td><td class="fielddoc">
<p>Immediately start the temperature measurement </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e3be6b83f17c6136b5d9135350a5aa8a37e43a400d43c354a5c1086abba8b047"></a>PMHAL_BGAP_BAND_GAP_1_MS&#160;</td><td class="fielddoc">
<p>Start the temperature measurement after 1 ms </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e3be6b83f17c6136b5d9135350a5aa8ae082342e7c11991a57eba07340d94d67"></a>PMHAL_BGAP_BAND_GAP_10_MS&#160;</td><td class="fielddoc">
<p>Start the temperature measurement after 10 ms </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e3be6b83f17c6136b5d9135350a5aa8a8d1d38ba000f830b4d85d84d23327c26"></a>PMHAL_BGAP_BAND_GAP_100_MS&#160;</td><td class="fielddoc">
<p>Start the temperature measurement after 100 ms </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e3be6b83f17c6136b5d9135350a5aa8a3fa11a01ef805538a2b95ea295bc43da"></a>PMHAL_BGAP_BAND_GAP_250_MS&#160;</td><td class="fielddoc">
<p>Start the temperature measurement after 250 ms </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e3be6b83f17c6136b5d9135350a5aa8ae92a60d1b3359c93d4f0284b0f4dbc26"></a>PMHAL_BGAP_BAND_GAP_500_MS&#160;</td><td class="fielddoc">
<p>Start the temperature measurement after 500 ms </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e3be6b83f17c6136b5d9135350a5aa8abe6df2cbc555b1b1297ee0ba9ed0bfd4"></a>PMHAL_BGAP_BAND_GAP_MAX&#160;</td><td class="fielddoc">
<p>Max temperature measurement delay </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga39b75f077139eb5b30a41163646e1919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga39b75f077139eb5b30a41163646e1919">pmhalBgapBandgapSIdleMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Band Gap Sensor valid SIDLE modes. The SIDLE modes for BGAP sensor is different than the other modules on the basis of the actual value to be programmed in the register. Hence use this enumeration and not the module mode SIDLE. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga39b75f077139eb5b30a41163646e1919a56c18e1fdc91c61beef6350a36ae209d"></a>PMHAL_BGAP_BAND_GAP_NO_IDLE&#160;</td><td class="fielddoc">
<p>Band Gap Sensor no idle mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga39b75f077139eb5b30a41163646e1919a75bd2e8f674bd98abcb6c49c03a955cc"></a>PMHAL_BGAP_BAND_GAP_FORCE_IDLE&#160;</td><td class="fielddoc">
<p>Band Gap Sensor force idle mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga39b75f077139eb5b30a41163646e1919ae32601226d741d85c27b13e3453b15ad"></a>PMHAL_BGAP_BAND_GAP_SMART_IDLE&#160;</td><td class="fielddoc">
<p>Band Gap Sensor smart idle mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga39b75f077139eb5b30a41163646e1919a0828a15d784925006329b25c54012093"></a>PMHAL_BGAP_BAND_GAP_MAX_SIDLE&#160;</td><td class="fielddoc">
<p>Max allowed Slave Idle mode </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7dc4212896dcc937bfd5ab5d3b2c83a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapClearState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the accumulator and the FIFO entries of the band gap temperature sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the sensor read registers are cleared correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage ID is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8c705fcc954ffc186f2cdf1e9f865ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapDisableColdEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable a Cold alert event for the threshold temperature set by the API PMHALBgapSetColdThreshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the cold event is disabled correctly</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage ID is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2bb1fd3328e3f7044b04a718516a1a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapDisableHotEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable a Hot alert event for the threshold temperature set by the API PMHALBgapSetHotThreshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the hot event is disabled correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage ID is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabe9cd65ae02b50b4a4842b9832f86dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapEnableColdEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable a Cold alert event for the threshold temperature set by the API PMHALBgapSetColdThreshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the cold event is enabled correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage ID is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf0c1b48d06c0970bad3b206a5ba307d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapEnableHotEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable a Hot alert event for the threshold temperature set by the API PMHALBgapSetHotThreshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the hot event is enabled correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage ID is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga954fa4f56710232125fa5212764bc743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapGetColdAlertStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>coldStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The non masked (raw) comparator outputs are available for reading through the corresponding bits in the CTRL_CORE_BANDGAP_STATUS_1 and CTRL_CORE_BANDGAP_STATUS_2 registers. The low temperature threshold comparator outputs are read through the COLD_x bits using this API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details. </td></tr>
    <tr><td class="paramname">coldStatus</td><td>Low temperature threshold comparator output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the output is read correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage domain is not correct or the pointer coldStatus is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1c39efb43c585749884c5623387d17f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapGetColdThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gae6518098bfa81255b15a8fe40168dafd">pmhalBgapRange_t</a> *&#160;</td>
          <td class="paramname"><em>thresholdTempRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the configured low temperature threshold range programmed into the CTRL_CORE_BANDGAP_THRESHOLD_x[25:16] THOLD_COLD_x bit fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details. </td></tr>
    <tr><td class="paramname">thresholdTempRange</td><td>Pointer to the threshold temperature range. Gives the max and min temperature which corresponds to the read threshold ADC value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the threshold is read correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage domain is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaea55de58be4108aa2cc7a4452170cb75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapGetCurrTemperature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gae6518098bfa81255b15a8fe40168dafd">pmhalBgapRange_t</a> *&#160;</td>
          <td class="paramname"><em>currTempRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Band gap Temperature Sensor value for a given voltage domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details. </td></tr>
    <tr><td class="paramname">currTempRange</td><td>Pointer to the current temperature range. Gives the max and min temperature which corresponds to the read ADC value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the temperature is read correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage ID is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3091af8301b9bb88988f1d6ae29d8f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapGetFifoEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>entryNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga038837b8add4e9e48cf7f9cbc12bd45d">pmhalBgapFifoEntry_t</a> *&#160;</td>
          <td class="paramname"><em>fifoEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each time one of the CTRL_CORE_TEMP_SENSOR_x[9:0] BGAP_DTEMP_x bit fields is updated with new temperature value, this value is also automatically stored into a 5-level deep FIFO and a time stamp is registered too. This API helps read the value for a given entry number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details. </td></tr>
    <tr><td class="paramname">entryNum</td><td>Entry number of the FIFO. Has to be lesser than number supported in the SoC. Number starts from 0 which corresponds to the most recent entry. </td></tr>
    <tr><td class="paramname">fifoEntry</td><td>The Bandgap sensor fifo entry value is returned corresponding to the given voltage domain and entry number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the FIFO entry is read correctly</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage domain is not correct or the pointer fifoEntry is NULL or the entryNum is higher than supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7177b00e8082cbf21d9306b8bd20b6cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapGetHotAlertStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hotStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The non masked (raw) comparator outputs are available for reading through the corresponding bits in the CTRL_CORE_BANDGAP_STATUS_1 and CTRL_CORE_BANDGAP_STATUS_2 registers. The high temperature threshold comparator outputs are read through the HOT_x bits using this API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details. </td></tr>
    <tr><td class="paramname">hotStatus</td><td>High temperature threshold comparator output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the output is read correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage domain is not correct or the pointer hotStatus is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga59b239aeba842db476998a6a48b44c30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapGetHotThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gae6518098bfa81255b15a8fe40168dafd">pmhalBgapRange_t</a> *&#160;</td>
          <td class="paramname"><em>thresholdTempRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the configured high temperature threshold range programmed into the CTRL_CORE_BANDGAP_THRESHOLD_x[25:16] THOLD_HOT_x bit fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details. </td></tr>
    <tr><td class="paramname">thresholdTempRange</td><td>Pointer to the threshold temperature range. Gives the max and min temperature which corresponds to the read threshold ADC value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the threshold is read correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage domain is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga98a8b2fbbe397127b7f5a0a27b21e864"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapSetColdThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tempInMilliDegree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the Low temperature threshold for generating thermal alerts through programming the CTRL_CORE_BANDGAP_THRESHOLD_x[25:16] THOLD_COLD_x bit fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details. </td></tr>
    <tr><td class="paramname">tempInMilliDegree</td><td>Temperature Threshold in milli Degree Celsius.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the threshold is programmed correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage domain is not correct or the temperature is out of the range supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadabacd5b54c117985daa4185fb93b40b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapSetHotThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467">pmhalPrcmVdId_t</a>&#160;</td>
          <td class="paramname"><em>voltId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tempInMilliDegree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the high temperature threshold for generating thermal alerts through programming the CTRL_CORE_BANDGAP_THRESHOLD_x[25:16] THOLD_HOT_x bit fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltId</td><td>Unique voltage domain ID. Refer enum <a class="el" href="group___m_i_s_c.html#ga13b1aa199904e91aaf4052f17d598467" title="Voltage Domains. ">pmhalPrcmVdId_t</a> for details. </td></tr>
    <tr><td class="paramname">tempInMilliDegree</td><td>Temperature Threshold in milli Degree Celsius.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the threshold is programmed correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the voltage domain is not correct or the temperature is out of the range supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga78064ce17403eac1a21f56d15a351bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapSetMeasureDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga5324e9c0c57f3e5b04d1a026bccea505">pmhalBgapBandgapCntDelay_t</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The start of temperature measurement is initiated automatically by each FSM after it goes out of reset state. To control the main delay between two measurements the CTRL_CORE_BANDGAP_MASK_1[29:27] COUNTER_DELAY bit field is used. This API sets this field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Unique delay value ID. Refer enum <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#ga5324e9c0c57f3e5b04d1a026bccea505" title="FSM delay counter (COUNTER_DELAY) valid values. ">pmhalBgapBandgapCntDelay_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the delay is programmed correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the delay is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga932fc6f7cf6844e736d22abbef0872ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapSetSIldeMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gaf6aa72909c0201bfec7528cdcf14a0de">pmhalBgapBandgapSIdleMode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Temperature Sensors FSMs comply with the PRCM slave idle protocol. They share common functional clock (L3INSTR_TS_GCLK), which is automatically gated by PRCM depending on the value of the CTRL_CORE_BANDGAP_MASK_1[31:30] SIDLEMODE bit field. This field is set by this API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Unique idle mode to be set . Refer enum <a class="el" href="group___t_e_m_p_e_r_a_t_u_r_e.html#gaf6aa72909c0201bfec7528cdcf14a0de" title="Band Gap Sensor valid SIDLE modes. The SIDLE modes for BGAP sensor is different than the other module...">pmhalBgapBandgapSIdleMode_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the slave idle mode is programmed correctly.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the slave idle mode is not supported </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0df6b35b7d55ef4c0ad4a29a301df3ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t PMHALBgapWaitForAlertClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CTRL_MODULE_CORE_IRQ_THERMAL_ALERT signal is also routed to the CTRL_CORE_BANDGAP_STATUS_1[31] ALERT bit. Value of 0x1 indicates that the CTRL_MODULE_CORE_IRQ_THERMAL_ALERT signal is asserted. Software can use this interrupt to implement the device thermal management policy. This API can be used to wait for the clearing of the alert signal as the temperature of the voltage domains drop below their threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOut</td><td>Time out to wait till the temperature drops below the threshold and the alert signal is cleared. Valid values are PM_TIMEOUT_INFINITE (wait infinitely) or any non zero time out value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Status of the API call.<ul>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba2fec0467f2b290a3bfd0bbd1be3b0783">PM_SUCCESS</a> If the alert is cleared.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9ba949533714505ba7d144c0db785e61284">PM_BADARGS</a> If the timeout value provided is 0.</li>
<li><a class="el" href="pm__types_8h.html#aaa0d1ee0f22b2df6888809fd8e77ea9bae9c4b8c915fd3ade44fdce499be82ba1">PM_FAIL</a> If the alert is not cleared in the given timeOut. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
