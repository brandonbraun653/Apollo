<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>UART Driver API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART Driver API<div class="ingroups"><a class="el" href="group___d_r_v___u_a_r_t___m_o_d_u_l_e.html">UART Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_u_a_r_t_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html">UART.h</a></td></tr>
<tr class="memdesc:_u_a_r_t_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART driver interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___transaction__s.html">UART_Transaction_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2() ...">UART_Transaction</a> data structure is used with <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga59997fcf8ebb14c34797717d9dde8d6e" title="Extended function that read data from a UART. ">UART_read2()</a>, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6fc38efd825942b5a43e937411aab890" title="Extended function that writes data to a UART. ">UART_write2()</a> and <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga873e53d7c98e831152ca7186b7209cd7" title="The definition of a callback2 function used by the UART driver when used in UART_MODE_CALLBACK. ">UART_Callback2()</a>  <a href="struct_u_a_r_t___transaction__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___params__s.html">UART_Params_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic UART Parameters.  <a href="struct_u_a_r_t___params__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___fxn_table__s.html">UART_FxnTable_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation.  <a href="struct_u_a_r_t___fxn_table__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___config__s.html">UART_Config_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="struct_u_a_r_t___config__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7d332e86b841e3aed39cdcee35d9508e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7d332e86b841e3aed39cdcee35d9508e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga7d332e86b841e3aed39cdcee35d9508e">UART_NO_WAIT</a>&#160;&#160;&#160;((uint32_t)0U)</td></tr>
<tr class="memdesc:ga7d332e86b841e3aed39cdcee35d9508e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART transaction timeout define. <br /></td></tr>
<tr class="separator:ga7d332e86b841e3aed39cdcee35d9508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9a2cb7a6a7cd3136a2299f155ebd0a36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a2cb7a6a7cd3136a2299f155ebd0a36"></a>
typedef struct <a class="el" href="struct_u_a_r_t___config__s.html">UART_Config_s</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a></td></tr>
<tr class="memdesc:ga9a2cb7a6a7cd3136a2299f155ebd0a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate. ">UART_open()</a> call. <br /></td></tr>
<tr class="separator:ga9a2cb7a6a7cd3136a2299f155ebd0a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d43bd8997e9153ce790bc81467ec935"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga5d43bd8997e9153ce790bc81467ec935">UART_Callback</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buf, size_t count)</td></tr>
<tr class="memdesc:ga5d43bd8997e9153ce790bc81467ec935"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the UART driver when used in <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga0d2a27a518c1a4474a556544acf86e74ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.  <a href="#ga5d43bd8997e9153ce790bc81467ec935">More...</a><br /></td></tr>
<tr class="separator:ga5d43bd8997e9153ce790bc81467ec935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf60ad7c7a967e590b8a6581792122e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf60ad7c7a967e590b8a6581792122e6"></a>
typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga5c62b4d6da039b581146a6d39d9c5b85">UART_TransferApiVer_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gadf60ad7c7a967e590b8a6581792122e6">UART_TransferApiVer</a></td></tr>
<tr class="memdesc:gadf60ad7c7a967e590b8a6581792122e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer API version. <br /></td></tr>
<tr class="separator:gadf60ad7c7a967e590b8a6581792122e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6634ee9805130c5b83906faa5f770c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6634ee9805130c5b83906faa5f770c9"></a>
typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga0f3cc3797952a54f210eac51d8c65525">UART_TransferStatus_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gab6634ee9805130c5b83906faa5f770c9">UART_TransferStatus</a></td></tr>
<tr class="memdesc:gab6634ee9805130c5b83906faa5f770c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer status codes that are set by the UART driver. <br /></td></tr>
<tr class="separator:gab6634ee9805130c5b83906faa5f770c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3374395b6401556fefbbd5b9fe4f80c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac3374395b6401556fefbbd5b9fe4f80c"></a>
typedef struct <a class="el" href="struct_u_a_r_t___transaction__s.html">UART_Transaction_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a></td></tr>
<tr class="memdesc:gac3374395b6401556fefbbd5b9fe4f80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c" title="A UART_Transaction data structure is used with UART_read2(), UART_write2() and UART_Callback2() ...">UART_Transaction</a> data structure is used with <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga59997fcf8ebb14c34797717d9dde8d6e" title="Extended function that read data from a UART. ">UART_read2()</a>, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6fc38efd825942b5a43e937411aab890" title="Extended function that writes data to a UART. ">UART_write2()</a> and <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga873e53d7c98e831152ca7186b7209cd7" title="The definition of a callback2 function used by the UART driver when used in UART_MODE_CALLBACK. ">UART_Callback2()</a> <br /></td></tr>
<tr class="separator:gac3374395b6401556fefbbd5b9fe4f80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873e53d7c98e831152ca7186b7209cd7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga873e53d7c98e831152ca7186b7209cd7">UART_Callback2</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:ga873e53d7c98e831152ca7186b7209cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback2 function used by the UART driver when used in <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga0d2a27a518c1a4474a556544acf86e74ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>.  <a href="#ga873e53d7c98e831152ca7186b7209cd7">More...</a><br /></td></tr>
<tr class="separator:ga873e53d7c98e831152ca7186b7209cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d6ede39ae58d1e58cc1133843740be"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga0d2a27a518c1a4474a556544acf86e74">UART_Mode_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga98d6ede39ae58d1e58cc1133843740be">UART_Mode</a></td></tr>
<tr class="memdesc:ga98d6ede39ae58d1e58cc1133843740be"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART mode settings.  <a href="#ga98d6ede39ae58d1e58cc1133843740be">More...</a><br /></td></tr>
<tr class="separator:ga98d6ede39ae58d1e58cc1133843740be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa180fc9d177be8a1fbf44fc33a2bc73c"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaf181cd5aa441af5f4e18ab6bc7212b94">UART_ReturnMode_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaa180fc9d177be8a1fbf44fc33a2bc73c">UART_ReturnMode</a></td></tr>
<tr class="memdesc:gaa180fc9d177be8a1fbf44fc33a2bc73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART return mode settings.  <a href="#gaa180fc9d177be8a1fbf44fc33a2bc73c">More...</a><br /></td></tr>
<tr class="separator:gaa180fc9d177be8a1fbf44fc33a2bc73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3df8ab128966ece5c06a82213a1a7aac"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga337b3c4a16154975e56efd930999fcb8">UART_DataMode_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga3df8ab128966ece5c06a82213a1a7aac">UART_DataMode</a></td></tr>
<tr class="memdesc:ga3df8ab128966ece5c06a82213a1a7aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data mode settings.  <a href="#ga3df8ab128966ece5c06a82213a1a7aac">More...</a><br /></td></tr>
<tr class="separator:ga3df8ab128966ece5c06a82213a1a7aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e11c6c8410167fd0ae53f151c2f917"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga300f4e491cd61d8e974598e670ff39e8">UART_Echo_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gab8e11c6c8410167fd0ae53f151c2f917">UART_Echo</a></td></tr>
<tr class="memdesc:gab8e11c6c8410167fd0ae53f151c2f917"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART echo settings.  <a href="#gab8e11c6c8410167fd0ae53f151c2f917">More...</a><br /></td></tr>
<tr class="separator:gab8e11c6c8410167fd0ae53f151c2f917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafafb90f891f1e14959d9ed45d7af1b09"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93">UART_LEN_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gafafb90f891f1e14959d9ed45d7af1b09">UART_LEN</a></td></tr>
<tr class="memdesc:gafafb90f891f1e14959d9ed45d7af1b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data length settings.  <a href="#gafafb90f891f1e14959d9ed45d7af1b09">More...</a><br /></td></tr>
<tr class="separator:gafafb90f891f1e14959d9ed45d7af1b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91040de76e05e47441f1112522bf69a6"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga354ada9bf4e549345820568ff9ad0ca7">UART_STOP_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga91040de76e05e47441f1112522bf69a6">UART_STOP</a></td></tr>
<tr class="memdesc:ga91040de76e05e47441f1112522bf69a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit settings.  <a href="#ga91040de76e05e47441f1112522bf69a6">More...</a><br /></td></tr>
<tr class="separator:ga91040de76e05e47441f1112522bf69a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac030bbb8f2bbf15cc97cc8d965cc76ca"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6c5930832f38f32dacf8370542ba2f67">UART_PAR_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac030bbb8f2bbf15cc97cc8d965cc76ca">UART_PAR</a></td></tr>
<tr class="memdesc:gac030bbb8f2bbf15cc97cc8d965cc76ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity type settings.  <a href="#gac030bbb8f2bbf15cc97cc8d965cc76ca">More...</a><br /></td></tr>
<tr class="separator:gac030bbb8f2bbf15cc97cc8d965cc76ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6162c608c1a65055a43a924523415536"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6162c608c1a65055a43a924523415536"></a>
typedef struct <a class="el" href="struct_u_a_r_t___params__s.html">UART_Params_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6162c608c1a65055a43a924523415536">UART_Params</a></td></tr>
<tr class="memdesc:ga6162c608c1a65055a43a924523415536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic UART Parameters. <br /></td></tr>
<tr class="separator:ga6162c608c1a65055a43a924523415536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae08ff15291bd6b21cb4e2eb1fce164a6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gae08ff15291bd6b21cb4e2eb1fce164a6">UART_CloseFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:gae08ff15291bd6b21cb4e2eb1fce164a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn(). ">UART_CloseFxn()</a>. <br /></td></tr>
<tr class="separator:gae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef3a1deae1514eb9c268f34542fe27b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaef3a1deae1514eb9c268f34542fe27b2"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaef3a1deae1514eb9c268f34542fe27b2">UART_ControlFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:gaef3a1deae1514eb9c268f34542fe27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gafff81a6e76deb098c5d3ebfcd758472b" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a>. <br /></td></tr>
<tr class="separator:gaef3a1deae1514eb9c268f34542fe27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3e89df3065fffb47e7354067c14d1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2b3e89df3065fffb47e7354067c14d1b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga2b3e89df3065fffb47e7354067c14d1b">UART_InitFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga2b3e89df3065fffb47e7354067c14d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gab60a36f7295d704926120d22f806dcd1" title="Function to initializes the UART module. ">UART_init()</a>. <br /></td></tr>
<tr class="separator:ga2b3e89df3065fffb47e7354067c14d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga207bd25ca9f85df92b668fa39219c00d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga207bd25ca9f85df92b668fa39219c00d"></a>
typedef <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga207bd25ca9f85df92b668fa39219c00d">UART_OpenFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6162c608c1a65055a43a924523415536">UART_Params</a> *params)</td></tr>
<tr class="memdesc:ga207bd25ca9f85df92b668fa39219c00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga207bd25ca9f85df92b668fa39219c00d" title="A function pointer to a driver specific implementation of UART_OpenFxn(). ">UART_OpenFxn()</a>. <br /></td></tr>
<tr class="separator:ga207bd25ca9f85df92b668fa39219c00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82a43e1e6984f793b63c2a55aacad6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa82a43e1e6984f793b63c2a55aacad6a"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaa82a43e1e6984f793b63c2a55aacad6a">UART_ReadFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:gaa82a43e1e6984f793b63c2a55aacad6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaa82a43e1e6984f793b63c2a55aacad6a" title="A function pointer to a driver specific implementation of UART_ReadFxn(). ">UART_ReadFxn()</a>. <br /></td></tr>
<tr class="separator:gaa82a43e1e6984f793b63c2a55aacad6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5efe63f4037573a63df6ba811821296e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5efe63f4037573a63df6ba811821296e"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga5efe63f4037573a63df6ba811821296e">UART_ReadPollingFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:ga5efe63f4037573a63df6ba811821296e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga5efe63f4037573a63df6ba811821296e" title="A function pointer to a driver specific implementation of UART_ReadPollingFxn(). ">UART_ReadPollingFxn()</a>. <br /></td></tr>
<tr class="separator:ga5efe63f4037573a63df6ba811821296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46296acc2c197a775d44458e1eca197"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa46296acc2c197a775d44458e1eca197"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaa46296acc2c197a775d44458e1eca197">UART_ReadCancelFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:gaa46296acc2c197a775d44458e1eca197"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaa46296acc2c197a775d44458e1eca197" title="A function pointer to a driver specific implementation of UART_ReadCancelFxn(). ">UART_ReadCancelFxn()</a>. <br /></td></tr>
<tr class="separator:gaa46296acc2c197a775d44458e1eca197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc9b86a586eedd8eafecff9b46d5413"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbc9b86a586eedd8eafecff9b46d5413"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gabbc9b86a586eedd8eafecff9b46d5413">UART_WriteFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:gabbc9b86a586eedd8eafecff9b46d5413"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn(). ">UART_CloseFxn()</a>. <br /></td></tr>
<tr class="separator:gabbc9b86a586eedd8eafecff9b46d5413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6eb05c87515b7c7ccc71a1298dcfb93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6eb05c87515b7c7ccc71a1298dcfb93"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gad6eb05c87515b7c7ccc71a1298dcfb93">UART_WritePollingFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:gad6eb05c87515b7c7ccc71a1298dcfb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gad6eb05c87515b7c7ccc71a1298dcfb93" title="A function pointer to a driver specific implementation of UART_WritePollingFxn(). ...">UART_WritePollingFxn()</a>. <br /></td></tr>
<tr class="separator:gad6eb05c87515b7c7ccc71a1298dcfb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a3d974279a2d161746dfbc8ca91774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5a3d974279a2d161746dfbc8ca91774"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac5a3d974279a2d161746dfbc8ca91774">UART_WriteCancelFxn</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:gac5a3d974279a2d161746dfbc8ca91774"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac5a3d974279a2d161746dfbc8ca91774" title="A function pointer to a driver specific implementation of UART_WriteCancelFxn(). ">UART_WriteCancelFxn()</a>. <br /></td></tr>
<tr class="separator:gac5a3d974279a2d161746dfbc8ca91774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cacf984a8b1ce5144154561445b9ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga49cacf984a8b1ce5144154561445b9ab"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49cacf984a8b1ce5144154561445b9ab">UART_ReadFxn2</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:ga49cacf984a8b1ce5144154561445b9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49cacf984a8b1ce5144154561445b9ab" title="A function pointer to a driver specific implementation of UART_ReadFxn2(). ">UART_ReadFxn2()</a>. <br /></td></tr>
<tr class="separator:ga49cacf984a8b1ce5144154561445b9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30c486bfc0594d4f2d20c414ea772b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad30c486bfc0594d4f2d20c414ea772b7"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gad30c486bfc0594d4f2d20c414ea772b7">UART_WriteFxn2</a>) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:gad30c486bfc0594d4f2d20c414ea772b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gad30c486bfc0594d4f2d20c414ea772b7" title="A function pointer to a driver specific implementation of UART_WriteFxn2(). ">UART_WriteFxn2()</a>. <br /></td></tr>
<tr class="separator:gad30c486bfc0594d4f2d20c414ea772b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5de8f8f6b54733f443013c3aa710b49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5de8f8f6b54733f443013c3aa710b49"></a>
typedef struct <a class="el" href="struct_u_a_r_t___fxn_table__s.html">UART_FxnTable_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gad5de8f8f6b54733f443013c3aa710b49">UART_FxnTable</a></td></tr>
<tr class="memdesc:gad5de8f8f6b54733f443013c3aa710b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation. <br /></td></tr>
<tr class="separator:gad5de8f8f6b54733f443013c3aa710b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f2e9db8b05e6457b6b36c632168e5c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f2e9db8b05e6457b6b36c632168e5c3"></a>
typedef struct <a class="el" href="struct_u_a_r_t___config__s.html">UART_Config_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga3f2e9db8b05e6457b6b36c632168e5c3">UART_Config</a></td></tr>
<tr class="memdesc:ga3f2e9db8b05e6457b6b36c632168e5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration. <br /></td></tr>
<tr class="separator:ga3f2e9db8b05e6457b6b36c632168e5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5c62b4d6da039b581146a6d39d9c5b85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5c62b4d6da039b581146a6d39d9c5b85"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga5c62b4d6da039b581146a6d39d9c5b85">UART_TransferApiVer_s</a> </td></tr>
<tr class="memdesc:ga5c62b4d6da039b581146a6d39d9c5b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer API version. <br /></td></tr>
<tr class="separator:ga5c62b4d6da039b581146a6d39d9c5b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3cc3797952a54f210eac51d8c65525"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0f3cc3797952a54f210eac51d8c65525"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga0f3cc3797952a54f210eac51d8c65525">UART_TransferStatus_s</a> </td></tr>
<tr class="memdesc:ga0f3cc3797952a54f210eac51d8c65525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer status codes that are set by the UART driver. <br /></td></tr>
<tr class="separator:ga0f3cc3797952a54f210eac51d8c65525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d2a27a518c1a4474a556544acf86e74"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga0d2a27a518c1a4474a556544acf86e74">UART_Mode_e</a> { <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga0d2a27a518c1a4474a556544acf86e74ae6b6bd5d2d5df859ad6724e89e605ebf">UART_MODE_BLOCKING</a>, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga0d2a27a518c1a4474a556544acf86e74ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>
 }</td></tr>
<tr class="memdesc:ga0d2a27a518c1a4474a556544acf86e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART mode settings.  <a href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga0d2a27a518c1a4474a556544acf86e74">More...</a><br /></td></tr>
<tr class="separator:ga0d2a27a518c1a4474a556544acf86e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf181cd5aa441af5f4e18ab6bc7212b94"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaf181cd5aa441af5f4e18ab6bc7212b94">UART_ReturnMode_e</a> { <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ggaf181cd5aa441af5f4e18ab6bc7212b94a50c07cbaf7518a0acd14137e801687e5">UART_RETURN_FULL</a>, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ggaf181cd5aa441af5f4e18ab6bc7212b94a3b8e419e0e12abf80b25f72d17745f76">UART_RETURN_NEWLINE</a>
 }</td></tr>
<tr class="memdesc:gaf181cd5aa441af5f4e18ab6bc7212b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART return mode settings.  <a href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaf181cd5aa441af5f4e18ab6bc7212b94">More...</a><br /></td></tr>
<tr class="separator:gaf181cd5aa441af5f4e18ab6bc7212b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga337b3c4a16154975e56efd930999fcb8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga337b3c4a16154975e56efd930999fcb8">UART_DataMode_e</a> { <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga337b3c4a16154975e56efd930999fcb8aaa8edcbf6c236b0d86491ea1e7c9e4d8">UART_DATA_BINARY</a>, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga337b3c4a16154975e56efd930999fcb8a87fdfb7ca981eab7f56c51380fd7094e">UART_DATA_TEXT</a>
 }</td></tr>
<tr class="memdesc:ga337b3c4a16154975e56efd930999fcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data mode settings.  <a href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga337b3c4a16154975e56efd930999fcb8">More...</a><br /></td></tr>
<tr class="separator:ga337b3c4a16154975e56efd930999fcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300f4e491cd61d8e974598e670ff39e8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga300f4e491cd61d8e974598e670ff39e8">UART_Echo_e</a> { <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga300f4e491cd61d8e974598e670ff39e8a2b286f182793d4a71bdf99409b9600dd">UART_ECHO_OFF</a> = 0, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga300f4e491cd61d8e974598e670ff39e8a6c4d8a2d4e30c22cf9fa45cd1bf79306">UART_ECHO_ON</a> = 1
 }</td></tr>
<tr class="memdesc:ga300f4e491cd61d8e974598e670ff39e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART echo settings.  <a href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga300f4e491cd61d8e974598e670ff39e8">More...</a><br /></td></tr>
<tr class="separator:ga300f4e491cd61d8e974598e670ff39e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93">UART_LEN_e</a> { <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga3d8a0f559cd6fd14ab9e1d7a0b6d5a93a27d04dd1fa818f764eb9b8e849feb7ff">UART_LEN_5</a> = 0, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga3d8a0f559cd6fd14ab9e1d7a0b6d5a93a5bfd5507335d394d826e560930ce2a12">UART_LEN_6</a> = 1, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga3d8a0f559cd6fd14ab9e1d7a0b6d5a93a2ac8467047f55cc1954388bf94c72e35">UART_LEN_7</a> = 2, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga3d8a0f559cd6fd14ab9e1d7a0b6d5a93a31abbaaeaa38a5c66fbe13bfc8ece221">UART_LEN_8</a> = 3
 }</td></tr>
<tr class="memdesc:ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data length settings.  <a href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93">More...</a><br /></td></tr>
<tr class="separator:ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354ada9bf4e549345820568ff9ad0ca7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga354ada9bf4e549345820568ff9ad0ca7">UART_STOP_e</a> { <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga354ada9bf4e549345820568ff9ad0ca7a9bfa599e95c5da9cfe5f964dab8a9c6c">UART_STOP_ONE</a> = 0, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga354ada9bf4e549345820568ff9ad0ca7a3f41137f3775e7d33fdb250471c0248e">UART_STOP_TWO</a> = 1
 }</td></tr>
<tr class="memdesc:ga354ada9bf4e549345820568ff9ad0ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit settings.  <a href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga354ada9bf4e549345820568ff9ad0ca7">More...</a><br /></td></tr>
<tr class="separator:ga354ada9bf4e549345820568ff9ad0ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5930832f38f32dacf8370542ba2f67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6c5930832f38f32dacf8370542ba2f67">UART_PAR_e</a> { <br />
&#160;&#160;<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga6c5930832f38f32dacf8370542ba2f67a469955a283c95f261990ad07043d5d2d">UART_PAR_NONE</a> = 0, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga6c5930832f38f32dacf8370542ba2f67a5405c8d842bffa2f76999eef9cee32c3">UART_PAR_EVEN</a> = 1, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga6c5930832f38f32dacf8370542ba2f67a498f72ae68542763da3072d3e3af6603">UART_PAR_ODD</a> = 2, 
<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga6c5930832f38f32dacf8370542ba2f67adfb9d17fa33753ea5550e757b323bd46">UART_PAR_ZERO</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga6c5930832f38f32dacf8370542ba2f67a7ab50a9a14f4c614e875fbab74911afa">UART_PAR_ONE</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:ga6c5930832f38f32dacf8370542ba2f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity type settings.  <a href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6c5930832f38f32dacf8370542ba2f67">More...</a><br /></td></tr>
<tr class="separator:ga6c5930832f38f32dacf8370542ba2f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga74da6620ba02549caeffff1ba1a12878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga74da6620ba02549caeffff1ba1a12878">UART_close</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> uartHnd)</td></tr>
<tr class="memdesc:ga74da6620ba02549caeffff1ba1a12878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to closes a given UART peripheral specified by the UART handle.  <a href="#ga74da6620ba02549caeffff1ba1a12878">More...</a><br /></td></tr>
<tr class="separator:ga74da6620ba02549caeffff1ba1a12878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff81a6e76deb098c5d3ebfcd758472b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gafff81a6e76deb098c5d3ebfcd758472b">UART_control</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> uartHnd, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:gafff81a6e76deb098c5d3ebfcd758472b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given UART_Handle.  <a href="#gafff81a6e76deb098c5d3ebfcd758472b">More...</a><br /></td></tr>
<tr class="separator:gafff81a6e76deb098c5d3ebfcd758472b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60a36f7295d704926120d22f806dcd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gab60a36f7295d704926120d22f806dcd1">UART_init</a> (void)</td></tr>
<tr class="memdesc:gab60a36f7295d704926120d22f806dcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initializes the UART module.  <a href="#gab60a36f7295d704926120d22f806dcd1">More...</a><br /></td></tr>
<tr class="separator:gab60a36f7295d704926120d22f806dcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49e4b22cd81c9435577ea35ead0c6a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49e4b22cd81c9435577ea35ead0c6a38">UART_open</a> (uint32_t idx, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6162c608c1a65055a43a924523415536">UART_Params</a> *uartParams)</td></tr>
<tr class="memdesc:ga49e4b22cd81c9435577ea35ead0c6a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate.  <a href="#ga49e4b22cd81c9435577ea35ead0c6a38">More...</a><br /></td></tr>
<tr class="separator:ga49e4b22cd81c9435577ea35ead0c6a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433972fdc2d8d45d2ecef607a61e4cff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga433972fdc2d8d45d2ecef607a61e4cff">UART_Params_init</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6162c608c1a65055a43a924523415536">UART_Params</a> *uartParams)</td></tr>
<tr class="memdesc:ga433972fdc2d8d45d2ecef607a61e4cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the UART_Params struct to its defaults.  <a href="#ga433972fdc2d8d45d2ecef607a61e4cff">More...</a><br /></td></tr>
<tr class="separator:ga433972fdc2d8d45d2ecef607a61e4cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb9e485ab29323a7df04c922dfc4c5fe"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gadb9e485ab29323a7df04c922dfc4c5fe">UART_write</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> uartHnd, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:gadb9e485ab29323a7df04c922dfc4c5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART.  <a href="#gadb9e485ab29323a7df04c922dfc4c5fe">More...</a><br /></td></tr>
<tr class="separator:gadb9e485ab29323a7df04c922dfc4c5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea4c4bb14ae6ef5c66cbdac5a4f5c221"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaea4c4bb14ae6ef5c66cbdac5a4f5c221">UART_writePolling</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> uartHnd, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:gaea4c4bb14ae6ef5c66cbdac5a4f5c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART.  <a href="#gaea4c4bb14ae6ef5c66cbdac5a4f5c221">More...</a><br /></td></tr>
<tr class="separator:gaea4c4bb14ae6ef5c66cbdac5a4f5c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga0482cd0ab9ee7e802c8e785a5754d16d">UART_writeCancel</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a UART_write function call.  <a href="#ga0482cd0ab9ee7e802c8e785a5754d16d">More...</a><br /></td></tr>
<tr class="separator:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5f16eaf4eff8add9e52911ab4b5df5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga8e5f16eaf4eff8add9e52911ab4b5df5">UART_read</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:ga8e5f16eaf4eff8add9e52911ab4b5df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that read data from a UART.  <a href="#ga8e5f16eaf4eff8add9e52911ab4b5df5">More...</a><br /></td></tr>
<tr class="separator:ga8e5f16eaf4eff8add9e52911ab4b5df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffab6273a151a89a8b4c3c2fc0846d0c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaffab6273a151a89a8b4c3c2fc0846d0c">UART_readPolling</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buffer, size_t size)</td></tr>
<tr class="memdesc:gaffab6273a151a89a8b4c3c2fc0846d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART.  <a href="#gaffab6273a151a89a8b4c3c2fc0846d0c">More...</a><br /></td></tr>
<tr class="separator:gaffab6273a151a89a8b4c3c2fc0846d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">UART_readCancel</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a UART_read function call.  <a href="#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">More...</a><br /></td></tr>
<tr class="separator:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59997fcf8ebb14c34797717d9dde8d6e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga59997fcf8ebb14c34797717d9dde8d6e">UART_read2</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *uartTrans)</td></tr>
<tr class="memdesc:ga59997fcf8ebb14c34797717d9dde8d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended function that read data from a UART.  <a href="#ga59997fcf8ebb14c34797717d9dde8d6e">More...</a><br /></td></tr>
<tr class="separator:ga59997fcf8ebb14c34797717d9dde8d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc38efd825942b5a43e937411aab890"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6fc38efd825942b5a43e937411aab890">UART_write2</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *uartTrans)</td></tr>
<tr class="memdesc:ga6fc38efd825942b5a43e937411aab890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended function that writes data to a UART.  <a href="#ga6fc38efd825942b5a43e937411aab890">More...</a><br /></td></tr>
<tr class="separator:ga6fc38efd825942b5a43e937411aab890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca30376be73cc071bfb8759a8a23e9b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaca30376be73cc071bfb8759a8a23e9b8">UART_transactionInit</a> (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *uartTrans)</td></tr>
<tr class="memdesc:gaca30376be73cc071bfb8759a8a23e9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the UART_Transaction struct to its defaults.  <a href="#gaca30376be73cc071bfb8759a8a23e9b8">More...</a><br /></td></tr>
<tr class="separator:gaca30376be73cc071bfb8759a8a23e9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UART driver interface </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5d43bd8997e9153ce790bc81467ec935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_Callback) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, void *buf, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the UART driver when used in <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga0d2a27a518c1a4474a556544acf86e74ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UART_Handle</td><td>UART_Handle</td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to read/write buffer</td></tr>
    <tr><td class="paramname">count</td><td>Number of elements read/written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga873e53d7c98e831152ca7186b7209cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UART_Callback2) (<a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> handle, <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *transaction)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback2 function used by the UART driver when used in <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gga0d2a27a518c1a4474a556544acf86e74ae0dbd9b5195e56c3c2aed10163523754">UART_MODE_CALLBACK</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UART_Handle</td><td>UART_Handle</td></tr>
    <tr><td class="paramname">transaction</td><td>A pointer to a UART_Transaction. All of the fields within transaction except <a class="el" href="struct_u_a_r_t___transaction__s.html#adf317d97733ffec98a56e27324d6ae3b">UART_Transaction.count</a> and <a class="el" href="struct_u_a_r_t___transaction__s.html#af6288b0ad7eb1e59972d1f923a36f2cb">UART_Transaction.status</a> are WO (write-only) unless otherwise noted in the driver implementations. If a transaction timeout or error has occured, <a class="el" href="struct_u_a_r_t___transaction__s.html#adf317d97733ffec98a56e27324d6ae3b">UART_Transaction.count</a> will contain the number of bytes that were transferred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3df8ab128966ece5c06a82213a1a7aac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga337b3c4a16154975e56efd930999fcb8">UART_DataMode_e</a>  <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga3df8ab128966ece5c06a82213a1a7aac">UART_DataMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data mode settings. </p>
<p>This enumeration defines the data mode for read and write. If the DataMode is text for write, write will add a return before a newline character. If the DataMode is text for a read, read will replace a return with a newline. This effectively treats all device line endings as LF and all host PC line endings as CRLF. </p>

</div>
</div>
<a class="anchor" id="gab8e11c6c8410167fd0ae53f151c2f917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga300f4e491cd61d8e974598e670ff39e8">UART_Echo_e</a>  <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gab8e11c6c8410167fd0ae53f151c2f917">UART_Echo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART echo settings. </p>
<p>This enumeration defines if the driver will echo data. </p>

</div>
</div>
<a class="anchor" id="gafafb90f891f1e14959d9ed45d7af1b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93">UART_LEN_e</a>  <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gafafb90f891f1e14959d9ed45d7af1b09">UART_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>

</div>
</div>
<a class="anchor" id="ga98d6ede39ae58d1e58cc1133843740be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga0d2a27a518c1a4474a556544acf86e74">UART_Mode_e</a>  <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga98d6ede39ae58d1e58cc1133843740be">UART_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART mode settings. </p>
<p>This enum defines the read and write modes for the configured UART. </p>

</div>
</div>
<a class="anchor" id="gac030bbb8f2bbf15cc97cc8d965cc76ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6c5930832f38f32dacf8370542ba2f67">UART_PAR_e</a>  <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac030bbb8f2bbf15cc97cc8d965cc76ca">UART_PAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>

</div>
</div>
<a class="anchor" id="gaa180fc9d177be8a1fbf44fc33a2bc73c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaf181cd5aa441af5f4e18ab6bc7212b94">UART_ReturnMode_e</a>  <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaa180fc9d177be8a1fbf44fc33a2bc73c">UART_ReturnMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for UART_read and UART_readPolling. UART_RETURN_FULL unblocks or performs a callback when the read buffer has been filled. UART_RETURN_NEWLINE unblocks or performs a callback whenever a newline character has been received. </p>

</div>
</div>
<a class="anchor" id="ga91040de76e05e47441f1112522bf69a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga354ada9bf4e549345820568ff9ad0ca7">UART_STOP_e</a>  <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga91040de76e05e47441f1112522bf69a6">UART_STOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga337b3c4a16154975e56efd930999fcb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga337b3c4a16154975e56efd930999fcb8">UART_DataMode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data mode settings. </p>
<p>This enumeration defines the data mode for read and write. If the DataMode is text for write, write will add a return before a newline character. If the DataMode is text for a read, read will replace a return with a newline. This effectively treats all device line endings as LF and all host PC line endings as CRLF. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga337b3c4a16154975e56efd930999fcb8aaa8edcbf6c236b0d86491ea1e7c9e4d8"></a>UART_DATA_BINARY&#160;</td><td class="fielddoc">
<p>Data is not processed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga337b3c4a16154975e56efd930999fcb8a87fdfb7ca981eab7f56c51380fd7094e"></a>UART_DATA_TEXT&#160;</td><td class="fielddoc">
<p>Data is processed according to above </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga300f4e491cd61d8e974598e670ff39e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga300f4e491cd61d8e974598e670ff39e8">UART_Echo_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART echo settings. </p>
<p>This enumeration defines if the driver will echo data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga300f4e491cd61d8e974598e670ff39e8a2b286f182793d4a71bdf99409b9600dd"></a>UART_ECHO_OFF&#160;</td><td class="fielddoc">
<p>Data is not echoed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga300f4e491cd61d8e974598e670ff39e8a6c4d8a2d4e30c22cf9fa45cd1bf79306"></a>UART_ECHO_ON&#160;</td><td class="fielddoc">
<p>Data is echoed </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga3d8a0f559cd6fd14ab9e1d7a0b6d5a93">UART_LEN_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga3d8a0f559cd6fd14ab9e1d7a0b6d5a93a27d04dd1fa818f764eb9b8e849feb7ff"></a>UART_LEN_5&#160;</td><td class="fielddoc">
<p>Data length is 5 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3d8a0f559cd6fd14ab9e1d7a0b6d5a93a5bfd5507335d394d826e560930ce2a12"></a>UART_LEN_6&#160;</td><td class="fielddoc">
<p>Data length is 6 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3d8a0f559cd6fd14ab9e1d7a0b6d5a93a2ac8467047f55cc1954388bf94c72e35"></a>UART_LEN_7&#160;</td><td class="fielddoc">
<p>Data length is 7 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3d8a0f559cd6fd14ab9e1d7a0b6d5a93a31abbaaeaa38a5c66fbe13bfc8ece221"></a>UART_LEN_8&#160;</td><td class="fielddoc">
<p>Data length is 8 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga0d2a27a518c1a4474a556544acf86e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga0d2a27a518c1a4474a556544acf86e74">UART_Mode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART mode settings. </p>
<p>This enum defines the read and write modes for the configured UART. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga0d2a27a518c1a4474a556544acf86e74ae6b6bd5d2d5df859ad6724e89e605ebf"></a>UART_MODE_BLOCKING&#160;</td><td class="fielddoc">
<p>Uses a semaphore to block while data is being sent. Context of the call must be a Task. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0d2a27a518c1a4474a556544acf86e74ae0dbd9b5195e56c3c2aed10163523754"></a>UART_MODE_CALLBACK&#160;</td><td class="fielddoc">
<p>Non-blocking and will return immediately. When the transfer by the Hwi is finished the configured callback function is called. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga6c5930832f38f32dacf8370542ba2f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6c5930832f38f32dacf8370542ba2f67">UART_PAR_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6c5930832f38f32dacf8370542ba2f67a469955a283c95f261990ad07043d5d2d"></a>UART_PAR_NONE&#160;</td><td class="fielddoc">
<p>No parity </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6c5930832f38f32dacf8370542ba2f67a5405c8d842bffa2f76999eef9cee32c3"></a>UART_PAR_EVEN&#160;</td><td class="fielddoc">
<p>Parity bit is even </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6c5930832f38f32dacf8370542ba2f67a498f72ae68542763da3072d3e3af6603"></a>UART_PAR_ODD&#160;</td><td class="fielddoc">
<p>Parity bit is odd </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6c5930832f38f32dacf8370542ba2f67adfb9d17fa33753ea5550e757b323bd46"></a>UART_PAR_ZERO&#160;</td><td class="fielddoc">
<p>Parity bit is always zero </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6c5930832f38f32dacf8370542ba2f67a7ab50a9a14f4c614e875fbab74911afa"></a>UART_PAR_ONE&#160;</td><td class="fielddoc">
<p>Parity bit is always one </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf181cd5aa441af5f4e18ab6bc7212b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gaf181cd5aa441af5f4e18ab6bc7212b94">UART_ReturnMode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for UART_read and UART_readPolling. UART_RETURN_FULL unblocks or performs a callback when the read buffer has been filled. UART_RETURN_NEWLINE unblocks or performs a callback whenever a newline character has been received. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf181cd5aa441af5f4e18ab6bc7212b94a50c07cbaf7518a0acd14137e801687e5"></a>UART_RETURN_FULL&#160;</td><td class="fielddoc">
<p>Unblock/callback when buffer is full. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf181cd5aa441af5f4e18ab6bc7212b94a3b8e419e0e12abf80b25f72d17745f76"></a>UART_RETURN_NEWLINE&#160;</td><td class="fielddoc">
<p>Unblock/callback when newline character is received. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga354ada9bf4e549345820568ff9ad0ca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga354ada9bf4e549345820568ff9ad0ca7">UART_STOP_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga354ada9bf4e549345820568ff9ad0ca7a9bfa599e95c5da9cfe5f964dab8a9c6c"></a>UART_STOP_ONE&#160;</td><td class="fielddoc">
<p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga354ada9bf4e549345820568ff9ad0ca7a3f41137f3775e7d33fdb250471c0248e"></a>UART_STOP_TWO&#160;</td><td class="fielddoc">
<p>Two stop bits </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga74da6620ba02549caeffff1ba1a12878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>uartHnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to closes a given UART peripheral specified by the UART handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate. ">UART_open()</a> had to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHnd</td><td>A UART_Handle returned from UART_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate. ">UART_open</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafff81a6e76deb098c5d3ebfcd758472b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>uartHnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a given UART_Handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate. ">UART_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHnd</td><td>A UART handle returned from <a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate. ">UART_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td>A command value defined by the driver specific implementation</td></tr>
    <tr><td class="paramname">arg</td><td>An optional argument that is accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga49e4b22cd81c9435577ea35ead0c6a38" title="Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate. ">UART_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab60a36f7295d704926120d22f806dcd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initializes the UART module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The UART controller needs to be powered up and clocked. The UART_config structure must exist and be persistent before this function can be called. This function must also be called before any other UART driver APIs. </dd></dl>

</div>
</div>
<a class="anchor" id="ga49e4b22cd81c9435577ea35ead0c6a38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a> UART_open </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6162c608c1a65055a43a924523415536">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>uartParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize a given UART peripheral specified by the particular index value. The parameter specifies which mode the UART will operate. </p>
<dl class="section pre"><dt>Precondition</dt><dd>UART controller has been initialized</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Logical peripheral number indexed into the HWAttrs table</td></tr>
    <tr><td class="paramname">uartParams</td><td>Pointer to an parameter block, if NULL it will use default values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UART_Handle on success or a NULL on an error or if it has been already opened</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga74da6620ba02549caeffff1ba1a12878" title="Function to closes a given UART peripheral specified by the UART handle. ">UART_close</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga433972fdc2d8d45d2ecef607a61e4cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga6162c608c1a65055a43a924523415536">UART_Params</a> *&#160;</td>
          <td class="paramname"><em>uartParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the UART_Params struct to its defaults. </p>
<p>Defaults values are: readMode = UART_MODE_BLOCKING; writeMode = UART_MODE_BLOCKING; readTimeout = BIOS_WAIT_FOREVER; writeTimeout = BIOS_WAIT_FOREVER; readCallback = NULL; writeCallback = NULL; readReturnMode = UART_RETURN_NEWLINE; writeDataMode = UART_DATA_TEXT; readDataMode = UART_DATA_TEXT; readEcho = UART_ECHO_ON; baudRate = 115200; stopBits = UART_STOP_ONE; parityType = UART_PAR_NONE;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartParams</td><td>Parameter structure to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e5f16eaf4eff8add9e52911ab4b5df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that read data from a UART. </p>
<p>This function initiates an operation to read data from a UART controller.</p>
<p>In UART_MODE_BLOCKING, UART_read will block task execution until all the data in buffer has been read.</p>
<p>In UART_MODE_CALLBACK, UART_read does not block task execution an calls a callback function specified by readCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an empty buffer in which data should be written to</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written into buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the UART, UART_ERROR on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59997fcf8ebb14c34797717d9dde8d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_read2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *&#160;</td>
          <td class="paramname"><em>uartTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended function that read data from a UART. </p>
<p>This function initiates an operation to read data from a UART controller.</p>
<p>In UART_MODE_BLOCKING, UART_read2 will block task execution until all the data in buffer has been read.</p>
<p>In UART_MODE_CALLBACK, UART_read2 does not block task execution an calls a callback function specified by readCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">uartTrans</td><td>A pointer to a UART_Transaction. All of the fields within transaction except <a class="el" href="struct_u_a_r_t___transaction__s.html#adf317d97733ffec98a56e27324d6ae3b">UART_Transaction.count</a> and <a class="el" href="struct_u_a_r_t___transaction__s.html#af6288b0ad7eb1e59972d1f923a36f2cb">UART_Transaction.status</a> are WO (write-only) unless otherwise noted in the driver implementations. If a transaction timeout or error has occured, <a class="el" href="struct_u_a_r_t___transaction__s.html#adf317d97733ffec98a56e27324d6ae3b">UART_Transaction.count</a> will contain the number of bytes that were transferred. In the callback mode, the application allocates transaction memory and UART driver owns the pointer unitil it is returned to the application via the callback function, thus the memory should not be allocated on the stack, and dynamic free must occur in the callback (not immediately after calling read2/write2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns UART_SUCCESS or UART_ERROR on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51ed7e94d5b409ca1fcb2d65c5a25c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_readCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a UART_read function call. </p>
<p>This function cancels an operation to read data from a UART controller when in UART_MODE_CALLBACK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaffab6273a151a89a8b4c3c2fc0846d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_readPolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads data from a UART. </p>
<p>This function initiates an operation to read data from a UART controller.</p>
<p>UART_readPolling will not return until size data was read to the UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an empty buffer in which data should be written to</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written into buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been read from the UART, UART_ERROR on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaca30376be73cc071bfb8759a8a23e9b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_transactionInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *&#160;</td>
          <td class="paramname"><em>uartTrans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the UART_Transaction struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartTrans</td><td>A pointer to a UART_Transaction to be initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uartTrans initialized with default values such as: uartTrans-&gt;buf = NULL; uartTrans-&gt;timeout = UART_WAIT_FOREVER; uartTrans-&gt;count = 0; uartTrans-&gt;status = UART_TRANSFER_STATUS_SUCCESS; </dd></dl>

</div>
</div>
<a class="anchor" id="gadb9e485ab29323a7df04c922dfc4c5fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>uartHnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART. </p>
<p>This function initiates an operation to write data to a UART controller.</p>
<p>In UART_MODE_BLOCKING, UART_write will block task execution until all the data in buffer has been written.</p>
<p>In UART_MODE_CALLBACK, UART_write does not block task execution an calls a callback function specified by writeCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHnd</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to buffer containing data to be written</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in buffer that should be written onto the UART.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the UART, UART_ERROR on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6fc38efd825942b5a43e937411aab890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_write2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#gac3374395b6401556fefbbd5b9fe4f80c">UART_Transaction</a> *&#160;</td>
          <td class="paramname"><em>uartTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended function that writes data to a UART. </p>
<p>This function initiates an operation to write data to a UART controller.</p>
<p>In UART_MODE_BLOCKING, UART_write will block task execution until all the data in buffer has been written.</p>
<p>In UART_MODE_CALLBACK, UART_write does not block task execution an calls a callback function specified by writeCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">uartTrans</td><td>A pointer to a UART_Transaction. All of the fields within transaction except <a class="el" href="struct_u_a_r_t___transaction__s.html#adf317d97733ffec98a56e27324d6ae3b">UART_Transaction.count</a> and <a class="el" href="struct_u_a_r_t___transaction__s.html#af6288b0ad7eb1e59972d1f923a36f2cb">UART_Transaction.status</a> are WO (write-only) unless otherwise noted in the driver implementations. If a transaction timeout or error has occured, <a class="el" href="struct_u_a_r_t___transaction__s.html#adf317d97733ffec98a56e27324d6ae3b">UART_Transaction.count</a> will contain the number of bytes that were transferred. In the callback mode, the application allocates transaction memory and UART driver owns the pointer unitil it is returned to the application via the callback function, thus the memory should not be allocated on the stack, and dynamic free must occur in the callback (not immediately after calling read2/write2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns UART_SUCCESS or UART_ERROR on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0482cd0ab9ee7e802c8e785a5754d16d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_writeCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that cancels a UART_write function call. </p>
<p>This function cancels an operation to write data to a UART controller when in UART_MODE_CALLBACK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A UART_Handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea4c4bb14ae6ef5c66cbdac5a4f5c221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UART_writePolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___u_a_r_t___a_p_i___m_o_d_u_l_e.html#ga9a2cb7a6a7cd3136a2299f155ebd0a36">UART_Handle</a>&#160;</td>
          <td class="paramname"><em>uartHnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes data to a UART. </p>
<p>This function initiates an operation to write data to a UART controller.</p>
<p>UART_write will not return until all the data was written to the UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHnd</td><td>A UART_Handle</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to buffer containing data to be written</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes in buffer that should be written onto the UART.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have been written to the UART, UART_ERROR on an error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
