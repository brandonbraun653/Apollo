<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Driver Function API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Driver Function API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga690aa798aa9b6bfb4a6c2db0bd074d70"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga690aa798aa9b6bfb4a6c2db0bd074d70">CUSBD_Probe</a> (const <a class="el" href="struct_c_u_s_b_d___config__s.html">CUSBD_Config</a> *config, <a class="el" href="struct_c_u_s_b_d___sys_req__s.html">CUSBD_SysReq</a> *sysReqCusbd)</td></tr>
<tr class="separator:ga690aa798aa9b6bfb4a6c2db0bd074d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b546f0ecbf7dc32471f5b8300c9402"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaf6b546f0ecbf7dc32471f5b8300c9402">CUSBD_Init</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, const <a class="el" href="struct_c_u_s_b_d___config__s.html">CUSBD_Config</a> *config, const <a class="el" href="struct_c_u_s_b_d___callbacks__s.html">CUSBD_Callbacks</a> *callbacks)</td></tr>
<tr class="separator:gaf6b546f0ecbf7dc32471f5b8300c9402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572204ff95b8c6e2ffda983fb1cd5ab5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga572204ff95b8c6e2ffda983fb1cd5ab5">CUSBD_Destroy</a> (const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD)</td></tr>
<tr class="separator:ga572204ff95b8c6e2ffda983fb1cd5ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8dfc03fa85a41fe403fdc513a71d27a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaa8dfc03fa85a41fe403fdc513a71d27a">CUSBD_Start</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD)</td></tr>
<tr class="separator:gaa8dfc03fa85a41fe403fdc513a71d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d41fb9ce00e1225d5f190525b01707"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga31d41fb9ce00e1225d5f190525b01707">CUSBD_Stop</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD)</td></tr>
<tr class="separator:ga31d41fb9ce00e1225d5f190525b01707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab314f1f42308bc40189eb51389ca3ec7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gab314f1f42308bc40189eb51389ca3ec7">CUSBD_Isr</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD)</td></tr>
<tr class="separator:gab314f1f42308bc40189eb51389ca3ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf741ad1b7123469dc17e287e1040afed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaf741ad1b7123469dc17e287e1040afed">CUSBD_EpEnable</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *ep, const uint8_t *desc)</td></tr>
<tr class="separator:gaf741ad1b7123469dc17e287e1040afed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0fea2b9270795067be8bb7b8e1cb99"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gada0fea2b9270795067be8bb7b8e1cb99">CUSBD_EpDisable</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *ep)</td></tr>
<tr class="separator:gada0fea2b9270795067be8bb7b8e1cb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6ada72aa914f54649c09767d5095ca"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaef6ada72aa914f54649c09767d5095ca">CUSBD_EpSetHalt</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *ep, uint8_t value)</td></tr>
<tr class="separator:gaef6ada72aa914f54649c09767d5095ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff95618fa88bd888762c24dd6ab3001"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gadff95618fa88bd888762c24dd6ab3001">CUSBD_EpSetWedge</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *ep)</td></tr>
<tr class="separator:gadff95618fa88bd888762c24dd6ab3001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aafb0f25d2de24f3318170762833d3c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga1aafb0f25d2de24f3318170762833d3c">CUSBD_EpFifoStatus</a> (const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *ep)</td></tr>
<tr class="separator:ga1aafb0f25d2de24f3318170762833d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a86b08caa0cd815d21e77259918fa1f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga8a86b08caa0cd815d21e77259918fa1f">CUSBD_EpFifoFlush</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *ep)</td></tr>
<tr class="separator:ga8a86b08caa0cd815d21e77259918fa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee624c58cff6bae45ecb1e020e3ebfeb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaee624c58cff6bae45ecb1e020e3ebfeb">CUSBD_ReqQueue</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *ep, <a class="el" href="struct_c_u_s_b_d___req__s.html">CUSBD_Req</a> *req)</td></tr>
<tr class="separator:gaee624c58cff6bae45ecb1e020e3ebfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbfbaa4f4c184fb154c9e04cb140b93f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gafbfbaa4f4c184fb154c9e04cb140b93f">CUSBD_ReqDequeue</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *ep, <a class="el" href="struct_c_u_s_b_d___req__s.html">CUSBD_Req</a> *req)</td></tr>
<tr class="separator:gafbfbaa4f4c184fb154c9e04cb140b93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4700ac4703f2263e19e742d01d5e8ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gab4700ac4703f2263e19e742d01d5e8ed">CUSBD_GetDevInstance</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, <a class="el" href="struct_c_u_s_b_d___dev__s.html">CUSBD_Dev</a> **dev)</td></tr>
<tr class="separator:gab4700ac4703f2263e19e742d01d5e8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52015c64e575d3b2e3e54baeb1952ace"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga52015c64e575d3b2e3e54baeb1952ace">CUSBD_DGetFrame</a> (<a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, uint32_t *numOfFrame)</td></tr>
<tr class="separator:ga52015c64e575d3b2e3e54baeb1952ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c60a053516b4dd08ccd745be6378d29"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga2c60a053516b4dd08ccd745be6378d29">CUSBD_DSetSelfpowered</a> (const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD)</td></tr>
<tr class="separator:ga2c60a053516b4dd08ccd745be6378d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0de78c85c280929a9000f6655a30967"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gac0de78c85c280929a9000f6655a30967">CUSBD_DClearSelfpowered</a> (const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD)</td></tr>
<tr class="separator:gac0de78c85c280929a9000f6655a30967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d7dcd2aa6ceb38a9fd0a529caa9c19"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gab6d7dcd2aa6ceb38a9fd0a529caa9c19">CUSBD_DGetConfigParams</a> (const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *pD, <a class="el" href="struct_c_h9___config_params__s.html">CH9_ConfigParams</a> *configParams)</td></tr>
<tr class="separator:gab6d7dcd2aa6ceb38a9fd0a529caa9c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef3793b87a808649ac56edffc8e96e5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga7ef3793b87a808649ac56edffc8e96e5">CUSBDMA_Probe</a> (const <a class="el" href="struct_c_u_s_b_d_m_a___config__s.html">CUSBDMA_Config</a> *config, <a class="el" href="struct_c_u_s_b_d_m_a___sys_req__s.html">CUSBDMA_SysReq</a> *sysReq)</td></tr>
<tr class="separator:ga7ef3793b87a808649ac56edffc8e96e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e973d65572e098851c945af7bbf6e5d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga4e973d65572e098851c945af7bbf6e5d">CUSBDMA_Init</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, const <a class="el" href="struct_c_u_s_b_d_m_a___config__s.html">CUSBDMA_Config</a> *config)</td></tr>
<tr class="separator:ga4e973d65572e098851c945af7bbf6e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacda51b20f36e31e1a5e790f035a35f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gabacda51b20f36e31e1a5e790f035a35f">CUSBDMA_Destroy</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD)</td></tr>
<tr class="separator:gabacda51b20f36e31e1a5e790f035a35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f4990472c1806f15a902a65a6874ad"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga92f4990472c1806f15a902a65a6874ad">CUSBDMA_ChannelAlloc</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> **channelPtr, <a class="el" href="struct_c_u_s_b_d_m_a___channel_params__s.html">CUSBDMA_ChannelParams</a> *channelParams)</td></tr>
<tr class="separator:ga92f4990472c1806f15a902a65a6874ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad933cd691689c290deaef05e946e2738"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gad933cd691689c290deaef05e946e2738">CUSBDMA_ChannelReset</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *channel)</td></tr>
<tr class="separator:gad933cd691689c290deaef05e946e2738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798f655c7b8510fbd907f3037961ad89"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga798f655c7b8510fbd907f3037961ad89">CUSBDMA_ChannelRelease</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *channel)</td></tr>
<tr class="separator:ga798f655c7b8510fbd907f3037961ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6178a861a6dc65fad5240dde8710b16"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gac6178a861a6dc65fad5240dde8710b16">CUSBDMA_ChannelProgram</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *channel, const <a class="el" href="struct_c_u_s_b_d_m_a___dma_transfer_param__s.html">CUSBDMA_DmaTransferParam</a> *params)</td></tr>
<tr class="separator:gac6178a861a6dc65fad5240dde8710b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e08f39e3850920922b883f2013709e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga9e08f39e3850920922b883f2013709e2">CUSBDMA_ChannelTrigger</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *channel)</td></tr>
<tr class="separator:ga9e08f39e3850920922b883f2013709e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb989cb71d5e1720724e02fd89075363"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gafb989cb71d5e1720724e02fd89075363">CUSBDMA_ChannelUpdateState</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *channel)</td></tr>
<tr class="separator:gafb989cb71d5e1720724e02fd89075363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad629dc3e841ff86e0d999dcc6e5924de"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gad629dc3e841ff86e0d999dcc6e5924de">CUSBDMA_ChannelSetMaxPktSz</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *channel, uint16_t maxPacketSize)</td></tr>
<tr class="separator:gad629dc3e841ff86e0d999dcc6e5924de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbbdf958993306c7ed2ee5ec0ac7eb4d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gacbbdf958993306c7ed2ee5ec0ac7eb4d">CUSBDMA_ChannelHandleStall</a> (<a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *channel, uint32_t value, uint32_t timeout)</td></tr>
<tr class="separator:gacbbdf958993306c7ed2ee5ec0ac7eb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301df274a4466d71e6b4f5460ce6d4d4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga301df274a4466d71e6b4f5460ce6d4d4">CUSBDMA_ChannelFreeHeadTrbChain</a> (const <a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *pD, <a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *channel)</td></tr>
<tr class="separator:ga301df274a4466d71e6b4f5460ce6d4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a558f2083b81ee5ef2df0ab59265b3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga50a558f2083b81ee5ef2df0ab59265b3">USB_SSP_DRD_Probe</a> (<a class="el" href="struct_u_s_b___s_s_p___d_r_d___sys_req__s.html">USB_SSP_DRD_SysReq</a> *sysReq)</td></tr>
<tr class="separator:ga50a558f2083b81ee5ef2df0ab59265b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1008d71abfa99ca4e0e08dbfd538c238"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga1008d71abfa99ca4e0e08dbfd538c238">USB_SSP_DRD_Init</a> (<a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData, const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___config__s.html">USB_SSP_DRD_Config</a> *config, const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___callbacks__s.html">USB_SSP_DRD_Callbacks</a> *callbacks)</td></tr>
<tr class="separator:ga1008d71abfa99ca4e0e08dbfd538c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9322f24c1ac6813e0326d90a50ac2c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga9f9322f24c1ac6813e0326d90a50ac2c">USB_SSP_DRD_Isr</a> (<a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData)</td></tr>
<tr class="separator:ga9f9322f24c1ac6813e0326d90a50ac2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd6eb5b4427663ad51e3859561b4ec0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaddd6eb5b4427663ad51e3859561b4ec0">USB_SSP_DRD_Start</a> (<a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData)</td></tr>
<tr class="separator:gaddd6eb5b4427663ad51e3859561b4ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2dd04a4cb14b6ce4fc7e5f3a3774b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga5a2dd04a4cb14b6ce4fc7e5f3a3774b5">USB_SSP_DRD_Stop</a> (const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData)</td></tr>
<tr class="separator:ga5a2dd04a4cb14b6ce4fc7e5f3a3774b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7528f8c57251dcb2a7307ff721fe1ef8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga7528f8c57251dcb2a7307ff721fe1ef8">USB_SSP_DRD_Destroy</a> (const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData)</td></tr>
<tr class="separator:ga7528f8c57251dcb2a7307ff721fe1ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a85531914acd15dd026c23b788080e5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga0a85531914acd15dd026c23b788080e5">USB_SSP_DRD_CheckIfReady</a> (<a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData, bool *isReady)</td></tr>
<tr class="separator:ga0a85531914acd15dd026c23b788080e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab69cc708ac88d4750c199b3585511d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga2ab69cc708ac88d4750c199b3585511d">USB_SSP_DRD_CheckStrapMode</a> (<a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData, <a class="el" href="group___data_structure.html#ga6ae5a8c2ad44594dc463c71e3b3ba776">USB_SSP_DRD_Mode</a> *strapMode)</td></tr>
<tr class="separator:ga2ab69cc708ac88d4750c199b3585511d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8383f60392516293234dd1d76c663ec9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga8383f60392516293234dd1d76c663ec9">USB_SSP_DRD_CheckOperationMode</a> (const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData, <a class="el" href="group___data_structure.html#ga6ae5a8c2ad44594dc463c71e3b3ba776">USB_SSP_DRD_Mode</a> *operationMode)</td></tr>
<tr class="separator:ga8383f60392516293234dd1d76c663ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46e5c5b3978369017ab995b7e95763c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gac46e5c5b3978369017ab995b7e95763c">USB_SSP_DRD_SetOperationMode</a> (<a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData, const <a class="el" href="group___data_structure.html#ga6ae5a8c2ad44594dc463c71e3b3ba776">USB_SSP_DRD_Mode</a> operationMode)</td></tr>
<tr class="separator:gac46e5c5b3978369017ab995b7e95763c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf191b5787d4ea165e9182438a75b343c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaf191b5787d4ea165e9182438a75b343c">USB_SSP_DRD_CheckIrq</a> (const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData, uint32_t *interruptVect)</td></tr>
<tr class="separator:gaf191b5787d4ea165e9182438a75b343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd30374ff5219d113b961bbd99c1652"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga0fd30374ff5219d113b961bbd99c1652">USB_SSP_DRD_ProcessIrq</a> (<a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *privData)</td></tr>
<tr class="separator:ga0fd30374ff5219d113b961bbd99c1652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2eaa6f759711ac3c43d18ac68e6e5d6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gad2eaa6f759711ac3c43d18ac68e6e5d6">USBSSP_TransferData</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epIndex, const uintptr_t buff, uint32_t size, <a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a> complete)</td></tr>
<tr class="separator:gad2eaa6f759711ac3c43d18ac68e6e5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53c5a2a434dffe27f2d0ef1774f2bd6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gab53c5a2a434dffe27f2d0ef1774f2bd6">USBSSP_TransferVectorData</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epIndex, const <a class="el" href="struct_u_s_b_s_s_p___xfer_buffer_desc__s.html">USBSSP_XferBufferDesc</a> *bufferDesc, uint32_t bufferCount, <a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a> complete)</td></tr>
<tr class="separator:gab53c5a2a434dffe27f2d0ef1774f2bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9533a40304dab6bf02b518d5749c83de"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga9533a40304dab6bf02b518d5749c83de">USBSSP_StopEndpoint</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t endpoint)</td></tr>
<tr class="separator:ga9533a40304dab6bf02b518d5749c83de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a2268c1e395189f1627bd86fde70a7e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga3a2268c1e395189f1627bd86fde70a7e">USBSSP_ResetEndpoint</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t endpoint)</td></tr>
<tr class="separator:ga3a2268c1e395189f1627bd86fde70a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4001a0f63cc2c8ef6b973794a0f69351"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga4001a0f63cc2c8ef6b973794a0f69351">USBSSP_ResetDevice</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res)</td></tr>
<tr class="separator:ga4001a0f63cc2c8ef6b973794a0f69351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e304c00c07e70c6814d2b9f816968e8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga0e304c00c07e70c6814d2b9f816968e8">USBSSP_Isr</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res)</td></tr>
<tr class="separator:ga0e304c00c07e70c6814d2b9f816968e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga725a3286e5782d9d6442d9d6af9d8e30"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga725a3286e5782d9d6442d9d6af9d8e30">USBSSP_SetMemRes</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, <a class="el" href="struct_u_s_b_s_s_p___xhci_resources_t__s.html">USBSSP_XhciResourcesT</a> *memRes)</td></tr>
<tr class="separator:ga725a3286e5782d9d6442d9d6af9d8e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8aae9f5e0bdb2accf5df8a6786f067"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga9e8aae9f5e0bdb2accf5df8a6786f067">USBSSP_Init</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uintptr_t base)</td></tr>
<tr class="separator:ga9e8aae9f5e0bdb2accf5df8a6786f067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b34f8b664bc3f17e132ec83bbed6c95"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga9b34f8b664bc3f17e132ec83bbed6c95">USBSSP_GetDescriptor</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t descType)</td></tr>
<tr class="separator:ga9b34f8b664bc3f17e132ec83bbed6c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa43281db522117dd9a1df11bac9af7bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaa43281db522117dd9a1df11bac9af7bd">USBSSP_SetAddress</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res)</td></tr>
<tr class="separator:gaa43281db522117dd9a1df11bac9af7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae60bec8a1235a85dd21b54c7d50a5263"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gae60bec8a1235a85dd21b54c7d50a5263">USBSSP_ResetRootHubPort</a> (const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res)</td></tr>
<tr class="separator:gae60bec8a1235a85dd21b54c7d50a5263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7761f5292b516039ba4503206124c1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga6c7761f5292b516039ba4503206124c1">USBSSP_IssueGenericCommand</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint32_t dword0, uint32_t dword1, uint32_t dword2, uint32_t dword3)</td></tr>
<tr class="separator:ga6c7761f5292b516039ba4503206124c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac93f1d4e99b0da7e5c5ea4cbab81f79d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gac93f1d4e99b0da7e5c5ea4cbab81f79d">USBSSP_EndpointSetFeature</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epIndex, uint8_t feature)</td></tr>
<tr class="separator:gac93f1d4e99b0da7e5c5ea4cbab81f79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga241d07022a646383bb50c54562a986a2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga241d07022a646383bb50c54562a986a2">USBSSP_SetConfiguration</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint32_t configValue)</td></tr>
<tr class="separator:ga241d07022a646383bb50c54562a986a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafdc597f1a50bade2a16bbd164cfbfcc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaafdc597f1a50bade2a16bbd164cfbfcc">USBSSP_ControlTransfer</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, const <a class="el" href="struct_c_h9___usb_setup__s.html">CH9_UsbSetup</a> *setup, const uint8_t *pdata)</td></tr>
<tr class="separator:gaafdc597f1a50bade2a16bbd164cfbfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb9b3287deca331317c6263691cc33c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaacb9b3287deca331317c6263691cc33c">USBSSP_NBControlTransfer</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, const <a class="el" href="struct_c_h9___usb_setup__s.html">CH9_UsbSetup</a> *setup, const uint8_t *pdata, <a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a> complete)</td></tr>
<tr class="separator:gaacb9b3287deca331317c6263691cc33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e46e8dd22b286bf2346a60534e7905"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaa2e46e8dd22b286bf2346a60534e7905">USBSSP_NoOpTest</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, <a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a> complete)</td></tr>
<tr class="separator:gaa2e46e8dd22b286bf2346a60534e7905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8409557e3deb37ad3b6dcac2f7662dae"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga8409557e3deb37ad3b6dcac2f7662dae">USBSSP_CalcFsLsEPIntrptInterval</a> (uint8_t bInterval)</td></tr>
<tr class="separator:ga8409557e3deb37ad3b6dcac2f7662dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c532b651a5066c8cd634baa81b13c42"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga3c532b651a5066c8cd634baa81b13c42">USBSSP_EnableSlot</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res)</td></tr>
<tr class="separator:ga3c532b651a5066c8cd634baa81b13c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528cb816dcc6ffbbf614927c273ed041"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga528cb816dcc6ffbbf614927c273ed041">USBSSP_DisableSlot</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res)</td></tr>
<tr class="separator:ga528cb816dcc6ffbbf614927c273ed041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd3cd59f20703e9539c93d4f43a1f52"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga0fd3cd59f20703e9539c93d4f43a1f52">USBSSP_EnableEndpoint</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, const uint8_t *desc)</td></tr>
<tr class="separator:ga0fd3cd59f20703e9539c93d4f43a1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3a477ca2074003f4a083a6c05b3cd1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga4e3a477ca2074003f4a083a6c05b3cd1">USBSSP_DisableEndpoint</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epAddress)</td></tr>
<tr class="separator:ga4e3a477ca2074003f4a083a6c05b3cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab50105a743f16e650448523b09f021e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gab50105a743f16e650448523b09f021e0">USBSSP_GetMicroFrameIndex</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint32_t *index)</td></tr>
<tr class="separator:gab50105a743f16e650448523b09f021e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72539a6c9ce4f619291aec57a962cdf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaf72539a6c9ce4f619291aec57a962cdf">USBSSP_SetEndpointExtraFlag</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epIndex, <a class="el" href="group___data_structure.html#ga4d601237425b481f37fbea05491be30c">USBSSP_ExtraFlagsEnumT</a> flags)</td></tr>
<tr class="separator:gaf72539a6c9ce4f619291aec57a962cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a04d4dd6209e1a8a7ba1765c060844"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga00a04d4dd6209e1a8a7ba1765c060844">USBSSP_CleanEndpointExtraFlag</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epIndex, <a class="el" href="group___data_structure.html#ga4d601237425b481f37fbea05491be30c">USBSSP_ExtraFlagsEnumT</a> flags)</td></tr>
<tr class="separator:ga00a04d4dd6209e1a8a7ba1765c060844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f755cc14a5a8223d4b96395144c4b4f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga4f755cc14a5a8223d4b96395144c4b4f">USBSSP_GetEndpointExtraFlag</a> (const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epIndex, uint8_t *flag)</td></tr>
<tr class="separator:ga4f755cc14a5a8223d4b96395144c4b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41529b9ad418ef9a3d4aaa76a133d80e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga41529b9ad418ef9a3d4aaa76a133d80e">USBSSP_SetFrameID</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epIndex, uint32_t frameID)</td></tr>
<tr class="separator:ga41529b9ad418ef9a3d4aaa76a133d80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06defbee1d8212685246e93d490b0ac4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga06defbee1d8212685246e93d490b0ac4">USBSSP_AddEventDataTRB</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t epIndex, uint32_t eventDataLo, uint32_t eventDataHi, uint32_t flags)</td></tr>
<tr class="separator:ga06defbee1d8212685246e93d490b0ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae688cd4e4cbb2913f4378c6151333651"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gae688cd4e4cbb2913f4378c6151333651">USBSSP_ForceHeader</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, const <a class="el" href="struct_u_s_b_s_s_p___force_hdr_params__s.html">USBSSP_ForceHdrParams</a> *trbDwords, <a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a> complete)</td></tr>
<tr class="separator:gae688cd4e4cbb2913f4378c6151333651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f938a6b20fae99020f93b7f0861b04"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga12f938a6b20fae99020f93b7f0861b04">USBSSP_SetPortOverrideReg</a> (const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint32_t regValue)</td></tr>
<tr class="separator:ga12f938a6b20fae99020f93b7f0861b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac83dea9fc36fd52d01324111b8f02bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaac83dea9fc36fd52d01324111b8f02bd">USBSSP_GetPortOverrideReg</a> (const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint32_t *regValue)</td></tr>
<tr class="separator:gaac83dea9fc36fd52d01324111b8f02bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bdef33ca9b2af8df3bbc42c14ea12ff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga0bdef33ca9b2af8df3bbc42c14ea12ff">USBSSP_SetPortControlReg</a> (const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t portId, <a class="el" href="group___data_structure.html#gaf6c56249f26c377af5b7e4567bd58a15">USBSSP_PortControlRegIdx</a> portRegIdx, uint32_t regValue)</td></tr>
<tr class="separator:ga0bdef33ca9b2af8df3bbc42c14ea12ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1798fecbdd2a5beaa5825efcc39609e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaa1798fecbdd2a5beaa5825efcc39609e">USBSSP_GetPortControlReg</a> (const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, uint8_t portId, <a class="el" href="group___data_structure.html#gaf6c56249f26c377af5b7e4567bd58a15">USBSSP_PortControlRegIdx</a> portRegIdx, uint32_t *regValue)</td></tr>
<tr class="separator:gaa1798fecbdd2a5beaa5825efcc39609e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93889db5af1f09ce04171e157ef75fb8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga93889db5af1f09ce04171e157ef75fb8">USBSSP_SaveState</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, <a class="el" href="struct_u_s_b_s_s_p___driver_context_t__s.html">USBSSP_DriverContextT</a> *drvContext)</td></tr>
<tr class="separator:ga93889db5af1f09ce04171e157ef75fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a1ab99b070cd08edf08a0fae7a0ed8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga83a1ab99b070cd08edf08a0fae7a0ed8">USBSSP_RestoreState</a> (<a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *res, const <a class="el" href="struct_u_s_b_s_s_p___driver_context_t__s.html">USBSSP_DriverContextT</a> *drvContext)</td></tr>
<tr class="separator:ga83a1ab99b070cd08edf08a0fae7a0ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Prototypes for the driver API functions. The user application can link statically to the necessary API functions and call them directly. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac0de78c85c280929a9000f6655a30967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_DClearSelfpowered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the device self powered feature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EOPNOTSUPP if feature is not supported </dd>
<dd>
CDN_EINVAL if pD is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga572204ff95b8c6e2ffda983fb1cd5ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_Destroy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the driver (automatically performs a stop) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if illegal/inconsistent values in 'config' </dd></dl>

</div>
</div>
<a class="anchor" id="gab6d7dcd2aa6ceb38a9fd0a529caa9c19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_DGetConfigParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_h9___config_params__s.html">CH9_ConfigParams</a> *&#160;</td>
          <td class="paramname"><em>configParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns configuration parameters: U1 exit latency and U2 exit latency Function useful only in Super Speed mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">configParams</td><td>pointer to CH9_ConfigParams structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if illegal/inconsistent values in 'config' </dd></dl>

</div>
</div>
<a class="anchor" id="ga52015c64e575d3b2e3e54baeb1952ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_DGetFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>numOfFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of frame. Some controllers have counter of SOF packets or ITP packets in the Super Speed case. Function returns value of this counter. This counter can be used for time measurement. Single FS frame is 1 ms measured, for HS and SS is 125us. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numOfFrame</td><td>returns number of USB frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EOPNOTSUPP if feature is not supported </dd>
<dd>
CDN_EINVAL if pD or numOfFrame is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c60a053516b4dd08ccd745be6378d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_DSetSelfpowered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the device self powered feature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EOPNOTSUPP if feature is not supported </dd>
<dd>
CDN_EINVAL if pD is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gada0fea2b9270795067be8bb7b8e1cb99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_EpDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable Endpoint. Functions unconfigures hardware endpoint. Endpoint will not respond to any host packets. This function should be called within SET_CONFIGURATION(configNum = 0) request context or on disconnect event. All queued requests on endpoint are completed with CDN_ECANCELED status. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint being unconfigured </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
CDN_EINVAL if pD or ep is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaf741ad1b7123469dc17e287e1040afed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_EpEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable Endpoint. This function should be called within SET_CONFIGURATION(configNum &gt; 0) request context. It configures required hardware controller endpoint with parameters given in desc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint being configured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>endpoint descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
CDN_EINVAL if pD, ep or desc is NULL or desc is not a endpoint descriptor </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a86b08caa0cd815d21e77259918fa1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_EpFifoFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush hardware endpoint FIFO. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint which FIFO is to be flushed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1aafb0f25d2de24f3318170762833d3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_EpFifoStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of bytes in hardware endpoint FIFO. Function useful in application where exact number of data bytes is required. In some situation software higher layers must be aware of number of data bytes issued but not transfered by hardware because of aborted transfers, for example on disconnect event. * </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint which status is to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes in hardware endpoint FIFO </dd>
<dd>
CDN_EINVAL if pD or ep is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaef6ada72aa914f54649c09767d5095ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_EpSetHalt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set halt or clear halt state on endpoint. When setting halt, device will respond with STALL packet to each host packet. When clearing halt, endpoint returns to normal operating. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint being setting or clearing halt state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>if 1 sets halt, if 0 clears halt on endpoint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
CDN_EPERM if endpoint is disabled (has not been configured yet) </dd>
<dd>
CDN_EINVAL if pD or ep is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gadff95618fa88bd888762c24dd6ab3001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_EpSetWedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set halt on endpoint. Function sets endpoint to permanent halt state. State can not be changed even with epSetHalt(pD, ep, 0) function. Endpoint returns automatically to its normal state on disconnect event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint being setting halt state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
CDN_EPERM if endpoint is disabled (has not been configured yet) </dd>
<dd>
CDN_EINVAL if pD or ep is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gab4700ac4703f2263e19e742d01d5e8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CUSBD_GetDevInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___dev__s.html">CUSBD_Dev</a> **&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns pointer to CUSBD object. CUSBD object is a logical representation of USB device. CUSBD contains endpoint collection accessed through epList field. Endpoints collection is organized as double linked list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev</td><td>returns pointer to CUSBD instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf6b546f0ecbf7dc32471f5b8300c9402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___config__s.html">CUSBD_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___callbacks__s.html">CUSBD_Callbacks</a> *&#160;</td>
          <td class="paramname"><em>callbacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the driver instance and state, configure the USB device as specified in the 'config' settings, initialize locks used by the driver. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">config</td><td>specifies driver/hardware configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callbacks</td><td>client-supplied callback functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_ENOTSUP if hardware has an inconsistent configuration or doesn't support feature(s) required by 'config' parameters </dd>
<dd>
CDN_ENOENT if insufficient locks were available (i.e. something allocated locks between probe and init) </dd>
<dd>
CDN_EIO if driver encountered an error accessing hardware </dd>
<dd>
CDN_EINVAL if illegal/inconsistent values in 'config' </dd></dl>

</div>
</div>
<a class="anchor" id="gab314f1f42308bc40189eb51389ca3ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_Isr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Driver ISR. Platform-specific code is responsible for ensuring this gets called when the corresponding hardware's interrupt is asserted. Registering the ISR should be done after calling init, and before calling start. The driver's ISR will not attempt to lock any locks, but will perform client callbacks. If the client wishes to defer processing to non-interrupt time, it is responsible for doing so. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga690aa798aa9b6bfb4a6c2db0bd074d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_Probe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___config__s.html">CUSBD_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___sys_req__s.html">CUSBD_SysReq</a> *&#160;</td>
          <td class="paramname"><em>sysReqCusbd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the private memory size required by the driver </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>driver/hardware configuration required </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sysReqCusbd</td><td>returns the size of memory allocations required </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (requirements structure filled) </dd>
<dd>
CDN_ENOTSUP if configuration cannot be supported due to driver/hardware constraints </dd></dl>

</div>
</div>
<a class="anchor" id="gafbfbaa4f4c184fb154c9e04cb140b93f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_ReqDequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___req__s.html">CUSBD_Req</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequeues IN/OUT transfer request from an endpoint. Function completes all queued request with CDN_ECANCELED status. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint associated with the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>request being dequeued </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
CDN_EINVAL if pD or ep is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaee624c58cff6bae45ecb1e020e3ebfeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_ReqQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d___ep__s.html">CUSBD_Ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___req__s.html">CUSBD_Req</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Submits IN/OUT transfer request to an endpoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint associated with the request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>request being submitted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
CDN_EPROTO only on default endpoint if endpoint is not in data stage phase </dd>
<dd>
CDN_EPERM if endpoint is not enabled </dd>
<dd>
CDN_EINVAL if pD, ep, or req is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8dfc03fa85a41fe403fdc513a71d27a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the USB driver. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if illegal/inconsistent values in 'config' </dd></dl>

</div>
</div>
<a class="anchor" id="ga31d41fb9ce00e1225d5f190525b01707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBD_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d___private_data__s.html">CUSBD_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop the driver. This should disable the hardware, including its interrupt at the source, and make a best-effort to cancel any pending transactions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if any input parameter is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga92f4990472c1806f15a902a65a6874ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> **&#160;</td>
          <td class="paramname"><em>channelPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___channel_params__s.html">CUSBDMA_ChannelParams</a> *&#160;</td>
          <td class="paramname"><em>channelParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocation the DMA channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">channelPtr</td><td>address of channel pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelParams</td><td>Channel parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga301df274a4466d71e6b4f5460ce6d4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelFreeHeadTrbChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the head(oldest) TRB chain descriptor for this channel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>pointer to DMA channel whose descriptor needs to be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd></dl>

</div>
</div>
<a class="anchor" id="gacbbdf958993306c7ed2ee5ec0ac7eb4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelHandleStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set or Clear channel stall </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>pointer to DMA channel whose stall state is handled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Clear stall if 0, else set stall </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout for waiting for flush operation while stalling </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on successful trigger or if the DMA is already active </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd></dl>

</div>
</div>
<a class="anchor" id="gac6178a861a6dc65fad5240dde8710b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d_m_a___dma_transfer_param__s.html">CUSBDMA_DmaTransferParam</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares transfer and starts it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>channel pointer to DMA channel for which transfer will be started </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>transfer parameters container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd>
<dd>
CDN_ENOMEM if DMA channel has no free memory for TRB </dd></dl>

</div>
</div>
<a class="anchor" id="ga798f655c7b8510fbd907f3037961ad89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the DMA channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>channel pointer to DMA channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd></dl>

</div>
</div>
<a class="anchor" id="gad933cd691689c290deaef05e946e2738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the DMA channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>channel pointer to DMA channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd>
<dd>
CDN_EPERM if the DMA is active and channel cannot be reset </dd></dl>

</div>
</div>
<a class="anchor" id="gad629dc3e841ff86e0d999dcc6e5924de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelSetMaxPktSz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxPacketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the max packet size for a channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>pointer to DMA channel whose state needs to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPacketSize</td><td>Value of max packet size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on successful successful update of max packet size </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e08f39e3850920922b883f2013709e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triggers DMA transfer for given DMA channel if TRBs are queued </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>pointer to DMA channel which needs to be triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on successful trigger or if the DMA is already active </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd>
<dd>
CDN_ENOTSUP if TRBs are not queued </dd></dl>

</div>
</div>
<a class="anchor" id="gafb989cb71d5e1720724e02fd89075363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_ChannelUpdateState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_channel__s.html">CUSBDMA_DmaChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the data transfer status of a channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>pointer to DMA channel whose state needs to be updated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on successful trigger or if the DMA is already active </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd></dl>

</div>
</div>
<a class="anchor" id="gabacda51b20f36e31e1a5e790f035a35f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the driver (automatically performs a stop). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4e973d65572e098851c945af7bbf6e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___dma_controller__s.html">CUSBDMA_DmaController</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d_m_a___config__s.html">CUSBDMA_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the driver instance and state, configure the USB device as specified in the 'config' settings, initialize locks used by the driver. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>driver state info specific to this instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>specifies driver/hardware configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd>
<dd>
CDN_ENOTSUP if configuration cannot be supported due to driver/hardware constraints </dd>
<dd>
CDN_EIO if driver encountered an error accessing hardware </dd>
<dd>
CDN_ENOENT insufficient locks were available (i.e. something allocated locks between probe and init) </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ef3793b87a808649ac56edffc8e96e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CUSBDMA_Probe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_u_s_b_d_m_a___config__s.html">CUSBDMA_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_s_b_d_m_a___sys_req__s.html">CUSBDMA_SysReq</a> *&#160;</td>
          <td class="paramname"><em>sysReq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the private memory size required by the driver. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>driver/hardware configuration required </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sysReq</td><td>sysReq returns the size of memory allocations required </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if function parameters are not valid </dd>
<dd>
CDN_ENOTSUP if configuration cannot be supported due to driver/hardware constraints </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a85531914acd15dd026c23b788080e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_CheckIfReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isReady</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if controller is ready. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isReady</td><td>Will tell if controller is ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="gaf191b5787d4ea165e9182438a75b343c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_CheckIrq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>interruptVect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if there is an unhndled interrupt pending. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">interruptVect</td><td>Interrupt Vector value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga8383f60392516293234dd1d76c663ec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_CheckOperationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga6ae5a8c2ad44594dc463c71e3b3ba776">USB_SSP_DRD_Mode</a> *&#160;</td>
          <td class="paramname"><em>operationMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks current operation mode of controller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">operationMode</td><td>Will tell operation mode of controller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ab69cc708ac88d4750c199b3585511d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_CheckStrapMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga6ae5a8c2ad44594dc463c71e3b3ba776">USB_SSP_DRD_Mode</a> *&#160;</td>
          <td class="paramname"><em>strapMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks strap mode of controller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">strapMode</td><td>Will tell how controller is strapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga7528f8c57251dcb2a7307ff721fe1ef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_Destroy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This performs an automatic stop and then de-initializes the driver. The client may not make further requests on this instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga1008d71abfa99ca4e0e08dbfd538c238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___config__s.html">USB_SSP_DRD_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___callbacks__s.html">USB_SSP_DRD_Callbacks</a> *&#160;</td>
          <td class="paramname"><em>callbacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiates the USB_SSP_DRD Core Driver, given the required blocks of memory (this includes initializing the instance and the underlying hardware). If a client configuration is required (likely to always be true), it is passed in also. Returns an instance pointer, which the client must maintain and pass to all other driver functions. (except probe). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Specifies driver/hardware configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callbacks</td><td>Event Handlers and Callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK On success </dd>
<dd>
CDN_EINVAL If illegal/inconsistent values in 'config' doesn't support feature(s) required by 'config' parameters. </dd>
<dd>
CDN_EIO if operation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f9322f24c1ac6813e0326d90a50ac2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_Isr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB_SSP_DRD Core Driver's ISR. Platform-specific code is responsible for ensuring this gets called when the corresponding hardware's interrupt is asserted. Registering the ISR should be done after calling init, and before calling start. The driver's ISR will not attempt to lock any locks, but will perform client callbacks. If the client wishes to defer processing to non- interrupt time, it is responsible for doing so. This function must not be called after calling destroy and releasing private data memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object filled by init. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga50a558f2083b81ee5ef2df0ab59265b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_Probe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___s_s_p___d_r_d___sys_req__s.html">USB_SSP_DRD_SysReq</a> *&#160;</td>
          <td class="paramname"><em>sysReq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the memory requirements for a driver instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sysReq</td><td>Returns the memory requirements for given configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK On success. </dd>
<dd>
CDN_EINVAL If config contains invalid values or not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0fd30374ff5219d113b961bbd99c1652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_ProcessIrq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will process an interrupt that is pending. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="gac46e5c5b3978369017ab995b7e95763c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_SetOperationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga6ae5a8c2ad44594dc463c71e3b3ba776">USB_SSP_DRD_Mode</a>&#160;</td>
          <td class="paramname"><em>operationMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets operation mode of controller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operationMode</td><td>Mode of operation that should be set for controller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="gaddd6eb5b4427663ad51e3859561b4ec0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the USB_SSP_DRD driver, enabling interrupts. This is called after the client has successfully initialized the driver and hooked the driver's ISR (the isr member of this struct) to the IRQ. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a2dd04a4cb14b6ce4fc7e5f3a3774b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USB_SSP_DRD_Stop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b___s_s_p___d_r_d___priv_data__s.html">USB_SSP_DRD_PrivData</a> *&#160;</td>
          <td class="paramname"><em>privData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The client may call this to disable the hardware (disabling its IRQ at the source and disconnecting it if applicable). Also, a best- effort is made to cancel any pending transactions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">privData</td><td>Pointer to driver's private data object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EIO if operation failed </dd>
<dd>
CDN_EINVAL if input parameters are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga06defbee1d8212685246e93d490b0ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_AddEventDataTRB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventDataLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventDataHi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add event data TRB </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epIndex</td><td>endpoint index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventDataLo</td><td>event data Low </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventDataHi</td><td>event data High </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value TBC </dd></dl>

</div>
</div>
<a class="anchor" id="ga8409557e3deb37ad3b6dcac2f7662dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBSSP_CalcFsLsEPIntrptInterval </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bInterval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate full/low speed endpoint interval based on bInterval See xHCI spec Section 6.2.3.6 for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bInterval</td><td>bInterval </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value valid endpoint contxt interval value </dd></dl>

</div>
</div>
<a class="anchor" id="ga00a04d4dd6209e1a8a7ba1765c060844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_CleanEndpointExtraFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga4d601237425b481f37fbea05491be30c">USBSSP_ExtraFlagsEnumT</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>clean endpoint extra flag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epIndex</td><td>end point index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Endpoint Extra Flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="gaafdc597f1a50bade2a16bbd164cfbfcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_ControlTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_h9___usb_setup__s.html">CH9_UsbSetup</a> *&#160;</td>
          <td class="paramname"><em>setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function executes control transfer. Information about transfer like: data direction, data length, wIndex, wValue etc. are passed in 'setup' parameter. This is a blocking function. This function should not be called from an interrupt context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setup</td><td>Keeps setup packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pdata</td><td>Pointer for data to send/receive $RANGE $NULLABLE $ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
complete_code XHCI transfer complete status code* </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e3a477ca2074003f4a083a6c05b3cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_DisableEndpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable endpoint. Function used in device context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epAddress</td><td>address of endpoint to be disabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL when driver's settings doesn't suit to native platform settings </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga528cb816dcc6ffbbf614927c273ed041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_DisableSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function disables slot of connected device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga0fd3cd59f20703e9539c93d4f43a1f52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_EnableEndpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable endpoint. Function used in device context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>pointer to endpoint descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL when driver's settings doesn't suit to native platform settings </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c532b651a5066c8cd634baa81b13c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_EnableSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function enables slot for new connected device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="gac93f1d4e99b0da7e5c5ea4cbab81f79d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_EndpointSetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set feature on device's endpoint. Functions sends setup requested to device with set/cleared endpoint feature </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epIndex</td><td>Index of endpoint to set/clear feature on $RANGE $FROM USBSSP_EP_CONT_OFFSET $TO USBSSP_EP_CONT_MAX $ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feature</td><td>When 1 sets stall, when 0 clears stall </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
complete_code XHCI transfer complete status code </dd></dl>

</div>
</div>
<a class="anchor" id="gae688cd4e4cbb2913f4378c6151333651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_ForceHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___force_hdr_params__s.html">USBSSP_ForceHdrParams</a> *&#160;</td>
          <td class="paramname"><em>trbDwords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a>&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force header </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trbDwords</td><td>trb words </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete</td><td>complete callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b34f8b664bc3f17e132ec83bbed6c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_GetDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>descType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get descriptor. Function gets descriptor from connected device, used in host mode and stores it in internal res-&gt;ep0Buff buffer. Maximal descriptor length is limited to 255. Function is blocking type and must not be called from interrupt context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descType</td><td>Type of descriptor to get (CH9_USB_DT_DEVICE, CH9_USB_DT_CONFIGURATION,...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
complete_code XHCI transfer complete status code </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f755cc14a5a8223d4b96395144c4b4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_GetEndpointExtraFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get endpoint extra flag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epIndex</td><td>endpoint index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>Endpoint Extra Flag returned by pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab50105a743f16e650448523b09f021e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_GetMicroFrameIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get actual frame number. Function returns actual frame number on USB bus. Remember that maximal frame number can be 0x7FF. Next frame increments returned value from 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>driver resources </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>Micro Frame Index returned by function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1798fecbdd2a5beaa5825efcc39609e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_GetPortControlReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>portId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#gaf6c56249f26c377af5b7e4567bd58a15">USBSSP_PortControlRegIdx</a>&#160;</td>
          <td class="paramname"><em>portRegIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>regValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get port control register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">portId</td><td>port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">portRegIdx</td><td>port control register ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">regValue</td><td>Register value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaac83dea9fc36fd52d01324111b8f02bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_GetPortOverrideReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>regValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get port override register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">regValue</td><td>Register value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e8aae9f5e0bdb2accf5df8a6786f067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialization of USBSSP_DriverResourcesT object. USBSSP_DriverResourcesT object keeps all resources required by USBSSP controller. It represents USBSSP hardware controller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Physical address of USBSSP controller where is mapped in system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL when driver's settings doesn't suit to native platform settings </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e304c00c07e70c6814d2b9f816968e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_Isr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handling of USBSSP controller interrupt. Function is called from USBSSP interrupt context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c7761f5292b516039ba4503206124c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_IssueGenericCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dword0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dword1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dword2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dword3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue generic command to SSP controller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dword0</td><td>word 0 of command </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dword1</td><td>word 1 of command </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dword2</td><td>word 2 of command </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dword3</td><td>word 3 of command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="gaacb9b3287deca331317c6263691cc33c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_NBControlTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_h9___usb_setup__s.html">CH9_UsbSetup</a> *&#160;</td>
          <td class="paramname"><em>setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a>&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No blocking control transfer. Function executes control transfer. Information about transfer like: data direction, data length, wIndex, wValue etc. are passed in 'setup' parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setup</td><td>Keeps setup packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pdata</td><td>Pointer for data to send/receive $RANGE $NULLABLE $ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete</td><td>Complete callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2e46e8dd22b286bf2346a60534e7905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_NoOpTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a>&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No Operation test. Function used for testing purposes: NO_OP_COMMAND is send to USBSSP controller. When event ring receives NO_OP_COMMAND complete it calls complete callback </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete</td><td>Callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL when driver's settings doesn't suit to native platform settings </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga4001a0f63cc2c8ef6b973794a0f69351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_ResetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset of connected device. Function sends RESET_DEVICE_COMMAND to USBSSP controller in order to issue reset state on USB bus. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL when driver's settings doesn't suit to native platform settings </dd>
<dd>
CDN_EOK selected endpoint is within available endpoint range </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a2268c1e395189f1627bd86fde70a7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_ResetEndpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Endpoint reset. Function sends RESET_ENDPOINT_COMMAND to USBSSP controller </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Index of endpoint to reset $RANGE $FROM USBSSP_EP0_CONT_OFFSET $TO USBSSP_EP_CONT_MAX $ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL when driver's settings doesn't suit to native platform settings </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="gae60bec8a1235a85dd21b54c7d50a5263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_ResetRootHubPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset port. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga83a1ab99b070cd08edf08a0fae7a0ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_RestoreState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___driver_context_t__s.html">USBSSP_DriverContextT</a> *&#160;</td>
          <td class="paramname"><em>drvContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restore state and start xHC </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drvContext</td><td>Pointer to driver context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga93889db5af1f09ce04171e157ef75fb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_SaveState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_context_t__s.html">USBSSP_DriverContextT</a> *&#160;</td>
          <td class="paramname"><em>drvContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save state and stop xHC </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drvContext</td><td>Pointer to driver context struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa43281db522117dd9a1df11bac9af7bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_SetAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set address. Function executes set address request on connected device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga241d07022a646383bb50c54562a986a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_SetConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>configValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set configuration. Function configures USBSSP controller as well as device connected to this USBSSP controller. This is a blocking function. This function must not be called from an interrupt context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configValue</td><td>USB device's configuration selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
complete_code XHCI transfer complete status code </dd></dl>

</div>
</div>
<a class="anchor" id="gaf72539a6c9ce4f619291aec57a962cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_SetEndpointExtraFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga4d601237425b481f37fbea05491be30c">USBSSP_ExtraFlagsEnumT</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set end point extra flag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epIndex</td><td>endpoint index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Endpoint Extra Flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga41529b9ad418ef9a3d4aaa76a133d80e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_SetFrameID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frameID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set Frame ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epIndex</td><td>endpoint index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameID</td><td>Frame ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL Invalid Input parameters </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga725a3286e5782d9d6442d9d6af9d8e30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_SetMemRes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___xhci_resources_t__s.html">USBSSP_XhciResourcesT</a> *&#160;</td>
          <td class="paramname"><em>memRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function sets memory resources used by driver. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memRes</td><td>User defined memory resources. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL when driver's settings doesn't suit to native platform settings </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bdef33ca9b2af8df3bbc42c14ea12ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_SetPortControlReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>portId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#gaf6c56249f26c377af5b7e4567bd58a15">USBSSP_PortControlRegIdx</a>&#160;</td>
          <td class="paramname"><em>portRegIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set port control register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">portId</td><td>port ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">portRegIdx</td><td>port control register ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValue</td><td>Register value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12f938a6b20fae99020f93b7f0861b04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_SetPortOverrideReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set port override register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValue</td><td>Register value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9533a40304dab6bf02b518d5749c83de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_StopEndpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop endpoint. Function sends STOP_ENDPOINT_COMMAND command to USBSSP controller </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Index of endpoint to stop $RANGE $FROM USBSSP_EP0_CONT_OFFSET $TO USBSSP_EP_CONT_MAX $ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL when driver's settings doesn't suit to native platform settings </dd>
<dd>
CDN_EOK if no errors </dd></dl>

</div>
</div>
<a class="anchor" id="gad2eaa6f759711ac3c43d18ac68e6e5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_TransferData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uintptr_t&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a>&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer data on given endpoint. This function is non-blocking type. The XHCI operation result should be checked in complete callback function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epIndex</td><td>index of endpoint according to xhci spec e.g for ep1out epIndex=2, for ep1in epIndex=3, for ep2out epIndex=4 end so on $RANGE $FROM USBSSP_EP_CONT_OFFSET $TO USBSSP_EP_CONT_MAX $ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>Buffer for data to send or to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of data in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete</td><td>pointer to function which will be returned in callback in input parameter, can be set to NULL when no extra parameter used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL if selected endpoint index is out of available range </dd>
<dd>
CDN_EOK if selected endpoint is within available endpoint range </dd></dl>

</div>
</div>
<a class="anchor" id="gab53c5a2a434dffe27f2d0ef1774f2bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t USBSSP_TransferVectorData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_s_b_s_s_p___driver_resources_t__s.html">USBSSP_DriverResourcesT</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>epIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_u_s_b_s_s_p___xfer_buffer_desc__s.html">USBSSP_XferBufferDesc</a> *&#160;</td>
          <td class="paramname"><em>bufferDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga1fadbc0d367a6f884d243e0987f0b470">USBSSP_Complete</a>&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gather and Transfer Vector data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>Driver resources </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epIndex</td><td>index of endpoint according to xhci spec e.g for ep1out epIndex=2, for ep1in epIndex=3, for ep2out epIndex=4 end so on $RANGE $FROM USBSSP_EP_CONT_OFFSET $TO USBSSP_EP_CONT_MAX $ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferDesc</td><td>Pointer to an array of buffer descriptors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferCount</td><td>Buffer descriptor count </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete</td><td>pointer to function which will be returned in callback in input parameter, can be set to NULL when no extra parameter used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EINVAL if selected endpoint index is out of available range </dd>
<dd>
CDN_EOK if selected endpoint is within available endpoint range </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
