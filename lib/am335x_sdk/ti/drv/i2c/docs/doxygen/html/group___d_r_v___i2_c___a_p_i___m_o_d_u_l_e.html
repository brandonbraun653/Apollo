<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>I2C Driver API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C Driver API<div class="ingroups"><a class="el" href="group___d_r_v___i2_c___m_o_d_u_l_e.html">I2C Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_i2_c_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html">I2C.h</a></td></tr>
<tr class="memdesc:_i2_c_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C driver interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___params__s.html">I2C_Params_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Parameters.  <a href="struct_i2_c___params__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___fxn_table__s.html">I2C_FxnTable_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a I2C function table that contains the required set of functions to control a specific I2C driver implementation.  <a href="struct_i2_c___fxn_table__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___config__s.html">I2C_Config_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Global configuration.  <a href="struct_i2_c___config__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga760ec0a6fdb876ccc67b6f06301d53ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga760ec0a6fdb876ccc67b6f06301d53ec">I2C_CMD_RESERVED</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ga760ec0a6fdb876ccc67b6f06301d53ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac180b6227ed3fdbeaee729c7142be292"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gac180b6227ed3fdbeaee729c7142be292">I2C_CMD_PROBE</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:gac180b6227ed3fdbeaee729c7142be292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b3af5c8efc2035485a769e056451a4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga3b3af5c8efc2035485a769e056451a4a">I2C_CMD_SET_BUS_FREQUENCY</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ga3b3af5c8efc2035485a769e056451a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb5c8eb4dfa903256744e611350d166"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga5eb5c8eb4dfa903256744e611350d166">I2C_CMD_RECOVER_BUS</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:ga5eb5c8eb4dfa903256744e611350d166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514007e93fddd909e8a318ed6d4dd5c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga514007e93fddd909e8a318ed6d4dd5c5">I2C_CMD_SMBUS_TYPE</a>&#160;&#160;&#160;(3U)</td></tr>
<tr class="separator:ga514007e93fddd909e8a318ed6d4dd5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd04572fe349d087c2547501cbc7e0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gacfd04572fe349d087c2547501cbc7e0a">I2C_STATUS_RESERVED</a>&#160;&#160;&#160;(-((int32_t)32))</td></tr>
<tr class="separator:gacfd04572fe349d087c2547501cbc7e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaa0bcf3acd26ac82bd8ff91daba2c78c4">I2C_STATUS_SUCCESS</a>&#160;&#160;&#160;((int32_t)(0))</td></tr>
<tr class="memdesc:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a>.  <a href="#gaa0bcf3acd26ac82bd8ff91daba2c78c4">More...</a><br /></td></tr>
<tr class="separator:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga7323fe57c39c46d0da9910e17f5f0b06">I2C_STATUS_ERROR</a>&#160;&#160;&#160;(-((int32_t)1))</td></tr>
<tr class="memdesc:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a>.  <a href="#ga7323fe57c39c46d0da9910e17f5f0b06">More...</a><br /></td></tr>
<tr class="separator:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c31c9869ed2441789205d9e5967d66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga11c31c9869ed2441789205d9e5967d66">I2C_STATUS_UNDEFINEDCMD</a>&#160;&#160;&#160;(-((int32_t)2))</td></tr>
<tr class="memdesc:ga11c31c9869ed2441789205d9e5967d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a> for undefined command codes.  <a href="#ga11c31c9869ed2441789205d9e5967d66">More...</a><br /></td></tr>
<tr class="separator:ga11c31c9869ed2441789205d9e5967d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436bc81547d25cbe81ce05723f52b07d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga436bc81547d25cbe81ce05723f52b07d">I2C_STS_SUCCESS</a>&#160;&#160;&#160;((int16_t)(1))</td></tr>
<tr class="memdesc:ga436bc81547d25cbe81ce05723f52b07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a>.  <a href="#ga436bc81547d25cbe81ce05723f52b07d">More...</a><br /></td></tr>
<tr class="separator:ga436bc81547d25cbe81ce05723f52b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b0b690d277c28a31e0d54adff41576"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga38b0b690d277c28a31e0d54adff41576">I2C_STS_RESTART</a>&#160;&#160;&#160;((int16_t)(2))</td></tr>
<tr class="memdesc:ga38b0b690d277c28a31e0d54adff41576"><td class="mdescLeft">&#160;</td><td class="mdescRight">A restart status code returned by I2C transfer callback.  <a href="#ga38b0b690d277c28a31e0d54adff41576">More...</a><br /></td></tr>
<tr class="separator:ga38b0b690d277c28a31e0d54adff41576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ef9c5b5af75eebd526d463caaa6ebb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaa1ef9c5b5af75eebd526d463caaa6ebb">I2C_STS_ERR</a>&#160;&#160;&#160;((int16_t)(0))</td></tr>
<tr class="memdesc:gaa1ef9c5b5af75eebd526d463caaa6ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A error status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a>.  <a href="#gaa1ef9c5b5af75eebd526d463caaa6ebb">More...</a><br /></td></tr>
<tr class="separator:gaa1ef9c5b5af75eebd526d463caaa6ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd84b85e7e90ce51a193e009a10f93b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gafd84b85e7e90ce51a193e009a10f93b5">I2C_STS_ERR_TIMEOUT</a>&#160;&#160;&#160;(-(int16_t)(1))</td></tr>
<tr class="memdesc:gafd84b85e7e90ce51a193e009a10f93b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A error status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a>.  <a href="#gafd84b85e7e90ce51a193e009a10f93b5">More...</a><br /></td></tr>
<tr class="separator:gafd84b85e7e90ce51a193e009a10f93b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4609322c95a91f3087cf8cedeaf50dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4609322c95a91f3087cf8cedeaf50dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaa4609322c95a91f3087cf8cedeaf50dc">I2C_STS_ERR_BUS_BUSY</a>&#160;&#160;&#160;(-(int16_t)(2))</td></tr>
<tr class="memdesc:gaa4609322c95a91f3087cf8cedeaf50dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C bus busy error. <br /></td></tr>
<tr class="separator:gaa4609322c95a91f3087cf8cedeaf50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f7e0ce66230391b0b2bff9a2a125da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga45f7e0ce66230391b0b2bff9a2a125da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga45f7e0ce66230391b0b2bff9a2a125da">I2C_STS_ERR_NO_ACK</a>&#160;&#160;&#160;(-(int16_t)(3))</td></tr>
<tr class="memdesc:ga45f7e0ce66230391b0b2bff9a2a125da"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C no ack error when no acknowledgement is received. <br /></td></tr>
<tr class="separator:ga45f7e0ce66230391b0b2bff9a2a125da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914692b73c08c5b4f416c99bbba1b1df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga914692b73c08c5b4f416c99bbba1b1df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga914692b73c08c5b4f416c99bbba1b1df">I2C_STS_ERR_ARBITRATION_LOST</a>&#160;&#160;&#160;(-(int16_t)(4))</td></tr>
<tr class="memdesc:ga914692b73c08c5b4f416c99bbba1b1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Arbitration lost error. <br /></td></tr>
<tr class="separator:ga914692b73c08c5b4f416c99bbba1b1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764c02df1aa2b1eabc660900f6c0e5fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga764c02df1aa2b1eabc660900f6c0e5fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga764c02df1aa2b1eabc660900f6c0e5fd">I2C_STS_ERR_ACCESS_ERROR</a>&#160;&#160;&#160;(-(int16_t)(5))</td></tr>
<tr class="memdesc:ga764c02df1aa2b1eabc660900f6c0e5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Bus Access error. <br /></td></tr>
<tr class="separator:ga764c02df1aa2b1eabc660900f6c0e5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b55fae2bff33fbbe7b989042413e039"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b55fae2bff33fbbe7b989042413e039"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga4b55fae2bff33fbbe7b989042413e039">I2C_STS_ERR_COMMAND_FAILURE</a>&#160;&#160;&#160;(-(int16_t)(6))</td></tr>
<tr class="memdesc:ga4b55fae2bff33fbbe7b989042413e039"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C FW Command Access Failure. <br /></td></tr>
<tr class="separator:ga4b55fae2bff33fbbe7b989042413e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf895f1f3d50b692c2327c3f2cdec9742"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf895f1f3d50b692c2327c3f2cdec9742"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaf895f1f3d50b692c2327c3f2cdec9742">I2C_STS_ERR_INVALID_COMMAND</a>&#160;&#160;&#160;(-(int16_t)(7))</td></tr>
<tr class="memdesc:gaf895f1f3d50b692c2327c3f2cdec9742"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C FW Invalid Command passed. <br /></td></tr>
<tr class="separator:gaf895f1f3d50b692c2327c3f2cdec9742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2082eaca20d22df76ee7c03ec9ff7852"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga2082eaca20d22df76ee7c03ec9ff7852">I2C_TRANS_VALID_PARAM_MASTER_MODE</a>&#160;&#160;&#160;(0x00000001U)</td></tr>
<tr class="memdesc:ga2082eaca20d22df76ee7c03ec9ff7852"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C_TRANSACTION valid parameter bit fields.  <a href="#ga2082eaca20d22df76ee7c03ec9ff7852">More...</a><br /></td></tr>
<tr class="separator:ga2082eaca20d22df76ee7c03ec9ff7852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd15612272a2c28f4e68ab6ab07d58d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaadd15612272a2c28f4e68ab6ab07d58d">I2C_TRANS_VALID_PARAM_EXPAND_SA</a>&#160;&#160;&#160;(0x00000002U)</td></tr>
<tr class="memdesc:gaadd15612272a2c28f4e68ab6ab07d58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transaction.  <a href="#gaadd15612272a2c28f4e68ab6ab07d58d">More...</a><br /></td></tr>
<tr class="separator:gaadd15612272a2c28f4e68ab6ab07d58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadd75c22230842b00010efe1d992b8979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd75c22230842b00010efe1d992b8979"></a>
typedef struct <a class="el" href="struct_i2_c___config__s.html">I2C_Config_s</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a></td></tr>
<tr class="memdesc:gadd75c22230842b00010efe1d992b8979"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open()</a> call. <br /></td></tr>
<tr class="separator:gadd75c22230842b00010efe1d992b8979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9a335048307e45baf67ffe1c286015"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga6542d13ae56d142b9f9ca97936881bef">I2C_TransferMode_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaec9a335048307e45baf67ffe1c286015">I2C_TransferMode</a></td></tr>
<tr class="memdesc:gaec9a335048307e45baf67ffe1c286015"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer mode.  <a href="#gaec9a335048307e45baf67ffe1c286015">More...</a><br /></td></tr>
<tr class="separator:gaec9a335048307e45baf67ffe1c286015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37389d5eec0eb91fe25e1524e2f339bc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga37389d5eec0eb91fe25e1524e2f339bc">I2C_CallbackFxn</a>) (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> handle, I2C_Transaction *msg, int16_t transferStatus)</td></tr>
<tr class="memdesc:ga37389d5eec0eb91fe25e1524e2f339bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C callback function.  <a href="#ga37389d5eec0eb91fe25e1524e2f339bc">More...</a><br /></td></tr>
<tr class="separator:ga37389d5eec0eb91fe25e1524e2f339bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e811b5532d85496de9014299c44b6c"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga3b315e755877e7b9fc141fde65564432">I2C_BitRate_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaf5e811b5532d85496de9014299c44b6c">I2C_BitRate</a></td></tr>
<tr class="memdesc:gaf5e811b5532d85496de9014299c44b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C bitRate.  <a href="#gaf5e811b5532d85496de9014299c44b6c">More...</a><br /></td></tr>
<tr class="separator:gaf5e811b5532d85496de9014299c44b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c010ca7e1a000d88b4ea7d2595f94d6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___params__s.html">I2C_Params_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga7c010ca7e1a000d88b4ea7d2595f94d6">I2C_Params</a></td></tr>
<tr class="memdesc:ga7c010ca7e1a000d88b4ea7d2595f94d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Parameters.  <a href="#ga7c010ca7e1a000d88b4ea7d2595f94d6">More...</a><br /></td></tr>
<tr class="separator:ga7c010ca7e1a000d88b4ea7d2595f94d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083200108e980a0ef61e458f0b9fb9e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga083200108e980a0ef61e458f0b9fb9e7"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga083200108e980a0ef61e458f0b9fb9e7">I2C_CloseFxn</a>) (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:ga083200108e980a0ef61e458f0b9fb9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga17b3618e4c0b145bc6d32c50d33c0818" title="Function to close a I2C peripheral specified by the I2C handle. ">I2C_close()</a>. <br /></td></tr>
<tr class="separator:ga083200108e980a0ef61e458f0b9fb9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83c5698318ecfc08ca3d536992af0fa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83c5698318ecfc08ca3d536992af0fa3"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga83c5698318ecfc08ca3d536992af0fa3">I2C_ControlFxn</a>) (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> handle, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:ga83c5698318ecfc08ca3d536992af0fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a>. <br /></td></tr>
<tr class="separator:ga83c5698318ecfc08ca3d536992af0fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb2451c8a1ce70402e43e4743c5fedf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadfb2451c8a1ce70402e43e4743c5fedf"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadfb2451c8a1ce70402e43e4743c5fedf">I2C_InitFxn</a>) (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:gadfb2451c8a1ce70402e43e4743c5fedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga9ff51ddf1d325776fef90cce0223772b" title="Function to initializes the I2C module. ">I2C_init()</a>. <br /></td></tr>
<tr class="separator:gadfb2451c8a1ce70402e43e4743c5fedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb3800d49a9dd7c11f7e39223600dabf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb3800d49a9dd7c11f7e39223600dabf"></a>
typedef <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gafb3800d49a9dd7c11f7e39223600dabf">I2C_OpenFxn</a>) (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> handle, const <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga7c010ca7e1a000d88b4ea7d2595f94d6">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:gafb3800d49a9dd7c11f7e39223600dabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open()</a>. <br /></td></tr>
<tr class="separator:gafb3800d49a9dd7c11f7e39223600dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1191de07b33b334d5ad2204d76fc03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed1191de07b33b334d5ad2204d76fc03"></a>
typedef int16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaed1191de07b33b334d5ad2204d76fc03">I2C_TransferFxn</a>) (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> handle, I2C_Transaction *transaction)</td></tr>
<tr class="memdesc:gaed1191de07b33b334d5ad2204d76fc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a>. <br /></td></tr>
<tr class="separator:gaed1191de07b33b334d5ad2204d76fc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0467e0443f45a99feb7122844c1359a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0467e0443f45a99feb7122844c1359a1"></a>
typedef struct <a class="el" href="struct_i2_c___fxn_table__s.html">I2C_FxnTable_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga0467e0443f45a99feb7122844c1359a1">I2C_FxnTable</a></td></tr>
<tr class="memdesc:ga0467e0443f45a99feb7122844c1359a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a I2C function table that contains the required set of functions to control a specific I2C driver implementation. <br /></td></tr>
<tr class="separator:ga0467e0443f45a99feb7122844c1359a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fa7931cdf3a2ac44a1599ee4f761564"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___config__s.html">I2C_Config_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga8fa7931cdf3a2ac44a1599ee4f761564">I2C_Config</a></td></tr>
<tr class="memdesc:ga8fa7931cdf3a2ac44a1599ee4f761564"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Global configuration.  <a href="#ga8fa7931cdf3a2ac44a1599ee4f761564">More...</a><br /></td></tr>
<tr class="separator:ga8fa7931cdf3a2ac44a1599ee4f761564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga6542d13ae56d142b9f9ca97936881bef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga6542d13ae56d142b9f9ca97936881bef">I2C_TransferMode_e</a> { <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gga6542d13ae56d142b9f9ca97936881befabe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, 
<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gga6542d13ae56d142b9f9ca97936881befa129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>
 }</td></tr>
<tr class="memdesc:ga6542d13ae56d142b9f9ca97936881bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer mode.  <a href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga6542d13ae56d142b9f9ca97936881bef">More...</a><br /></td></tr>
<tr class="separator:ga6542d13ae56d142b9f9ca97936881bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b315e755877e7b9fc141fde65564432"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga3b315e755877e7b9fc141fde65564432">I2C_BitRate_e</a> </td></tr>
<tr class="memdesc:ga3b315e755877e7b9fc141fde65564432"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C bitRate.  <a href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga3b315e755877e7b9fc141fde65564432">More...</a><br /></td></tr>
<tr class="separator:ga3b315e755877e7b9fc141fde65564432"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga17b3618e4c0b145bc6d32c50d33c0818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga17b3618e4c0b145bc6d32c50d33c0818">I2C_close</a> (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> i2cHnd)</td></tr>
<tr class="memdesc:ga17b3618e4c0b145bc6d32c50d33c0818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a I2C peripheral specified by the I2C handle.  <a href="#ga17b3618e4c0b145bc6d32c50d33c0818">More...</a><br /></td></tr>
<tr class="separator:ga17b3618e4c0b145bc6d32c50d33c0818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20f44c5f041a281b4b0e631a765c6cd2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2">I2C_control</a> (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> i2cHnd, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:ga20f44c5f041a281b4b0e631a765c6cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given I2C_Handle.  <a href="#ga20f44c5f041a281b4b0e631a765c6cd2">More...</a><br /></td></tr>
<tr class="separator:ga20f44c5f041a281b4b0e631a765c6cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff51ddf1d325776fef90cce0223772b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga9ff51ddf1d325776fef90cce0223772b">I2C_init</a> (void)</td></tr>
<tr class="memdesc:ga9ff51ddf1d325776fef90cce0223772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initializes the I2C module.  <a href="#ga9ff51ddf1d325776fef90cce0223772b">More...</a><br /></td></tr>
<tr class="separator:ga9ff51ddf1d325776fef90cce0223772b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab59fd6d22b790182114033b8056b36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b">I2C_open</a> (uint32_t idx, <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga7c010ca7e1a000d88b4ea7d2595f94d6">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:gaab59fd6d22b790182114033b8056b36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate.  <a href="#gaab59fd6d22b790182114033b8056b36b">More...</a><br /></td></tr>
<tr class="separator:gaab59fd6d22b790182114033b8056b36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11636302074d67180207ab81ceb323c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gab11636302074d67180207ab81ceb323c">I2C_Params_init</a> (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga7c010ca7e1a000d88b4ea7d2595f94d6">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:gab11636302074d67180207ab81ceb323c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the I2C_Params struct to its defaults.  <a href="#gab11636302074d67180207ab81ceb323c">More...</a><br /></td></tr>
<tr class="separator:gab11636302074d67180207ab81ceb323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga890f328870fd7c23c0f76dc12de222b2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2">I2C_transfer</a> (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> i2cHnd, I2C_Transaction *transaction)</td></tr>
<tr class="memdesc:ga890f328870fd7c23c0f76dc12de222b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that handles the I2C transfer for SYS/BIOS.  <a href="#ga890f328870fd7c23c0f76dc12de222b2">More...</a><br /></td></tr>
<tr class="separator:ga890f328870fd7c23c0f76dc12de222b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I2C driver interface </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac180b6227ed3fdbeaee729c7142be292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CMD_PROBE&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C probe IOCTL. This IOCTL returns I2C_STATUS_SUCCESS if the device is present. Returns I2C_STATUS_ERROR otherwise. The argument to this IOCTL is the uint32_t * of the device address. </p>

</div>
</div>
<a class="anchor" id="ga5eb5c8eb4dfa903256744e611350d166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CMD_RECOVER_BUS&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This command performs bus recovery in case of timeout error. This command returns I2C_STATUS_SUCCESS if the device is present. Returns I2C_STATUS_ERROR otherwise. The argument to this accepts the delay value. </p>

</div>
</div>
<a class="anchor" id="ga760ec0a6fdb876ccc67b6f06301d53ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CMD_RESERVED&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common I2C_control command code reservation offset. I2C driver implementations should offset command codes with I2C_CMD_RESERVED growing positively</p>
<p>Example implementation specific command codes: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define I2CXYZ_COMMAND0          I2C_CMD_RESERVED + 0</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define I2CXYZ_COMMAND1          I2C_CMD_RESERVED + 1</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga3b3af5c8efc2035485a769e056451a4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CMD_SET_BUS_FREQUENCY&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This command sets the i2c bus speed dynamically. This command returns I2C_STATUS_SUCCESS if the device is present. Returns I2C_STATUS_ERROR otherwise. The argument to this accepts the two macros I2C_100kHz, I2C_400kHz. </p>

</div>
</div>
<a class="anchor" id="ga514007e93fddd909e8a318ed6d4dd5c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CMD_SMBUS_TYPE&#160;&#160;&#160;(3U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This command performs SMBUS command and code setup. This command returns I2C_STATUS_SUCCESS if a valid smbus cmd is passed. Returns I2C_STATUS_ERROR otherwise. The argument to this accepts the SMBUS command and its subcode. </p>

</div>
</div>
<a class="anchor" id="ga7323fe57c39c46d0da9910e17f5f0b06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STATUS_ERROR&#160;&#160;&#160;(-((int32_t)1))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic error status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a>. </p>
<p><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a> returns I2C_STATUS_ERROR if the control code was not executed successfully. </p>

</div>
</div>
<a class="anchor" id="gacfd04572fe349d087c2547501cbc7e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STATUS_RESERVED&#160;&#160;&#160;(-((int32_t)32))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Common I2C_control status code reservation offset. I2C driver implementations should offset status codes with I2C_STATUS_RESERVED growing negatively.</p>
<p>Example implementation specific status codes: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define I2CXYZ_STATUS_ERROR0     I2C_STATUS_RESERVED - 0</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define I2CXYZ_STATUS_ERROR1     I2C_STATUS_RESERVED - 1</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#define I2CXYZ_STATUS_ERROR2     I2C_STATUS_RESERVED - 2</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa0bcf3acd26ac82bd8ff91daba2c78c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STATUS_SUCCESS&#160;&#160;&#160;((int32_t)(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Successful status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a>. </p>
<p><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a> returns I2C_STATUS_SUCCESS if the control code was executed successfully. </p>

</div>
</div>
<a class="anchor" id="ga11c31c9869ed2441789205d9e5967d66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STATUS_UNDEFINEDCMD&#160;&#160;&#160;(-((int32_t)2))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An error status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a> for undefined command codes. </p>
<p><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga20f44c5f041a281b4b0e631a765c6cd2" title="Function performs implementation specific features on a given I2C_Handle. ">I2C_control()</a> returns I2C_STATUS_UNDEFINEDCMD if the control code is not recognized by the driver implementation. </p>

</div>
</div>
<a class="anchor" id="gaa1ef9c5b5af75eebd526d463caaa6ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STS_ERR&#160;&#160;&#160;((int16_t)(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A error status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a>. </p>
<p><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a> returns I2C_STS_ERR if the transfer is failed. </p>

</div>
</div>
<a class="anchor" id="gafd84b85e7e90ce51a193e009a10f93b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STS_ERR_TIMEOUT&#160;&#160;&#160;(-(int16_t)(1))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A error status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a>. </p>
<p><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a> returns I2C_STS_ERR_TIMEOUT if the timeout error is occured during the transfer. </p>

</div>
</div>
<a class="anchor" id="ga38b0b690d277c28a31e0d54adff41576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STS_RESTART&#160;&#160;&#160;((int16_t)(2))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A restart status code returned by I2C transfer callback. </p>
<p>I2C transfer callback function returns I2C_STS_RESTART if the restart condition is detected. This status is only valid in slave mode. </p>

</div>
</div>
<a class="anchor" id="ga436bc81547d25cbe81ce05723f52b07d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_STS_SUCCESS&#160;&#160;&#160;((int16_t)(1))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A status code returned by <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a>. </p>
<p><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga890f328870fd7c23c0f76dc12de222b2" title="Function that handles the I2C transfer for SYS/BIOS. ">I2C_transfer()</a> returns I2C_STS_SUCCESS if the transfer is succesful. </p>

</div>
</div>
<a class="anchor" id="gaadd15612272a2c28f4e68ab6ab07d58d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_TRANS_VALID_PARAM_EXPAND_SA&#160;&#160;&#160;(0x00000002U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transaction. </p>
<p>This structure defines the nature of the I2C transaction.</p>
<p>I2C master mode: This structure specifies the buffer and buffer's size that is to be written to or read from the I2C slave peripheral.</p>
<p>I2C slave mode: This structure specifies the buffer and buffer's size that is to be read from or written to the I2C master. In restart condition, readBuf/writeBuf and readCount/writeCount are used repeatedly for every start in one transfer. When each restart happens, driver will call back to application with the restart transfer status, and application should save the data transferred in the previous start, and provide the new data to the current start. When all the starts complete (stop condition), driver will call back to application with transfer success status, and readBuf/writeBuf and readCount/writeCount will only record the data transferred in the last start condition.</p>
<p>arg is an optional user supplied argument that will be passed to the callback function when the I2C driver is in I2C_MODE_CALLBACK. nextPtr is to be only used by the I2C driver. </p>

</div>
</div>
<a class="anchor" id="ga2082eaca20d22df76ee7c03ec9ff7852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_TRANS_VALID_PARAM_MASTER_MODE&#160;&#160;&#160;(0x00000001U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C_TRANSACTION valid parameter bit fields. </p>
<p>Valid bit fields supported</p>
<p>I2C_TRANS_VALID_PARAM_MASTER_MODE I2C_TRANS_VALID_PARAM_EXPAND_SA </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaf5e811b5532d85496de9014299c44b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga3b315e755877e7b9fc141fde65564432">I2C_BitRate_e</a>  <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaf5e811b5532d85496de9014299c44b6c">I2C_BitRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C bitRate. </p>
<p>Specify one of the standardized I2C bus bit rates for I2C communications. The default is I2C_100kHz. </p>

</div>
</div>
<a class="anchor" id="ga37389d5eec0eb91fe25e1524e2f339bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_CallbackFxn) (<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> handle, I2C_Transaction *msg, int16_t transferStatus)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C callback function. </p>
<p>User definable callback function prototype. The I2C driver will call the defined function and pass in the I2C driver's handle, the pointer to the I2C transaction that just completed, and the return value of I2C_transfer.</p>
<p>In slave mode, when there is a restart condtion,the driver calls back to the application with received data and I2C_STS_RESTART transfer status, application needs to provide the restart transmit data in I2C_Transaction rsWrToMstBuf. Restart condition only works in callback mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I2C_Handle</td><td>I2C_Handle</td></tr>
    <tr><td class="paramname">I2C_Transaction*</td><td>Address of the I2C_Transaction performed</td></tr>
    <tr><td class="paramname">bool</td><td>Results of the I2C transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8fa7931cdf3a2ac44a1599ee4f761564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___config__s.html">I2C_Config_s</a>  <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga8fa7931cdf3a2ac44a1599ee4f761564">I2C_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Global configuration. </p>
<p>The I2C_Config structure contains a set of pointers used to characterize the I2C driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga9ff51ddf1d325776fef90cce0223772b" title="Function to initializes the I2C module. ">I2C_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga9ff51ddf1d325776fef90cce0223772b" title="Function to initializes the I2C module. ">I2C_init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c010ca7e1a000d88b4ea7d2595f94d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___params__s.html">I2C_Params_s</a>  <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga7c010ca7e1a000d88b4ea7d2595f94d6">I2C_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Parameters. </p>
<p>I2C parameters are used to with the <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open()</a> call. Default values for these parameters are set using <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gab11636302074d67180207ab81ceb323c" title="Function to initialize the I2C_Params struct to its defaults. ">I2C_Params_init()</a>.</p>
<p>If I2C_TransferMode is set to I2C_MODE_BLOCKING then I2C_transfer function calls will block thread execution until the transaction has completed.</p>
<p>If I2C_TransferMode is set to I2C_MODE_CALLBACK then I2C_transfer will not block thread execution and it will call the function specified by transferCallbackFxn. Sequential calls to I2C_transfer in I2C_MODE_CALLBACK mode will put the designated transaction onto an internal queue that automatically starts queued transactions after the previous transaction has completed. (regardless of error state).</p>
<p>I2C_BitRate specifies the I2C bus rate used for I2C communications.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gab11636302074d67180207ab81ceb323c" title="Function to initialize the I2C_Params struct to its defaults. ">I2C_Params_init()</a> I2C transaction timeout define </dd></dl>

</div>
</div>
<a class="anchor" id="gaec9a335048307e45baf67ffe1c286015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga6542d13ae56d142b9f9ca97936881bef">I2C_TransferMode_e</a>  <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaec9a335048307e45baf67ffe1c286015">I2C_TransferMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer mode. </p>
<p>I2C_MODE_BLOCKING block task execution while a I2C transfer is in progress I2C_MODE_CALLBACK does not block task execution; but calls a callback function when the I2C transfer has completed </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga3b315e755877e7b9fc141fde65564432"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga3b315e755877e7b9fc141fde65564432">I2C_BitRate_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C bitRate. </p>
<p>Specify one of the standardized I2C bus bit rates for I2C communications. The default is I2C_100kHz. </p>

</div>
</div>
<a class="anchor" id="ga6542d13ae56d142b9f9ca97936881bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga6542d13ae56d142b9f9ca97936881bef">I2C_TransferMode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer mode. </p>
<p>I2C_MODE_BLOCKING block task execution while a I2C transfer is in progress I2C_MODE_CALLBACK does not block task execution; but calls a callback function when the I2C transfer has completed </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6542d13ae56d142b9f9ca97936881befabe065350be2a0ae5c9beb24624626c75"></a>I2C_MODE_BLOCKING&#160;</td><td class="fielddoc">
<p>I2C_transfer blocks execution </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6542d13ae56d142b9f9ca97936881befa129731a7edeb285f43a54b2cf9f5ac72"></a>I2C_MODE_CALLBACK&#160;</td><td class="fielddoc">
<p>I2C_transfer queues transactions and does not block </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga17b3618e4c0b145bc6d32c50d33c0818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>i2cHnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a I2C peripheral specified by the I2C handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open()</a> had to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2cHnd</td><td>A I2C_Handle returned from I2C_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga20f44c5f041a281b4b0e631a765c6cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t I2C_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>i2cHnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a given I2C_Handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2cHnd</td><td>A I2C handle returned from <a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td>A command value defined by the driver specific implementation</td></tr>
    <tr><td class="paramname">arg</td><td>An optional R/W (read/write) argument that is accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ff51ddf1d325776fef90cce0223772b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initializes the I2C module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The I2C_config structure must exist and be persistent before this function can be called. This function must also be called before any other I2C driver APIs. This function call does not modify any peripheral registers. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab59fd6d22b790182114033b8056b36b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a> I2C_open </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga7c010ca7e1a000d88b4ea7d2595f94d6">I2C_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. </p>
<dl class="section pre"><dt>Precondition</dt><dd>I2C controller has been initialized</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Logical peripheral number for the I2C indexed into the I2C_config table</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to an parameter block, if NULL it will use default values. All the fields in this structure are RO (read-only).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A I2C_Handle on success or a NULL on an error or if it has been opened already.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga9ff51ddf1d325776fef90cce0223772b" title="Function to initializes the I2C module. ">I2C_init()</a> </dd>
<dd>
<a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga17b3618e4c0b145bc6d32c50d33c0818" title="Function to close a I2C peripheral specified by the I2C handle. ">I2C_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab11636302074d67180207ab81ceb323c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#ga7c010ca7e1a000d88b4ea7d2595f94d6">I2C_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the I2C_Params struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to I2C_Params structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: transferMode = I2C_MODE_BLOCKING transferCallbackFxn = NULL bitRate = I2C_100kHz </p>

</div>
</div>
<a class="anchor" id="ga890f328870fd7c23c0f76dc12de222b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t I2C_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gadd75c22230842b00010efe1d992b8979">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>i2cHnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2C_Transaction *&#160;</td>
          <td class="paramname"><em>transaction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that handles the I2C transfer for SYS/BIOS. </p>
<p>This function will start a I2C transfer and can only be called from a Task context when in I2C_MODE_BLOCKING. The I2C transfer procedure starts with evaluating how many bytes are to be written and how many are to be read from the I2C peripheral. Due to common I2C data transfer processes, to be written will always sent before any data is read.</p>
<p>The data written to the peripheral is preceded with the peripheral's 7-bit I2C slave address (with the Write bit set). After all the data has been transmitted, the driver will evaluate if any data needs to be read from the device. If so, a Re-START bit is sent, along with the same 7-bit I2C slave address (with the Read bit). Else, the transfer is concluded with a STOP bit. After the specified number of bytes have been read by the I2C, the transfer is ended with a NACK and STOP bit.</p>
<p>In I2C_MODE_BLOCKING, I2C_transfer will block task execution until the transaction has completed.</p>
<p>In I2C_MODE_CALLBACK, I2C_transfer does not block task execution and calls a callback function specified by transferCallbackFxn. If a transfer is already taking place, the transaction is put on an internal queue. The queue is serviced in a first come first served basis. The I2C_Transaction structure must stay persistent until the I2C_transfer function has completed!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2cHnd</td><td>A I2C_Handle</td></tr>
    <tr><td class="paramname">transaction</td><td>A pointer to a I2C_Transaction. All of the fields within transaction are WO (write-only) unless otherwise noted in the driver implementations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful transfer false on an error, such as a I2C bus fault</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___d_r_v___i2_c___a_p_i___m_o_d_u_l_e.html#gaab59fd6d22b790182114033b8056b36b" title="Function to initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. ">I2C_open</a> Function to initialize the I2C_Transaction struct to its defaults</dd></dl>
<p>Defaults values are: validParams = I2C_TRANS_VALID_PARAM_MASTER_MODE; writeBuf = NULL; writeCount = 0; readBuf = NULL; readCount = 0; slaveAddress = 0; arg = NULL; nextPtr = NULL; timeout = I2C_WAIT_FOREVER; rsWrToMstBuf = NULL; rsWrToMstCnt = 0; masterMode = true;</p>
<dl class="section return"><dt>Returns</dt><dd>transaction parameter structure to initialize </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
