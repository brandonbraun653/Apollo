/*
 *   Copyright (c) Texas Instruments Incorporated 2015-2017
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

 /**
 *  \file     rti_app_dwwd.c
 *
 *  \brief    This file contains RTI DWWD test code for window size 12.5%.
 *
 *  \details  DWWD window size is set to 12.5%.
 *            RTI clock source is selected as 32KHz.
 *            DWWD preload value is set for 10sec.
 *            DWWD time-out value is specified in "APP_RTI_DWWD_TIMEOUT_VALUE"
 *            macro in mili-seconds.
 *            RTI 4 suspend lines are tied to IPUC0 for this test.
 *            Test runs in two stages:
 *                  stage 1: DWWD will expire in 10sec and generate Reset to
 *                           System.
 *                  stage 2: DWWD is serviced and should not generate Reset
 *                           within 10 seconds.
 **/


/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */
#include <stdint.h>
#include <ti/csl/csl_types.h>
#include <ti/csl/hw_types.h>
#include <ti/csl/example/utils/uart_console/inc/uartConfig.h>
#include <ti/csl/cslr_rti.h>
#include <ti/csl/csl_rti.h>
#include <ti/csl/soc.h>

/* ========================================================================== */
/*                                Macros                                      */
/* ========================================================================== */
#define APP_RTI_MODULE                 (SOC_RTI4_BASE)
#define APP_RTI_DWWD_WINDOW_SIZE       (RTI_DWWD_WINDOWSIZE_12_5_PERCENT)
#define APP_RTI_DWWD_TIMEOUT_VALUE     (10000U)
#define APP_RTI_DWWD_REACTION          (RTI_DWWD_REACTION_GENERATE_RESET)

#define RTI_CLOCK_SOURCE_SYSCLK1_FREQ_KHz      (20000U / 4U)
#define RTI_CLOCK_SOURCE_SYSCLK2_FREQ_KHz      (20000U / 4U)
#define RTI_CLOCK_SOURCE_32KHZ_FREQ_KHz        (32U)

#define SOC_I_DRM_BASE_SUSPEND_CTRL20   (0x250U)
#define SOC_I_DRM_BASE_SUSPEND_CTRL21   (0x254U)
#define SOC_I_DRM_BASE_SUSPEND_CTRL22   (0x258U)
#define SOC_I_DRM_BASE_SUSPEND_CTRL23   (0x25CU)
#define SOC_I_DRM_BASE_SUSPEND_CTRL24   (0x260U)

/* ========================================================================== */
/*                         Structures and Enums                               */
/* ========================================================================== */
/**
 * \brief  Enum to report the last system reset status.
 */
typedef enum deviceLastResetStatus
{
    DEVICE_LAST_RESET_STATUS_WDT_GENERATED,
    /**< Last device reset is generated by WDT */
    DEVICE_LAST_RESET_STATUS_NOT_WDT_GENERATED
    /**< Last device reset is not generated by WDT */
}deviceLastResetStaus_t;

/**
 * \brief  Enum to select the clock source for RTI module.
 */
typedef enum rtiClockSource
{
    RTI_CLOCK_SOURCE_SYSCLK1 = CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL_RTI1_SYS_CLK1,
    /**< to select clock frequency of (sysclk1/4) */
    RTI_CLOCK_SOURCE_SYSCLK2 = CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL_RTI1_SYS_CLK2,
    /**< to select clock frequency of (sysclk1/4) */
    RTI_CLOCK_SOURCE_32KHZ = CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL_RTI1_XREF_CLK
                             /**< to select clock frequency of 32KHz */
}rtiClockSource_t;

/**
 * \brief  Enum to select the Suspend lines for RTI module.
 */
typedef enum rtiSuspendLineCore
{
    RTI_SUSPEND_LINE_CORE_IPU_C0 = 0x00000031U,
    /**< to select suspend line for IPU core 0 */
    RTI_SUSPEND_LINE_CORE_IPU_C1 = 0x00000041U,
    /**< to select suspend line for IPU core  */
    RTI_SUSPEND_LINE_CORE_DSP_C0 = 0x00000001U,
    /**< to select suspend line for DSP core 0 */
    RTI_SUSPEND_LINE_CORE_DSP_C1 = 0x00000071U,
    /**< to select suspend line for DSP core 1 */
    RTI_SUSPEND_LINE_CORE_EVE = 0x000000A1U
                                /**< to select suspend line for EVE */
}rtiSuspendLineCore_t;

/* ========================================================================== */
/*                            Global Variables                                */
/* ========================================================================== */
#if defined (SOC_AM574x) || defined (SOC_AM572x) || defined (SOC_AM571x)
uint32_t uartBaseAddr = CSL_MPU_UART1_REGS;
#define SOC_TIMER4_BASE CSL_MPU_TIMER4_REGS
#endif
#if defined (SOC_TDA2XX) || defined (SOC_TDA2PX) || defined (SOC_TDA2EX) || defined (SOC_DRA72x) || defined (SOC_DRA75x)
uint32_t uartBaseAddr = SOC_UART1_BASE;
#endif
#if defined (SOC_TDA3XX) || defined (SOC_DRA78x)
uint32_t uartBaseAddr = SOC_UART3_BASE;
#endif

/* ========================================================================== */
/*                 Internal Function Declarations                             */
/* ========================================================================== */
/**
 * \brief   This API return the status of the last system Reset.
 *
 * \param   none.
 *
 * \return  status          Last device reset status.
 *                          values given by enum #deviceLastResetStaus_t
 */
static deviceLastResetStaus_t DeviceGetLastResetStatus(void);

/**
 * \brief   This API to select clock source for RTI module.
 *
 * \param   rtiModule       RTI module instance
 *
 * \param   rtiClockSource  RTI module clock source
 *                          Values given by enum #rtiClockSource_t
 *
 * \return  none.
 */
static void RTISetClockSource(uint32_t rtiModuleSelect,
                              uint32_t rtiClockSourceSelect);

/**
 * \brief   This API to select suspend lines for RTI module.
 *
 * \param   rtiModule       RTI module instance
 *
 * \param   deviceCore      Device core to which suspend lines for given RTI
 *                          module needs to be tied off.
 *                          Values given by enum #rtiSuspendLineCore_t.
 *
 * \return  none.
 */
void RTISetSuspendLine(uint32_t rtiModule, uint32_t deviceCore);

/**
 * \brief   This API to calculate preload value from given time-out value.
 *
 * \param   rtiClockSource  RTI module clock source
 *                          Values given by enum #rtiClockSource_t
 *
 * \param   timeoutVal      RTI DWWD time-out value in mili-seconds.
 *
 * \return  Preload value   Time-out value in RTI source clock cycles.
 */
uint32_t RTIGetPreloadValue(uint32_t rtiClkSource, uint32_t timeoutVal);

/**
 * \brief   This API is for infinite loop. To avoid compile time warning.
 *
 * \param   None.
 *
 * \return  None.
 */
void infiniteLoop(void);

/* ========================================================================== */
/*                          Function Definitions                              */
/* ========================================================================== */
void padConfig_prcmEnable()
{
#if defined (SOC_AM574x) || defined (SOC_AM572x) || defined (SOC_AM571x)
/*Pad configurations */
    HW_WR_REG32(CSL_MPU_CORE_PAD_IO_REGISTERS_REGS+CSL_CONTROL_CORE_PAD_IO_PAD_UART1_RXD,0x00040000);
    HW_WR_REG32(CSL_MPU_CORE_PAD_IO_REGISTERS_REGS+CSL_CONTROL_CORE_PAD_IO_PAD_UART1_TXD,0x00000000);
#endif
#if defined (SOC_TDA2XX) || defined (SOC_TDA2PX) || defined (SOC_TDA2EX) || defined (SOC_DRA72x) || defined (SOC_DRA75x)
    /*Pad configurations */
    HW_WR_REG32(SOC_CORE_PAD_IO_REGISTERS_BASE+CTRL_CORE_PAD_UART1_RXD,0x00040000);
    HW_WR_REG32(SOC_CORE_PAD_IO_REGISTERS_BASE+CTRL_CORE_PAD_UART1_TXD,0x00000000);
#endif
#if defined (SOC_TDA3XX) || defined (SOC_DRA78x)
    /*Pad configurations */
    HW_WR_REG32(SOC_CORE_PAD_IO_REGISTERS_BASE+CTRL_CORE_PAD_IO_SPI1_SCLK,0x00040001);
    HW_WR_REG32(SOC_CORE_PAD_IO_REGISTERS_BASE+CTRL_CORE_PAD_IO_SPI1_CS0,0x00000001);
#endif
}

int main(void)
{
    uint32_t rtiModule, rtiWindow_size, rtiPreload_value, rtiReaction;
    deviceLastResetStaus_t reset_status;
    int32_t  config_status;

    /* Do Pad Config for UART */
    padConfig_prcmEnable();
    /* Initialize the UART Instance */
   /* Initialize the UART Instance */
    UARTConfigInit(uartBaseAddr, BAUD_RATE_115200, UART_WORD_LENGTH_8, UART_STOP_BIT_1, UART_NO_PARITY,
                   UART_16x_MODE);

    /* Configure RTI parameters */
    rtiModule        = APP_RTI_MODULE;
    rtiWindow_size   = APP_RTI_DWWD_WINDOW_SIZE;
    rtiReaction      = APP_RTI_DWWD_REACTION;
    rtiPreload_value = RTIGetPreloadValue((uint32_t) RTI_CLOCK_SOURCE_32KHZ,
                                          (uint32_t) APP_RTI_DWWD_TIMEOUT_VALUE);

    /* Select suspend lines for RTI module */
    RTISetSuspendLine(rtiModule, (uint32_t) RTI_SUSPEND_LINE_CORE_IPU_C0);
    /* Select RTI module clock source */
    RTISetClockSource(rtiModule, (uint32_t) RTI_CLOCK_SOURCE_32KHZ);
    reset_status = DeviceGetLastResetStatus();
    switch (reset_status)
    {
        case DEVICE_LAST_RESET_STATUS_NOT_WDT_GENERATED:
            config_status = RTIDwwdWindowConfig(rtiModule, rtiReaction,
                                                rtiPreload_value,
                                                rtiWindow_size);
            if (config_status == STW_EFAIL)
            {
                UARTConfigPuts(uartBaseAddr,"Error during Window configuration.\n", -1);
            }
            else
            {
                UARTConfigPuts(uartBaseAddr,"Run 1:.", -1);
                UARTConfigPuts(uartBaseAddr,"DWWD is configured for ",-1);
                UARTConfigPutNum(uartBaseAddr,(uint32_t)APP_RTI_DWWD_TIMEOUT_VALUE);
                UARTConfigPuts(uartBaseAddr," time-out\n",-1);
                UARTConfigPuts(uartBaseAddr,"DWWD will generate RESET after time-out period.\n",
                         -1);
                RTIDwwdCounterEnable(rtiModule);
                /* Let DWWD expire here */
                UARTConfigPuts(uartBaseAddr,"Wait for",-1);
                UARTConfigPutNum(uartBaseAddr,(uint32_t) APP_RTI_DWWD_TIMEOUT_VALUE);
                UARTConfigPuts(uartBaseAddr,"ms for RESET to be generated by DWWD.\n",-1);
                infiniteLoop();
            }
            break;
        case DEVICE_LAST_RESET_STATUS_WDT_GENERATED:
            if (RTI_DWWD_RESET_STATUS_GENERATED ==
                RTIDwwdGetLastResetStatus(rtiModule))
            {
                UARTConfigPuts(uartBaseAddr,"Last reset was generated by DWWD.\n", -1);
                UARTConfigPuts(uartBaseAddr,"Recovered from RESET generated by DWWD.\n", -1);
                UARTConfigPuts(uartBaseAddr,"Run 2:", -1);
                UARTConfigPuts(uartBaseAddr,"DWWD is configured for ",-1);
                UARTConfigPutNum(uartBaseAddr,(uint32_t) APP_RTI_DWWD_TIMEOUT_VALUE);
                UARTConfigPuts(uartBaseAddr," time-out.\n",-1);
                UARTConfigPuts(uartBaseAddr,"In this run DWWD will be serviced.\n", -1);
                UARTConfigPuts(uartBaseAddr,
                    "DWWD will not generate RESET after time-out period.\n"
                    , -1);
                config_status = RTIDwwdWindowConfig(rtiModule, rtiReaction,
                                                    rtiPreload_value,
                                                    rtiWindow_size);
                if (config_status == STW_EFAIL)
                {
                    UARTConfigPuts(uartBaseAddr," Error during Window configuration.\n", -1);
                }
                else
                {
                    RTIDwwdCounterEnable(rtiModule);
                    while (RTIDwwdIsClosedWindow(rtiModule))
                    {}
                    RTIDwwdService(rtiModule);
                    UARTConfigPuts(uartBaseAddr,"DWWD serviced.\n", -1);
                    while (RTIDwwdIsClosedWindow(rtiModule))
                    {}
                    UARTConfigPuts(uartBaseAddr,"No RSEET generated since more than ",-1);
                    UARTConfigPutNum(uartBaseAddr,(uint32_t) APP_RTI_DWWD_TIMEOUT_VALUE);
                    UARTConfigPuts(uartBaseAddr," have passed.\n",-1);
                    UARTConfigPuts(uartBaseAddr,"Wait for RESET to be generated by DWWD.\n", -1);
                    infiniteLoop();
                }
            }
            else
            {
                UARTConfigPuts(uartBaseAddr,"Last RESET was not generated by DWWD.\n", -1);
                UARTConfigPuts(uartBaseAddr,"Please try to run application again.\n", -1);
            }
            break;
        default:
            break;
    }
    return 0;
}

/* ========================================================================== */
/*                 Internal Function Definitions                              */
/* ========================================================================== */
static deviceLastResetStaus_t DeviceGetLastResetStatus(void)
{
    uint32_t regVal;
    deviceLastResetStaus_t status;
    regVal = HW_RD_REG32(SOC_DEVICE_PRM_BASE + PRM_RSTST);
    if (HW_GET_FIELD(regVal,
                     PRM_RSTST_SECURE_WDT_RST) == 1U)
    {
        status = DEVICE_LAST_RESET_STATUS_WDT_GENERATED;
    }
    else
    {
        status = DEVICE_LAST_RESET_STATUS_NOT_WDT_GENERATED;
    }
    return status;
}

static void RTISetClockSource(uint32_t rtiModuleSelect,
                              uint32_t rtiClockSourceSelect)
{
    switch (rtiModuleSelect) {
        case SOC_RTI1_BASE:
            HW_WR_FIELD32(SOC_SEC_EFUSE_REGISTERS_BASE +
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL,
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL_RTI1,
                          rtiClockSourceSelect);
            break;
        case SOC_RTI2_BASE:
            HW_WR_FIELD32(SOC_SEC_EFUSE_REGISTERS_BASE +
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL,
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL_RTI2,
                          rtiClockSourceSelect);
            break;
        case SOC_RTI3_BASE:
            HW_WR_FIELD32(SOC_SEC_EFUSE_REGISTERS_BASE +
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL,
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL_RTI3,
                          rtiClockSourceSelect);
            break;
        case SOC_RTI4_BASE:
            HW_WR_FIELD32(SOC_SEC_EFUSE_REGISTERS_BASE +
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL,
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL_RTI4,
                          rtiClockSourceSelect);
            break;
        case SOC_RTI5_BASE:
            HW_WR_FIELD32(SOC_SEC_EFUSE_REGISTERS_BASE +
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL,
                          CTRL_CORE_SEC_PRCM_CLKSEL_CONTROL_RTI5,
                          rtiClockSourceSelect);
            break;
        default:
            break;
    }
}

void RTISetSuspendLine(uint32_t rtiModule, uint32_t deviceCore)
{
    switch (rtiModule) {
        case SOC_RTI1_BASE:
            HW_WR_REG32(SOC_I_DRM_BASE + SOC_I_DRM_BASE_SUSPEND_CTRL20,
                        deviceCore);
            break;
        case SOC_RTI2_BASE:
            HW_WR_REG32(SOC_I_DRM_BASE + SOC_I_DRM_BASE_SUSPEND_CTRL21,
                        deviceCore);
            break;
        case SOC_RTI3_BASE:
            HW_WR_REG32(SOC_I_DRM_BASE + SOC_I_DRM_BASE_SUSPEND_CTRL22,
                        deviceCore);
            break;
        case SOC_RTI4_BASE:
            HW_WR_REG32(SOC_I_DRM_BASE + SOC_I_DRM_BASE_SUSPEND_CTRL23,
                        deviceCore);
            break;
        case SOC_RTI5_BASE:
            HW_WR_REG32(SOC_I_DRM_BASE + SOC_I_DRM_BASE_SUSPEND_CTRL24,
                        deviceCore);
            break;
        default:
            break;
    }
}

uint32_t RTIGetPreloadValue(uint32_t rtiClkSource, uint32_t timeoutVal)
{
    uint32_t clkFreqKHz       = (uint32_t) RTI_CLOCK_SOURCE_32KHZ_FREQ_KHz,
             timeoutNumCycles = 0;

    switch (rtiClkSource)
    {
        case RTI_CLOCK_SOURCE_SYSCLK1:
            clkFreqKHz = (uint32_t) RTI_CLOCK_SOURCE_SYSCLK1_FREQ_KHz;
            break;
        case RTI_CLOCK_SOURCE_SYSCLK2:
            clkFreqKHz = (uint32_t) RTI_CLOCK_SOURCE_SYSCLK2_FREQ_KHz;
            break;
        case RTI_CLOCK_SOURCE_32KHZ:
            clkFreqKHz = (uint32_t) RTI_CLOCK_SOURCE_32KHZ_FREQ_KHz;
            break;
        default:
            break;
    }
    /* Get the clock ticks for given time-out value */
    timeoutNumCycles = timeoutVal * clkFreqKHz;
    return timeoutNumCycles;
}

void infiniteLoop(void)
{
    volatile uint32_t tempVar = 1U;
    while (tempVar)
    {}
}
/********************************* End of file ******************************/
