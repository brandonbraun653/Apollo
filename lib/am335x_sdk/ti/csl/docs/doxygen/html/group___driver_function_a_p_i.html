<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Driver Function API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Driver Function API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab9b673939a711f62c11f0ccf5ddafc26"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gab9b673939a711f62c11f0ccf5ddafc26">LPDDR4_Probe</a> (const <a class="el" href="struct_l_p_d_d_r4___config__s.html">LPDDR4_Config</a> *config, uint16_t *configSize)</td></tr>
<tr class="separator:gab9b673939a711f62c11f0ccf5ddafc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c7f28ca1815b81f98db4dfb447634d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga42c7f28ca1815b81f98db4dfb447634d">LPDDR4_Init</a> (<a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const <a class="el" href="struct_l_p_d_d_r4___config__s.html">LPDDR4_Config</a> *cfg)</td></tr>
<tr class="separator:ga42c7f28ca1815b81f98db4dfb447634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3591218c4b0b6cfc193b0cac1dfc94ff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga3591218c4b0b6cfc193b0cac1dfc94ff">LPDDR4_Start</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD)</td></tr>
<tr class="separator:ga3591218c4b0b6cfc193b0cac1dfc94ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae10c34462f83915da68d8f22ba339c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gacae10c34462f83915da68d8f22ba339c">LPDDR4_ReadReg</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="group___data_structure.html#ga667139fd1b36917fe2e4d30476fac6d0">LPDDR4_RegBlock</a> cpp, uint32_t regOffset, uint32_t *regValue)</td></tr>
<tr class="separator:gacae10c34462f83915da68d8f22ba339c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3fdab52d7d656ad5ecbda45b54f18bf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gad3fdab52d7d656ad5ecbda45b54f18bf">LPDDR4_WriteReg</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="group___data_structure.html#ga667139fd1b36917fe2e4d30476fac6d0">LPDDR4_RegBlock</a> cpp, uint32_t regOffset, uint32_t regValue)</td></tr>
<tr class="separator:gad3fdab52d7d656ad5ecbda45b54f18bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02b7f0c9a7f544b0985dab2b36f70645"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga02b7f0c9a7f544b0985dab2b36f70645">LPDDR4_GetMmrRegister</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t readModeRegVal, uint64_t *mmrValue, uint8_t *mmrStatus)</td></tr>
<tr class="separator:ga02b7f0c9a7f544b0985dab2b36f70645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada30019ba9f2a3f42d7e56a17e1188e7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gada30019ba9f2a3f42d7e56a17e1188e7">LPDDR4_SetMmrRegister</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t writeModeRegVal, uint8_t *mrwStatus)</td></tr>
<tr class="separator:gada30019ba9f2a3f42d7e56a17e1188e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5dcb571b46e6143eab5ff30b834cd28"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gad5dcb571b46e6143eab5ff30b834cd28">LPDDR4_WriteCtlConfig</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t regValues[], uint16_t regNum[], uint16_t regCount)</td></tr>
<tr class="separator:gad5dcb571b46e6143eab5ff30b834cd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d41dc38b4fc7763d0e478cae357427"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaf5d41dc38b4fc7763d0e478cae357427">LPDDR4_WritePhyConfig</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t regValues[], uint16_t regNum[], uint16_t regCount)</td></tr>
<tr class="separator:gaf5d41dc38b4fc7763d0e478cae357427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6a0089b6f6df7dd88bed59d0ae7628"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaeb6a0089b6f6df7dd88bed59d0ae7628">LPDDR4_WritePhyIndepConfig</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t regValues[], uint16_t regNum[], uint16_t regCount)</td></tr>
<tr class="separator:gaeb6a0089b6f6df7dd88bed59d0ae7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd807f0fefe02cbe0fbf0ce6e3f2b271"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gabd807f0fefe02cbe0fbf0ce6e3f2b271">LPDDR4_ReadCtlConfig</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t regValues[], uint16_t regNum[], uint16_t regCount)</td></tr>
<tr class="separator:gabd807f0fefe02cbe0fbf0ce6e3f2b271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ed7af9cb1fed86325963a907072bd5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga15ed7af9cb1fed86325963a907072bd5">LPDDR4_ReadPhyConfig</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t regValues[], uint16_t regNum[], uint16_t regCount)</td></tr>
<tr class="separator:ga15ed7af9cb1fed86325963a907072bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae27acfb90dd90c1551363094917ed6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga9ae27acfb90dd90c1551363094917ed6">LPDDR4_ReadPhyIndepConfig</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t regValues[], uint16_t regNum[], uint16_t regCount)</td></tr>
<tr class="separator:ga9ae27acfb90dd90c1551363094917ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92cefea60934551f70c67e9f30e3836e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga92cefea60934551f70c67e9f30e3836e">LPDDR4_GetCtlInterruptMask</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint64_t *mask)</td></tr>
<tr class="separator:ga92cefea60934551f70c67e9f30e3836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga807a6ec62b2c3096fbc0db8411bdc27a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga807a6ec62b2c3096fbc0db8411bdc27a">LPDDR4_SetCtlInterruptMask</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const uint64_t *mask)</td></tr>
<tr class="separator:ga807a6ec62b2c3096fbc0db8411bdc27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c44e44298a65c3d5f207318f0842e80"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga3c44e44298a65c3d5f207318f0842e80">LPDDR4_CheckCtlInterrupt</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="group___data_structure.html#ga1eceae8dc814b93076319be1564bca8c">LPDDR4_CtlInterrupt</a> intr, bool *irqStatus)</td></tr>
<tr class="separator:ga3c44e44298a65c3d5f207318f0842e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d88c87a379cbff076cc5b1280a9b9d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga53d88c87a379cbff076cc5b1280a9b9d">LPDDR4_AckCtlInterrupt</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="group___data_structure.html#ga1eceae8dc814b93076319be1564bca8c">LPDDR4_CtlInterrupt</a> intr)</td></tr>
<tr class="separator:ga53d88c87a379cbff076cc5b1280a9b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104eb09a83a6426a02d6a70cb1e53a19"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga104eb09a83a6426a02d6a70cb1e53a19">LPDDR4_GetPhyIndepInterruptMask</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, uint32_t *mask)</td></tr>
<tr class="separator:ga104eb09a83a6426a02d6a70cb1e53a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae363c18bd00feaf04666030d23e3a536"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gae363c18bd00feaf04666030d23e3a536">LPDDR4_SetPhyIndepInterruptMask</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const uint32_t *mask)</td></tr>
<tr class="separator:gae363c18bd00feaf04666030d23e3a536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060d7746a12b4ff45c0762559508a045"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga060d7746a12b4ff45c0762559508a045">LPDDR4_CheckPhyIndepInterrupt</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="group___data_structure.html#ga5116158ff4843dc700098a4a723af229">LPDDR4_PhyIndepInterrupt</a> intr, bool *irqStatus)</td></tr>
<tr class="separator:ga060d7746a12b4ff45c0762559508a045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbda3ff65752610394eafe5b42f24b28"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gacbda3ff65752610394eafe5b42f24b28">LPDDR4_AckPhyIndepInterrupt</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="group___data_structure.html#ga5116158ff4843dc700098a4a723af229">LPDDR4_PhyIndepInterrupt</a> intr)</td></tr>
<tr class="separator:gacbda3ff65752610394eafe5b42f24b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a69e7718aa23d9fbe6cd94bafc6f7a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga9a69e7718aa23d9fbe6cd94bafc6f7a7">LPDDR4_GetDebugInitInfo</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="struct_l_p_d_d_r4___debug_info__s.html">LPDDR4_DebugInfo</a> *debugInfo)</td></tr>
<tr class="separator:ga9a69e7718aa23d9fbe6cd94bafc6f7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef4374226288198eb7ba1300cfda11a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga8ef4374226288198eb7ba1300cfda11a">LPDDR4_GetLpiWakeUpTime</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const <a class="el" href="group___data_structure.html#ga3b7bbd03fb6a366c59cc780ef2b390a7">LPDDR4_LpiWakeUpParam</a> *lpiWakeUpParam, const <a class="el" href="group___data_structure.html#ga84de27fd53164bcf2fecaa333ec2e05b">LPDDR4_CtlFspNum</a> *fspNum, uint32_t *cycles)</td></tr>
<tr class="separator:ga8ef4374226288198eb7ba1300cfda11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dbe2d1da9953316c8df4109e7efe0fc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga0dbe2d1da9953316c8df4109e7efe0fc">LPDDR4_SetLpiWakeUpTime</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const <a class="el" href="group___data_structure.html#ga3b7bbd03fb6a366c59cc780ef2b390a7">LPDDR4_LpiWakeUpParam</a> *lpiWakeUpParam, const <a class="el" href="group___data_structure.html#ga84de27fd53164bcf2fecaa333ec2e05b">LPDDR4_CtlFspNum</a> *fspNum, const uint32_t *cycles)</td></tr>
<tr class="separator:ga0dbe2d1da9953316c8df4109e7efe0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1adfe28eca26af674e82da41f456efc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaf1adfe28eca26af674e82da41f456efc">LPDDR4_GetEccEnable</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="group___data_structure.html#gad6fe1cdd998012103ba2802289304d90">LPDDR4_EccEnable</a> *eccParam)</td></tr>
<tr class="separator:gaf1adfe28eca26af674e82da41f456efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c6fadadddd475cdff169275cc0c067"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga13c6fadadddd475cdff169275cc0c067">LPDDR4_SetEccEnable</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const <a class="el" href="group___data_structure.html#gad6fe1cdd998012103ba2802289304d90">LPDDR4_EccEnable</a> *eccParam)</td></tr>
<tr class="separator:ga13c6fadadddd475cdff169275cc0c067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc20d77bd0733a1d32fdccc6dd63b09"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gafcc20d77bd0733a1d32fdccc6dd63b09">LPDDR4_GetReducMode</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, <a class="el" href="group___data_structure.html#ga3d47e0e87ca1c66e5853899cdb61d763">LPDDR4_ReducMode</a> *mode)</td></tr>
<tr class="separator:gafcc20d77bd0733a1d32fdccc6dd63b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a2d1ddbfea9150ac0b39730fba70c32"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga9a2d1ddbfea9150ac0b39730fba70c32">LPDDR4_SetReducMode</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const <a class="el" href="group___data_structure.html#ga3d47e0e87ca1c66e5853899cdb61d763">LPDDR4_ReducMode</a> *mode)</td></tr>
<tr class="separator:ga9a2d1ddbfea9150ac0b39730fba70c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d0c7be3f7f295cb40653909ef599a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaf3d0c7be3f7f295cb40653909ef599a3">LPDDR4_GetDbiReadMode</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, bool *on_off)</td></tr>
<tr class="separator:gaf3d0c7be3f7f295cb40653909ef599a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f4f46c34d208e6a06d884f9280652a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gad9f4f46c34d208e6a06d884f9280652a">LPDDR4_GetDbiWriteMode</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, bool *on_off)</td></tr>
<tr class="separator:gad9f4f46c34d208e6a06d884f9280652a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f322942bb4f325e9c579dcee34472c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga64f322942bb4f325e9c579dcee34472c">LPDDR4_SetDbiMode</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const <a class="el" href="group___data_structure.html#ga3316ebeb037f1f17888cf606971c2f22">LPDDR4_DbiMode</a> *mode)</td></tr>
<tr class="separator:ga64f322942bb4f325e9c579dcee34472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880f3c3546166943d24ab4890f42227c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga880f3c3546166943d24ab4890f42227c">LPDDR4_GetRefreshRate</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const <a class="el" href="group___data_structure.html#ga84de27fd53164bcf2fecaa333ec2e05b">LPDDR4_CtlFspNum</a> *fspNum, uint32_t *cycles)</td></tr>
<tr class="separator:ga880f3c3546166943d24ab4890f42227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050da5e6ac8beee7e27456d642ae0bc8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#ga050da5e6ac8beee7e27456d642ae0bc8">LPDDR4_SetRefreshRate</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const <a class="el" href="group___data_structure.html#ga84de27fd53164bcf2fecaa333ec2e05b">LPDDR4_CtlFspNum</a> *fspNum, const uint32_t *cycles)</td></tr>
<tr class="separator:ga050da5e6ac8beee7e27456d642ae0bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba149bf084d56e58b84bfe4c9077270"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver_function_a_p_i.html#gaeba149bf084d56e58b84bfe4c9077270">LPDDR4_RefreshPerChipSelect</a> (const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *pD, const uint32_t trefInterval)</td></tr>
<tr class="separator:gaeba149bf084d56e58b84bfe4c9077270"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Prototypes for the driver API functions. The user application can link statically to the necessary API functions and call them directly. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga53d88c87a379cbff076cc5b1280a9b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_AckCtlInterrupt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga1eceae8dc814b93076319be1564bca8c">LPDDR4_CtlInterrupt</a>&#160;</td>
          <td class="paramname"><em>intr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acknowledge a specific controller interrupt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr</td><td>Interrupt to be acknowledged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if intr is not valid </dd></dl>

</div>
</div>
<a class="anchor" id="gacbda3ff65752610394eafe5b42f24b28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_AckPhyIndepInterrupt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga5116158ff4843dc700098a4a723af229">LPDDR4_PhyIndepInterrupt</a>&#160;</td>
          <td class="paramname"><em>intr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acknowledge a specific PHY Independent Module interrupt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr</td><td>Interrupt to be acknowledged </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if intr is not valid </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c44e44298a65c3d5f207318f0842e80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_CheckCtlInterrupt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga1eceae8dc814b93076319be1564bca8c">LPDDR4_CtlInterrupt</a>&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>irqStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a specific controller interrupt is active </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr</td><td>Interrupt to be checked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">irqStatus</td><td>Status of the interrupt, TRUE if active </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if intr is not valid </dd></dl>

</div>
</div>
<a class="anchor" id="ga060d7746a12b4ff45c0762559508a045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_CheckPhyIndepInterrupt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga5116158ff4843dc700098a4a723af229">LPDDR4_PhyIndepInterrupt</a>&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>irqStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a specific PHY Independent Module interrupt is active </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr</td><td>Interrupt to be checked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">irqStatus</td><td>Status of the interrupt, TRUE if active </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if intr is not valid </dd></dl>

</div>
</div>
<a class="anchor" id="ga92cefea60934551f70c67e9f30e3836e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetCtlInterruptMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the current interrupt mask for the controller </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mask</td><td>Value of interrupt mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if mask pointer is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3d0c7be3f7f295cb40653909ef599a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetDbiReadMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>on_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current value for Data Bus Inversion setting. This will be compared with the current DRAM setting using the MR3 register. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">on_off</td><td>DBI read value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if on_off is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gad9f4f46c34d208e6a06d884f9280652a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetDbiWriteMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>on_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current value for Data Bus Inversion setting. This will be compared with the current DRAM setting using the MR3 register. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">on_off</td><td>DBI write value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if on_off is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a69e7718aa23d9fbe6cd94bafc6f7a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetDebugInitInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_l_p_d_d_r4___debug_info__s.html">LPDDR4_DebugInfo</a> *&#160;</td>
          <td class="paramname"><em>debugInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve status information after a failed init. The DebugStructInfo will be filled in with error codes which can be referenced against the driver documentation for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">debugInfo</td><td>status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if debugInfo is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1adfe28eca26af674e82da41f456efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetEccEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#gad6fe1cdd998012103ba2802289304d90">LPDDR4_EccEnable</a> *&#160;</td>
          <td class="paramname"><em>eccParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current value for ECC auto correction </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eccParam</td><td>ECC parameter setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if on_off is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ef4374226288198eb7ba1300cfda11a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetLpiWakeUpTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga3b7bbd03fb6a366c59cc780ef2b390a7">LPDDR4_LpiWakeUpParam</a> *&#160;</td>
          <td class="paramname"><em>lpiWakeUpParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga84de27fd53164bcf2fecaa333ec2e05b">LPDDR4_CtlFspNum</a> *&#160;</td>
          <td class="paramname"><em>fspNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current value of Low power Interface wake up time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lpiWakeUpParam</td><td>LPI timing parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fspNum</td><td>Frequency copy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cycles</td><td>Timing value(in cycles) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if powerMode is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga02b7f0c9a7f544b0985dab2b36f70645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetMmrRegister </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>readModeRegVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>mmrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mmrStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a memory mode register from DRAM </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">readModeRegVal</td><td>Value to set in 'read_modereg' parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mmrValue</td><td>Value which is read from memory mode register(mmr) for all devices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mmrStatus</td><td>Status of mode register read(mrr) instruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regNumber is out of range or regValue is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga104eb09a83a6426a02d6a70cb1e53a19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetPhyIndepInterruptMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the current interrupt mask for the PHY Independent Module </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mask</td><td>Value of interrupt mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if mask pointer is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gafcc20d77bd0733a1d32fdccc6dd63b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetReducMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga3d47e0e87ca1c66e5853899cdb61d763">LPDDR4_ReducMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current value for the Half Datapath option </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Half Datapath setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if mode is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga880f3c3546166943d24ab4890f42227c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_GetRefreshRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga84de27fd53164bcf2fecaa333ec2e05b">LPDDR4_CtlFspNum</a> *&#160;</td>
          <td class="paramname"><em>fspNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current value for the refresh rate (reading Refresh per command timing). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fspNum</td><td>Frequency set number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cycles</td><td>Refresh rate (in cycles) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if rate is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga42c7f28ca1815b81f98db4dfb447634d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___config__s.html">LPDDR4_Config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init function to be called after LPDDR4_probe() to set up the driver configuration. Memory should be allocated for drv_data (using the size determined using LPDDR4_probe) before calling this API. init_settings should be initialised with base addresses for PHY Indepenent Module, Controller and PHY before calling this function. If callbacks are required for interrupt handling, these should also be configured in init_settings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Specifies driver/hardware configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success </dd>
<dd>
CDN_EINVAL if illegal/inconsistent values in cfg. </dd>
<dd>
CDN_ENOTSUP if hardware has an inconsistent configuration or doesn't support feature(s) required by 'config' parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9b673939a711f62c11f0ccf5ddafc26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_Probe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___config__s.html">LPDDR4_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>configSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks configuration object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Driver/hardware configuration required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">configSize</td><td>Size of memory allocations required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success (requirements structure filled). </dd>
<dd>
CDN_ENOTSUP if configuration cannot be supported due to driver/hardware constraints. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd807f0fefe02cbe0fbf0ce6e3f2b271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_ReadCtlConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regNum</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read values of the controller registers in bulk and store in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValues</td><td>Pointer to feedback the read values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regNum</td><td>Register Number to be read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regCount</td><td>Count of registers to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regValues is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga15ed7af9cb1fed86325963a907072bd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_ReadPhyConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regNum</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the values of the PHY module registers in bulk and store in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValues</td><td>Pointer to feedback the read values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regNum</td><td>Register Number to be read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regCount</td><td>Count of registers to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regValues is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ae27acfb90dd90c1551363094917ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_ReadPhyIndepConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regNum</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the values of the PHY Independent module registers in bulk and store in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValues</td><td>Pointer to feedback the read values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regNum</td><td>Register Number to be read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regCount</td><td>Count of registers to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regValues is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gacae10c34462f83915da68d8f22ba339c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_ReadReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga667139fd1b36917fe2e4d30476fac6d0">LPDDR4_RegBlock</a>&#160;</td>
          <td class="paramname"><em>cpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>regValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a register from the controller, PHY or PHY Independent Module </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpp</td><td>Indicates whether controller, PHY or PHY Independent Module register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regOffset</td><td>Register offset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">regValue</td><td>Register value read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regOffset if out of range or regValue is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaeba149bf084d56e58b84bfe4c9077270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_RefreshPerChipSelect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trefInterval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle Refreshing per chip select </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trefInterval</td><td>status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if chipSelect is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga807a6ec62b2c3096fbc0db8411bdc27a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_SetCtlInterruptMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the interrupt mask for the controller </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Value of interrupt mask to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if mask pointer is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga64f322942bb4f325e9c579dcee34472c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_SetDbiMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga3316ebeb037f1f17888cf606971c2f22">LPDDR4_DbiMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the mode for Data Bus Inversion. This will also be set in DRAM using the MR3 controller register. This API must be called before startup of memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if mode is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga13c6fadadddd475cdff169275cc0c067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_SetEccEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#gad6fe1cdd998012103ba2802289304d90">LPDDR4_EccEnable</a> *&#160;</td>
          <td class="paramname"><em>eccParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the value for ECC auto correction. This API must be called before startup of memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccParam</td><td>ECC control parameter setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if on_off is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dbe2d1da9953316c8df4109e7efe0fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_SetLpiWakeUpTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga3b7bbd03fb6a366c59cc780ef2b390a7">LPDDR4_LpiWakeUpParam</a> *&#160;</td>
          <td class="paramname"><em>lpiWakeUpParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga84de27fd53164bcf2fecaa333ec2e05b">LPDDR4_CtlFspNum</a> *&#160;</td>
          <td class="paramname"><em>fspNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current value of Low power Interface wake up time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lpiWakeUpParam</td><td>LPI timing parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fspNum</td><td>Frequency copy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cycles</td><td>Timing value(in cycles) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if powerMode is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gada30019ba9f2a3f42d7e56a17e1188e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_SetMmrRegister </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>writeModeRegVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mrwStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a memory mode register in DRAM </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">writeModeRegVal</td><td>Value to set in 'write_modereg' parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mrwStatus</td><td>Status of mode register write(mrw) instruction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regNumber is out of range or regValue is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gae363c18bd00feaf04666030d23e3a536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_SetPhyIndepInterruptMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the interrupt mask for the PHY Independent Module </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Value of interrupt mask to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if mask pointer is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a2d1ddbfea9150ac0b39730fba70c32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_SetReducMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga3d47e0e87ca1c66e5853899cdb61d763">LPDDR4_ReducMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the value for the Half Datapath option. This API must be called before startup of memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Half Datapath setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if mode is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga050da5e6ac8beee7e27456d642ae0bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_SetRefreshRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___data_structure.html#ga84de27fd53164bcf2fecaa333ec2e05b">LPDDR4_CtlFspNum</a> *&#160;</td>
          <td class="paramname"><em>fspNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the refresh rate (writing Refresh per command timing). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fspNum</td><td>Frequency set number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cycles</td><td>Refresh rate (in cycles) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if rate is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga3591218c4b0b6cfc193b0cac1dfc94ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_Start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the driver. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5dcb571b46e6143eab5ff30b834cd28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_WriteCtlConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regNum</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a set of initialisation values to the controller registers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValues</td><td>Register values to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regNum</td><td>Register Number to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regCount</td><td>Count of registers to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regValues is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5d41dc38b4fc7763d0e478cae357427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_WritePhyConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regNum</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a set of initialisation values to the PHY registers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValues</td><td>Register values to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regNum</td><td>Register Number to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regCount</td><td>Count of registers to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regValues is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb6a0089b6f6df7dd88bed59d0ae7628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_WritePhyIndepConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regNum</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>regCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a set of initialisation values to the PHY Independent Module registers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValues</td><td>Register values to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regNum</td><td>Register Number to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regCount</td><td>Count of registers to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regValues is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gad3fdab52d7d656ad5ecbda45b54f18bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPDDR4_WriteReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_p_d_d_r4___private_data__s.html">LPDDR4_PrivateData</a> *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data_structure.html#ga667139fd1b36917fe2e4d30476fac6d0">LPDDR4_RegBlock</a>&#160;</td>
          <td class="paramname"><em>cpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a register in the controller, PHY or PHY Independent Module </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pD</td><td>Driver state info specific to this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cpp</td><td>Indicates whether controller, PHY or PHY Independent Module register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regOffset</td><td>Register offset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regValue</td><td>Register value to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CDN_EOK on success. </dd>
<dd>
CDN_EINVAL if regOffset is out of range or regValue is NULL </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
