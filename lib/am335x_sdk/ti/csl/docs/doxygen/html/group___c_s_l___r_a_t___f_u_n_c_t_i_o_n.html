<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RAT Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RAT Functions<div class="ingroups"><a class="el" href="group___c_s_l___r_a_t___a_p_i.html">Region-based Address Translation (RAT)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaca162ebf653f02de9326ce296a43d091"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gaca162ebf653f02de9326ce296a43d091">CSL_ratGetRevision</a> (const CSL_ratRegs *pRatRegs)</td></tr>
<tr class="separator:gaca162ebf653f02de9326ce296a43d091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd02724e8eebdf1517530f5befa07a11"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gabd02724e8eebdf1517530f5befa07a11">CSL_ratGetMaxRegions</a> (const CSL_ratRegs *pRatRegs)</td></tr>
<tr class="separator:gabd02724e8eebdf1517530f5befa07a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551238f5ab3a029f7d4aa8377523505"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga2551238f5ab3a029f7d4aa8377523505">CSL_ratIsRegionTranslationEnabled</a> (const CSL_ratRegs *pRatRegs, uint32_t regionIndex)</td></tr>
<tr class="separator:ga2551238f5ab3a029f7d4aa8377523505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd8504b4eb10e7380faa8ec80adc203"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga8dd8504b4eb10e7380faa8ec80adc203">CSL_ratSetErrMsgDestId</a> (CSL_ratRegs *pRatRegs, uint32_t destId)</td></tr>
<tr class="separator:ga8dd8504b4eb10e7380faa8ec80adc203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c7b633ee5f9eaec2f6cd4cd98a1917"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga45c7b633ee5f9eaec2f6cd4cd98a1917">CSL_ratGetErrMsgDestId</a> (const CSL_ratRegs *pRatRegs, uint32_t *pDestId)</td></tr>
<tr class="separator:ga45c7b633ee5f9eaec2f6cd4cd98a1917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaaf2a55b968439b2adb877803b26280"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gacaaf2a55b968439b2adb877803b26280">CSL_ratEnableExceptionLogging</a> (CSL_ratRegs *pRatRegs)</td></tr>
<tr class="separator:gacaaf2a55b968439b2adb877803b26280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c854d2d939207be9140555de304178"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gad9c854d2d939207be9140555de304178">CSL_ratDisableExceptionLogging</a> (CSL_ratRegs *pRatRegs)</td></tr>
<tr class="separator:gad9c854d2d939207be9140555de304178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0397e2b6e6c6bbd8d354a0b53629202"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gac0397e2b6e6c6bbd8d354a0b53629202">CSL_ratIsExceptionLoggingEnabled</a> (const CSL_ratRegs *pRatRegs)</td></tr>
<tr class="separator:gac0397e2b6e6c6bbd8d354a0b53629202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51295c6e7159e5e28f9610fb5154e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gae51295c6e7159e5e28f9610fb5154e5e">CSL_ratIsIntrPending</a> (const CSL_ratRegs *pRatRegs, CSL_RatIntrSrcTypes intrSrc)</td></tr>
<tr class="separator:gae51295c6e7159e5e28f9610fb5154e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf10b4ba87f86df2f665e8e3c69cd6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga6bf10b4ba87f86df2f665e8e3c69cd6e">CSL_ratSetIntrPending</a> (CSL_ratRegs *pRatRegs, CSL_RatIntrSrcTypes intrSrc)</td></tr>
<tr class="separator:ga6bf10b4ba87f86df2f665e8e3c69cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c709e3e424df40c0c4c4198035e6ecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga9c709e3e424df40c0c4c4198035e6ecb">CSL_ratClrIntrPending</a> (CSL_ratRegs *pRatRegs, CSL_RatIntrSrcTypes intrSrc)</td></tr>
<tr class="separator:ga9c709e3e424df40c0c4c4198035e6ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae952dd0fa5fd33568f922b7d3d06169f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gae952dd0fa5fd33568f922b7d3d06169f">CSL_ratAckIntr</a> (CSL_ratRegs *pRatRegs, CSL_RatIntrSrcTypes intrSrc)</td></tr>
<tr class="separator:gae952dd0fa5fd33568f922b7d3d06169f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9d777d92eea8ae3d7cba494f110686"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gacc9d777d92eea8ae3d7cba494f110686">CSL_ratEnableIntr</a> (CSL_ratRegs *pRatRegs, CSL_RatIntrSrcTypes intrSrc)</td></tr>
<tr class="separator:gacc9d777d92eea8ae3d7cba494f110686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga328f454fe702319856ef3c6569ac4b8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga328f454fe702319856ef3c6569ac4b8e">CSL_ratDisableIntr</a> (CSL_ratRegs *pRatRegs, CSL_RatIntrSrcTypes intrSrc)</td></tr>
<tr class="separator:ga328f454fe702319856ef3c6569ac4b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96317a633cc14efcc50fb46ff2d6246b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga96317a633cc14efcc50fb46ff2d6246b">CSL_ratGetExceptionInfo</a> (CSL_ratRegs *pRatRegs, <a class="el" href="struct_c_s_l___rat_exception_info.html">CSL_RatExceptionInfo</a> *pExceptionInfo)</td></tr>
<tr class="separator:ga96317a633cc14efcc50fb46ff2d6246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c0c0d5e8f0890cf21994dbfebe9c77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga32c0c0d5e8f0890cf21994dbfebe9c77">CSL_ratEnableRegionTranslation</a> (CSL_ratRegs *pRatRegs, uint32_t regionIndex)</td></tr>
<tr class="separator:ga32c0c0d5e8f0890cf21994dbfebe9c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab899e0a2c8393aab3577cc61a253daa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gab899e0a2c8393aab3577cc61a253daa0">CSL_ratDisableRegionTranslation</a> (CSL_ratRegs *pRatRegs, uint32_t regionIndex)</td></tr>
<tr class="separator:gab899e0a2c8393aab3577cc61a253daa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8f6f47613738d88b98082fc70eb8999"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gae8f6f47613738d88b98082fc70eb8999">CSL_ratConfigRegionTranslation</a> (CSL_ratRegs *pRatRegs, uint32_t regionIndex, <a class="el" href="struct_c_s_l___rat_translation_cfg_info.html">CSL_RatTranslationCfgInfo</a> *pTranslationCfg)</td></tr>
<tr class="separator:gae8f6f47613738d88b98082fc70eb8999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69c9d6259b36561e9bd796a7ad6351c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gae69c9d6259b36561e9bd796a7ad6351c">CSL_ratVerifyConfigRegionTranslation</a> (CSL_ratRegs *pRatRegs, uint32_t regionIndex, <a class="el" href="struct_c_s_l___rat_translation_cfg_info.html">CSL_RatTranslationCfgInfo</a> *pTranslationCfg)</td></tr>
<tr class="separator:gae69c9d6259b36561e9bd796a7ad6351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae952dd0fa5fd33568f922b7d3d06169f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratAckIntr </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_RatIntrSrcTypes&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratAckIntr</b> </p>
<p><b>Description</b> <br />
 This function is used to acknowledge the specified interrupt source.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 intrSrc - The interrupt source of type <a class="el" href="group___c_s_l___r_a_t___e_n_u_m.html#CSL_RatIntrSrcTypes">CSL_RatIntrSrcTypes</a></p>
<p><b> Return Value </b> <br />
 true - Success <br />
 false - The specified interrupt source is invalid</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 EOI_REG</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;

   CSL_ratAckIntr(pRatRegs, CSL_RAT_INTR_SRC_EXCEPTION);
</pre> 
</div>
</div>
<a class="anchor" id="ga9c709e3e424df40c0c4c4198035e6ecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratClrIntrPending </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_RatIntrSrcTypes&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratClrIntrPending</b> </p>
<p><b>Description</b> <br />
 This function is used to clear the pending status of the specified interrupt source.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 intrSrc - The interrupt source of type <a class="el" href="group___c_s_l___r_a_t___e_n_u_m.html#CSL_RatIntrSrcTypes">CSL_RatIntrSrcTypes</a></p>
<p><b> Return Value </b> <br />
 true - Success <br />
 false - The specified interrupt source is invalid</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 EXCEPTION_PEND_CLEAR</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;

   CSL_ratClrIntrPending(pRatRegs, CSL_RAT_INTR_SRC_EXCEPTION);
</pre> 
</div>
</div>
<a class="anchor" id="gae8f6f47613738d88b98082fc70eb8999"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratConfigRegionTranslation </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___rat_translation_cfg_info.html">CSL_RatTranslationCfgInfo</a> *&#160;</td>
          <td class="paramname"><em>pTranslationCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratConfigRegionTranslation</b> </p>
<p><b>Description</b> <br />
 This function is used to configure a region address translation for the specified region index. The translation is automatically enabled after it is configured.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 regionIndex - The index of the region to configure. This value must be in the range 0..(<a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gabd02724e8eebdf1517530f5befa07a11">CSL_ratGetMaxRegions()</a>-1) inclusive. <br />
 pTranslationCfg - A pointer of type <a class="el" href="struct_c_s_l___rat_translation_cfg_info.html" title="This structure contains information required to configure an address translation region. ">CSL_RatTranslationCfgInfo</a> containing configuration information</p>
<p><b> Return Value </b> <br />
 true - The region address translation was configured properly <br />
 false - An error occurred. Either 1) the regionIndex was out of range, 2) the region base address and translated base address are not aligned to the region size, or 3) this region overlaps another enabled region's address range.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CSL_RAT_CTRL, CSL_RAT_BASE, CSL_RAT_LOWER, CSL_RAT_UPPER</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs       *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   CSL_RatTranslationCfgInfo   TranslationCfg =
   {
       0x00010000,     // sizeInBytes
       0x00020000,     // baseAddress
       0x01000000      // translatedAddress
   };

   CSL_ratConfigRegionTranslation(pRatRegs, 0, &amp;TranslationCfg);
</pre> 
</div>
</div>
<a class="anchor" id="gad9c854d2d939207be9140555de304178"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ratDisableExceptionLogging </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratDisableExceptionLogging</b> </p>
<p><b>Description</b> <br />
 This function disables the exception logging capability. It also disables the module's exception interrupt signal generation, regardless of whether the exception interrupt source is enabled or disabled.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module</p>
<p><b> Return Value </b> <br />
 CSL_PASS - Disable the exception logging capability is successful. <br />
 CS:_EFAIL - An error occurred, base address pointer is NULL.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 EXCEPTION_LOGGING_CONTROL</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;

   CSL_ratDisableExceptionLogging(pRatRegs);
</pre> 
</div>
</div>
<a class="anchor" id="ga328f454fe702319856ef3c6569ac4b8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratDisableIntr </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_RatIntrSrcTypes&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratDisableIntr</b> </p>
<p><b>Description</b> <br />
 This function disables the specified interrupt source. This prevents the module's exception interrupt signal from being asserted. Note that software can still call <a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gae51295c6e7159e5e28f9610fb5154e5e">CSL_ratIsIntrPending</a> to poll for an exception event and call <a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#ga96317a633cc14efcc50fb46ff2d6246b">CSL_ratGetExceptionInfo</a> to read exception event information if exception logging is enabled.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 intrSrc - The interrupt source of type <a class="el" href="group___c_s_l___r_a_t___e_n_u_m.html#CSL_RatIntrSrcTypes">CSL_RatIntrSrcTypes</a></p>
<p><b> Return Value </b> <br />
 true - Success <br />
 false - The specified interrupt source is invalid</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 EXCEPTION_ENABLE_CLEAR</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;

   CSL_ratDisableIntr(pRatRegs, CSL_RAT_INTR_SRC_EXCEPTION);
</pre> 
</div>
</div>
<a class="anchor" id="gab899e0a2c8393aab3577cc61a253daa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratDisableRegionTranslation </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratDisableRegionTranslation</b> </p>
<p><b>Description</b> <br />
 This function disables address translation for the specified region.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 regionIndex - The index of the region to configure. This value must be in the range 0..(<a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gabd02724e8eebdf1517530f5befa07a11">CSL_ratGetMaxRegions()</a>-1) inclusive.</p>
<p><b> Return Value </b> <br />
 true - The function completed successfully <br />
 false - An error occurred. Either 1) the regionIndex was out of range, or if enabling, 2) the region base address and translated base address are not aligned to the region size, or 3) this region overlaps another enabled region's address range.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CSL_RAT_CTRL</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   uint32_t       regionIndex = CSL_ratGetMaxRegions(pRatRegs) - 1;

   CSL_ratDisableRegionTranslation(pRatRegs, regionIndex);
</pre> 
</div>
</div>
<a class="anchor" id="gacaaf2a55b968439b2adb877803b26280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ratEnableExceptionLogging </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratEnableExceptionLogging</b> </p>
<p><b>Description</b> <br />
 This function enables the exception logging capability. It also enables exception interrupt generation. The module's exception interrupt signal is asserted if the exception logging capability is enabled and the exception interrupt source is enabled by calling the <a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gacc9d777d92eea8ae3d7cba494f110686">CSL_ratEnableIntr</a> function.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 EXCEPTION_LOGGING_CONTROL</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;

   CSL_ratEnableExceptionLogging(pRatRegs);
</pre><p> <br />
 CSL_PASS - Enable the exception logging capability is successful. <br />
 CS:_EFAIL - An error occurred, base address pointer is NULL. </p>

</div>
</div>
<a class="anchor" id="gacc9d777d92eea8ae3d7cba494f110686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratEnableIntr </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_RatIntrSrcTypes&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratEnableIntr</b> </p>
<p><b>Description</b> <br />
 This function enables the specified interrupt source. It also calls <a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gacaaf2a55b968439b2adb877803b26280">CSL_ratEnableExceptionLogging</a> to enable exception logging as there is no valid reason to enable the exception interrupt source and not log the exception information and assert the module's exception interrupt signal.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 intrSrc - The interrupt source of type <a class="el" href="group___c_s_l___r_a_t___e_n_u_m.html#CSL_RatIntrSrcTypes">CSL_RatIntrSrcTypes</a></p>
<p><b> Return Value </b> <br />
 true - Success <br />
 false - The specified interrupt source is invalid</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 EXCEPTION_ENABLE_SET</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;

   CSL_ratEnableIntr(pRatRegs, CSL_RAT_INTR_SRC_EXCEPTION);
</pre> 
</div>
</div>
<a class="anchor" id="ga32c0c0d5e8f0890cf21994dbfebe9c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratEnableRegionTranslation </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratEnableRegionTranslation</b> </p>
<p><b>Description</b> <br />
 This function enables address translation for the specified region.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 regionIndex - The index of the region to configure. This value must be in the range 0..(<a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gabd02724e8eebdf1517530f5befa07a11">CSL_ratGetMaxRegions()</a>-1) inclusive.</p>
<p><b> Return Value </b> <br />
 true - The function completed successfully <br />
 false - An error occurred. Either 1) the regionIndex was out of range, or if enabling, 2) the region base address and translated base address are not aligned to the region size, or 3) this region overlaps another enabled region's address range.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CSL_RAT_CTRL</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   uint32_t    regionIndex = CSL_ratGetMaxRegions(pRatRegs) - 1;

   CSL_ratEnableRegionTranslation(pRatRegs, regionIndex);
</pre> 
</div>
</div>
<a class="anchor" id="ga45c7b633ee5f9eaec2f6cd4cd98a1917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ratGetErrMsgDestId </td>
          <td>(</td>
          <td class="paramtype">const CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pDestId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratGetErrMsgDestId</b> </p>
<p><b>Description</b> <br />
 This function is used to read the destination ID for error messages.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 pDestId - A pointer to hold the destination ID register value</p>
<p><b> Return Value </b> <br />
 CSL_PASS - Get destination ID for error messages is successful. <br />
 CS:_EFAIL - An error occurred. Either 1) base address pointer is NULL, 2) destination ID pointer is NULL.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>reads</b> <br />
 DESTINATION_ID</p>
<p><b>Example</b> </p><pre class="fragment">  CSL_ratRegs   *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
  uint32_t      destId;

  CSL_ratGetErrMsgDestId(pRatRegs, &amp;destId);
</pre> 
</div>
</div>
<a class="anchor" id="ga96317a633cc14efcc50fb46ff2d6246b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratGetExceptionInfo </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___rat_exception_info.html">CSL_RatExceptionInfo</a> *&#160;</td>
          <td class="paramname"><em>pExceptionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratGetExceptionInfo</b> </p>
<p><b>Description</b> <br />
 This function is used to get information for the last boundary crossing transaction exception captured. The log is automatically cleared by this function so that a future exception can be captured.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 pExceptionInfo - A pointer to a <a class="el" href="struct_c_s_l___rat_exception_info.html" title="This structure contains exception status information returned by the CSL_ratGetExceptionInfo function...">CSL_RatExceptionInfo</a> structure containing returned exception information</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 EXCEPTION_LOGGING_HEADER0, EXCEPTION_LOGGING_HEADER1, EXCEPTION_LOGGING_DATA0, EXCEPTION_LOGGING_DATA1, EXCEPTION_LOGGING_DATA2, EXCEPTION_LOGGING_DATA3</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs   *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   CSL_RatExceptionInfo     ExceptionInfo;

   CSL_ratGetExceptionInfo(pRatRegs, &amp;ExceptionInfo);
</pre> 
</div>
</div>
<a class="anchor" id="gabd02724e8eebdf1517530f5befa07a11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ratGetMaxRegions </td>
          <td>(</td>
          <td class="paramtype">const CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratGetMaxRegions</b> </p>
<p><b>Description</b> <br />
 This function returns the maximum number of regions that can be configured.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module</p>
<p><b> Return Value </b> <br />
 The the maximum number of regions that can be configured in this RAT</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   uint32_t    maxRegions;

   maxRegions = CSL_ratGetMaxRegions(pRatRegs);
</pre> 
</div>
</div>
<a class="anchor" id="gaca162ebf653f02de9326ce296a43d091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ratGetRevision </td>
          <td>(</td>
          <td class="paramtype">const CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratGetRevision</b> </p>
<p><b>Description</b> <br />
 This function returns the revision information for the RAT</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module</p>
<p><b> Return Value </b> <br />
 Revision information. See design specification for details.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PID</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   uint32_t    rev;

   rev = CSL_ratGetRevision(pRatRegs);
</pre> 
</div>
</div>
<a class="anchor" id="gac0397e2b6e6c6bbd8d354a0b53629202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ratIsExceptionLoggingEnabled </td>
          <td>(</td>
          <td class="paramtype">const CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratIsExceptionLoggingEnabled</b> </p>
<p><b>Description</b> <br />
 This function is used to determine if the exception logging capability is enabled or disabled.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module</p>
<p><b> Return Value </b> <br />
 Returns true if exception logging is enabled otherwise false</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 EXCEPTION_LOGGING_CONTROL</p>
<p><b>Example</b> </p><pre class="fragment">      CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
      uint32_t        status;
      status = CSL_ratIsExceptionLoggingEnabled(pRatRegs);</pre> 
</div>
</div>
<a class="anchor" id="gae51295c6e7159e5e28f9610fb5154e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratIsIntrPending </td>
          <td>(</td>
          <td class="paramtype">const CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_RatIntrSrcTypes&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratIsIntrPending</b> </p>
<p><b>Description</b> <br />
 This function returns the pending interrupt status of the specified interrupt source.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 intrSrc - The interrupt source of type <a class="el" href="group___c_s_l___r_a_t___e_n_u_m.html#CSL_RatIntrSrcTypes">CSL_RatIntrSrcTypes</a></p>
<p><b> Return Value </b> <br />
 true - An interrupt of the specified source is pending <br />
 false - An interrupt of the specified source is not pending</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 EXCEPTION_PEND_SET</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_ratRegs   *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
*      bool                    bIntPending;
*
*      bIntPending = CSL_ratIsIntrPending(pRatRegs, CSL_RAT_INTR_SRC_EXCEPTION);
*      printf("Exception interrupt is %s\n", bIntPending ? "pending" : "not pending" );
*   </pre> 
</div>
</div>
<a class="anchor" id="ga2551238f5ab3a029f7d4aa8377523505"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratIsRegionTranslationEnabled </td>
          <td>(</td>
          <td class="paramtype">const CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratIsRegionTranslationEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the enable status of the specified region address translation</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 regionIndex - The index of the region to configure. This value must be in the range 0..(<a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gabd02724e8eebdf1517530f5befa07a11">CSL_ratGetMaxRegions()</a>-1) inclusive.</p>
<p><b> Return Value </b> <br />
 true - The specified region address translation is enabled <br />
 false - The specified region address translation is not enabled</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CSL_RAT_CTRL</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   uint32_t    regionIndex = 0;
   bool        bIsEnabled;

   bIsEnabled = CSL_ratIsRegionTranslationEnabled(pRatRegs,regionIndex);
   printf("Address translation for region %u is %s\n", regionIndex, bIsEnabled ? "enabled" : "not enabled" );
</pre> 
</div>
</div>
<a class="anchor" id="ga8dd8504b4eb10e7380faa8ec80adc203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ratSetErrMsgDestId </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratSetErrMsgDestId</b> </p>
<p><b>Description</b> <br />
 This function is used to set the destination ID for error messages.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 destId - The destination ID for future error messages</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 DESTINATION_ID</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs   *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   uint32_t      destId = 0;

   CSL_ratSetErrMsgDestId(pRatRegs, destId);
</pre><p> <br />
 CSL_PASS - Set destination ID for error messages is successful <br />
 CS:_EFAIL - An error occurred. Either 1) base address pointer is NULL, 2) destination ID value is invalid. </p>

</div>
</div>
<a class="anchor" id="ga6bf10b4ba87f86df2f665e8e3c69cd6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_ratSetIntrPending </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_RatIntrSrcTypes&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratSetIntrPending</b> </p>
<p><b>Description</b> <br />
 This function is used to forceably set the pending status of the specified interrupt source.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 intrSrc - The interrupt source of type <a class="el" href="group___c_s_l___r_a_t___e_n_u_m.html#CSL_RatIntrSrcTypes">CSL_RatIntrSrcTypes</a></p>
<p><b> Return Value </b> <br />
 true - Success <br />
 false - The specified interrupt source is invalid</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 EXCEPTION_PEND_SET</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs    *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;

   CSL_ratSetIntrPending(pRatRegs, CSL_RAT_INTR_SRC_EXCEPTION);
</pre> 
</div>
</div>
<a class="anchor" id="gae69c9d6259b36561e9bd796a7ad6351c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ratVerifyConfigRegionTranslation </td>
          <td>(</td>
          <td class="paramtype">CSL_ratRegs *&#160;</td>
          <td class="paramname"><em>pRatRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___rat_translation_cfg_info.html">CSL_RatTranslationCfgInfo</a> *&#160;</td>
          <td class="paramname"><em>pTranslationCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ratVerifyConfigRegionTranslation</b> </p>
<p><b>Description</b> <br />
 This function is used to check configure a region address translation for the specified region index. The translation is checked for enable after it is configured.</p>
<p><b>Arguments</b> <br />
 pRatRegs - A pointer (of type CSL_ratRegs*) to the base address of the RAT module <br />
 regionIndex - The index of the region to configure. This value must be in the range 0..(<a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gabd02724e8eebdf1517530f5befa07a11">CSL_ratGetMaxRegions()</a>-1) inclusive. <br />
 pTranslationCfg - A pointer of type <a class="el" href="struct_c_s_l___rat_translation_cfg_info.html" title="This structure contains information required to configure an address translation region. ">CSL_RatTranslationCfgInfo</a> containing configuration information</p>
<p><b> Return Value </b> <br />
 CSL_PASS - The region address translation was configured properly <br />
 CS:_EFAIL - An error occurred. Either 1) the regionIndex was out of range, 2) the region base address and translated base address are not aligned to the region size, or 3) this region overlaps another enabled region's address range.</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___r_a_t___f_u_n_c_t_i_o_n.html#gae8f6f47613738d88b98082fc70eb8999">CSL_ratConfigRegionTranslation()</a> API is called to prior for RAT config and returned true (success)</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CSL_RAT_CTRL, CSL_RAT_BASE, CSL_RAT_LOWER, CSL_RAT_UPPER</p>
<p><b>Example</b> </p><pre class="fragment">   CSL_ratRegs       *pRatRegs = (CSL_ratRegs *)RAT_BASE_ADDRESS;
   int32_t            status;
   CSL_RatTranslationCfgInfo   TranslationCfg =
   {
       0x00010000,     // sizeInBytes
       0x00020000,     // baseAddress
       0x01000000      // translatedAddress
   };

   status = CSL_ratVerifyConfigRegionTranslation(pRatRegs, 0, &amp;TranslationCfg);
</pre> 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
