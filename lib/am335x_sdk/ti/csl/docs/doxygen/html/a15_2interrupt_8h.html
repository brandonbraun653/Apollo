<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>interrupt.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ea9599923402ca8ab47fc3e495999dea.html">arch</a></li><li class="navelem"><a class="el" href="dir_0550b2aff0c46de3ed5936b6fa19301e.html">a15</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">a15/interrupt.h File Reference<div class="ingroups"><a class="el" href="group___c_s_l___a_r_c_h.html">CSL ARCH Module</a> &raquo; <a class="el" href="group___c_s_l___a_r_c_h___a15.html">A15</a> &raquo; <a class="el" href="group___c_s_l___a_r_c_h___a15___i_n_t_e_r_r_u_p_t.html">Interrupt</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains the API prototypes for configuring INTC for ARM Cortex-A15.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="csl__arch_8h.html">ti/csl/arch/csl_arch.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="hw__types_8h.html">ti/csl/hw_types.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adbf14fc8f1fb9ad3edd5a37c1feb5a1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#adbf14fc8f1fb9ad3edd5a37c1feb5a1c">Intc_IntRegister</a> (uint16_t intrNum, IntrFuncPtr fptr, void *fun_arg)</td></tr>
<tr class="memdesc:adbf14fc8f1fb9ad3edd5a37c1feb5a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an interrupt Handler in the interrupt vector table for system interrupts.  <a href="#adbf14fc8f1fb9ad3edd5a37c1feb5a1c">More...</a><br /></td></tr>
<tr class="separator:adbf14fc8f1fb9ad3edd5a37c1feb5a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0d7290cd712e7bcfea80c900dd6da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#aca0d7290cd712e7bcfea80c900dd6da2">Intc_IntUnregister</a> (uint16_t intrNum)</td></tr>
<tr class="memdesc:aca0d7290cd712e7bcfea80c900dd6da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an interrupt.  <a href="#aca0d7290cd712e7bcfea80c900dd6da2">More...</a><br /></td></tr>
<tr class="separator:aca0d7290cd712e7bcfea80c900dd6da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d4462aeeeaefcc22533c1ccfe0cc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#ad14d4462aeeeaefcc22533c1ccfe0cc7">Intc_Init</a> (void)</td></tr>
<tr class="memdesc:ad14d4462aeeeaefcc22533c1ccfe0cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to initialize the interrupt controller. This API shall be called before using the interrupt controller.  <a href="#ad14d4462aeeeaefcc22533c1ccfe0cc7">More...</a><br /></td></tr>
<tr class="separator:ad14d4462aeeeaefcc22533c1ccfe0cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86093c96128baa5af1603e601d3ee496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a86093c96128baa5af1603e601d3ee496">Intc_IntPrioritySet</a> (uint16_t intrNum, uint16_t priority, uint8_t hostIntRoute)</td></tr>
<tr class="memdesc:a86093c96128baa5af1603e601d3ee496"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API assigns a priority to an interrupt and routes it to either IRQ or to FIQ. Priority 0 is the highest priority level Among the host interrupts, FIQ has more priority than IRQ.  <a href="#a86093c96128baa5af1603e601d3ee496">More...</a><br /></td></tr>
<tr class="separator:a86093c96128baa5af1603e601d3ee496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5d4094844e6b53e70d5dadda16ab3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a0d5d4094844e6b53e70d5dadda16ab3a">Intc_SystemEnable</a> (uint16_t intrNum)</td></tr>
<tr class="memdesc:a0d5d4094844e6b53e70d5dadda16ab3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the system interrupt in INTC. However, for the interrupt generation, make sure that the interrupt is enabled at the peripheral level also.  <a href="#a0d5d4094844e6b53e70d5dadda16ab3a">More...</a><br /></td></tr>
<tr class="separator:a0d5d4094844e6b53e70d5dadda16ab3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c41dd88a707773ee5c2054b63acb54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a67c41dd88a707773ee5c2054b63acb54">Intc_SystemDisable</a> (uint16_t intrNum)</td></tr>
<tr class="memdesc:a67c41dd88a707773ee5c2054b63acb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the system interrupt in INTC.  <a href="#a67c41dd88a707773ee5c2054b63acb54">More...</a><br /></td></tr>
<tr class="separator:a67c41dd88a707773ee5c2054b63acb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb771411ec290f7d5f8354269b22f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a9fb771411ec290f7d5f8354269b22f0a">IntEnableSecureMode</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:a9fb771411ec290f7d5f8354269b22f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the interrupt passed to secure. In secure mode interrupts can be routed to either IRQ or FIQ.  <a href="#a9fb771411ec290f7d5f8354269b22f0a">More...</a><br /></td></tr>
<tr class="separator:a9fb771411ec290f7d5f8354269b22f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a071144b052693eb042098add0157d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a89a071144b052693eb042098add0157d">IntDisableSecureMode</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:a89a071144b052693eb042098add0157d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the interrupt passed to non-secure. In non-secure mode interrupts can only be routed to IRQ.  <a href="#a89a071144b052693eb042098add0157d">More...</a><br /></td></tr>
<tr class="separator:a89a071144b052693eb042098add0157d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40a9ad3a14364236cd7e175a3637fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#ab40a9ad3a14364236cd7e175a3637fd3">IntSetPendingState</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:ab40a9ad3a14364236cd7e175a3637fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the status of the interrupt passed to pending.  <a href="#ab40a9ad3a14364236cd7e175a3637fd3">More...</a><br /></td></tr>
<tr class="separator:ab40a9ad3a14364236cd7e175a3637fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3072027cd175f51e53b7eac0ee006e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a3072027cd175f51e53b7eac0ee006e6d">IntClearPendingState</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:a3072027cd175f51e53b7eac0ee006e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the pending status of interrupt passed.  <a href="#a3072027cd175f51e53b7eac0ee006e6d">More...</a><br /></td></tr>
<tr class="separator:a3072027cd175f51e53b7eac0ee006e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd977ee7632da9dfa0178c10853501a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#acd977ee7632da9dfa0178c10853501a9">IntGetPendingState</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:acd977ee7632da9dfa0178c10853501a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the pending status of interrupt passed.  <a href="#acd977ee7632da9dfa0178c10853501a9">More...</a><br /></td></tr>
<tr class="separator:acd977ee7632da9dfa0178c10853501a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a35c9960823dddd1dfd7b5c8b492b3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a05a35c9960823dddd1dfd7b5c8b492b3">IntGetActiveState</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:a05a35c9960823dddd1dfd7b5c8b492b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the active status of interrupt passed.  <a href="#a05a35c9960823dddd1dfd7b5c8b492b3">More...</a><br /></td></tr>
<tr class="separator:a05a35c9960823dddd1dfd7b5c8b492b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6f7ae2bddb7ffdbafbaadf526e423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a54c6f7ae2bddb7ffdbafbaadf526e423">IntClearActiveState</a> (uint32_t intrNum)</td></tr>
<tr class="memdesc:a54c6f7ae2bddb7ffdbafbaadf526e423"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the Active status of interrupt passed.  <a href="#a54c6f7ae2bddb7ffdbafbaadf526e423">More...</a><br /></td></tr>
<tr class="separator:a54c6f7ae2bddb7ffdbafbaadf526e423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0db408fa3caf0224c274e57ad259624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#ab0db408fa3caf0224c274e57ad259624">IntSetTargetProcessor</a> (uint32_t intrNum, uint32_t processorSelect)</td></tr>
<tr class="memdesc:ab0db408fa3caf0224c274e57ad259624"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the target processor for the interrupt passed.  <a href="#ab0db408fa3caf0224c274e57ad259624">More...</a><br /></td></tr>
<tr class="separator:ab0db408fa3caf0224c274e57ad259624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414deb31f214def249432590c1da897b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a414deb31f214def249432590c1da897b">IntConfigTypenModel</a> (uint32_t intrNum, uint32_t intType, uint32_t intHandleModel)</td></tr>
<tr class="memdesc:a414deb31f214def249432590c1da897b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the type of interrupt and Mode of interupt handling.  <a href="#a414deb31f214def249432590c1da897b">More...</a><br /></td></tr>
<tr class="separator:a414deb31f214def249432590c1da897b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac264d334e811e651f4ca45ba62d155ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#ac264d334e811e651f4ca45ba62d155ea">IntEnableSecureFIQ</a> (uint32_t intRoute)</td></tr>
<tr class="memdesc:ac264d334e811e651f4ca45ba62d155ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures whether the interrupt in secure mode to be routed to IRQ or FIQ.  <a href="#ac264d334e811e651f4ca45ba62d155ea">More...</a><br /></td></tr>
<tr class="separator:ac264d334e811e651f4ca45ba62d155ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07fa0c85923c60ada764bda084d6d92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#ab07fa0c85923c60ada764bda084d6d92">IntSetProirityMask</a> (uint32_t priorityMask)</td></tr>
<tr class="memdesc:ab07fa0c85923c60ada764bda084d6d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">The priority mask level for the CPU interface. If the priority of an interrupt is higher than the value indicated by this field, the interface signals the interrupt to the processor. If the GIC supports fewer than 256 priority levels then some bits are RAZ/WI, as follows: 128 supported levels Bit [0] = 0. 64 supported levels Bit [1:0] = 0b00. 32 supported levels Bit [2:0] = 0b000. 16 supported levels Bit [3:0] = 0b0000. - (RW)  <a href="#ab07fa0c85923c60ada764bda084d6d92">More...</a><br /></td></tr>
<tr class="separator:ab07fa0c85923c60ada764bda084d6d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057a46d192f9a2a64099da543de7ce67"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a057a46d192f9a2a64099da543de7ce67">IntGetProirityMask</a> (void)</td></tr>
<tr class="memdesc:a057a46d192f9a2a64099da543de7ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the priority mask level for the CPU interface.  <a href="#a057a46d192f9a2a64099da543de7ce67">More...</a><br /></td></tr>
<tr class="separator:a057a46d192f9a2a64099da543de7ce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e60f0f5860905bdbeedb992bbeca3b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a62e60f0f5860905bdbeedb992bbeca3b">IntGetActivePriority</a> (void)</td></tr>
<tr class="memdesc:a62e60f0f5860905bdbeedb992bbeca3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the priority value of the highest priority interrupt that is active on the CPU interface.  <a href="#a62e60f0f5860905bdbeedb992bbeca3b">More...</a><br /></td></tr>
<tr class="separator:a62e60f0f5860905bdbeedb992bbeca3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb32909ada7c28f8919e6aaf1c6fbe0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a8fb32909ada7c28f8919e6aaf1c6fbe0">IntGetPendingIntNum</a> (void)</td></tr>
<tr class="memdesc:a8fb32909ada7c28f8919e6aaf1c6fbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the interrupt ID of the highest priority pending interrupt  <a href="#a8fb32909ada7c28f8919e6aaf1c6fbe0">More...</a><br /></td></tr>
<tr class="separator:a8fb32909ada7c28f8919e6aaf1c6fbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cee0a407574b303d84d8c5b5082b260"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a7cee0a407574b303d84d8c5b5082b260">IntGetPendingCPUID</a> (void)</td></tr>
<tr class="memdesc:a7cee0a407574b303d84d8c5b5082b260"><td class="mdescLeft">&#160;</td><td class="mdescRight">On a multiprocessor implementation, if the PENDINTID field returns the ID of an SGI, this field contains the CPUID value for that interrupt. This identifies the processor that generated the interrupt.  <a href="#a7cee0a407574b303d84d8c5b5082b260">More...</a><br /></td></tr>
<tr class="separator:a7cee0a407574b303d84d8c5b5082b260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab762b4e340eb694a59114d16a252919f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#ab762b4e340eb694a59114d16a252919f">IntMasterIRQEnable</a> (void)</td></tr>
<tr class="memdesc:ab762b4e340eb694a59114d16a252919f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the processor IRQ only in CPSR. Makes the processor to respond to IRQs. This does not affect the set of interrupts enabled/disabled in the AINTC.  <a href="#ab762b4e340eb694a59114d16a252919f">More...</a><br /></td></tr>
<tr class="separator:ab762b4e340eb694a59114d16a252919f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5ffeca4b44276baa4181d3311a97fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#acb5ffeca4b44276baa4181d3311a97fc">IntMasterIRQDisable</a> (void)</td></tr>
<tr class="memdesc:acb5ffeca4b44276baa4181d3311a97fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the processor IRQ only in CPSR.Prevents the processor to respond to IRQs. This does not affect the set of interrupts enabled/disabled in the AINTC.  <a href="#acb5ffeca4b44276baa4181d3311a97fc">More...</a><br /></td></tr>
<tr class="separator:acb5ffeca4b44276baa4181d3311a97fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4febbbc95b51d284bc346b5aa788a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a4d4febbbc95b51d284bc346b5aa788a2">IntMasterFIQEnable</a> (void)</td></tr>
<tr class="memdesc:a4d4febbbc95b51d284bc346b5aa788a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the processor FIQ only in CPSR. Makes the processor to respond to FIQs. This does not affect the set of interrupts enabled/disabled in the AINTC.  <a href="#a4d4febbbc95b51d284bc346b5aa788a2">More...</a><br /></td></tr>
<tr class="separator:a4d4febbbc95b51d284bc346b5aa788a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae274b2821fba73c2739571453cc045a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#aae274b2821fba73c2739571453cc045a">IntMasterFIQDisable</a> (void)</td></tr>
<tr class="memdesc:aae274b2821fba73c2739571453cc045a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the processor FIQ only in CPSR.Prevents the processor to respond to FIQs. This does not affect the set of interrupts enabled/disabled in the AINTC.  <a href="#aae274b2821fba73c2739571453cc045a">More...</a><br /></td></tr>
<tr class="separator:aae274b2821fba73c2739571453cc045a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076af1c528b235afb104fc527ea51ab3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a076af1c528b235afb104fc527ea51ab3">IntMasterStatusGet</a> (void)</td></tr>
<tr class="memdesc:a076af1c528b235afb104fc527ea51ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the interrupts FIQ and IRQ.  <a href="#a076af1c528b235afb104fc527ea51ab3">More...</a><br /></td></tr>
<tr class="separator:a076af1c528b235afb104fc527ea51ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bb917cceb9f3524c228ffc5d8fe469"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#af5bb917cceb9f3524c228ffc5d8fe469">Intc_IntDisable</a> (void)</td></tr>
<tr class="memdesc:af5bb917cceb9f3524c228ffc5d8fe469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and save the stasus and Disables the processor IRQ . Prevents the processor to respond to IRQs.  <a href="#af5bb917cceb9f3524c228ffc5d8fe469">More...</a><br /></td></tr>
<tr class="separator:af5bb917cceb9f3524c228ffc5d8fe469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba4ea4abc9456bfce232e7afc9ece74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a2ba4ea4abc9456bfce232e7afc9ece74">Intc_IntEnable</a> (uint32_t status)</td></tr>
<tr class="memdesc:a2ba4ea4abc9456bfce232e7afc9ece74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the processor IRQ only status. This does not affect the set of interrupts enabled/disabled in the AINTC.  <a href="#a2ba4ea4abc9456bfce232e7afc9ece74">More...</a><br /></td></tr>
<tr class="separator:a2ba4ea4abc9456bfce232e7afc9ece74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27195087c67f56b1cf07216286e6a3c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a15_2interrupt_8h.html#a27195087c67f56b1cf07216286e6a3c7">Intc_AbortHandler</a> (void)</td></tr>
<tr class="memdesc:a27195087c67f56b1cf07216286e6a3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is called when the CPU is aborted When the abort interrupt occurs , the control goes to the ISR which is registered using Intc_IntRegister else will result in infinite loop.  <a href="#a27195087c67f56b1cf07216286e6a3c7">More...</a><br /></td></tr>
<tr class="separator:a27195087c67f56b1cf07216286e6a3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the API prototypes for configuring INTC for ARM Cortex-A15. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a27195087c67f56b1cf07216286e6a3c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Intc_AbortHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is called when the CPU is aborted When the abort interrupt occurs , the control goes to the ISR which is registered using Intc_IntRegister else will result in infinite loop. </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad14d4462aeeeaefcc22533c1ccfe0cc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Intc_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to initialize the interrupt controller. This API shall be called before using the interrupt controller. </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af5bb917cceb9f3524c228ffc5d8fe469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Intc_IntDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and save the stasus and Disables the processor IRQ . Prevents the processor to respond to IRQs. </p>
<dl class="section return"><dt>Returns</dt><dd>Current status of IRQ</dd></dl>
<p>Note: This function call shall be done only in previleged mode of ARM </p>

</div>
</div>
<a class="anchor" id="a2ba4ea4abc9456bfce232e7afc9ece74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Intc_IntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the processor IRQ only status. This does not affect the set of interrupts enabled/disabled in the AINTC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Status returned by the IntDisable fundtion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Note: This function call shall be done only in previleged mode of ARM </p>

</div>
</div>
<a class="anchor" id="a86093c96128baa5af1603e601d3ee496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Intc_IntPrioritySet </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intrNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hostIntRoute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API assigns a priority to an interrupt and routes it to either IRQ or to FIQ. Priority 0 is the highest priority level Among the host interrupts, FIQ has more priority than IRQ. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number </td></tr>
    <tr><td class="paramname">priority</td><td>- Interrupt priority level </td></tr>
    <tr><td class="paramname">hostIntRoute</td><td>- Unused currently</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="adbf14fc8f1fb9ad3edd5a37c1feb5a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Intc_IntRegister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intrNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntrFuncPtr&#160;</td>
          <td class="paramname"><em>fptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fun_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an interrupt Handler in the interrupt vector table for system interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt Number </td></tr>
    <tr><td class="paramname">fptr</td><td>- Function pointer to the ISR </td></tr>
    <tr><td class="paramname">fun_arg</td><td>- Argument to the ISR</td></tr>
  </table>
  </dd>
</dl>
<p>Note: When the interrupt occurs for the sytem interrupt number indicated, the control goes to the ISR given as the parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aca0d7290cd712e7bcfea80c900dd6da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Intc_IntUnregister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters an interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt Number</td></tr>
  </table>
  </dd>
</dl>
<p>Note: Once an interrupt is unregistered it will enter infinite loop once an interrupt occurs</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a67c41dd88a707773ee5c2054b63acb54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Intc_SystemDisable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the system interrupt in INTC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d5d4094844e6b53e70d5dadda16ab3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Intc_SystemEnable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the system interrupt in INTC. However, for the interrupt generation, make sure that the interrupt is enabled at the peripheral level also. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a54c6f7ae2bddb7ffdbafbaadf526e423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntClearActiveState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the Active status of interrupt passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a3072027cd175f51e53b7eac0ee006e6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntClearPendingState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the pending status of interrupt passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a414deb31f214def249432590c1da897b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntConfigTypenModel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intHandleModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the type of interrupt and Mode of interupt handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
    <tr><td class="paramname">intType</td><td>- Possible values are: 0x0 - interrupt set to level sensitive type 0x1 - interrupt set to edge triggered type</td></tr>
    <tr><td class="paramname">intHandleModel</td><td>- 1-N Model : Only one processor handles this interrupt. The system must implement a mechanism to determine which processor handles an interrupt that is programmed to target more than one processor.</td></tr>
  </table>
  </dd>
</dl>
<p>1-N Model :All processors receive the interrupt independently. When a processor acknowledges the interrupt, the interrupt pending state is cleared only for that processor. The interrupt remains pending for the other processors</p>
<p>Possible values are: 0x0 - interrupt set to 1-N interrupt handling Model 0x1 - interrupt set to N-N interrupt handling Model</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a89a071144b052693eb042098add0157d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntDisableSecureMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the interrupt passed to non-secure. In non-secure mode interrupts can only be routed to IRQ. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac264d334e811e651f4ca45ba62d155ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntEnableSecureFIQ </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intRoute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures whether the interrupt in secure mode to be routed to IRQ or FIQ. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intRoute</td><td>- Possible values AINTC_HOSTINT_ROUTE_IRQ - Interrupt routed to IRQ AINTC_HOSTINT_ROUTE_FIQ - Interrupt routed to FIQ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fb771411ec290f7d5f8354269b22f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntEnableSecureMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the interrupt passed to secure. In secure mode interrupts can be routed to either IRQ or FIQ. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a62e60f0f5860905bdbeedb992bbeca3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntGetActivePriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the priority value of the highest priority interrupt that is active on the CPU interface. </p>
<dl class="section return"><dt>Returns</dt><dd>priority value of the highest priority interrupt that is active on the CPU interface </dd></dl>

</div>
</div>
<a class="anchor" id="a05a35c9960823dddd1dfd7b5c8b492b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntGetActiveState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the active status of interrupt passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if active. 0 if not active </dd></dl>

</div>
</div>
<a class="anchor" id="a7cee0a407574b303d84d8c5b5082b260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntGetPendingCPUID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On a multiprocessor implementation, if the PENDINTID field returns the ID of an SGI, this field contains the CPUID value for that interrupt. This identifies the processor that generated the interrupt. </p>
<dl class="section return"><dt>Returns</dt><dd>CPUID of the highest priority pending interrupt </dd></dl>

</div>
</div>
<a class="anchor" id="a8fb32909ada7c28f8919e6aaf1c6fbe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntGetPendingIntNum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the interrupt ID of the highest priority pending interrupt </p>
<dl class="section return"><dt>Returns</dt><dd>interrupt ID of the highest priority pending interrupt </dd></dl>

</div>
</div>
<a class="anchor" id="acd977ee7632da9dfa0178c10853501a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntGetPendingState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the pending status of interrupt passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if pending. 0 if not pending </dd></dl>

</div>
</div>
<a class="anchor" id="a057a46d192f9a2a64099da543de7ce67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntGetProirityMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the priority mask level for the CPU interface. </p>
<dl class="section return"><dt>Returns</dt><dd>prirityMask. </dd></dl>

</div>
</div>
<a class="anchor" id="aae274b2821fba73c2739571453cc045a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntMasterFIQDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the processor FIQ only in CPSR.Prevents the processor to respond to FIQs. This does not affect the set of interrupts enabled/disabled in the AINTC. </p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Note: This function call shall be done only in previleged mode of ARM </p>

</div>
</div>
<a class="anchor" id="a4d4febbbc95b51d284bc346b5aa788a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntMasterFIQEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the processor FIQ only in CPSR. Makes the processor to respond to FIQs. This does not affect the set of interrupts enabled/disabled in the AINTC. </p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Note: This function call shall be done only in previleged mode of ARM </p>

</div>
</div>
<a class="anchor" id="acb5ffeca4b44276baa4181d3311a97fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntMasterIRQDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the processor IRQ only in CPSR.Prevents the processor to respond to IRQs. This does not affect the set of interrupts enabled/disabled in the AINTC. </p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Note: This function call shall be done only in previleged mode of ARM </p>

</div>
</div>
<a class="anchor" id="ab762b4e340eb694a59114d16a252919f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntMasterIRQEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the processor IRQ only in CPSR. Makes the processor to respond to IRQs. This does not affect the set of interrupts enabled/disabled in the AINTC. </p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Note: This function call shall be done only in previleged mode of ARM </p>

</div>
</div>
<a class="anchor" id="a076af1c528b235afb104fc527ea51ab3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IntMasterStatusGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the interrupts FIQ and IRQ. </p>
<dl class="section return"><dt>Returns</dt><dd>Status of interrupt as in CPSR.</dd></dl>
<p>Note: This function call shall be done only in previleged mode of ARM </p>

</div>
</div>
<a class="anchor" id="ab40a9ad3a14364236cd7e175a3637fd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntSetPendingState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the status of the interrupt passed to pending. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab07fa0c85923c60ada764bda084d6d92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntSetProirityMask </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priorityMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The priority mask level for the CPU interface. If the priority of an interrupt is higher than the value indicated by this field, the interface signals the interrupt to the processor. If the GIC supports fewer than 256 priority levels then some bits are RAZ/WI, as follows: 128 supported levels Bit [0] = 0. 64 supported levels Bit [1:0] = 0b00. 32 supported levels Bit [2:0] = 0b000. 16 supported levels Bit [3:0] = 0b0000. - (RW) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priorityMask</td><td>- Priority mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0db408fa3caf0224c274e57ad259624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntSetTargetProcessor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>processorSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the target processor for the interrupt passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrNum</td><td>- Interrupt number</td></tr>
    <tr><td class="paramname">processorSelect</td><td>- Possible values are: 0x1 - Pending interrupt is sent to processors 0 0x2 - Pending interrupt is sent to processors 1 0x3 - Pending interrupt is sent to processors 0 and 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
