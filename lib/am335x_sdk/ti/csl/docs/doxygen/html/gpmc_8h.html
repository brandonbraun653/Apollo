<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gpmc.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_5c9827f39abcc28a92e5a02429a0e390.html">ip</a></li><li class="navelem"><a class="el" href="dir_66d98a18f6e639166c8ffff1b00e2f31.html">gpmc</a></li><li class="navelem"><a class="el" href="dir_544a1e7013b7f062aa11f08ef904b77e.html">V1</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gpmc.h File Reference<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a> &raquo; <a class="el" href="group___c_s_l___g_p_m_c.html">GPMC</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>GPMC APIs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;ti/csl/cslr_gpmc.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2a1728b1b1f4a6f85df11bda02c5fa4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a2a1728b1b1f4a6f85df11bda02c5fa4b">GPMCECCEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a2a1728b1b1f4a6f85df11bda02c5fa4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Enables the ECC feature.<br />
.  <a href="#a2a1728b1b1f4a6f85df11bda02c5fa4b">More...</a><br /></td></tr>
<tr class="separator:a2a1728b1b1f4a6f85df11bda02c5fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ccdd062439562bfce242d5bc3a4ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#aa10ccdd062439562bfce242d5bc3a4ca">GPMCECCDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:aa10ccdd062439562bfce242d5bc3a4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the ECC feature.<br />
.  <a href="#aa10ccdd062439562bfce242d5bc3a4ca">More...</a><br /></td></tr>
<tr class="separator:aa10ccdd062439562bfce242d5bc3a4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317e33786b3d6ea27d49e709f62df819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a317e33786b3d6ea27d49e709f62df819">GPMCModuleSoftReset</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a317e33786b3d6ea27d49e709f62df819"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the GPMC.<br />
.  <a href="#a317e33786b3d6ea27d49e709f62df819">More...</a><br /></td></tr>
<tr class="separator:a317e33786b3d6ea27d49e709f62df819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121b8c90c34fbb2eef9affe724f57044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a121b8c90c34fbb2eef9affe724f57044">GPMCECCResultRegClear</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a121b8c90c34fbb2eef9affe724f57044"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears all ECC result registers.<br />
.  <a href="#a121b8c90c34fbb2eef9affe724f57044">More...</a><br /></td></tr>
<tr class="separator:a121b8c90c34fbb2eef9affe724f57044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5a4911d121f3f70dc4341d8622ce3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#afe5a4911d121f3f70dc4341d8622ce3c">GPMCPrefetchEngineStop</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:afe5a4911d121f3f70dc4341d8622ce3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the PREFETCH and POST WRITE engine.<br />
.  <a href="#afe5a4911d121f3f70dc4341d8622ce3c">More...</a><br /></td></tr>
<tr class="separator:afe5a4911d121f3f70dc4341d8622ce3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8ab95768edcbc0067302fe3ba17369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a6d8ab95768edcbc0067302fe3ba17369">GPMCPrefetchEngineStart</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a6d8ab95768edcbc0067302fe3ba17369"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the FIFO pointer to 0 in prefetch mode and 40h in postwrite mode starts the PREFETCH and POST WRITE engine.<br />
.  <a href="#a6d8ab95768edcbc0067302fe3ba17369">More...</a><br /></td></tr>
<tr class="separator:a6d8ab95768edcbc0067302fe3ba17369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3022e0c0d9f1412211552aecfa735ea6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a3022e0c0d9f1412211552aecfa735ea6">GPMCErrAddrGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a3022e0c0d9f1412211552aecfa735ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the address of illegal access when an error occures.<br />
.  <a href="#a3022e0c0d9f1412211552aecfa735ea6">More...</a><br /></td></tr>
<tr class="separator:a3022e0c0d9f1412211552aecfa735ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d2463a14805b647cd9669d7b559459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a65d2463a14805b647cd9669d7b559459">GPMCPrefetchEngineEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a65d2463a14805b647cd9669d7b559459"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the PREFETCH POSTWRITE engine. <br />
.  <a href="#a65d2463a14805b647cd9669d7b559459">More...</a><br /></td></tr>
<tr class="separator:a65d2463a14805b647cd9669d7b559459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ec12372af08b1b88f974b1ba8b1d6a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a91ec12372af08b1b88f974b1ba8b1d6a">GPMCRevisionGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a91ec12372af08b1b88f974b1ba8b1d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the IP revision code of GPMC.<br />
.  <a href="#a91ec12372af08b1b88f974b1ba8b1d6a">More...</a><br /></td></tr>
<tr class="separator:a91ec12372af08b1b88f974b1ba8b1d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05c71de36f1692eb9421ff50dfeb82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ad05c71de36f1692eb9421ff50dfeb82e">GPMCPrefetchEngineDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ad05c71de36f1692eb9421ff50dfeb82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disable the PREFETCH POSTWRITE engine. <br />
.  <a href="#ad05c71de36f1692eb9421ff50dfeb82e">More...</a><br /></td></tr>
<tr class="separator:ad05c71de36f1692eb9421ff50dfeb82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0949a9cf1c0a9abcc4b29cb5a954aa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a9b0949a9cf1c0a9abcc4b29cb5a954aa">GPMCErrSysCmdGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a9b0949a9cf1c0a9abcc4b29cb5a954aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the System Command of the transaction that caused the error.<br />
.  <a href="#a9b0949a9cf1c0a9abcc4b29cb5a954aa">More...</a><br /></td></tr>
<tr class="separator:a9b0949a9cf1c0a9abcc4b29cb5a954aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa4442ef5e5a8ba01501a5f5a06d377"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#aaaa4442ef5e5a8ba01501a5f5a06d377">GPMCECCBCHSWDataRead</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:aaaa4442ef5e5a8ba01501a5f5a06d377"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function read the data to BCH_SWDATA register. This is used to directly padd data to the BCH ECC calculator without accessing the actual NAND flash interface.<br />
.  <a href="#aaaa4442ef5e5a8ba01501a5f5a06d377">More...</a><br /></td></tr>
<tr class="separator:aaaa4442ef5e5a8ba01501a5f5a06d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c2e2e25215e1cd8c1152685f8eeee"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a002c2e2e25215e1cd8c1152685f8eeee">GPMCErrValStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a002c2e2e25215e1cd8c1152685f8eeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the status of error validity.<br />
.  <a href="#a002c2e2e25215e1cd8c1152685f8eeee">More...</a><br /></td></tr>
<tr class="separator:a002c2e2e25215e1cd8c1152685f8eeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a39454d569d90d78b15a69f8ca595a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ae8a39454d569d90d78b15a69f8ca595a">GPMCIntEnable</a> (uint32_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:ae8a39454d569d90d78b15a69f8ca595a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the interrupts.<br />
.  <a href="#ae8a39454d569d90d78b15a69f8ca595a">More...</a><br /></td></tr>
<tr class="separator:ae8a39454d569d90d78b15a69f8ca595a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb14ae067cc4e53a0cb66ab73b87a87"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a5bb14ae067cc4e53a0cb66ab73b87a87">GPMCModuleResetStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a5bb14ae067cc4e53a0cb66ab73b87a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the software resets status of GPMC.<br />
.  <a href="#a5bb14ae067cc4e53a0cb66ab73b87a87">More...</a><br /></td></tr>
<tr class="separator:a5bb14ae067cc4e53a0cb66ab73b87a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633fdf3231581fed9134cb9b8b128237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a633fdf3231581fed9134cb9b8b128237">GPMCIntDisable</a> (uint32_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:a633fdf3231581fed9134cb9b8b128237"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disable/masks the interrupts.<br />
.  <a href="#a633fdf3231581fed9134cb9b8b128237">More...</a><br /></td></tr>
<tr class="separator:a633fdf3231581fed9134cb9b8b128237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750ba07c84de466283bea197f748c6c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a750ba07c84de466283bea197f748c6c7">GPMCECCCSSelect</a> (uint32_t baseAddr, uint32_t csNum)</td></tr>
<tr class="memdesc:a750ba07c84de466283bea197f748c6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the Chip-select where ECC is computed.<br />
.  <a href="#a750ba07c84de466283bea197f748c6c7">More...</a><br /></td></tr>
<tr class="separator:a750ba07c84de466283bea197f748c6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a79ba6340e6d858c4a2f7c4d3f79d79"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a0a79ba6340e6d858c4a2f7c4d3f79d79">GPMCPrefetchEngineStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a0a79ba6340e6d858c4a2f7c4d3f79d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of PREFETCH and POST WRITE engine.<br />
.  <a href="#a0a79ba6340e6d858c4a2f7c4d3f79d79">More...</a><br /></td></tr>
<tr class="separator:a0a79ba6340e6d858c4a2f7c4d3f79d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcf3a891b2f74f925794a8802af637e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a8dcf3a891b2f74f925794a8802af637e">GPMCPrefetchCountValGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a8dcf3a891b2f74f925794a8802af637e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the number of remaining bytes to be read or to be written by the engine according to the TransferCount value.<br />
.  <a href="#a8dcf3a891b2f74f925794a8802af637e">More...</a><br /></td></tr>
<tr class="separator:a8dcf3a891b2f74f925794a8802af637e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f41adebad615e8613b3e06efe442a1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a01f41adebad615e8613b3e06efe442a1">GPMCPrefetchFifoThrldStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a01f41adebad615e8613b3e06efe442a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the PREFETCH engine FIFO threshold status. <br />
.  <a href="#a01f41adebad615e8613b3e06efe442a1">More...</a><br /></td></tr>
<tr class="separator:a01f41adebad615e8613b3e06efe442a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5455e95b256917470e534c59b60f739"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ab5455e95b256917470e534c59b60f739">GPMCPrefetchFifoPtrValGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ab5455e95b256917470e534c59b60f739"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the FIFO pointer value of PREFETCH engine. FIFO pointer value indicates number of bytes available to be read or number of free empty place to write.<br />
.  <a href="#ab5455e95b256917470e534c59b60f739">More...</a><br /></td></tr>
<tr class="separator:ab5455e95b256917470e534c59b60f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab668cbc2ef3dc1048177bbbcc6bb9a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ab668cbc2ef3dc1048177bbbcc6bb9a31">GPMCECCAlgoSelect</a> (uint32_t baseAddr, uint32_t algo)</td></tr>
<tr class="memdesc:ab668cbc2ef3dc1048177bbbcc6bb9a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the ECC algorithm to use for ECC error detection and correction.<br />
.  <a href="#ab668cbc2ef3dc1048177bbbcc6bb9a31">More...</a><br /></td></tr>
<tr class="separator:ab668cbc2ef3dc1048177bbbcc6bb9a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87c71bfe694f793e8d9ea83566903c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ab87c71bfe694f793e8d9ea83566903c8">GPMCIntStatusClear</a> (uint32_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:ab87c71bfe694f793e8d9ea83566903c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears/resets the interrupt status.<br />
.  <a href="#ab87c71bfe694f793e8d9ea83566903c8">More...</a><br /></td></tr>
<tr class="separator:ab87c71bfe694f793e8d9ea83566903c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa577d30a0728f51f9c43feb2888511b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#aa577d30a0728f51f9c43feb2888511b1">GPMCIdleModeSelect</a> (uint32_t baseAddr, uint32_t mode)</td></tr>
<tr class="memdesc:aa577d30a0728f51f9c43feb2888511b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the idle mode for gpmc.<br />
.  <a href="#aa577d30a0728f51f9c43feb2888511b1">More...</a><br /></td></tr>
<tr class="separator:aa577d30a0728f51f9c43feb2888511b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3369b49f234914d346d903356c1ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#afc3369b49f234914d346d903356c1ca6">GPMCPrefetchCSSelect</a> (uint32_t baseAddr, uint32_t csNum)</td></tr>
<tr class="memdesc:afc3369b49f234914d346d903356c1ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the chip select(CS) where Prefetch Postwrite engine is active.<br />
.  <a href="#afc3369b49f234914d346d903356c1ca6">More...</a><br /></td></tr>
<tr class="separator:afc3369b49f234914d346d903356c1ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3405c3dd4b1bf99efc45918d065459fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a3405c3dd4b1bf99efc45918d065459fe">GPMCECCBCHSWDataWrite</a> (uint32_t baseAddr, uint32_t bchData)</td></tr>
<tr class="memdesc:a3405c3dd4b1bf99efc45918d065459fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function write the data to BCH_SWDATA register. This is used to directly padd data to the BCH ECC calculator without accessing the actual NAND flash interface.<br />
.  <a href="#a3405c3dd4b1bf99efc45918d065459fe">More...</a><br /></td></tr>
<tr class="separator:a3405c3dd4b1bf99efc45918d065459fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab977806888d1553702c5cf1f7ee76501"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ab977806888d1553702c5cf1f7ee76501">GPMCErrStatusGet</a> (uint32_t baseAddr, uint32_t err)</td></tr>
<tr class="memdesc:ab977806888d1553702c5cf1f7ee76501"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether passed error is occured or not.<br />
.  <a href="#ab977806888d1553702c5cf1f7ee76501">More...</a><br /></td></tr>
<tr class="separator:ab977806888d1553702c5cf1f7ee76501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5595c2f501a9dc27eed6a7328538a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#aea5595c2f501a9dc27eed6a7328538a8">GPMCAutoIdleConfig</a> (uint32_t baseAddr, uint32_t configVal)</td></tr>
<tr class="memdesc:aea5595c2f501a9dc27eed6a7328538a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the internal OCP clock gating strategy.<br />
.  <a href="#aea5595c2f501a9dc27eed6a7328538a8">More...</a><br /></td></tr>
<tr class="separator:aea5595c2f501a9dc27eed6a7328538a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2377751a3c935eb34dff185528b58df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a2377751a3c935eb34dff185528b58df7">GPMCECCColumnSelect</a> (uint32_t baseAddr, uint32_t eccColVal)</td></tr>
<tr class="memdesc:a2377751a3c935eb34dff185528b58df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects number of columns to use for ECC calculation.<br />
.  <a href="#a2377751a3c935eb34dff185528b58df7">More...</a><br /></td></tr>
<tr class="separator:a2377751a3c935eb34dff185528b58df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbac13cc1b4e507095491832022f94a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#afbac13cc1b4e507095491832022f94a3">GPMCIntStatusGet</a> (uint32_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:afbac13cc1b4e507095491832022f94a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets Interrupt status of interrupt passed.<br />
.  <a href="#afbac13cc1b4e507095491832022f94a3">More...</a><br /></td></tr>
<tr class="separator:afbac13cc1b4e507095491832022f94a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297101f0265157c2a5d1e3953d5efc2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a297101f0265157c2a5d1e3953d5efc2f">GPMCTimeOutFeatureConfig</a> (uint32_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:a297101f0265157c2a5d1e3953d5efc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the timeout feature.<br />
.  <a href="#a297101f0265157c2a5d1e3953d5efc2f">More...</a><br /></td></tr>
<tr class="separator:a297101f0265157c2a5d1e3953d5efc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9124b5296fcc371c3e53b369662369fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a9124b5296fcc371c3e53b369662369fc">GPMCPrefetchSyncModeConfig</a> (uint32_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:a9124b5296fcc371c3e53b369662369fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function congigs when the PREFETCH engine has to start the access to CS.<br />
.  <a href="#a9124b5296fcc371c3e53b369662369fc">More...</a><br /></td></tr>
<tr class="separator:a9124b5296fcc371c3e53b369662369fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3abfb76d310b1c062cc6c2d65f7eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a7d3abfb76d310b1c062cc6c2d65f7eed">GPMCECCResultRegSelect</a> (uint32_t baseAddr, uint32_t eccResReg)</td></tr>
<tr class="memdesc:a7d3abfb76d310b1c062cc6c2d65f7eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the ECC result register where the first ECC computation will be stored.<br />
.  <a href="#a7d3abfb76d310b1c062cc6c2d65f7eed">More...</a><br /></td></tr>
<tr class="separator:a7d3abfb76d310b1c062cc6c2d65f7eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad961bef50564f35777af41ff5b39c522"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ad961bef50564f35777af41ff5b39c522">GPMCECCResultGet</a> (uint32_t baseAddr, uint32_t eccResReg)</td></tr>
<tr class="memdesc:ad961bef50564f35777af41ff5b39c522"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the ECC result from the ECC register.<br />
.  <a href="#ad961bef50564f35777af41ff5b39c522">More...</a><br /></td></tr>
<tr class="separator:ad961bef50564f35777af41ff5b39c522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c912e940eef4f6c17f8ae7349b8dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a46c912e940eef4f6c17f8ae7349b8dcb">GPMCPrefetchWaitPinSelect</a> (uint32_t baseAddr, uint32_t waitPin)</td></tr>
<tr class="memdesc:a46c912e940eef4f6c17f8ae7349b8dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the wait pin edge detector to start the PREFETCH engine in synchronized mode.<br />
.  <a href="#a46c912e940eef4f6c17f8ae7349b8dcb">More...</a><br /></td></tr>
<tr class="separator:a46c912e940eef4f6c17f8ae7349b8dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe04806c4a2a6133ada943ac9623b423"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#abe04806c4a2a6133ada943ac9623b423">GPMCWaitPinStatusGet</a> (uint32_t baseAddr, uint32_t pin)</td></tr>
<tr class="memdesc:abe04806c4a2a6133ada943ac9623b423"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the waitpin status.<br />
.  <a href="#abe04806c4a2a6133ada943ac9623b423">More...</a><br /></td></tr>
<tr class="separator:abe04806c4a2a6133ada943ac9623b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3573bb56bb44f0eb91636e4200802a8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a3573bb56bb44f0eb91636e4200802a8c">GPMCPrefetchSyncTypeSelect</a> (uint32_t baseAddr, uint32_t syncType)</td></tr>
<tr class="memdesc:a3573bb56bb44f0eb91636e4200802a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function select the synchronization type to use on FIFO threshold crossing.<br />
.  <a href="#a3573bb56bb44f0eb91636e4200802a8c">More...</a><br /></td></tr>
<tr class="separator:a3573bb56bb44f0eb91636e4200802a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0d05b68d9f872d3ebf5fba5200a608"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a2a0d05b68d9f872d3ebf5fba5200a608">GPMCTimeOutStartValSet</a> (uint32_t baseAddr, uint32_t timeoutVal)</td></tr>
<tr class="memdesc:a2a0d05b68d9f872d3ebf5fba5200a608"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the start timeout value(TIMEOUTSTARTVALUE) of the timeout counter.<br />
.  <a href="#a2a0d05b68d9f872d3ebf5fba5200a608">More...</a><br /></td></tr>
<tr class="separator:a2a0d05b68d9f872d3ebf5fba5200a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13901030cc7c9b9ad3ed6475caf407ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a13901030cc7c9b9ad3ed6475caf407ab">GPMCPrefetchCycleOptValSet</a> (uint32_t baseAddr, uint32_t cleOptVal)</td></tr>
<tr class="memdesc:a13901030cc7c9b9ad3ed6475caf407ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the number of GPMC_FCLK cycles to be substracted from RdCycleTime,WrCycleTime, AccessTime, CSRdOffTime, CSWrOffTime, ADVRdOffTime,ADVWrOffTime, OEOffTime, WEOffTime for PREFETCH engine cycle optimization. <br />
.  <a href="#a13901030cc7c9b9ad3ed6475caf407ab">More...</a><br /></td></tr>
<tr class="separator:a13901030cc7c9b9ad3ed6475caf407ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d6efa14a9d745e9edce27e61104d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ab3d6efa14a9d745e9edce27e61104d79">GPMCECCBCHWrapModeValSet</a> (uint32_t baseAddr, uint32_t wrapModeVal)</td></tr>
<tr class="memdesc:ab3d6efa14a9d745e9edce27e61104d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the wrap mode(Spare area organization definition) for the ECC BCH algorithm.<br />
.  <a href="#ab3d6efa14a9d745e9edce27e61104d79">More...</a><br /></td></tr>
<tr class="separator:ab3d6efa14a9d745e9edce27e61104d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f659ba9d8c95e65c3e70dad11208a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a60f659ba9d8c95e65c3e70dad11208a8">GPMCPrefetchTrnsCntValSet</a> (uint32_t baseAddr, uint32_t trnsCntVal)</td></tr>
<tr class="memdesc:a60f659ba9d8c95e65c3e70dad11208a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the transfer count (number of bytes to be read or written by the engine to the selected CS) for the PREFETCH engine.<br />
.  <a href="#a60f659ba9d8c95e65c3e70dad11208a8">More...</a><br /></td></tr>
<tr class="separator:a60f659ba9d8c95e65c3e70dad11208a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7725c561cdac19107942206f858f2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#abc7725c561cdac19107942206f858f2a">GPMCPrefetchRRArbitrationConfig</a> (uint32_t baseAddr, uint32_t configVal)</td></tr>
<tr class="memdesc:abc7725c561cdac19107942206f858f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the PREFETCH and POSTWRITE ROUND ROBIN arbitration. <br />
.  <a href="#abc7725c561cdac19107942206f858f2a">More...</a><br /></td></tr>
<tr class="separator:abc7725c561cdac19107942206f858f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9462388affa744fabc739eff154340a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a9462388affa744fabc739eff154340a1">GPMCPrefetchWeightedPrioSet</a> (uint32_t baseAddr, uint32_t accessVal)</td></tr>
<tr class="memdesc:a9462388affa744fabc739eff154340a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the number of access to be granted to PREFETCH engine when ROUND ROBIN arbitration. i.e When an arbitration occurs between a direct memory access and a PFPW engine access, the direct memory access is always serviced. If the PFPWEnRoundRobin is enabled value set by this function plus one number of access is granted to the PREFETCH and WRITE POST engine.<br />
.  <a href="#a9462388affa744fabc739eff154340a1">More...</a><br /></td></tr>
<tr class="separator:a9462388affa744fabc739eff154340a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f15792be017a67f8c97cfcec579d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ab59f15792be017a67f8c97cfcec579d2">GPMCPrefetchAccessCycleOptConfig</a> (uint32_t baseAddr, uint32_t configVal)</td></tr>
<tr class="memdesc:ab59f15792be017a67f8c97cfcec579d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the access cycle optimization for PREFETCH engine. <br />
.  <a href="#ab59f15792be017a67f8c97cfcec579d2">More...</a><br /></td></tr>
<tr class="separator:ab59f15792be017a67f8c97cfcec579d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954ba97bea94e7bf0904de11e0303402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a954ba97bea94e7bf0904de11e0303402">GPMCECCBCHNumOfSectorsSelect</a> (uint32_t baseAddr, uint32_t numOfSects)</td></tr>
<tr class="memdesc:a954ba97bea94e7bf0904de11e0303402"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the number of sectors to process with the BCH algorithm.<br />
.  <a href="#a954ba97bea94e7bf0904de11e0303402">More...</a><br /></td></tr>
<tr class="separator:a954ba97bea94e7bf0904de11e0303402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870f4d78dcaaa78a0ea7af5c7d62b28f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a870f4d78dcaaa78a0ea7af5c7d62b28f">GPMCPrefetchAccessModeSelect</a> (uint32_t baseAddr, uint32_t accessMode)</td></tr>
<tr class="memdesc:a870f4d78dcaaa78a0ea7af5c7d62b28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the access mode of the prefetch engine.<br />
.  <a href="#a870f4d78dcaaa78a0ea7af5c7d62b28f">More...</a><br /></td></tr>
<tr class="separator:a870f4d78dcaaa78a0ea7af5c7d62b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4618adfc74e55addd81bcd18aba97e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a1d4618adfc74e55addd81bcd18aba97e">GPMCPrefetchFifoThrldValSet</a> (uint32_t baseAddr, uint32_t fifoThrsld)</td></tr>
<tr class="memdesc:a1d4618adfc74e55addd81bcd18aba97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the FIFOTHRESHOLD (maximum number of bytes read from the FIFO or written to the FIFO by the host on a DMA or interrupt request) value for the PREFETCH and POSTWRITE engine.<br />
.  <a href="#a1d4618adfc74e55addd81bcd18aba97e">More...</a><br /></td></tr>
<tr class="separator:a1d4618adfc74e55addd81bcd18aba97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfde4e3712a35ef5eababdfa002af3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a4bfde4e3712a35ef5eababdfa002af3a">GPMCECCBCHErrCorrectionCapSelect</a> (uint32_t baseAddr, uint32_t errCorrCapVal)</td></tr>
<tr class="memdesc:a4bfde4e3712a35ef5eababdfa002af3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the Error correction capability used for BCH ECC algorithm.<br />
.  <a href="#a4bfde4e3712a35ef5eababdfa002af3a">More...</a><br /></td></tr>
<tr class="separator:a4bfde4e3712a35ef5eababdfa002af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4244ebccd44f0b708ec8db8f78514c39"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a4244ebccd44f0b708ec8db8f78514c39">GPMCEmptyWriteBuffStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a4244ebccd44f0b708ec8db8f78514c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the empty write buffer status.<br />
.  <a href="#a4244ebccd44f0b708ec8db8f78514c39">More...</a><br /></td></tr>
<tr class="separator:a4244ebccd44f0b708ec8db8f78514c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1256a56727e4e5415492c68811d10ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a1256a56727e4e5415492c68811d10ec1">GPMCNANDForcePostedWriteFeatureConfig</a> (uint32_t baseAddr, uint32_t flag)</td></tr>
<tr class="memdesc:a1256a56727e4e5415492c68811d10ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the Force Posted Write feature to NAND Cmd/Add/Data location.<br />
.  <a href="#a1256a56727e4e5415492c68811d10ec1">More...</a><br /></td></tr>
<tr class="separator:a1256a56727e4e5415492c68811d10ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158484b1ff684cd38b329c4c485f3eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a158484b1ff684cd38b329c4c485f3eb3">GPMCECCSizeValSet</a> (uint32_t baseAddr, uint32_t eccSize, uint32_t eccSizeVal)</td></tr>
<tr class="memdesc:a158484b1ff684cd38b329c4c485f3eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the ECCSIZE1 value. <br />
.  <a href="#a158484b1ff684cd38b329c4c485f3eb3">More...</a><br /></td></tr>
<tr class="separator:a158484b1ff684cd38b329c4c485f3eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458d980b61bb6a6217cc169e5f5fc30d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a458d980b61bb6a6217cc169e5f5fc30d">GPMCCSConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t conf)</td></tr>
<tr class="memdesc:a458d980b61bb6a6217cc169e5f5fc30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the chip select. This function is called during the chip select configuration.<br />
.  <a href="#a458d980b61bb6a6217cc169e5f5fc30d">More...</a><br /></td></tr>
<tr class="separator:a458d980b61bb6a6217cc169e5f5fc30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c62b501b3c714367fd8cfd86998f26d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a0c62b501b3c714367fd8cfd86998f26d">GPMCBaseAddrSet</a> (uint32_t baseAddr, uint32_t csNum, uint32_t <a class="el" href="csl__udmap__tr_8h.html#a0e89cf6b9f6cd3125470b1bed2b823df">addr</a>)</td></tr>
<tr class="memdesc:a0c62b501b3c714367fd8cfd86998f26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the base address for the chip select spcified.<br />
.  <a href="#a0c62b501b3c714367fd8cfd86998f26d">More...</a><br /></td></tr>
<tr class="separator:a0c62b501b3c714367fd8cfd86998f26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be686b554dd7fc06a4404a5228b5259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a1be686b554dd7fc06a4404a5228b5259">GPMCMaskAddrSet</a> (uint32_t baseAddr, uint32_t csNum, uint32_t maskaddr)</td></tr>
<tr class="memdesc:a1be686b554dd7fc06a4404a5228b5259"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the chip select mask address or size.<br />
.  <a href="#a1be686b554dd7fc06a4404a5228b5259">More...</a><br /></td></tr>
<tr class="separator:a1be686b554dd7fc06a4404a5228b5259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8269233218901c823ce0f5adec37a6ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a8269233218901c823ce0f5adec37a6ac">GPMCSNANDCmdWrite</a> (uint32_t baseAddr, uint32_t csNum, uint32_t cmd)</td></tr>
<tr class="memdesc:a8269233218901c823ce0f5adec37a6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the NAND command to COMMAND register.<br />
.  <a href="#a8269233218901c823ce0f5adec37a6ac">More...</a><br /></td></tr>
<tr class="separator:a8269233218901c823ce0f5adec37a6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9b2821085f15eafdf553822ae9ff64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a3c9b2821085f15eafdf553822ae9ff64">GPMCDevTypeSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t devType)</td></tr>
<tr class="memdesc:a3c9b2821085f15eafdf553822ae9ff64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the device type for the device connected to csNum.<br />
.  <a href="#a3c9b2821085f15eafdf553822ae9ff64">More...</a><br /></td></tr>
<tr class="separator:a3c9b2821085f15eafdf553822ae9ff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6ee3462afa58074238cdb138c1a174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a0d6ee3462afa58074238cdb138c1a174">GPMCDevSizeSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t devSize)</td></tr>
<tr class="memdesc:a0d6ee3462afa58074238cdb138c1a174"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the device size for the device connected to csNum.<br />
.  <a href="#a0d6ee3462afa58074238cdb138c1a174">More...</a><br /></td></tr>
<tr class="separator:a0d6ee3462afa58074238cdb138c1a174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cff5e49943bd4564b81b705151876e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a71cff5e49943bd4564b81b705151876e">GPMCWaitPinSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t waitPin)</td></tr>
<tr class="memdesc:a71cff5e49943bd4564b81b705151876e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the WAIT PIN for the device connected to csNum.<br />
.  <a href="#a71cff5e49943bd4564b81b705151876e">More...</a><br /></td></tr>
<tr class="separator:a71cff5e49943bd4564b81b705151876e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ab7afdd85e7fa21774298b1f2d6013"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ab0ab7afdd85e7fa21774298b1f2d6013">GPMCCSTimingConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t conf)</td></tr>
<tr class="memdesc:ab0ab7afdd85e7fa21774298b1f2d6013"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the timing parameters for Chip Select signal.<br />
.  <a href="#ab0ab7afdd85e7fa21774298b1f2d6013">More...</a><br /></td></tr>
<tr class="separator:ab0ab7afdd85e7fa21774298b1f2d6013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e19235bf279cb0b3b963189e10863d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a8e19235bf279cb0b3b963189e10863d1">GPMCNANDAddrWrite</a> (uint32_t baseAddr, uint32_t csNum, uint32_t <a class="el" href="csl__udmap__tr_8h.html#a0e89cf6b9f6cd3125470b1bed2b823df">addr</a>)</td></tr>
<tr class="memdesc:a8e19235bf279cb0b3b963189e10863d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the NAND address to ADDRESS register.<br />
.  <a href="#a8e19235bf279cb0b3b963189e10863d1">More...</a><br /></td></tr>
<tr class="separator:a8e19235bf279cb0b3b963189e10863d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac090e4e13d9f6cd45c64915623f8a466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ac090e4e13d9f6cd45c64915623f8a466">GPMCNANDDataWrite</a> (uint32_t baseAddr, uint32_t csNum, uint32_t <a class="el" href="csl__udmap__tr_8h.html#ae4abda5e3cab325153762e904fd3f1e8">data</a>)</td></tr>
<tr class="memdesc:ac090e4e13d9f6cd45c64915623f8a466"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the NAND data to DATA register.<br />
.  <a href="#ac090e4e13d9f6cd45c64915623f8a466">More...</a><br /></td></tr>
<tr class="separator:ac090e4e13d9f6cd45c64915623f8a466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fb28417a37a7bf6c06919cb9bd25fe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a75fb28417a37a7bf6c06919cb9bd25fe">GPMCNANDDataRead</a> (uint32_t baseAddr, uint32_t csNum)</td></tr>
<tr class="memdesc:a75fb28417a37a7bf6c06919cb9bd25fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function the data from NAND DATA register.<br />
.  <a href="#a75fb28417a37a7bf6c06919cb9bd25fe">More...</a><br /></td></tr>
<tr class="separator:a75fb28417a37a7bf6c06919cb9bd25fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc7b3b1a0df78f892ddc935df29a1e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#aecc7b3b1a0df78f892ddc935df29a1e6">GPMCReadTypeSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t readType)</td></tr>
<tr class="memdesc:aecc7b3b1a0df78f892ddc935df29a1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the read type.<br />
.  <a href="#aecc7b3b1a0df78f892ddc935df29a1e6">More...</a><br /></td></tr>
<tr class="separator:aecc7b3b1a0df78f892ddc935df29a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e44e4885c69eca643e7a4094a53a1e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a3e44e4885c69eca643e7a4094a53a1e5">GPMCADVTimingConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t conf)</td></tr>
<tr class="memdesc:a3e44e4885c69eca643e7a4094a53a1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the timing parameters for ADV# signal.<br />
.  <a href="#a3e44e4885c69eca643e7a4094a53a1e5">More...</a><br /></td></tr>
<tr class="separator:a3e44e4885c69eca643e7a4094a53a1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ac45b8ea0522c3b269f8937e483b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a46ac45b8ea0522c3b269f8937e483b9c">GPMCWriteTypeSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t writeType)</td></tr>
<tr class="memdesc:a46ac45b8ea0522c3b269f8937e483b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the write type.<br />
.  <a href="#a46ac45b8ea0522c3b269f8937e483b9c">More...</a><br /></td></tr>
<tr class="separator:a46ac45b8ea0522c3b269f8937e483b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9795181a126342e67b1c5eb55c1252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a7e9795181a126342e67b1c5eb55c1252">GPMCDevPageLenSet</a> (uint32_t baseAddr, uint32_t csNum, uint32_t pageLen)</td></tr>
<tr class="memdesc:a7e9795181a126342e67b1c5eb55c1252"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the device page length.<br />
.  <a href="#a7e9795181a126342e67b1c5eb55c1252">More...</a><br /></td></tr>
<tr class="separator:a7e9795181a126342e67b1c5eb55c1252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066c7955dd6c1f5fd5ebfa0e0c1e91ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a066c7955dd6c1f5fd5ebfa0e0c1e91ce">GPMCFclkDividerSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t divideVal)</td></tr>
<tr class="memdesc:a066c7955dd6c1f5fd5ebfa0e0c1e91ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the FCLK DIVIDER for the chip select passed.<br />
.  <a href="#a066c7955dd6c1f5fd5ebfa0e0c1e91ce">More...</a><br /></td></tr>
<tr class="separator:a066c7955dd6c1f5fd5ebfa0e0c1e91ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34642199d07bf53d60b68db091e0879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ad34642199d07bf53d60b68db091e0879">GPMCWaitPinPolaritySelect</a> (uint32_t baseAddr, uint32_t pin, uint32_t polarity)</td></tr>
<tr class="memdesc:ad34642199d07bf53d60b68db091e0879"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets/selects the waitpin polarity.<br />
.  <a href="#ad34642199d07bf53d60b68db091e0879">More...</a><br /></td></tr>
<tr class="separator:ad34642199d07bf53d60b68db091e0879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8262e4189b14fba4222b90319d641bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a8262e4189b14fba4222b90319d641bf5">GPMCECCResultSizeSelect</a> (uint32_t baseAddr, uint32_t eccResReg, uint32_t eccSize)</td></tr>
<tr class="memdesc:a8262e4189b14fba4222b90319d641bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the ECC size for the ECC result register. <br />
.  <a href="#a8262e4189b14fba4222b90319d641bf5">More...</a><br /></td></tr>
<tr class="separator:a8262e4189b14fba4222b90319d641bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e96a1245cf5c870394dba6381e14aa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a2e96a1245cf5c870394dba6381e14aa1">GPMCWEAndOETimingConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t conf)</td></tr>
<tr class="memdesc:a2e96a1245cf5c870394dba6381e14aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the timing parameters for WE# and OE# signal.<br />
.  <a href="#a2e96a1245cf5c870394dba6381e14aa1">More...</a><br /></td></tr>
<tr class="separator:a2e96a1245cf5c870394dba6381e14aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa566459c986d4b74bd636ae104c6384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#aaa566459c986d4b74bd636ae104c6384">GPMCSyncWrapBurstConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t flag)</td></tr>
<tr class="memdesc:aaa566459c986d4b74bd636ae104c6384"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the wrapping burst capability.<br />
.  <a href="#aaa566459c986d4b74bd636ae104c6384">More...</a><br /></td></tr>
<tr class="separator:aaa566459c986d4b74bd636ae104c6384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab051a53ac2e13c6fbd0e9d14c070165a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#ab051a53ac2e13c6fbd0e9d14c070165a">GPMCECCBCHResultGet</a> (uint32_t baseAddr, uint32_t resIndex, uint32_t csNum)</td></tr>
<tr class="memdesc:ab051a53ac2e13c6fbd0e9d14c070165a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the BCH result.<br />
.  <a href="#ab051a53ac2e13c6fbd0e9d14c070165a">More...</a><br /></td></tr>
<tr class="separator:ab051a53ac2e13c6fbd0e9d14c070165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3e8f0884dfdd6da80e8d84975226c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#abd3e8f0884dfdd6da80e8d84975226c2">GPMCClkActivationTimeConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t flag)</td></tr>
<tr class="memdesc:abd3e8f0884dfdd6da80e8d84975226c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the output GPMC_CLK activation time.<br />
.  <a href="#abd3e8f0884dfdd6da80e8d84975226c2">More...</a><br /></td></tr>
<tr class="separator:abd3e8f0884dfdd6da80e8d84975226c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8673903515d9967990045a93050ae254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a8673903515d9967990045a93050ae254">GPMCWaitMonitoringTimeSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t flag)</td></tr>
<tr class="memdesc:a8673903515d9967990045a93050ae254"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs/selects the wait monitoring time for the device connected to csNum.<br />
.  <a href="#a8673903515d9967990045a93050ae254">More...</a><br /></td></tr>
<tr class="separator:a8673903515d9967990045a93050ae254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeae77f75db3d88d52b48ea63a71198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#abeeae77f75db3d88d52b48ea63a71198">GPMCAddrDataMuxProtocolSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t protocol)</td></tr>
<tr class="memdesc:abeeae77f75db3d88d52b48ea63a71198"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the Address and data multiplexed protocol for the device connected to csNum.<br />
.  <a href="#abeeae77f75db3d88d52b48ea63a71198">More...</a><br /></td></tr>
<tr class="separator:abeeae77f75db3d88d52b48ea63a71198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef592f64d05ed4e4576467967779c8f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#aef592f64d05ed4e4576467967779c8f9">GPMCTimeParaGranularitySelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t scaleftr)</td></tr>
<tr class="memdesc:aef592f64d05ed4e4576467967779c8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function selects the signals timing latencies scalar factor for the chip select.<br />
.  <a href="#aef592f64d05ed4e4576467967779c8f9">More...</a><br /></td></tr>
<tr class="separator:aef592f64d05ed4e4576467967779c8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a86d7d6f1ef8540eeb7bfd2b5e7adc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a7a86d7d6f1ef8540eeb7bfd2b5e7adc5">GPMCRdAccessAndCycleTimeTimingConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t conf)</td></tr>
<tr class="memdesc:a7a86d7d6f1ef8540eeb7bfd2b5e7adc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the RdAccessTime and CycleTime timing parameters.<br />
.  <a href="#a7a86d7d6f1ef8540eeb7bfd2b5e7adc5">More...</a><br /></td></tr>
<tr class="separator:a7a86d7d6f1ef8540eeb7bfd2b5e7adc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad5768a2746375cfbb7fa1f312aa3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#aacad5768a2746375cfbb7fa1f312aa3b">GPMCycle2CycleAndTurnArndTimeTimingConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t conf)</td></tr>
<tr class="memdesc:aacad5768a2746375cfbb7fa1f312aa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the Cycle2Cycle and BusTurnAround timing parameters.<br />
.  <a href="#aacad5768a2746375cfbb7fa1f312aa3b">More...</a><br /></td></tr>
<tr class="separator:aacad5768a2746375cfbb7fa1f312aa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd21e64c3e4353a339e82610397d8f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a9fd21e64c3e4353a339e82610397d8f1">GPMCAccessTypeSelect</a> (uint32_t baseAddr, uint32_t csNum, uint32_t mode, uint32_t accessType)</td></tr>
<tr class="memdesc:a9fd21e64c3e4353a339e82610397d8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the access type for read and write.<br />
.  <a href="#a9fd21e64c3e4353a339e82610397d8f1">More...</a><br /></td></tr>
<tr class="separator:a9fd21e64c3e4353a339e82610397d8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631de331cf86ce475c14a0990b6ea616"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a631de331cf86ce475c14a0990b6ea616">GPMCWaitPinMonitoringConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t mode, uint32_t flag)</td></tr>
<tr class="memdesc:a631de331cf86ce475c14a0990b6ea616"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the wait pin monitoring for read and write access.  <a href="#a631de331cf86ce475c14a0990b6ea616">More...</a><br /></td></tr>
<tr class="separator:a631de331cf86ce475c14a0990b6ea616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69573bc3885ea59a3d5db21ac290d2db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpmc_8h.html#a69573bc3885ea59a3d5db21ac290d2db">GPMCWrAccessAndWrDataOnADMUXBusTimingConfig</a> (uint32_t baseAddr, uint32_t csNum, uint32_t wrAccessTime, uint32_t wrDataOnADmuxBus)</td></tr>
<tr class="memdesc:a69573bc3885ea59a3d5db21ac290d2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configs the WrAccessTime, Cycle2Cycle and BusTurnAround timing parameters.<br />
.  <a href="#a69573bc3885ea59a3d5db21ac290d2db">More...</a><br /></td></tr>
<tr class="separator:a69573bc3885ea59a3d5db21ac290d2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GPMC APIs. </p>
<p>This file contains the device abstraction layer APIs for GPMC. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9fd21e64c3e4353a339e82610397d8f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCAccessTypeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>accessType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the access type for read and write.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">mode</td><td>Mode for which access type has to config.<br />
 This can take one of the following values :<br />
 GPMC_MODE_READ &ndash; To config access type for READ.<br />
 GPMC_MODE_WRITE &ndash; To config access type for WRITE.<br />
</td></tr>
    <tr><td class="paramname">accessType</td><td>Access Type.<br />
 This can take one of the following values :<br />
 GPMC_ACCESSTYPE_SINGLE &ndash; For single access.<br />
 GPMC_ACCESSTYPE_MULTIPLE &ndash; For multiple access.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="abeeae77f75db3d88d52b48ea63a71198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCAddrDataMuxProtocolSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the Address and data multiplexed protocol for the device connected to csNum.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol type.<br />
 This can take one of the following values :<br />
 GPMC_MUXADDDATA_AADMUX &ndash; For Address, address and data(AAD) muxed protocol.<br />
 GPMC_MUXADDDATA_NOMUX &ndash; For Non-muxed prorocol.<br />
 GPMC_MUXADDDATA_ADMUX &ndash; For Address &amp; Data muxed protocol.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a3e44e4885c69eca643e7a4094a53a1e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCADVTimingConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the timing parameters for ADV# signal.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">conf</td><td>Configuration value for ADV# signal timing parameters Use the GPMC_ADV_TIMING_CONFIG macro to get the value of conf. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="aea5595c2f501a9dc27eed6a7328538a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCAutoIdleConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>configVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the internal OCP clock gating strategy.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of gpmc.<br />
 </td></tr>
    <tr><td class="paramname">configVal</td><td>Config value.<br />
 This can take one of the following values :<br />
 GPMC_AUTOIDLE_FREERUN &ndash; When Interface clock is free-running. <br />
 GPMC_AUTOIDLE_AUTORUN &ndash; When Automatic Interface clk gating strategy is applied.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a0c62b501b3c714367fd8cfd86998f26d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCBaseAddrSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the base address for the chip select spcified.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">addr</td><td>Chip Select Base address.Value can range from 0 to 0x3F<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="abd3e8f0884dfdd6da80e8d84975226c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCClkActivationTimeConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the output GPMC_CLK activation time.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number. This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag to indicate the activation time of GPMC_CLK.<br />
 This can take one of the following values :<br />
 GPMC_CLKACTIVATIONTIME_ATSTART &ndash; For First rising edge of GPMC_CLK at start access time.<br />
 GPMC_CLKACTIVATIONTIME_ONECLK_AFTR &ndash; For First rising edge of GPMC_CLK one GPMC_FCLK cycle aftr start access time.<br />
 GPMC_CLKACTIVATIONTIME_TWOCLK_AFTR &ndash; For First rising edge of GPMC_CLK two GPMC_FCLK cycle aftr start access time.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a458d980b61bb6a6217cc169e5f5fc30d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCCSConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the chip select. This function is called during the chip select configuration.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">conf</td><td>Flag to indicate whether to enable or disable the Chip select.<br />
 This can take one of the following values :<br />
 GPMC_CS_ENABLE &ndash; To enable the chip select.<br />
 GPMC_CS_DISABLE &ndash; To disable the chip select.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ab0ab7afdd85e7fa21774298b1f2d6013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCCSTimingConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the timing parameters for Chip Select signal.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">conf</td><td>Configuration value for chip select timing parameters Use the GPMC_CS_TIMING_CONFIG macro to get the value of conf. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a7e9795181a126342e67b1c5eb55c1252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCDevPageLenSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the device page length.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">pageLen</td><td>Device Page Length.<br />
 This can take one of the following values :<br />
 GPMC_DEV_PAGELENGTH_FOUR &ndash; For 4 words page length.<br />
 GPMC_DEV_PAGELENGTH_EIGHT &ndash; For 8 words page length.<br />
 GPMC_DEV_PAGELENGTH_SIXTEEN &ndash; For 16 words page length. <br />
 GPMC_DEV_PAGELENGTH_THIRTYTWO &ndash; For 32 words page length. <br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a0d6ee3462afa58074238cdb138c1a174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCDevSizeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>devSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the device size for the device connected to csNum.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">devSize</td><td>Device Size.<br />
 This can take one of the following values :<br />
 GPMC_DEVICESIZE_8BITS &ndash; For 8-bit device.<br />
 GPMC_DEVICESIZE_16BITS &ndash; For 16-bit device.<br />
 GPMC_DEVICESIZE_32BITS &ndash; For 32-bit device.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a3c9b2821085f15eafdf553822ae9ff64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCDevTypeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>devType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the device type for the device connected to csNum.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">devType</td><td>Device Type.<br />
 This can take one of the following values :<br />
 GPMC_DEVICETYPE_NANDLIKE &ndash; For NAND flash like devices.<br />
 GPMC_DEVICETYPE_NORLIKE &ndash; For NOR flash like devices.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ab668cbc2ef3dc1048177bbbcc6bb9a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCAlgoSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the ECC algorithm to use for ECC error detection and correction.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">algo</td><td>ECC algorithm to use.<br />
 This can take one of the following values :<br />
 GPMC_ECC_ALGORITHM_HAMMINGCODE &ndash; For Hamming code.<br />
 GPMC_ECC_ALGORITHM_BCH &ndash; For BCH.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a4bfde4e3712a35ef5eababdfa002af3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCBCHErrCorrectionCapSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>errCorrCapVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the Error correction capability used for BCH ECC algorithm.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">errCorrCapVal</td><td>Error correction capability value.<br />
 This can take one of the following values :<br />
 GPMC_ECC_BCH_ERRCORRCAP_UPTO_4BITS &ndash; For Up to 4 bits error correction.<br />
 GPMC_ECC_BCH_ERRCORRCAP_UPTO_8BITS &ndash; For Up to 8 bits error correction.<br />
 GPMC_ECC_BCH_ERRCORRCAP_UPTO_16BITS &ndash; For Up to 16 bits error correction.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a954ba97bea94e7bf0904de11e0303402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCBCHNumOfSectorsSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numOfSects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the number of sectors to process with the BCH algorithm.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">numOfSects</td><td>Number of sectors.<br />
 This can take one of the following values :<br />
 GPMC_ECC_BCH_NUMOFSECTS_1 &ndash; For 1 sector (512 bytes page).<br />
 GPMC_ECC_BCH_NUMOFSECTS_2 &ndash; For 2 sectors. <br />
 GPMC_ECC_BCH_NUMOFSECTS_3 &ndash; For 3 sectors. <br />
 GPMC_ECC_BCH_NUMOFSECTS_4 &ndash; For 4 sectors. <br />
 GPMC_ECC_BCH_NUMOFSECTS_5 &ndash; For 5 sectors. <br />
 GPMC_ECC_BCH_NUMOFSECTS_6 &ndash; For 6 sectors. <br />
 GPMC_ECC_BCH_NUMOFSECTS_7 &ndash; For 7 sectors. <br />
 GPMC_ECC_BCH_NUMOFSECTS_8 &ndash; For 8 sectors (4KB page).<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ab051a53ac2e13c6fbd0e9d14c070165a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCECCBCHResultGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the BCH result.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">resIndex</td><td>BCH ECC result index.<br />
 This can take one of the following values :<br />
 GPMC_BCH_RESULT0 &ndash; For BCH result 0.<br />
 GPMC_BCH_RESULT1 &ndash; For BCH result 1.<br />
 GPMC_BCH_RESULT2 &ndash; For BCH result 2.<br />
 GPMC_BCH_RESULT3 &ndash; For BCH result 3.<br />
 GPMC_BCH_RESULT4 &ndash; For BCH result 4.<br />
 GPMC_BCH_RESULT5 &ndash; For BCH result 5.<br />
 GPMC_BCH_RESULT6 &ndash; For BCH result 6.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select. <br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ECC result.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="aaaa4442ef5e5a8ba01501a5f5a06d377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCECCBCHSWDataRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function read the data to BCH_SWDATA register. This is used to directly padd data to the BCH ECC calculator without accessing the actual NAND flash interface.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a3405c3dd4b1bf99efc45918d065459fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCBCHSWDataWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bchData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function write the data to BCH_SWDATA register. This is used to directly padd data to the BCH ECC calculator without accessing the actual NAND flash interface.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">bchData</td><td>BCH data to be included in the BCH calculation. Only bits 0 to 7 are taken into account, if the calculator is configured to use 8 bits data using GPMCECCColumnSelect function.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ab3d6efa14a9d745e9edce27e61104d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCBCHWrapModeValSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wrapModeVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the wrap mode(Spare area organization definition) for the ECC BCH algorithm.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">wrapModeVal</td><td>Wrap mode value. Value can range from 0x00 to 0x0F.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a2377751a3c935eb34dff185528b58df7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCColumnSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eccColVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects number of columns to use for ECC calculation.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">eccColVal</td><td>ECC column value.<br />
 This can take one of the following values :<br />
 GPMC_ECC_COLUMNS_8 &ndash; ECC calculated on 8 columns.<br />
 GPMC_ECC_COLUMNS_16 &ndash; ECC calculated on 16 columns.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a750ba07c84de466283bea197f748c6c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCCSSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the Chip-select where ECC is computed.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select. <br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="aa10ccdd062439562bfce242d5bc3a4ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the ECC feature.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a2a1728b1b1f4a6f85df11bda02c5fa4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function Enables the ECC feature.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ad961bef50564f35777af41ff5b39c522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCECCResultGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eccResReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the ECC result from the ECC register.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">eccResReg</td><td>ECC result register for from which ECC value has to retrive.<br />
 This can take one of the following values :<br />
 GPMC_ECC_RESULT_0 &ndash; For ECC result 0 register.<br />
 GPMC_ECC_RESULT_1 &ndash; For ECC result 1 register.<br />
 GPMC_ECC_RESULT_2 &ndash; For ECC result 2 register.<br />
 GPMC_ECC_RESULT_3 &ndash; For ECC result 3 register.<br />
 GPMC_ECC_RESULT_4 &ndash; For ECC result 4 register.<br />
 GPMC_ECC_RESULT_5 &ndash; For ECC result 5 register.<br />
 GPMC_ECC_RESULT_6 &ndash; For ECC result 6 register.<br />
 GPMC_ECC_RESULT_7 &ndash; For ECC result 7 register.<br />
 GPMC_ECC_RESULT_8 &ndash; For ECC result 8 register.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ECC result.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a121b8c90c34fbb2eef9affe724f57044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCResultRegClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears all ECC result registers.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a7d3abfb76d310b1c062cc6c2d65f7eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCResultRegSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eccResReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the ECC result register where the first ECC computation will be stored.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">eccResReg</td><td>ECC result register.<br />
 This can take one of the following values :<br />
 GPMC_ECCPOINTER_RESULT_1 &ndash; ECC pointer for result 1 register.<br />
 GPMC_ECCPOINTER_RESULT_2 &ndash; ECC pointer for result 2 register.<br />
 GPMC_ECCPOINTER_RESULT_3 &ndash; ECC pointer for result 3 register.<br />
 GPMC_ECCPOINTER_RESULT_4 &ndash; ECC pointer for result 4 register.<br />
 GPMC_ECCPOINTER_RESULT_5 &ndash; ECC pointer for result 5 register.<br />
 GPMC_ECCPOINTER_RESULT_6 &ndash; ECC pointer for result 6 register.<br />
 GPMC_ECCPOINTER_RESULT_7 &ndash; ECC pointer for result 7 register.<br />
 GPMC_ECCPOINTER_RESULT_8 &ndash; ECC pointer for result 8 register.<br />
 GPMC_ECCPOINTER_RESULT_9 &ndash; ECC pointer for result 9 register.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a8262e4189b14fba4222b90319d641bf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCResultSizeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eccResReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eccSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the ECC size for the ECC result register. <br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">eccResReg</td><td>ECC result register for which ECC size has to select.<br />
 This can take one of the following values :<br />
 GPMC_ECC_RESULT_1 &ndash; For ECC result 1 register.<br />
 GPMC_ECC_RESULT_2 &ndash; For ECC result 2 register.<br />
 GPMC_ECC_RESULT_3 &ndash; For ECC result 3 register.<br />
 GPMC_ECC_RESULT_4 &ndash; For ECC result 4 register.<br />
 GPMC_ECC_RESULT_5 &ndash; For ECC result 5 register.<br />
 GPMC_ECC_RESULT_6 &ndash; For ECC result 6 register.<br />
 GPMC_ECC_RESULT_7 &ndash; For ECC result 7 register.<br />
 GPMC_ECC_RESULT_8 &ndash; For ECC result 8 register.<br />
 GPMC_ECC_RESULT_9 &ndash; For ECC result 9 register.<br />
 </td></tr>
    <tr><td class="paramname">eccSize</td><td>ECC size.<br />
 This can take one of the following values :<br />
 GPMC_ECC_SIZE_0 &ndash; For ECC size 0.<br />
 GPMC_ECC_SIZE_1 &ndash; For ECC size 1.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a158484b1ff684cd38b329c4c485f3eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCECCSizeValSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eccSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eccSizeVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the ECCSIZE1 value. <br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">eccSize</td><td>ECC size for which size has to set.<br />
 This can take one of the following values :<br />
 GPMC_ECC_SIZE_0 &ndash; For ECC size 0.<br />
 GPMC_ECC_SIZE_1 &ndash; For ECC size 1.<br />
 </td></tr>
    <tr><td class="paramname">eccSizeVal</td><td>ECC size value.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a4244ebccd44f0b708ec8db8f78514c39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCEmptyWriteBuffStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the empty write buffer status.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Empty buffer status.<br />
 0 : If the Write Buffer is not empty.<br />
 1 : If the Write Buffer is empty.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a3022e0c0d9f1412211552aecfa735ea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCErrAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the address of illegal access when an error occures.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>illegalAddrVal Address of illegal access. <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ab977806888d1553702c5cf1f7ee76501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCErrStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether passed error is occured or not.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">err</td><td>Type of the error.<br />
 This can take one of the following values :<br />
 GPMC_TIMEOUT_ERROR &ndash; For timeout error.<br />
 GPMC_NOTSUPPMCMD_ERROR &ndash; For non-supported cmd error.<br />
 GPMC_NOTSUPPADD_ERROR &ndash; For non-supported add error.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ErrStatus <br />
<pre class="fragment">                    1 : If passed argument type of error occured.\n
                    0 : If passed argument type of error doesn't
                        occured.\n</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="a9b0949a9cf1c0a9abcc4b29cb5a954aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCErrSysCmdGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the System Command of the transaction that caused the error.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>errCmd System Command that caused the error. <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a002c2e2e25215e1cd8c1152685f8eeee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCErrValStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the status of error validity.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ErrValstatus Error validity status. <br />
 0 : Error fields are no longer valid.<br />
 1 : Error detected and logged in the other error fields.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a066c7955dd6c1f5fd5ebfa0e0c1e91ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCFclkDividerSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>divideVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the FCLK DIVIDER for the chip select passed.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">divideVal</td><td>FCLK Divice value.<br />
 This can take one of the following values :<br />
 GPMC_FCLK_DIV_BY_1 &ndash; For GPMC_CLK = (GPMC_FCLK / 1)<br />
 GPMC_FCLK_DIV_BY_2 &ndash; For GPMC_CLK = (GPMC_FCLK / 2)<br />
 GPMC_FCLK_DIV_BY_3 &ndash; For GPMC_CLK = (GPMC_FCLK / 3)<br />
 GPMC_FCLK_DIV_BY_4 &ndash; For GPMC_CLK = (GPMC_FCLK / 4)<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="aa577d30a0728f51f9c43feb2888511b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCIdleModeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the idle mode for gpmc.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of gpmc.<br />
 </td></tr>
    <tr><td class="paramname">mode</td><td>Idle mode.<br />
 This can take one of the following values :<br />
 GPMC_IDLEMODE_FORCEIDLE &ndash; for force-idle. <br />
 GPMC_IDLEMODE_NOIDLE &ndash; for no-idle. <br />
 GPMC_IDLEMODE_SMARTIDLE &ndash; for smart-idle.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a633fdf3231581fed9134cb9b8b128237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disable/masks the interrupts.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag for which interrupt has to mask.<br />
 This can take one of the following values :<br />
 GPMC_FIFOEVENT_INT : For FIFOEvent interrupt.<br />
 GPMC_TERMINALCOUNT_INT : For TerminalCountEvent interrupt.<br />
 GPMC_WAIT0EDGEDETECTION_INT : For Wait1 Edge Detection interrupt.<br />
 GPMC_WAIT1EDGEDETECTION_INT : For Wait1 Edge Detection interrupt. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ae8a39454d569d90d78b15a69f8ca595a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the interrupts.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag for which interrupt has to enable. This can take one of the following values :<br />
 GPMC_FIFOEVENT_INT : For FIFOEvent interrupt.<br />
 GPMC_TERMINALCOUNT_INT : For TerminalCountEvent interrupt.<br />
 GPMC_WAIT0EDGEDETECTION_INT : For Wait1 Edge Detection interrupt.<br />
 GPMC_WAIT1EDGEDETECTION_INT : For Wait1 Edge Detection interrupt.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ab87c71bfe694f793e8d9ea83566903c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCIntStatusClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears/resets the interrupt status.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag for which interrupt status has to reset.<br />
 This can take one of the following values :<br />
 GPMC_FIFOEVENT_STATUS : For FIFOEvent interrupt status.<br />
 GPMC_TERMINALCOUNT_STATUS : For TerminalCountEvent interrupt status.<br />
 GPMC_WAIT0EDGEDETECTION_STATUS: For Wait1 Edge Detection interrupt status.<br />
 GPMC_WAIT1EDGEDETECTION_STATUS: For Wait1 Edge Detection interrupt status.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="afbac13cc1b4e507095491832022f94a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCIntStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets Interrupt status of interrupt passed.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag for which interrupt status has to get.<br />
 This can take one of the following values :<br />
 GPMC_FIFOEVENT_STATUS : For FIFOEvent interrupt status.<br />
 GPMC_TERMINALCOUNT_STATUS : For TerminalCountEvent interrupt status.<br />
 GPMC_WAIT0EDGEDETECTION_STATUS: For Wait1 Edge Detection interrupt status.<br />
 GPMC_WAIT1EDGEDETECTION_STATUS: For Wait1 Edge Detection interrupt status.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>intSts Interrupt Status. Return value meaning depends on the interrupt flag passed. <br />
 if flag is GPMC_FIFOEVENT_STATUS, then <br />
 0 : Less than FIFOTHRESHOLD bytes are available in prefetch/read mode.<br />
 Less than FIFOTHRESHOLD byte free spaces are available in write-posting/write mode. <br />
 1 : Atleast FIFOTHRESHOLD bytes are available in prefetch/read mode.<br />
 Atlease FIFOTHRESHOLD byte free places are available in write-posting/write mode.<br />
 if flag is GPMC_TERMINALCOUNT_STATUS, then <br />
 0 : CountValue is greater than 0.<br />
 1 : CountValue is equal to 0.<br />
 if flag is GPMC_WAIT0EDGEDETECTION_STATUS, then <br />
 0 : A transition on WAIT0 input pin has not been detected.<br />
 1 : A transition on WAIT0 input pin has been detected.<br />
 if flag is GPMC_WAIT1EDGEDETECTION_STATUS, then <br />
 0 : A transition on WAIT1 input pin has not been detected.<br />
 1 : A transition on WAIT1 input pin has been detected.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a1be686b554dd7fc06a4404a5228b5259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCMaskAddrSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maskaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the chip select mask address or size.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">maskaddr</td><td>Address Mask to set. <br />
 This can take one of the following values :<br />
 GPMC_CS_SIZE_256MB &ndash; For Chip-select size of 256 MB.<br />
 GPMC_CS_SIZE_128MB &ndash; For Chip-select size of 128 MB.<br />
 GPMC_CS_SIZE_64MB &ndash; For Chip-select size of 64 MB.<br />
 GPMC_CS_SIZE_32MB &ndash; For Chip-select size of 32 MB.<br />
 GPMC_CS_SIZE_16MB &ndash; For Chip-select size of 16 MB.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a5bb14ae067cc4e53a0cb66ab73b87a87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCModuleResetStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the software resets status of GPMC.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Reset status : <br />
 0 : Module reset is on-going.<br />
 1 : Module reset is completed.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a317e33786b3d6ea27d49e709f62df819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCModuleSoftReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the GPMC.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a8e19235bf279cb0b3b963189e10863d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCNANDAddrWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes the NAND address to ADDRESS register.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number for which NAND is interfaced.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">addr</td><td>ADDRESS to write. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a75fb28417a37a7bf6c06919cb9bd25fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCNANDDataRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function the data from NAND DATA register.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number for which NAND is interfaced.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read NAND data.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ac090e4e13d9f6cd45c64915623f8a466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCNANDDataWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes the NAND data to DATA register.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number for which NAND is interfaced.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">data</td><td>data to write. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a1256a56727e4e5415492c68811d10ec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCNANDForcePostedWriteFeatureConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the Force Posted Write feature to NAND Cmd/Add/Data location.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag to indicate whether to enable/disable the Force Posted Write feature.<br />
 This can take one of the following values :<br />
 GPMC_FORCEPOSTEDWRITE_ENABLE &ndash; To enable the feature.<br />
 GPMC_FORCEPOSTEDWRITE_DISABLE &ndash; To disable the feature.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ab59f15792be017a67f8c97cfcec579d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchAccessCycleOptConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>configVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the access cycle optimization for PREFETCH engine. <br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">configVal</td><td>access cycle optimization config value.<br />
 This can take one of the following values :<br />
 GPMC_PREFETCH_OPTIMIZED_ACCESS_ENABLE &ndash; To enable the access</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">                                                           optimization\n
                    GPMC_PREFETCH_OPTIMIZED_ACCESS_DISABLE -- To disable
                                                              the access



                                                           optimization\n
</pre><dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a870f4d78dcaaa78a0ea7af5c7d62b28f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchAccessModeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>accessMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the access mode of the prefetch engine.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">accessMode</td><td>Access mode of prefetch engine.<br />
 This can take one of the following values :<br />
 GPMC_PREFETCH_ACCESSMODE_READ &ndash; For READ Access mode.<br />
 GPMC_PREFETCH_ACCESSMODE_WRITE &ndash; For WRITE Access mode.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a8dcf3a891b2f74f925794a8802af637e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCPrefetchCountValGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the number of remaining bytes to be read or to be written by the engine according to the TransferCount value.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count value.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="afc3369b49f234914d346d903356c1ca6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchCSSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the chip select(CS) where Prefetch Postwrite engine is active.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select. <br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a13901030cc7c9b9ad3ed6475caf407ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchCycleOptValSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cleOptVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of GPMC_FCLK cycles to be substracted from RdCycleTime,WrCycleTime, AccessTime, CSRdOffTime, CSWrOffTime, ADVRdOffTime,ADVWrOffTime, OEOffTime, WEOffTime for PREFETCH engine cycle optimization. <br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">cleOptVal</td><td>Cycle optimization value. This can take value from 0 to 7.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ad05c71de36f1692eb9421ff50dfeb82e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchEngineDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disable the PREFETCH POSTWRITE engine. <br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a65d2463a14805b647cd9669d7b559459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchEngineEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the PREFETCH POSTWRITE engine. <br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a6d8ab95768edcbc0067302fe3ba17369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchEngineStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the FIFO pointer to 0 in prefetch mode and 40h in postwrite mode starts the PREFETCH and POST WRITE engine.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a0a79ba6340e6d858c4a2f7c4d3f79d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCPrefetchEngineStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of PREFETCH and POST WRITE engine.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Prefetch engine status<br />
 0 : If engine is stopped.<br />
 1 : If engine is running.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="afe5a4911d121f3f70dc4341d8622ce3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchEngineStop </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the PREFETCH and POST WRITE engine.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ab5455e95b256917470e534c59b60f739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCPrefetchFifoPtrValGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the FIFO pointer value of PREFETCH engine. FIFO pointer value indicates number of bytes available to be read or number of free empty place to write.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FIFO pointer value.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a01f41adebad615e8613b3e06efe442a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCPrefetchFifoThrldStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the PREFETCH engine FIFO threshold status. <br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stauts Threshold status.<br />
 1 : FIFO Pointer is greater than FIFO Threshold.<br />
 0 : FIFO Pointer is smaller or equal to FIFO Threshold.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a1d4618adfc74e55addd81bcd18aba97e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchFifoThrldValSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fifoThrsld</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the FIFOTHRESHOLD (maximum number of bytes read from the FIFO or written to the FIFO by the host on a DMA or interrupt request) value for the PREFETCH and POSTWRITE engine.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">fifoThrsld</td><td>FIFO threshold value. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="abc7725c561cdac19107942206f858f2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchRRArbitrationConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>configVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the PREFETCH and POSTWRITE ROUND ROBIN arbitration. <br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">configVal</td><td>Round Robin arbitration config value.<br />
 This can take one of the following values :<br />
 GPMC_PREFETCH_RR_ARBITRATION_ENABLE &ndash; To enable the Round robin</td></tr>
  </table>
  </dd>
</dl>
<p>arbitration<br />
 GPMC_PREFETCH_RR_ARBITRATION_DISABLE &ndash; To disable the Round robin</p>
<p>arbitration<br />
 </p><dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a9124b5296fcc371c3e53b369662369fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchSyncModeConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function congigs when the PREFETCH engine has to start the access to CS.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag to specify when PREFETCH engine has to start the access to CS.<br />
 This can take one of the following values :<br />
 GPMC_PREFETCH_ACCESSCS_AT_START &ndash; To start the access as soon as STARTENGINE is set.<br />
 GPMC_PREFETCH_ACCESSCS_AT_STARTANDWAIT &ndash; To start the access as soon as STARTENGINE is set and non wait edge detection on the selected wait pin.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a3573bb56bb44f0eb91636e4200802a8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchSyncTypeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>syncType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function select the synchronization type to use on FIFO threshold crossing.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">syncType</td><td>Synchronization type.<br />
 This can take one of the following values :<br />
 GPMC_PREFETCH_SYNCTYPE_DMA &ndash; For DMA sync mode <br />
 GPMC_PREFETCH_SYNCTYPE_INT &ndash; For INTERRUPT sync mode.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a60f659ba9d8c95e65c3e70dad11208a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchTrnsCntValSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>trnsCntVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the transfer count (number of bytes to be read or written by the engine to the selected CS) for the PREFETCH engine.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">trnsCntVal</td><td>Tranfer count value. Value can range from 0 to 2000h i.e 8 KB.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a46c912e940eef4f6c17f8ae7349b8dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchWaitPinSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>waitPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the wait pin edge detector to start the PREFETCH engine in synchronized mode.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">waitPin</td><td>Wait pin to use for edge detector. <br />
 This can take one of the following values :<br />
 GPMC_PREFETCH_WAITPINSELECTOR_W0 &ndash; To Selects</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">                                                     Wait0EdgeDetection\n
                    GPMC_PREFETCH_WAITPINSELECTOR_W1 -- To Selects



                                                     Wait1EdgeDetection\n
</pre><dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a9462388affa744fabc739eff154340a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCPrefetchWeightedPrioSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>accessVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of access to be granted to PREFETCH engine when ROUND ROBIN arbitration. i.e When an arbitration occurs between a direct memory access and a PFPW engine access, the direct memory access is always serviced. If the PFPWEnRoundRobin is enabled value set by this function plus one number of access is granted to the PREFETCH and WRITE POST engine.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">accessVal</td><td>Access value to set. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a7a86d7d6f1ef8540eeb7bfd2b5e7adc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCRdAccessAndCycleTimeTimingConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the RdAccessTime and CycleTime timing parameters.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">conf</td><td>Configuration value for RdAccessTime and CycleTime timing parameters. Use the GPMC_RDACCESS_CYCLETIME_TIMING_CONFIG macro to get the value of conf. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="aecc7b3b1a0df78f892ddc935df29a1e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCReadTypeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>readType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the read type.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">readType</td><td>readType for the read mode operation.<br />
 This can take one of the following values :<br />
 GPMC_READTYPE_ASYNC &ndash; For read asynchronous.<br />
 GPMC_READTYPE_SYNC &ndash; For read synchronous.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a91ec12372af08b1b88f974b1ba8b1d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCRevisionGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the IP revision code of GPMC.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ipRev IP revision code of GPMC.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a8269233218901c823ce0f5adec37a6ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCSNANDCmdWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes the NAND command to COMMAND register.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number for which NAND is interfaced. This can take one of the following values : GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0. GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1. GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2. GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3. GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4. GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5. GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6. GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">cmd</td><td>COMMAND to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="aaa566459c986d4b74bd636ae104c6384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCSyncWrapBurstConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the wrapping burst capability.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag to indicate whether to enable/disable Synchronous wrapping burst capability.<br />
 This can take one of the following values :<br />
 GPMC_WRAPBURST_ENABLE &ndash; To enable the wrap burst capability.<br />
 GPMC_WRAPBURST_DISABLE &ndash; To disable the wrap burst capability.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a297101f0265157c2a5d1e3953d5efc2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCTimeOutFeatureConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the timeout feature.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag to indicate whether to enable or disable the feature.<br />
 This can take one of the following values :<br />
 GPMC_TIMEOUTFEATURE_ENABLE - To enable the timout feature.<br />
 GPMC_TIMEOUTFEATURE_DISABLE - To disable the timout feature.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a2a0d05b68d9f872d3ebf5fba5200a608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCTimeOutStartValSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeoutVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the start timeout value(TIMEOUTSTARTVALUE) of the timeout counter.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">timeoutVal</td><td>Timeout start Value in GPMC_FCLK cycles.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="aef592f64d05ed4e4576467967779c8f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCTimeParaGranularitySelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>scaleftr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the signals timing latencies scalar factor for the chip select.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">scaleftr</td><td>Scalar factor.<br />
 This can take one of the following values :<br />
 GPMC_TIMEPARAGRANULARITY_X1 &ndash; For x1 latencies<br />
 GPMC_TIMEPARAGRANULARITY_X2 &ndash; For x2 latencies<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a8673903515d9967990045a93050ae254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCWaitMonitoringTimeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs/selects the wait monitoring time for the device connected to csNum.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag to indicate the wait monitoring time.<br />
 This can take one of the following values :<br />
 GPMC_WAITMONITORINGTIME_WITH_VALIDDATA &ndash; For wait pin monitoring with valid data.<br />
 GPMC_WAITMONITORINGTIME_ONECLKB4_VALIDDATA &ndash; For wait pin monitoring one GPMC_CLK before valid data. <br />
 GPMC_WAITMONITORINGTIME_TWOCLKB4_VALIDDATA &ndash; For wait pin monitoring two GPMC_CLK before valid data. <br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a631de331cf86ce475c14a0990b6ea616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCWaitPinMonitoringConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the wait pin monitoring for read and write access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">mode</td><td>Mode for which wait monitoring has to config.<br />
 This can take one of the following values :<br />
 GPMC_MODE_READ &ndash; To config the wait monitoring for READ.<br />
 GPMC_MODE_WRITE &ndash; To config the wait monitoring for WRITE.<br />
 </td></tr>
    <tr><td class="paramname">flag</td><td>Flag to indicate whether to enable/disable the wait monitoring.<br />
 This can take one of the following values :<br />
 GPMC_WAITMONITORING_ENABLE &ndash; To enable the wait monitoring.<br />
 GPMC_WAITMONITORING_DISABLE &ndash; To disable the wait monitoring.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ad34642199d07bf53d60b68db091e0879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCWaitPinPolaritySelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>polarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets/selects the waitpin polarity.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">pin</td><td>Wait pin.<br />
 This can take one of the following values :<br />
 GPMC_WAIT_PIN0 &ndash; For WAITPIN0.<br />
 GPMC_WAIT_PIN1 &ndash; For WAITPIN1.<br />
 </td></tr>
    <tr><td class="paramname">polarity</td><td>Wait pin polarity.<br />
 This can take one of the following values :<br />
 GPMC_WAIT_PIN_POLARITY_LOW &ndash; for active low.<br />
 GPMC_WAIT_PIN_POLARITY_HIGH &ndash; for active high.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a71cff5e49943bd4564b81b705151876e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCWaitPinSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>waitPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the WAIT PIN for the device connected to csNum.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">waitPin</td><td>Wait Pin.<br />
 This can take one of the following values :<br />
 GPMC_WAIT_PIN0 &ndash; To Select WAITPIN0.<br />
 GPMC_WAIT_PIN1 &ndash; To Select WAITPIN1.<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="abe04806c4a2a6133ada943ac9623b423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPMCWaitPinStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the waitpin status.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">pin</td><td>Wait pin.<br />
 This can take one of the following values :<br />
 GPMC_WAIT_PIN0 &ndash; For WAITPIN0.<br />
 GPMC_WAIT_PIN1 &ndash; For WAITPIN1.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pinStatus Pin Status.<br />
 0 : If the status is active low.<br />
 1 : If the status is active high.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a2e96a1245cf5c870394dba6381e14aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCWEAndOETimingConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the timing parameters for WE# and OE# signal.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">conf</td><td>Configuration value for WE# and OE# signal timing Parameters. Use the GPMC_WE_OE_TIMING_CONFIG macro to get the value of conf. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a69573bc3885ea59a3d5db21ac290d2db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCWrAccessAndWrDataOnADMUXBusTimingConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wrAccessTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wrDataOnADmuxBus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the WrAccessTime, Cycle2Cycle and BusTurnAround timing parameters.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">wrAccessTime</td><td>Write Access Time(Delay from StartAccessTime to the GPMC_FCLK rising edge corresponding the GPMC_CLK rising edge used by the attached memory for the first data capture) in GPMC_FCLK cycles.<br />
 </td></tr>
    <tr><td class="paramname">wrDataOnADmuxBus</td><td>Specifies on which GPMC_FCLK rising edge the first data of the synchronous burst write is driven in the add/data multiplexed bus.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="a46ac45b8ea0522c3b269f8937e483b9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCWriteTypeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>writeType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function selects the write type.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">writeType</td><td>writeType for the write mode operation.<br />
 This can take one of the following values :<br />
 GPMC_WRITETYPE_ASYNC &ndash; For write asynchronous.<br />
 GPMC_WRITETYPE_SYNC &ndash; For write synchronous.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="aacad5768a2746375cfbb7fa1f312aa3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPMCycle2CycleAndTurnArndTimeTimingConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>csNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configs the Cycle2Cycle and BusTurnAround timing parameters.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of GPMC.<br />
 </td></tr>
    <tr><td class="paramname">csNum</td><td>Chip Select Number.<br />
 This can take one of the following values :<br />
 GPMC_CHIP_SELECT_0 &ndash; For Chip Select 0.<br />
 GPMC_CHIP_SELECT_1 &ndash; For Chip Select 1.<br />
 GPMC_CHIP_SELECT_2 &ndash; For Chip Select 2.<br />
 GPMC_CHIP_SELECT_3 &ndash; For Chip Select 3.<br />
 GPMC_CHIP_SELECT_4 &ndash; For Chip Select 4.<br />
 GPMC_CHIP_SELECT_5 &ndash; For Chip Select 5.<br />
 GPMC_CHIP_SELECT_6 &ndash; For Chip Select 6.<br />
 GPMC_CHIP_SELECT_7 &ndash; For Chip Select 7.<br />
 </td></tr>
    <tr><td class="paramname">conf</td><td>Configuration value for Cycle2Cycle and BusTurnAround timing parameters. Use the GPMC_CYCLE2CYCLE_BUSTURNAROUND_TIMING_CONFIG macro to get the value of conf. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
