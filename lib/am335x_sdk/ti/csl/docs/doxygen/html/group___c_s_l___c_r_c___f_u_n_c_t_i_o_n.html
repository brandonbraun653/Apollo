<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CRC Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CRC Functions<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a> &raquo; <a class="el" href="group___c_s_l___c_r_c.html">CRC</a><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a> &raquo; <a class="el" href="group___c_s_l___c_r_c.html">CRC</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_r_c___a_p_i.html">CRC (CRC)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf1d528be4ec219989ea1c82a2a53080f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gaf1d528be4ec219989ea1c82a2a53080f">CRCInitialize</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t crcWatchdogPreload, uint32_t crcBlockPreload)</td></tr>
<tr class="memdesc:gaf1d528be4ec219989ea1c82a2a53080f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize CRC channel and will configure watchdog and block preload value for given channel.  <a href="#gaf1d528be4ec219989ea1c82a2a53080f">More...</a><br /></td></tr>
<tr class="separator:gaf1d528be4ec219989ea1c82a2a53080f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2883454c481524baf9ba8594a6d6d57"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gaf2883454c481524baf9ba8594a6d6d57">CRCVerifyInitialize</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t crcWatchdogPreload, uint32_t crcBlockPreload)</td></tr>
<tr class="memdesc:gaf2883454c481524baf9ba8594a6d6d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the CRC watchdog and block preload value initialized for given channel.  <a href="#gaf2883454c481524baf9ba8594a6d6d57">More...</a><br /></td></tr>
<tr class="separator:gaf2883454c481524baf9ba8594a6d6d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab100922d0ce9e269d1fb0ac524ec71cb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gab100922d0ce9e269d1fb0ac524ec71cb">CRCConfigure</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t crcPatternCount, uint32_t crcSectorCount, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a> crcMode)</td></tr>
<tr class="memdesc:gab100922d0ce9e269d1fb0ac524ec71cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will configure CRC mode, pattern and sector count for given channel.  <a href="#gab100922d0ce9e269d1fb0ac524ec71cb">More...</a><br /></td></tr>
<tr class="separator:gab100922d0ce9e269d1fb0ac524ec71cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559bd16f4436d4bf626a479fa70f5540"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga559bd16f4436d4bf626a479fa70f5540">CRCVerifyConfigure</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t crcPatternCount, uint32_t crcSectorCount, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a> crcMode)</td></tr>
<tr class="memdesc:ga559bd16f4436d4bf626a479fa70f5540"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will verify the configure of CRC mode, pattern and sector count for given channel.  <a href="#ga559bd16f4436d4bf626a479fa70f5540">More...</a><br /></td></tr>
<tr class="separator:ga559bd16f4436d4bf626a479fa70f5540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga986eb01b813b10a74bc20ee60a748eef"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga986eb01b813b10a74bc20ee60a748eef">CRCChannelReset</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel)</td></tr>
<tr class="memdesc:ga986eb01b813b10a74bc20ee60a748eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to reset the CRC channel.  <a href="#ga986eb01b813b10a74bc20ee60a748eef">More...</a><br /></td></tr>
<tr class="separator:ga986eb01b813b10a74bc20ee60a748eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308100fb0c56aabeeb2dcad350173233"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga308100fb0c56aabeeb2dcad350173233">CRCGetPSASigRegAddr</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#gabb3457a6c9cfb6011304b0bff52c125c">crcSignatureRegAddr_t</a> *pCRCRegAddr)</td></tr>
<tr class="memdesc:ga308100fb0c56aabeeb2dcad350173233"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the PSA register address for given Channel.  <a href="#ga308100fb0c56aabeeb2dcad350173233">More...</a><br /></td></tr>
<tr class="separator:ga308100fb0c56aabeeb2dcad350173233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ad20b7cb7075cad634a01e0f084dcb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gae1ad20b7cb7075cad634a01e0f084dcb">CRCGetPSASig</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *pCRCPSASign)</td></tr>
<tr class="memdesc:gae1ad20b7cb7075cad634a01e0f084dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the PSA register value for given Channel.  <a href="#gae1ad20b7cb7075cad634a01e0f084dcb">More...</a><br /></td></tr>
<tr class="separator:gae1ad20b7cb7075cad634a01e0f084dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49330fea3c0ac807ae8e9e70f00a5e4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gad49330fea3c0ac807ae8e9e70f00a5e4">CRCSetPSASeedSig</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, const <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *pCRCPSASeedSign)</td></tr>
<tr class="memdesc:gad49330fea3c0ac807ae8e9e70f00a5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to set the PSA seed value without compression for given Channel.  <a href="#gad49330fea3c0ac807ae8e9e70f00a5e4">More...</a><br /></td></tr>
<tr class="separator:gad49330fea3c0ac807ae8e9e70f00a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eab9ba6d3098f09fb5c23445005a54b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga1eab9ba6d3098f09fb5c23445005a54b">CRCGetPSASectorSig</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *pCRCSectorSign)</td></tr>
<tr class="memdesc:ga1eab9ba6d3098f09fb5c23445005a54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get sector signature Value/ CRC value for given channel.  <a href="#ga1eab9ba6d3098f09fb5c23445005a54b">More...</a><br /></td></tr>
<tr class="separator:ga1eab9ba6d3098f09fb5c23445005a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6123f3d71a683cc23a18264376007e63"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga6123f3d71a683cc23a18264376007e63">CRCGetHighestPriorityIntrStatus</a> (uint32_t baseAddr, uint32_t *pIntVecAddr)</td></tr>
<tr class="memdesc:ga6123f3d71a683cc23a18264376007e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the pending interrupt with highest priority.  <a href="#ga6123f3d71a683cc23a18264376007e63">More...</a><br /></td></tr>
<tr class="separator:ga6123f3d71a683cc23a18264376007e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab02b753542d9f0ef26f9cca56e91ecf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gaab02b753542d9f0ef26f9cca56e91ecf">CRCGetIntrStatus</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t *pIntrStatus)</td></tr>
<tr class="memdesc:gaab02b753542d9f0ef26f9cca56e91ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the pending interrupts for given Channel.  <a href="#gaab02b753542d9f0ef26f9cca56e91ecf">More...</a><br /></td></tr>
<tr class="separator:gaab02b753542d9f0ef26f9cca56e91ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2403b0f0b751df526cd4898569bf436d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga2403b0f0b751df526cd4898569bf436d">CRCEnableIntr</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga2403b0f0b751df526cd4898569bf436d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to enable interrupts for given Channel.  <a href="#ga2403b0f0b751df526cd4898569bf436d">More...</a><br /></td></tr>
<tr class="separator:ga2403b0f0b751df526cd4898569bf436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356d6deabd7fbe11005ad0e903975045"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga356d6deabd7fbe11005ad0e903975045">CRCDisableIntr</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga356d6deabd7fbe11005ad0e903975045"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to disable interrupts for given Channel.  <a href="#ga356d6deabd7fbe11005ad0e903975045">More...</a><br /></td></tr>
<tr class="separator:ga356d6deabd7fbe11005ad0e903975045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71509ef795b47e2400a72c47109f9b6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gab71509ef795b47e2400a72c47109f9b6">CRCClearIntr</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t intrMask)</td></tr>
<tr class="memdesc:gab71509ef795b47e2400a72c47109f9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to clear interrupts for given Channel.  <a href="#gab71509ef795b47e2400a72c47109f9b6">More...</a><br /></td></tr>
<tr class="separator:gab71509ef795b47e2400a72c47109f9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79190e984729641dd78a7f123a8628e1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga79190e984729641dd78a7f123a8628e1">CRCPowerDownCtrl</a> (uint32_t baseAddr, uint32_t ctrlFlag)</td></tr>
<tr class="memdesc:ga79190e984729641dd78a7f123a8628e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to control the power down of the CRC module.  <a href="#ga79190e984729641dd78a7f123a8628e1">More...</a><br /></td></tr>
<tr class="separator:ga79190e984729641dd78a7f123a8628e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155f2eb0b82fa4811ac4f625607db982"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga155f2eb0b82fa4811ac4f625607db982">CRCIsBusy</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t *pBusyFlag)</td></tr>
<tr class="memdesc:ga155f2eb0b82fa4811ac4f625607db982"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to check if CRC is busy for given Channel.  <a href="#ga155f2eb0b82fa4811ac4f625607db982">More...</a><br /></td></tr>
<tr class="separator:ga155f2eb0b82fa4811ac4f625607db982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7bee1b027384ffecae6828a1b6512f4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gaf7bee1b027384ffecae6828a1b6512f4">CRCGetCurSecNum</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, uint32_t *pCurSecNum)</td></tr>
<tr class="memdesc:gaf7bee1b027384ffecae6828a1b6512f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the current sector number of which the signature verification fails in AUTO mode for given channel.  <a href="#gaf7bee1b027384ffecae6828a1b6512f4">More...</a><br /></td></tr>
<tr class="separator:gaf7bee1b027384ffecae6828a1b6512f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52320890e39ad27ff3ab9561402be321"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga52320890e39ad27ff3ab9561402be321">CRCGetCurPSASig</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *pCurPSASig)</td></tr>
<tr class="memdesc:ga52320890e39ad27ff3ab9561402be321"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get current known good signature value/ CRC value for given channel.  <a href="#ga52320890e39ad27ff3ab9561402be321">More...</a><br /></td></tr>
<tr class="separator:ga52320890e39ad27ff3ab9561402be321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d1b2540776a00821c0bfce73234e1f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#ga56d1b2540776a00821c0bfce73234e1f">CRCGetRawData</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a> channel, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *pRawData)</td></tr>
<tr class="memdesc:ga56d1b2540776a00821c0bfce73234e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to get the uncompressed raw data value for given channel.  <a href="#ga56d1b2540776a00821c0bfce73234e1f">More...</a><br /></td></tr>
<tr class="separator:ga56d1b2540776a00821c0bfce73234e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d5dc88321f5e5561aff2ddf7e7a047"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gac3d5dc88321f5e5561aff2ddf7e7a047">CRCDataBusTracingCtrl</a> (uint32_t baseAddr, uint32_t ctrlFlag, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a> dataBusMask, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a> busEnableMask)</td></tr>
<tr class="memdesc:gac3d5dc88321f5e5561aff2ddf7e7a047"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to control the CRC data bus tracing.  <a href="#gac3d5dc88321f5e5561aff2ddf7e7a047">More...</a><br /></td></tr>
<tr class="separator:gac3d5dc88321f5e5561aff2ddf7e7a047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5967fdbd2766ecca927d8fccbb51b01"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gab5967fdbd2766ecca927d8fccbb51b01">CRCVerifyBusTracingCtrl</a> (uint32_t baseAddr, uint32_t ctrlFlag, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a> dataBusMask, <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a> busEnableMask)</td></tr>
<tr class="memdesc:gab5967fdbd2766ecca927d8fccbb51b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to verify the control the CRC data bus tracing.  <a href="#gab5967fdbd2766ecca927d8fccbb51b01">More...</a><br /></td></tr>
<tr class="separator:gab5967fdbd2766ecca927d8fccbb51b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb02dda6e658b735332c862d24dbce54"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_r_c___f_u_n_c_t_i_o_n.html#gadb02dda6e658b735332c862d24dbce54">CRCReadStaticRegs</a> (uint32_t baseAddr, <a class="el" href="struct_c_s_l___crc_static_regs.html">CSL_CrcStaticRegs</a> *pStaticRegs)</td></tr>
<tr class="memdesc:gadb02dda6e658b735332c862d24dbce54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read static registers of CRC module. This API needs to be called after the initial configuration is done and hence mutliple read between static registers do not change the values.  <a href="#gadb02dda6e658b735332c862d24dbce54">More...</a><br /></td></tr>
<tr class="separator:gadb02dda6e658b735332c862d24dbce54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>===========================================================================</p>
<hr/>
 <h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga986eb01b813b10a74bc20ee60a748eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCChannelReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to reset the CRC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which reset is to be done. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel reset status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gab71509ef795b47e2400a72c47109f9b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCClearIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to clear interrupts for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt is to clear. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Interrupts to clear status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC clear interrupts status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gab100922d0ce9e269d1fb0ac524ec71cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcPatternCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcSectorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a>&#160;</td>
          <td class="paramname"><em>crcMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will configure CRC mode, pattern and sector count for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number to be configured. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">crcPatternCount</td><td>Number of data patterns in one sector to be compressed. </td></tr>
    <tr><td class="paramname">crcSectorCount</td><td>Number of sectors in a block of memory. </td></tr>
    <tr><td class="paramname">crcMode</td><td>CRC operational mode. Refer <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga5450d088cdc236ce3aea07bf37464502" title="CRC operation mode supported. CRC can either operate in Semi-CPU, Full-CPU or Auto mode...">crcOperationMode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel configuration status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gac3d5dc88321f5e5561aff2ddf7e7a047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCDataBusTracingCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a>&#160;</td>
          <td class="paramname"><em>dataBusMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a>&#160;</td>
          <td class="paramname"><em>busEnableMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to control the CRC data bus tracing. </p>
<p><br />
 Data tracing is only available on channel 1, when it is enabled, the operation mode is automatically reset to data capture mode on channel 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">ctrlFlag</td><td>Data bus tracing control flag. CSL_TRUE: enable data tracing. CSL_FALSE: disable data tracing. </td></tr>
    <tr><td class="paramname">dataBusMask</td><td>Data bus mask bits for which what data buses are to be selected. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956" title="CRC data bus type mask selected for tracing control. ">crcDataBusMask_t</a>. </td></tr>
    <tr><td class="paramname">busEnableMask</td><td>Data bus enable mask bits for which what data buses are to be enabled or disabled. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956" title="CRC data bus type mask selected for tracing control. ">crcDataBusMask_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC data bus tracing control status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga356d6deabd7fbe11005ad0e903975045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCDisableIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to disable interrupts for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt is to disable. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Interrupts to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC disable interrupts status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga2403b0f0b751df526cd4898569bf436d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCEnableIntr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to enable interrupts for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt is to enable. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Interrupts to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC enable interrupts status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga52320890e39ad27ff3ab9561402be321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetCurPSASig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pCurPSASig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get current known good signature value/ CRC value for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which current CRC value is to get. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCurPSASig</td><td>Pointer to current CRC PSA signature values Refer struct <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388" title="Structure for accessing CRC register data which are 64 bit wide. ">crcSignature_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get current PSA signaure value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7bee1b027384ffecae6828a1b6512f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetCurSecNum </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pCurSecNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the current sector number of which the signature verification fails in AUTO mode for given channel. </p>
<p><br />
 When a sector fails, the erroneous sector number is logged and the CRC fail interrupt is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which the curent sector number is to get. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCurSecNum</td><td>Pointer to current sector number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get current sector number status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga6123f3d71a683cc23a18264376007e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetHighestPriorityIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pIntVecAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the pending interrupt with highest priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers.</td></tr>
    <tr><td class="paramname">pIntVecAddr</td><td>Pointer to highest priority pending interrupt vector address defined in <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga83b2e093a6aaef69c40bfe37eafb8d06" title="The offset for the highest pending priority interrupt. These interrupt offset returned in CRCGetHighe...">crcIntrPriority_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC get interrupt vector address status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gaab02b753542d9f0ef26f9cca56e91ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pIntrStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the pending interrupts for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which pending interrupt is to get. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>.</td></tr>
    <tr><td class="paramname">pIntrStatus</td><td>Pointer to pending interrupt status/occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC get pending interrupts status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga1eab9ba6d3098f09fb5c23445005a54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetPSASectorSig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pCRCSectorSign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get sector signature Value/ CRC value for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number which was configured for CRC calculation. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCRCSectorSign</td><td>Pointer to CRC PSA sector signature values Refer struct <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388" title="Structure for accessing CRC register data which are 64 bit wide. ">crcSignature_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get PSA sector signaure value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gae1ad20b7cb7075cad634a01e0f084dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetPSASig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pCRCPSASign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the PSA register value for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which PSA register data is to get. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCRCPSASign</td><td>Pointer to CRC PSA signature values. Refer struct <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388" title="Structure for accessing CRC register data which are 64 bit wide. ">crcSignature_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get PSA signature register value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga308100fb0c56aabeeb2dcad350173233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetPSASigRegAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#gabb3457a6c9cfb6011304b0bff52c125c">crcSignatureRegAddr_t</a> *&#160;</td>
          <td class="paramname"><em>pCRCRegAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the PSA register address for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which PSA register address is to get. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCRCRegAddr</td><td>Pointer to CRC PSA register address structure. Refer structure <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#gabb3457a6c9cfb6011304b0bff52c125c" title="Structure for accessing CRC registers address which are 64 bit wide. ">crcSignatureRegAddr_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get PSA signature register address status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga56d1b2540776a00821c0bfce73234e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCGetRawData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pRawData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to get the uncompressed raw data value for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which raw data value is to get. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pRawData</td><td>Pointer to raw data value Refer struct <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388" title="Structure for accessing CRC register data which are 64 bit wide. ">crcSignature_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel get raw data value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1d528be4ec219989ea1c82a2a53080f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCInitialize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcWatchdogPreload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcBlockPreload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize CRC channel and will configure watchdog and block preload value for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers.</td></tr>
    <tr><td class="paramname">channel</td><td>Channel number to be initializaed. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">crcWatchdogPreload</td><td>It is used to check if DMA does supply a block of data responding to a request in a given time frame. </td></tr>
    <tr><td class="paramname">crcBlockPreload</td><td>It is used to check if CRC for an entire block is completed in a given time frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel initialization status. CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga155f2eb0b82fa4811ac4f625607db982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCIsBusy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pBusyFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to check if CRC is busy for given Channel. </p>
<p><br />
 During Auto or Semi-CPU mode, the busy flag is set when the first data pattern of the block is compressed and remains set until the the last data pattern of the block is compressed. The flag is cleared when the last data pattern of the block is compressed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which busy status is to get. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>.</td></tr>
    <tr><td class="paramname">pBusyFlag</td><td>Pointer to busy flag. CSL_TRUE: CRC channel is busy. CSL_FALSE: CRC channel is free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel check busy status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga79190e984729641dd78a7f123a8628e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCPowerDownCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to control the power down of the CRC module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">ctrlFlag</td><td>Pointer to power control flag. CSL_TRUE: power down the CRC. CSL_FALSE: power on the CRC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC power control status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gadb02dda6e658b735332c862d24dbce54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCReadStaticRegs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___crc_static_regs.html">CSL_CrcStaticRegs</a> *&#160;</td>
          <td class="paramname"><em>pStaticRegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read static registers of CRC module. This API needs to be called after the initial configuration is done and hence mutliple read between static registers do not change the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CRC Registers.</td></tr>
    <tr><td class="paramname">pStaticRegs</td><td>pointer to static registers to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS - success <br />
 CSL_EBADARGS - API fails due to bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gad49330fea3c0ac807ae8e9e70f00a5e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCSetPSASeedSig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388">crcSignature_t</a> *&#160;</td>
          <td class="paramname"><em>pCRCPSASeedSign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to set the PSA seed value without compression for given Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which PSA seed value to be set. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">pCRCPSASeedSign</td><td>Pointer to CRC PSA seed signature values. Refer struct <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_s_t_r_u_c_t.html#ga257df0c728bb887897c43f9d1f92f388" title="Structure for accessing CRC register data which are 64 bit wide. ">crcSignature_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel set PSA seed value status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments </dd></dl>

</div>
</div>
<a class="anchor" id="gab5967fdbd2766ecca927d8fccbb51b01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCVerifyBusTracingCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a>&#160;</td>
          <td class="paramname"><em>dataBusMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956">crcDataBusMask_t</a>&#160;</td>
          <td class="paramname"><em>busEnableMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to verify the control the CRC data bus tracing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">ctrlFlag</td><td>Data bus tracing control flag. CSL_TRUE: enable data tracing. CSL_FALSE: disable data tracing. </td></tr>
    <tr><td class="paramname">dataBusMask</td><td>Data bus mask bits for which what data buses are to be selected. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956" title="CRC data bus type mask selected for tracing control. ">crcDataBusMask_t</a>. </td></tr>
    <tr><td class="paramname">busEnableMask</td><td>Data bus enable mask bits for which what data buses are to be enabled or disabled. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#gab153b03e11b59b1219a3fb386950f956" title="CRC data bus type mask selected for tracing control. ">crcDataBusMask_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC verify data bus tracing control status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments CSL_EFAIL: failure, indicate verify failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga559bd16f4436d4bf626a479fa70f5540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCVerifyConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcPatternCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcSectorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga5450d088cdc236ce3aea07bf37464502">crcOperationMode_t</a>&#160;</td>
          <td class="paramname"><em>crcMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will verify the configure of CRC mode, pattern and sector count for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number to be verified configuration. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">crcPatternCount</td><td>Number of data patterns in one sector to be compressed. </td></tr>
    <tr><td class="paramname">crcSectorCount</td><td>Number of sectors in a block of memory. </td></tr>
    <tr><td class="paramname">crcMode</td><td>CRC operational mode. Refer <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga5450d088cdc236ce3aea07bf37464502" title="CRC operation mode supported. CRC can either operate in Semi-CPU, Full-CPU or Auto mode...">crcOperationMode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel configuration status CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments CSL_EFAIL: failure, indicate verify configure failed </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2883454c481524baf9ba8594a6d6d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CRCVerifyInitialize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4">crcChannel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcWatchdogPreload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>crcBlockPreload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the CRC watchdog and block preload value initialized for given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CRC registers.</td></tr>
    <tr><td class="paramname">channel</td><td>Channel number to be verified initialization. Values given by <a class="el" href="group___c_s_l___c_r_c___d_a_t_a_t_y_p_e.html#ga2a4441992bd1824965c309668ca0e4c4" title="CRC channel supported. ">crcChannel_t</a>. </td></tr>
    <tr><td class="paramname">crcWatchdogPreload</td><td>It is used to check if DMA does supply a block of data responding to a request in a given time frame. </td></tr>
    <tr><td class="paramname">crcBlockPreload</td><td>It is used to check if CRC for an entire block is completed in a given time frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status CRC channel verfiy initialization status. CSL_PASS: success CSL_EBADARGS: failure, indicate the bad input arguments CSL_EFAIL: failure, indicate verify initialization failed </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
