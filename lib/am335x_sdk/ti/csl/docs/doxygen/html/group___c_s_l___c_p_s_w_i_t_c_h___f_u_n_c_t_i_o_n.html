<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CPSW Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CPSW Functions<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a> &raquo; <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h.html">CPSW CSL-FL</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga98716c4add3fb3138807bd552e8ff0f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga98716c4add3fb3138807bd552e8ff0f7">CSL_CPSW_getCpswVersionInfo</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___v_e_r_s_i_o_n.html">CSL_CPSW_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:ga98716c4add3fb3138807bd552e8ff0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c59c4bffd6f0a2810a2dd99887c1a9d"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga7c59c4bffd6f0a2810a2dd99887c1a9d">CSL_CPSW_isVlanAwareEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga7c59c4bffd6f0a2810a2dd99887c1a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c914725fe256b446a0610b55d10a36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga0c914725fe256b446a0610b55d10a36f">CSL_CPSW_enableVlanAware</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga0c914725fe256b446a0610b55d10a36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga010d7114304e9faf49a8c0ad1a701db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga010d7114304e9faf49a8c0ad1a701db0">CSL_CPSW_disableVlanAware</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga010d7114304e9faf49a8c0ad1a701db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf464239bf5869ace763c84c2218461a"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gabf464239bf5869ace763c84c2218461a">CSL_CPSW_isPort0Enabled</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gabf464239bf5869ace763c84c2218461a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8303adc68a59678aac5d2013e1e0bd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8303adc68a59678aac5d2013e1e0bd3f">CSL_CPSW_enablePort0</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga8303adc68a59678aac5d2013e1e0bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2810fdaabae4bf44a127ee7fb38dd8d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga2810fdaabae4bf44a127ee7fb38dd8d8">CSL_CPSW_disablePort0</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga2810fdaabae4bf44a127ee7fb38dd8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2f09fbfe387096fb2bbd49d4b5b273"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaae2f09fbfe387096fb2bbd49d4b5b273">CSL_CPSW_isPort0PassPriTagEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gaae2f09fbfe387096fb2bbd49d4b5b273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa279eaaaaf5215787051ff4bc71151cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa279eaaaaf5215787051ff4bc71151cd">CSL_CPSW_enablePort0PassPriTag</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gaa279eaaaaf5215787051ff4bc71151cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09c50cf52764b7b8395e63efc9b8bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa09c50cf52764b7b8395e63efc9b8bd3">CSL_CPSW_disablePort0PassPriTag</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gaa09c50cf52764b7b8395e63efc9b8bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa291f4716a36ecb25b1a623b39e8ea6d"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa291f4716a36ecb25b1a623b39e8ea6d">CSL_CPSW_isPort1PassPriTagEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gaa291f4716a36ecb25b1a623b39e8ea6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10a81f822d2370892c815b166666b81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaf10a81f822d2370892c815b166666b81">CSL_CPSW_enablePortPassPriTag</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gaf10a81f822d2370892c815b166666b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4890dd216951fc98a84b7f5e880bb39a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4890dd216951fc98a84b7f5e880bb39a">CSL_CPSW_disablePortPassPriTag</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:ga4890dd216951fc98a84b7f5e880bb39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb3e539e0d0f42121a1aa2cf3914aa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga2bb3e539e0d0f42121a1aa2cf3914aa3">CSL_CPSW_getCpswControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *pControlRegInfo)</td></tr>
<tr class="separator:ga2bb3e539e0d0f42121a1aa2cf3914aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03d3bf68535356a82dfcdfbdd8743bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gad03d3bf68535356a82dfcdfbdd8743bf">CSL_CPSW_setCpswControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *pControlRegInfo)</td></tr>
<tr class="separator:gad03d3bf68535356a82dfcdfbdd8743bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c729944ab6a9656edbef8627de2d6eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4c729944ab6a9656edbef8627de2d6eb">CSL_CPSW_getEmulationControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 *pFree, Uint32 *pSoft)</td></tr>
<tr class="separator:ga4c729944ab6a9656edbef8627de2d6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553ac7798956eb6f078bb83ba7e41e19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga553ac7798956eb6f078bb83ba7e41e19">CSL_CPSW_setEmulationControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 free, Uint32 soft)</td></tr>
<tr class="separator:ga553ac7798956eb6f078bb83ba7e41e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff737247b28ae9e74c89cd2d1b1aabcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaff737247b28ae9e74c89cd2d1b1aabcb">CSL_CPSW_getPortStatsEnableReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *pPortStatsCfg)</td></tr>
<tr class="separator:gaff737247b28ae9e74c89cd2d1b1aabcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2114a6cefe1d8168a09dcadd2dbd6738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga2114a6cefe1d8168a09dcadd2dbd6738">CSL_CPSW_setPortStatsEnableReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *pPortStatsCfg)</td></tr>
<tr class="separator:ga2114a6cefe1d8168a09dcadd2dbd6738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8accb9ec8727af6e80e8aa206d9aebcc"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8accb9ec8727af6e80e8aa206d9aebcc">CSL_CPSW_isSoftIdle</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga8accb9ec8727af6e80e8aa206d9aebcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b6149272df7e9d4cf35d5e36033d0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga12b6149272df7e9d4cf35d5e36033d0e">CSL_CPSW_enableSoftIdle</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga12b6149272df7e9d4cf35d5e36033d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe91e62d9151eea69158e979e64ed0d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gabe91e62d9151eea69158e979e64ed0d4">CSL_CPSW_disableSoftIdle</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gabe91e62d9151eea69158e979e64ed0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c6ba5cacc13be9dee3456fa0bfbb3a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9c6ba5cacc13be9dee3456fa0bfbb3a4">CSL_CPSW_getPortControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t___c_o_n_t_r_o_l.html">CSL_CPSW_PORT_CONTROL</a> *pControlInfo)</td></tr>
<tr class="separator:ga9c6ba5cacc13be9dee3456fa0bfbb3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9a75a9bce93f38ff6bb85362bf20df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga7a9a75a9bce93f38ff6bb85362bf20df">CSL_CPSW_setPortControlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t___c_o_n_t_r_o_l.html">CSL_CPSW_PORT_CONTROL</a> *pControlInfo)</td></tr>
<tr class="separator:ga7a9a75a9bce93f38ff6bb85362bf20df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7562d1a580779af9a669223dbbd120"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gace7562d1a580779af9a669223dbbd120">CSL_CPSW_getCppiSourceIdReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 *pTxSrcId)</td></tr>
<tr class="separator:gace7562d1a580779af9a669223dbbd120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a5180dc3d7ef00963b88d74b9275bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gac5a5180dc3d7ef00963b88d74b9275bc">CSL_CPSW_setCppiSourceIdReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 *pTxSrcId)</td></tr>
<tr class="separator:gac5a5180dc3d7ef00963b88d74b9275bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafadc027a511a2662e9e469d875bda89f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gafadc027a511a2662e9e469d875bda89f">CSL_CPSW_getPort0VlanReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 *pPortVID, Uint32 *pPortCFI, Uint32 *pPortPRI)</td></tr>
<tr class="separator:gafadc027a511a2662e9e469d875bda89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada614cf2b30040359fac45b1361429e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gada614cf2b30040359fac45b1361429e6">CSL_CPSW_setPort0VlanReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portVID, Uint32 portCFI, Uint32 portPRI)</td></tr>
<tr class="separator:gada614cf2b30040359fac45b1361429e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ad7f0902052a675e63dc60e8ae9aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gad5ad7f0902052a675e63dc60e8ae9aa9">CSL_CPSW_getPort0RxPriMapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:gad5ad7f0902052a675e63dc60e8ae9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac34e5d352f5717763756354daadffe97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gac34e5d352f5717763756354daadffe97">CSL_CPSW_setPort0RxPriMapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:gac34e5d352f5717763756354daadffe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f1b10a7fb7126b1295f9e6e38141ce"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga99f1b10a7fb7126b1295f9e6e38141ce">CSL_CPSW_getPort0FlowIdOffset</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga99f1b10a7fb7126b1295f9e6e38141ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0412fd6b86de66f81c7574fb0ddd71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga7f0412fd6b86de66f81c7574fb0ddd71">CSL_CPSW_setPort0FlowIdOffset</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 flowIdOffset)</td></tr>
<tr class="separator:ga7f0412fd6b86de66f81c7574fb0ddd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f34a50e105b1448d480fbfadde60ab"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga47f34a50e105b1448d480fbfadde60ab">CSL_CPSW_getPort0RxMaxLen</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga47f34a50e105b1448d480fbfadde60ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039462f7c97da5e516759cde7796b714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga039462f7c97da5e516759cde7796b714">CSL_CPSW_setPort0RxMaxLen</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 rxMaxLen)</td></tr>
<tr class="separator:ga039462f7c97da5e516759cde7796b714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8bdf915ba9965ef0c3c50dfe8a237fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gab8bdf915ba9965ef0c3c50dfe8a237fc">CSL_CPSW_getPortBlockCountReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pRxBlkCnt_e, Uint32 *pRxBlkCnt_p, Uint32 *pTxBlkCnt)</td></tr>
<tr class="separator:gab8bdf915ba9965ef0c3c50dfe8a237fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfcd08f9f04573738126bf24070473e7"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gabfcd08f9f04573738126bf24070473e7">CSL_CPSW_getPortRxMaxLen</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum)</td></tr>
<tr class="separator:gabfcd08f9f04573738126bf24070473e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bfa6c1f39b92700a9222be3db281508"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga0bfa6c1f39b92700a9222be3db281508">CSL_CPSW_setPortRxMaxLen</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 rxMaxLen)</td></tr>
<tr class="separator:ga0bfa6c1f39b92700a9222be3db281508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba2fa2f44eb06cebeeb1bb874fb1bb00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaba2fa2f44eb06cebeeb1bb874fb1bb00">CSL_CPSW_getPortTxPriMapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:gaba2fa2f44eb06cebeeb1bb874fb1bb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe7a0eb133c7cec5105795746fad709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8fe7a0eb133c7cec5105795746fad709">CSL_CPSW_setPortTxPriMapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:ga8fe7a0eb133c7cec5105795746fad709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2c150f76c9861775c92ddea3a8c6f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4b2c150f76c9861775c92ddea3a8c6f2">CSL_CPSW_getPortRxPriMapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:ga4b2c150f76c9861775c92ddea3a8c6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af707049c91e40f09e7922710d7c8be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga2af707049c91e40f09e7922710d7c8be">CSL_CPSW_setPortRxPriMapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:ga2af707049c91e40f09e7922710d7c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4314a49009ed3d4fbce2d88232496954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4314a49009ed3d4fbce2d88232496954">CSL_CPSW_getPortRxDscpMap</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pRxDscpPriMap)</td></tr>
<tr class="separator:ga4314a49009ed3d4fbce2d88232496954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a6e0be8ea9d1dfe772ebd6a95fc2127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9a6e0be8ea9d1dfe772ebd6a95fc2127">CSL_CPSW_setPortRxDscpMap</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pRxDscpPriMap)</td></tr>
<tr class="separator:ga9a6e0be8ea9d1dfe772ebd6a95fc2127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e50213762210c88094c92d1d12d2a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga1e50213762210c88094c92d1d12d2a38">CSL_CPSW_getEEEGlobConfig</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_EEE_GLOB_CONFIG</a> *pGlobConfig)</td></tr>
<tr class="separator:ga1e50213762210c88094c92d1d12d2a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0514d5a95053b63431bdb79dbe7e639e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga0514d5a95053b63431bdb79dbe7e639e">CSL_CPSW_setEEEGlobConfig</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_EEE_GLOB_CONFIG</a> *pGlobConfig)</td></tr>
<tr class="separator:ga0514d5a95053b63431bdb79dbe7e639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga025f37f1e325cc1c178e69a15099270e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga025f37f1e325cc1c178e69a15099270e">CSL_CPSW_getEEEPortConfig</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___c_o_n_f_i_g.html">CSL_CPSW_EEE_PORT_CONFIG</a> *pPortConfig)</td></tr>
<tr class="separator:ga025f37f1e325cc1c178e69a15099270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d3707160244a0a100bf31f58262d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gac1d3707160244a0a100bf31f58262d79">CSL_CPSW_setEEEPortConfig</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___c_o_n_f_i_g.html">CSL_CPSW_EEE_PORT_CONFIG</a> *pPortConfig)</td></tr>
<tr class="separator:gac1d3707160244a0a100bf31f58262d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cc26d47e96993b27ba4ae00ecbec21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9cc26d47e96993b27ba4ae00ecbec21d">CSL_CPSW_EEEPortStatus</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___s_t_a_t_u_s.html">CSL_CPSW_EEE_PORT_STATUS</a> *pPortStatus)</td></tr>
<tr class="separator:ga9cc26d47e96993b27ba4ae00ecbec21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd2c3c3e44100633c826f0a9a442ccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4bd2c3c3e44100633c826f0a9a442ccc">CSL_CPSW_getPortVlanReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pPortVID, Uint32 *pPortCFI, Uint32 *pPortPRI)</td></tr>
<tr class="separator:ga4bd2c3c3e44100633c826f0a9a442ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4b869d60a6fc6ddd3e58f3c1257500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gabc4b869d60a6fc6ddd3e58f3c1257500">CSL_CPSW_setPortVlanReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 portVID, Uint32 portCFI, Uint32 portPRI)</td></tr>
<tr class="separator:gabc4b869d60a6fc6ddd3e58f3c1257500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef635d6f53c29371f2dd968b8709e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga3ef635d6f53c29371f2dd968b8709e50">CSL_CPSW_getPortMaxBlksReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pRxMaxBlks, Uint32 *pTxMaxBlks)</td></tr>
<tr class="separator:ga3ef635d6f53c29371f2dd968b8709e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6edcedc354331ea18997e69676e0209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa6edcedc354331ea18997e69676e0209">CSL_CPSW_setPortMaxBlksReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 rxMaxBlks, Uint32 txMaxBlks)</td></tr>
<tr class="separator:gaa6edcedc354331ea18997e69676e0209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802cc18464ae9f9e3cda4c20683d95ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga802cc18464ae9f9e3cda4c20683d95ac">CSL_CPSW_getPortMACAddress</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint8 *pMacAddress)</td></tr>
<tr class="separator:ga802cc18464ae9f9e3cda4c20683d95ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8077fee6ab9228d0f423fc122bb155f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8077fee6ab9228d0f423fc122bb155f8">CSL_CPSW_setPortMACAddress</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint8 *pMacAddress)</td></tr>
<tr class="separator:ga8077fee6ab9228d0f423fc122bb155f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f3bbb4ce0f52167e0c8da545ea42e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga40f3bbb4ce0f52167e0c8da545ea42e7">CSL_CPSW_getPortTimeSyncCntlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_n_t_l.html">CSL_CPSW_TSCNTL</a> *pTimeSyncCntlCfg)</td></tr>
<tr class="separator:ga40f3bbb4ce0f52167e0c8da545ea42e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd36f2ff4288c2921483414ca6d4033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8bd36f2ff4288c2921483414ca6d4033">CSL_CPSW_setPortTimeSyncCntlReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_n_t_l.html">CSL_CPSW_TSCNTL</a> *pTimeSyncCntlCfg)</td></tr>
<tr class="separator:ga8bd36f2ff4288c2921483414ca6d4033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b17b3c29530336aeeb0d10235b7000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gae1b17b3c29530336aeeb0d10235b7000">CSL_CPSW_getPortTimeSyncSeqIdReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pTsLtype, Uint32 *pTsSeqIdOffset)</td></tr>
<tr class="separator:gae1b17b3c29530336aeeb0d10235b7000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939d9a8afd1a5b0e726e95b17ed23317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga939d9a8afd1a5b0e726e95b17ed23317">CSL_CPSW_setVlanLTypeReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 pVlanLtypeInner, Uint32 pVlanLtypeOuter)</td></tr>
<tr class="separator:ga939d9a8afd1a5b0e726e95b17ed23317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f019a8c0aea97581dfe70f7f7ad49e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga00f019a8c0aea97581dfe70f7f7ad49e">CSL_CPSW_setPortTimeSyncSeqIdReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 tsLtype, Uint32 tsSeqIdOffset)</td></tr>
<tr class="separator:ga00f019a8c0aea97581dfe70f7f7ad49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975e0f0f872803de9fd8d2e0d39b57a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga975e0f0f872803de9fd8d2e0d39b57a2">CSL_CPSW_getPortTimeSyncVlanLTypeReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 *pTsVlanLtype1, Uint32 *pTsVlanLtype2)</td></tr>
<tr class="separator:ga975e0f0f872803de9fd8d2e0d39b57a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3164c2d6fc6c2dce7a5619a626b51d0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga3164c2d6fc6c2dce7a5619a626b51d0b">CSL_CPSW_setPortTimeSyncVlanLTypeReg</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, Uint32 tsVlanLtype1, Uint32 tsVlanLtype2)</td></tr>
<tr class="separator:ga3164c2d6fc6c2dce7a5619a626b51d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78167e64460fc3c25e25409c6a8ab550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga78167e64460fc3c25e25409c6a8ab550">CSL_CPSW_getPortTimeSyncConfig</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_o_n_f_i_g.html">CSL_CPSW_TSCONFIG</a> *pTimeSyncConfig)</td></tr>
<tr class="separator:ga78167e64460fc3c25e25409c6a8ab550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c8ccd121d500c8080b25bb15b619ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga32c8ccd121d500c8080b25bb15b619ee">CSL_CPSW_setPortTimeSyncConfig</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_o_n_f_i_g.html">CSL_CPSW_TSCONFIG</a> *pTimeSyncConfig)</td></tr>
<tr class="separator:ga32c8ccd121d500c8080b25bb15b619ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79eeb5bb32872fd76c5b6526871b0d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga79eeb5bb32872fd76c5b6526871b0d38">CSL_CPSW_getStats</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *pCpswStats)</td></tr>
<tr class="separator:ga79eeb5bb32872fd76c5b6526871b0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6cc15c7d0888060e88e6afabdd897a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa6cc15c7d0888060e88e6afabdd897a4">CSL_CPSW_getRawStats</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *pCpswStats)</td></tr>
<tr class="separator:gaa6cc15c7d0888060e88e6afabdd897a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b1ea6766b6c4421fc7e1b7cf3b7862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga08b1ea6766b6c4421fc7e1b7cf3b7862">CSL_CPSW_getAleVersionInfo</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_e_r_s_i_o_n.html">CSL_CPSW_ALE_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:ga08b1ea6766b6c4421fc7e1b7cf3b7862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4247ae0d57ae2f43495def6125a987f"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaf4247ae0d57ae2f43495def6125a987f">CSL_CPSW_isAleRateLimitEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaf4247ae0d57ae2f43495def6125a987f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4756fd5faea6eaf631a1a32e6b82df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gab4756fd5faea6eaf631a1a32e6b82df5">CSL_CPSW_enableAleRateLimit</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gab4756fd5faea6eaf631a1a32e6b82df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b50eec2825e9b38ca8d5644b02d485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga27b50eec2825e9b38ca8d5644b02d485">CSL_CPSW_disableAleRateLimit</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga27b50eec2825e9b38ca8d5644b02d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5ea095c2878b1cafa8f6c866751377"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaeb5ea095c2878b1cafa8f6c866751377">CSL_CPSW_isAleMacAuthModeEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaeb5ea095c2878b1cafa8f6c866751377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d3138f3d3d25a2668f31e1e644cb631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga1d3138f3d3d25a2668f31e1e644cb631">CSL_CPSW_enableAleMacAuthMode</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga1d3138f3d3d25a2668f31e1e644cb631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad4a0e625dc6422a33a7f198dc9d06a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4ad4a0e625dc6422a33a7f198dc9d06a">CSL_CPSW_disableAleMacAuthMode</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga4ad4a0e625dc6422a33a7f198dc9d06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeafe07c2b288d4c9e48da656513cff5a"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaeafe07c2b288d4c9e48da656513cff5a">CSL_CPSW_isAleVlanAwareEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaeafe07c2b288d4c9e48da656513cff5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d0b2fd09bb593c9b74a9987b9385b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga67d0b2fd09bb593c9b74a9987b9385b9">CSL_CPSW_enableAleVlanAware</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga67d0b2fd09bb593c9b74a9987b9385b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade35edb6c5ad3b7eff1e12f6119a37b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gade35edb6c5ad3b7eff1e12f6119a37b1">CSL_CPSW_disableAleVlanAware</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gade35edb6c5ad3b7eff1e12f6119a37b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f52a0aee2807781949e6e9930fa25d2"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9f52a0aee2807781949e6e9930fa25d2">CSL_CPSW_isAleTxRateLimitEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga9f52a0aee2807781949e6e9930fa25d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0880a0988baf93d3604b9276b59c1264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga0880a0988baf93d3604b9276b59c1264">CSL_CPSW_enableAleTxRateLimit</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga0880a0988baf93d3604b9276b59c1264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf784c546c74eaaae98e9608b2d5a5d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaf784c546c74eaaae98e9608b2d5a5d77">CSL_CPSW_disableAleTxRateLimit</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaf784c546c74eaaae98e9608b2d5a5d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca6ba8f673a412be138080a6b6756c1d"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaca6ba8f673a412be138080a6b6756c1d">CSL_CPSW_isAleBypassEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaca6ba8f673a412be138080a6b6756c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7f0f1cf09d9edd3fcb9c173754d8be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4e7f0f1cf09d9edd3fcb9c173754d8be">CSL_CPSW_enableAleBypass</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga4e7f0f1cf09d9edd3fcb9c173754d8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeac18f372e7526a04d90c44d810907c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaaeac18f372e7526a04d90c44d810907c">CSL_CPSW_disableAleBypass</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaaeac18f372e7526a04d90c44d810907c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95212faaf707746a85b1e999bb4144ef"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga95212faaf707746a85b1e999bb4144ef">CSL_CPSW_isAleOUIDenyModeEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga95212faaf707746a85b1e999bb4144ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba08545b0305d835f6a10b26562a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gabfba08545b0305d835f6a10b26562a22">CSL_CPSW_enableAleOUIDenyMode</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gabfba08545b0305d835f6a10b26562a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4a6fc0daa35f58bca082dd76b06c4b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gae4a6fc0daa35f58bca082dd76b06c4b4">CSL_CPSW_disableAleOUIDenyMode</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gae4a6fc0daa35f58bca082dd76b06c4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f0b4d91a8a9e4d4723e0eb93e97fc9"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga82f0b4d91a8a9e4d4723e0eb93e97fc9">CSL_CPSW_isAleVID0ModeEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga82f0b4d91a8a9e4d4723e0eb93e97fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf621862622daf5b33b2be9b8478899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaadf621862622daf5b33b2be9b8478899">CSL_CPSW_enableAleVID0Mode</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaadf621862622daf5b33b2be9b8478899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6adff81ed7c79d3888cbd14b6633c302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga6adff81ed7c79d3888cbd14b6633c302">CSL_CPSW_disableAleVID0Mode</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga6adff81ed7c79d3888cbd14b6633c302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53db7587a638dfcf13e88deca37e9d7"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gae53db7587a638dfcf13e88deca37e9d7">CSL_CPSW_isAleLearnNoVIDEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gae53db7587a638dfcf13e88deca37e9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949881e581f42100d2da685a31152eb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga949881e581f42100d2da685a31152eb4">CSL_CPSW_enableAleLearnNoVID</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga949881e581f42100d2da685a31152eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa33489b6a734ab28c48a5bcc09ac9299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa33489b6a734ab28c48a5bcc09ac9299">CSL_CPSW_disableAleLearnNoVID</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaa33489b6a734ab28c48a5bcc09ac9299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef5073e9c145d57fb682ca2617145bf"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9ef5073e9c145d57fb682ca2617145bf">CSL_CPSW_isAleUUNIToHostEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga9ef5073e9c145d57fb682ca2617145bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048d7a2b3ac8204399b5de1574105cb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga048d7a2b3ac8204399b5de1574105cb6">CSL_CPSW_enableAleUUNIToHost</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga048d7a2b3ac8204399b5de1574105cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a59c7c1444c2c835e2bcb293ca342b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga3a59c7c1444c2c835e2bcb293ca342b0">CSL_CPSW_disableAleUUNIToHost</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga3a59c7c1444c2c835e2bcb293ca342b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e198591ca3268ec97d8cff71a45cdb"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gac2e198591ca3268ec97d8cff71a45cdb">CSL_CPSW_isAleUVLANNoLearnEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gac2e198591ca3268ec97d8cff71a45cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2d293230879ca8f4f177e4bd16756c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga1e2d293230879ca8f4f177e4bd16756c">CSL_CPSW_enableAleUVLANNoLearn</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga1e2d293230879ca8f4f177e4bd16756c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf3e0abc2c3861248e60f815c0325521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaaf3e0abc2c3861248e60f815c0325521">CSL_CPSW_disableAleUVLANNoLearn</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gaaf3e0abc2c3861248e60f815c0325521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d668aa04fa45f1f2316aa9b1111c035"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga7d668aa04fa45f1f2316aa9b1111c035">CSL_CPSW_getAleUpdateBW</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga7d668aa04fa45f1f2316aa9b1111c035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab70f248087266b0552b36b7db579c1f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gab70f248087266b0552b36b7db579c1f1">CSL_CPSW_setAleUpdateBW</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 aleUpdBW)</td></tr>
<tr class="separator:gab70f248087266b0552b36b7db579c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b16dcecede268baba9e2a033866374e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga1b16dcecede268baba9e2a033866374e">CSL_CPSW_startAleAgeOutNow</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga1b16dcecede268baba9e2a033866374e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47249c2830bb22d4334d380ea4f8e3d1"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga47249c2830bb22d4334d380ea4f8e3d1">CSL_CPSW_isAleAgeOutDone</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga47249c2830bb22d4334d380ea4f8e3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab305c646fdd1139657a40bd5bb171b8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gab305c646fdd1139657a40bd5bb171b8d">CSL_CPSW_clearAleTable</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:gab305c646fdd1139657a40bd5bb171b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53272fad54a7a3ee110f044f2cd41663"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga53272fad54a7a3ee110f044f2cd41663">CSL_CPSW_isAleEnabled</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga53272fad54a7a3ee110f044f2cd41663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bdf7b22acaae33633d2af87e4e319b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga7bdf7b22acaae33633d2af87e4e319b5">CSL_CPSW_enableAle</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga7bdf7b22acaae33633d2af87e4e319b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc0f5fd57ededbc9a6f135fc000625f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga7fc0f5fd57ededbc9a6f135fc000625f">CSL_CPSW_disableAle</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga7fc0f5fd57ededbc9a6f135fc000625f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db9ca6941cef5ae1224f8323d117082"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9db9ca6941cef5ae1224f8323d117082">CSL_CPSW_getAleControlReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga9db9ca6941cef5ae1224f8323d117082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59db759abfffcc2643cca9ddc9f9cf87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga59db759abfffcc2643cca9ddc9f9cf87">CSL_CPSW_setAleControlReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 aleCtrlVal)</td></tr>
<tr class="separator:ga59db759abfffcc2643cca9ddc9f9cf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24543bac1ec2cb4a9cd70ba653794a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga24543bac1ec2cb4a9cd70ba653794a97">CSL_CPSW_getAleStatusReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 *pNumPolicers, Uint32 *pNumEntries)</td></tr>
<tr class="separator:ga24543bac1ec2cb4a9cd70ba653794a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cc4e6007bc13443e2b1f8597d98d604"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8cc4e6007bc13443e2b1f8597d98d604">CSL_CPSW_getAlePrescaleReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga8cc4e6007bc13443e2b1f8597d98d604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f4d2955fb79ddb7922eec47ffebaaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga14f4d2955fb79ddb7922eec47ffebaaf">CSL_CPSW_setAlePrescaleReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 alePrescaleVal)</td></tr>
<tr class="separator:ga14f4d2955fb79ddb7922eec47ffebaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e8dbd43d07faf3f3f497a6dd6cff37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga81e8dbd43d07faf3f3f497a6dd6cff37">CSL_CPSW_getAleAgingTimerReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 *pAgingPrescale, Uint32 *pAgingPeriod)</td></tr>
<tr class="separator:ga81e8dbd43d07faf3f3f497a6dd6cff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32dad5a1a11c8a75bc3f34b271cde160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga32dad5a1a11c8a75bc3f34b271cde160">CSL_CPSW_setAleAgingTimerReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 agingPrescale, Uint32 agingPeriod)</td></tr>
<tr class="separator:ga32dad5a1a11c8a75bc3f34b271cde160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fab533264233ad7110fb1b5c3e49c7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga1fab533264233ad7110fb1b5c3e49c7f">CSL_CPSW_getAleUnkownVlanReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 *pUnVlanMemList, Uint32 *pUnMcastFloodMask, Uint32 *pUnRegMcastFloodMask, Uint32 *pUnForceUntagEgress)</td></tr>
<tr class="separator:ga1fab533264233ad7110fb1b5c3e49c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e42239f1bb2d394395fe03b629d5838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga6e42239f1bb2d394395fe03b629d5838">CSL_CPSW_setAleUnkownVlanReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 unVlanMemList, Uint32 unMcastFloodMask, Uint32 unRegMcastFloodMask, Uint32 unForceUntagEgress)</td></tr>
<tr class="separator:ga6e42239f1bb2d394395fe03b629d5838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3daad62fede44583e16111e2f2ff15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaca3daad62fede44583e16111e2f2ff15">CSL_CPSW_getAleVlanMaskMuxReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 *vlanMaskMux)</td></tr>
<tr class="separator:gaca3daad62fede44583e16111e2f2ff15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4d34df05c5e8dec6ea76841f2dc21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4a4d34df05c5e8dec6ea76841f2dc21a">CSL_CPSW_setAleVlanMaskMuxReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 *vlanMaskMux)</td></tr>
<tr class="separator:ga4a4d34df05c5e8dec6ea76841f2dc21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba937013cadabc0da5c310b56e52771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9ba937013cadabc0da5c310b56e52771">CSL_CPSW_getAleVlanMaskMuxEntryReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 maskMuxIndex, Uint32 *vlanMaskMuxPtr)</td></tr>
<tr class="separator:ga9ba937013cadabc0da5c310b56e52771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765391dfa6e3300acf7e9bf2a83e6a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga765391dfa6e3300acf7e9bf2a83e6a20">CSL_CPSW_setAleVlanMaskMuxEntryReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 maskMuxIndex, Uint32 vlanMaskMuxVal)</td></tr>
<tr class="separator:ga765391dfa6e3300acf7e9bf2a83e6a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c8eb89e1bc65c314bb1c4338e53389f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9c8eb89e1bc65c314bb1c4338e53389f">CSL_CPSW_getAleTableEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, Uint32 *pAleInfoWd0, Uint32 *pAleInfoWd1, Uint32 *pAleInfoWd2)</td></tr>
<tr class="separator:ga9c8eb89e1bc65c314bb1c4338e53389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf47f5c3dc8350770130b28b61c98d53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gabf47f5c3dc8350770130b28b61c98d53">CSL_CPSW_setAleTableEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, Uint32 aleInfoWd0, Uint32 aleInfoWd1, Uint32 aleInfoWd2)</td></tr>
<tr class="separator:gabf47f5c3dc8350770130b28b61c98d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eaf96500e2015b4d91f835d18e68a54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga6ea23133eb6b1517c106ca3f1a8b7729">CSL_CPSW_ALE_ENTRYTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga5eaf96500e2015b4d91f835d18e68a54">CSL_CPSW_getALEEntryType</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga5eaf96500e2015b4d91f835d18e68a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a6d882933f74e1059ab2ba464e66c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#gac08366dceb5ccaea33ad2555f63471d5">CSL_CPSW_ALE_ADDRTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa7a6d882933f74e1059ab2ba464e66c0">CSL_CPSW_getALEAddressType</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gaa7a6d882933f74e1059ab2ba464e66c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e579f2de8c8b4e645066d285db4250d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga13963cf3e07219d0a5b09cfb6c376b27">CSL_CPSW_ALE_POLICER_ENTRYTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9e579f2de8c8b4e645066d285db4250d">CSL_CPSW_getALEPolicerEntryType</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga9e579f2de8c8b4e645066d285db4250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2fa1ccc58b6ecf658961b8f6ce1e894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaf2fa1ccc58b6ecf658961b8f6ce1e894">CSL_CPSW_getAleMcastAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *pMcastAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gaf2fa1ccc58b6ecf658961b8f6ce1e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1717c120d3b9944a488e4a2ee64a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gabe1717c120d3b9944a488e4a2ee64a1e">CSL_CPSW_setAleMcastAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *pMcastAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gabe1717c120d3b9944a488e4a2ee64a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d066681b82a1eb7c7d789b592c41ef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga5d066681b82a1eb7c7d789b592c41ef2">CSL_CPSW_getAleVlanMcastAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *pVlanMcastAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga5d066681b82a1eb7c7d789b592c41ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad17bb3469a70072fad86a2cf1502584f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gad17bb3469a70072fad86a2cf1502584f">CSL_CPSW_setAleVlanMcastAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *pVlanMcastAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gad17bb3469a70072fad86a2cf1502584f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d72e78becfdead73d1177612c044b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4d72e78becfdead73d1177612c044b09">CSL_CPSW_getAleUnicastAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *pUcastAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga4d72e78becfdead73d1177612c044b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c8d0098f0bd62caacb7436db4fd289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga09c8d0098f0bd62caacb7436db4fd289">CSL_CPSW_setAleUnicastAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *pUcastAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga09c8d0098f0bd62caacb7436db4fd289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5680c4b6086e4495cab211a8361dce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa5680c4b6086e4495cab211a8361dce3">CSL_CPSW_getAleOUIAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *pOUIAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gaa5680c4b6086e4495cab211a8361dce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb0bc72164cd43831b2f662bcbef0e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga3bb0bc72164cd43831b2f662bcbef0e1">CSL_CPSW_setAleOUIAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *pOUIAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga3bb0bc72164cd43831b2f662bcbef0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c18bd7e46874aa1f74b9f2d445f286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gac8c18bd7e46874aa1f74b9f2d445f286">CSL_CPSW_getAleVlanUnicastAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *pVlanUcastAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gac8c18bd7e46874aa1f74b9f2d445f286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20cbfc51f9a5fc2c7007e4b18e1aefa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga20cbfc51f9a5fc2c7007e4b18e1aefa8">CSL_CPSW_setAleVlanUnicastAddrEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *pVlanUcastAddrCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga20cbfc51f9a5fc2c7007e4b18e1aefa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead22a8d0db17beef4363368a380cba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaead22a8d0db17beef4363368a380cba8">CSL_CPSW_getAleVlanEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *pVlanCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gaead22a8d0db17beef4363368a380cba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6baf814cad5ff96a7a74773b8869928e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga6baf814cad5ff96a7a74773b8869928e">CSL_CPSW_setAleVlanEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *pVlanCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga6baf814cad5ff96a7a74773b8869928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694509502153b42b07268f179a8dc9f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga694509502153b42b07268f179a8dc9f7">CSL_CPSW_getAleOutVlanEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *pOutVlanCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga694509502153b42b07268f179a8dc9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8b64c241ff5590a81dcc3bd59af8f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaf8b64c241ff5590a81dcc3bd59af8f95">CSL_CPSW_setAleOutVlanEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *pOutVlanCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gaf8b64c241ff5590a81dcc3bd59af8f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga885f776b19bc55df2f786c94dffefbe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga885f776b19bc55df2f786c94dffefbe4">CSL_CPSW_getAleEthertypeEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *pEthertypeCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga885f776b19bc55df2f786c94dffefbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a49e60cdb50a1e7c8e3a912370d4052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga3a49e60cdb50a1e7c8e3a912370d4052">CSL_CPSW_setAleEthertypeEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *pEthertypeCfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga3a49e60cdb50a1e7c8e3a912370d4052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be1d89f43c9c29c18b2f12be2eafd05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga2be1d89f43c9c29c18b2f12be2eafd05">CSL_CPSW_getAleIPv4Entry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *pIPv4Cfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga2be1d89f43c9c29c18b2f12be2eafd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20ca6fbf927b8666a4d22cbfca1bf020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga20ca6fbf927b8666a4d22cbfca1bf020">CSL_CPSW_setAleIPv4Entry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *pIPv4Cfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga20ca6fbf927b8666a4d22cbfca1bf020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ab9b5a8feb2e3d9e9599a6026e75142"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga0ab9b5a8feb2e3d9e9599a6026e75142">CSL_CPSW_getAleIPv6HighEntryOffset</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>)</td></tr>
<tr class="separator:ga0ab9b5a8feb2e3d9e9599a6026e75142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba148c4b480f8bcc74a4f5d20b0761c9"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaba148c4b480f8bcc74a4f5d20b0761c9">CSL_CPSW_getAleIPv6HighEntryIndex</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 entryIndex)</td></tr>
<tr class="separator:gaba148c4b480f8bcc74a4f5d20b0761c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e4bb31b1cdbd44b73f514be762a788"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gad5e4bb31b1cdbd44b73f514be762a788">CSL_CPSW_getAleIPv6LowEntryIndex</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 entryIndex)</td></tr>
<tr class="separator:gad5e4bb31b1cdbd44b73f514be762a788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b4b2bcb2016369ef8320240c684d236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4b4b2bcb2016369ef8320240c684d236">CSL_CPSW_getAleIPv6Entry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *pIPv6Cfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga4b4b2bcb2016369ef8320240c684d236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb0a2df2f4afbf65575d6700761e1f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaceb0a2df2f4afbf65575d6700761e1f5">CSL_CPSW_setAleIPv6Entry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *pIPv6Cfg, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gaceb0a2df2f4afbf65575d6700761e1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f7224a0625bcfa656cc3c17b9b06f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga60f7224a0625bcfa656cc3c17b9b06f2">CSL_CPSW_mapTableWord2MacAddr</a> (uint32_t word0, uint32_t word1, uint8_t *macAddr, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga60f7224a0625bcfa656cc3c17b9b06f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc8d45fdbebd2e36655777cfc9dddeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gafcc8d45fdbebd2e36655777cfc9dddeb">CSL_CPSW_mapMacAddr2TableWord</a> (uint32_t *word0, uint32_t *word1, uint8_t *macAddr, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gafcc8d45fdbebd2e36655777cfc9dddeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d507df53333e9aed89d4516e903685b"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9d507df53333e9aed89d4516e903685b">CSL_CPSW_extractVid</a> (Uint32 word1, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga9d507df53333e9aed89d4516e903685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37095a6ca853c669810a74b7aec4f4e"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gab37095a6ca853c669810a74b7aec4f4e">CSL_CPSW_getEthertypeMax</a> (<a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gab37095a6ca853c669810a74b7aec4f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d40354608b8493bb31ff2353fd6ac5"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga01d40354608b8493bb31ff2353fd6ac5">CSL_CPSW_getIpv4IgnBitsMax</a> (<a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:ga01d40354608b8493bb31ff2353fd6ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb6066891f0da90b8ff9f2a3cafa752"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gadeb6066891f0da90b8ff9f2a3cafa752">CSL_CPSW_getIpv6IgnBitsMax</a> (<a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a> aleType)</td></tr>
<tr class="separator:gadeb6066891f0da90b8ff9f2a3cafa752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a55b25144f93f132a4c2d1ddf5e67f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga6a55b25144f93f132a4c2d1ddf5e67f9">CSL_CPSW_clearAleEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga6a55b25144f93f132a4c2d1ddf5e67f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e5bfaacacef1d37a1d1be46ca1cf67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga57e5bfaacacef1d37a1d1be46ca1cf67">CSL_CPSW_getAlePortControlReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 portNo, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *pPortControlInfo)</td></tr>
<tr class="separator:ga57e5bfaacacef1d37a1d1be46ca1cf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6b638d2fe79f91254880e710942d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9d6b638d2fe79f91254880e710942d1b">CSL_CPSW_setAlePortControlReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 portNo, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *pPortControlInfo)</td></tr>
<tr class="separator:ga9d6b638d2fe79f91254880e710942d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e81788b963d534cd978ed0d34e3de6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8e81788b963d534cd978ed0d34e3de6f">CSL_CPSW_getAlePortState</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 portNo, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga9d09a0a21ede770428dfeec9661f2db6">CSL_CPSW_ALE_PORTSTATE</a> *pPortState)</td></tr>
<tr class="separator:ga8e81788b963d534cd978ed0d34e3de6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ed589beb125f41729c6f38851325cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga98ed589beb125f41729c6f38851325cf">CSL_CPSW_setAlePortState</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 portNo, <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga9d09a0a21ede770428dfeec9661f2db6">CSL_CPSW_ALE_PORTSTATE</a> portState)</td></tr>
<tr class="separator:ga98ed589beb125f41729c6f38851325cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30af57bb4fbbda8ce2089a9dbde9e8dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga30af57bb4fbbda8ce2089a9dbde9e8dd">CSL_CPSW_setAlePortMirrorSouce</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 portNo, bool enableMirror)</td></tr>
<tr class="separator:ga30af57bb4fbbda8ce2089a9dbde9e8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c9bcf9e6f3b368427b266201b63158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gac4c9bcf9e6f3b368427b266201b63158">CSL_CPSW_setAleCtrl2MirrorMatchIndex</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 mirrorMatchIndex)</td></tr>
<tr class="separator:gac4c9bcf9e6f3b368427b266201b63158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fa0bc55e92da26dd2aa20caaf055f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga58fa0bc55e92da26dd2aa20caaf055f2">CSL_CPSW_setAleCtrl2TrunkParams</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, CSL_CPSW_ALE_CTRL2_TRUNK_CONFIG *trunkCfg)</td></tr>
<tr class="separator:ga58fa0bc55e92da26dd2aa20caaf055f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf10a7dfee1cdac2465294b22d0aeb81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gacf10a7dfee1cdac2465294b22d0aeb81">CSL_CPSW_setAleCtrl2IPPktFilterConfig</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, CSL_CPSW_ALE_CTRL2_IPPKTFLT_CONFIG *ipPktFltCfg)</td></tr>
<tr class="separator:gacf10a7dfee1cdac2465294b22d0aeb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d92131168eb2541b4ba128257eb7fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga72d92131168eb2541b4ba128257eb7fd">CSL_CPSW_setAleCtrl2MalformedFrameConfig</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, CSL_CPSW_ALE_CTRL2_MALFORMEDFRAME_CONFIG *badFrmCfg)</td></tr>
<tr class="separator:ga72d92131168eb2541b4ba128257eb7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a7b496bf725c1292d9f6e8f55a53d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gae7a7b496bf725c1292d9f6e8f55a53d7">CSL_CPSW_setAleIPNxtHdrWhitelist</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint8 ipNxtHdr0, Uint8 ipNxtHdr1, Uint8 ipNxtHdr2, Uint8 ipNxtHdr3)</td></tr>
<tr class="separator:gae7a7b496bf725c1292d9f6e8f55a53d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29df9d206921605a42a5109b848a38b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa29df9d206921605a42a5109b848a38b">CSL_CPSW_getAlePolicerGlobConfig</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_ALE_POLICER_GLOB_CONFIG</a> *pGlobConfig)</td></tr>
<tr class="separator:gaa29df9d206921605a42a5109b848a38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719be1ef2e7af2d3f01bd8fc7cbb06c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga719be1ef2e7af2d3f01bd8fc7cbb06c1">CSL_CPSW_setAlePolicerGlobConfig</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_ALE_POLICER_GLOB_CONFIG</a> *pGlobConfig)</td></tr>
<tr class="separator:ga719be1ef2e7af2d3f01bd8fc7cbb06c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced6795d975d6da7d4738fab21708fc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaced6795d975d6da7d4738fab21708fc7">CSL_CPSW_getAlePolicerEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___e_n_t_r_y.html">CSL_CPSW_ALE_POLICER_ENTRY</a> *pPolCfg)</td></tr>
<tr class="separator:gaced6795d975d6da7d4738fab21708fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e9d55aba3df44153c50e7c819667f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga53e9d55aba3df44153c50e7c819667f3">CSL_CPSW_setAlePolicerEntry</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___e_n_t_r_y.html">CSL_CPSW_ALE_POLICER_ENTRY</a> *pPolCfg)</td></tr>
<tr class="separator:ga53e9d55aba3df44153c50e7c819667f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c4941fedc5bdddf43bc204a58bb1916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga0c4941fedc5bdddf43bc204a58bb1916">CSL_CPSW_setAleUnknwnVlanMemberReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 aleUnknwnVlanMemberVal)</td></tr>
<tr class="separator:ga0c4941fedc5bdddf43bc204a58bb1916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba9867fa93a71e9eadd419738e07488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaeba9867fa93a71e9eadd419738e07488">CSL_CPSW_setAleUnknwnVlanUntagReg</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 aleUnknwnVlanUntagVal)</td></tr>
<tr class="separator:gaeba9867fa93a71e9eadd419738e07488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga008e20f33754ef6e73add333f0162fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga008e20f33754ef6e73add333f0162fea">CSL_CPSW_setCppiP0Control</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___c_o_n_t_r_o_l.html">CSL_CPSW_CPPI_P0_CONTROL</a> *pCppiP0ControlCfg)</td></tr>
<tr class="separator:ga008e20f33754ef6e73add333f0162fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3ee95b299aff1dcfb1c06404c4768a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8c3ee95b299aff1dcfb1c06404c4768a">CSL_CPSW_setAleOAMLpbkControl</a> (CSL_AleRegs *<a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html#ga7dc77e81be38e138d9480ba7e2e354b0">hCpswAleRegs</a>, Uint32 lpbkEnablePortMask)</td></tr>
<tr class="separator:ga8c3ee95b299aff1dcfb1c06404c4768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4879425499d9f3a99199d89cfccfccb"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gac4879425499d9f3a99199d89cfccfccb">CSL_CPSW_isP0TxCastagnoliCRCEnabled</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gac4879425499d9f3a99199d89cfccfccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa062318fad0a5e55ab4f64136b63faa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa062318fad0a5e55ab4f64136b63faa7">CSL_CPSW_enableP0TxCastagnoliCRC</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gaa062318fad0a5e55ab4f64136b63faa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8769f843e6e792cab042eb8c6f844ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa8769f843e6e792cab042eb8c6f844ab">CSL_CPSW_disableP0TxCastagnoliCRC</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gaa8769f843e6e792cab042eb8c6f844ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f87508de725dc304d8d9b0d2fee22d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga82f87508de725dc304d8d9b0d2fee22d">CSL_CPSW_getPTypeReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *pPtypeCfg)</td></tr>
<tr class="separator:ga82f87508de725dc304d8d9b0d2fee22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd4f3820efd9036614c813a8eea8dfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga4bd4f3820efd9036614c813a8eea8dfe">CSL_CPSW_setPTypeReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *pPtypeCfg)</td></tr>
<tr class="separator:ga4bd4f3820efd9036614c813a8eea8dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0b47b05422ee0c53639055d675b9d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga3e0b47b05422ee0c53639055d675b9d1">CSL_CPSW_getThruRateReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___t_h_r_u_r_a_t_e.html">CSL_CPSW_THRURATE</a> *pThruRateCfg)</td></tr>
<tr class="separator:ga3e0b47b05422ee0c53639055d675b9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dfca18ecce1f026c74f22b89f1ce07"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa4dfca18ecce1f026c74f22b89f1ce07">CSL_CPSW_getGapThreshold</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gaa4dfca18ecce1f026c74f22b89f1ce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874fbde8401a182b651e2a55f53feb10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga874fbde8401a182b651e2a55f53feb10">CSL_CPSW_setGapThreshold</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 gapThreshold)</td></tr>
<tr class="separator:ga874fbde8401a182b651e2a55f53feb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa117936301e5edac26635cc4c0215008"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaa117936301e5edac26635cc4c0215008">CSL_CPSW_getTxStartWords</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:gaa117936301e5edac26635cc4c0215008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756fe2bbb77d4efcc02f2f6eed60e8f3"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga756fe2bbb77d4efcc02f2f6eed60e8f3">CSL_CPSW_getTxMaxLenPerPriority</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 priority)</td></tr>
<tr class="separator:ga756fe2bbb77d4efcc02f2f6eed60e8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9396b5b5ced99a2b18e1a70d7817feef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga9396b5b5ced99a2b18e1a70d7817feef">CSL_CPSW_setTxMaxLenPerPriority</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 priority, Uint32 maxLen)</td></tr>
<tr class="separator:ga9396b5b5ced99a2b18e1a70d7817feef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fed817472e50bc131635dd2f944c3d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8fed817472e50bc131635dd2f944c3d9">CSL_CPSW_getCppiP0Control</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___c_o_n_t_r_o_l.html">CSL_CPSW_CPPI_P0_CONTROL</a> *pCppiP0ControlCfg)</td></tr>
<tr class="separator:ga8fed817472e50bc131635dd2f944c3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e12cdd76450a2d2f4363c3e09ffd0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga61e12cdd76450a2d2f4363c3e09ffd0a">CSL_CPSW_setCppiRxPType</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 p0RxPtype)</td></tr>
<tr class="separator:ga61e12cdd76450a2d2f4363c3e09ffd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7cb04f40c422c713eaa4cc6826fe1d"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8c7cb04f40c422c713eaa4cc6826fe1d">CSL_CPSW_getCppiRxPType</a> (CSL_Xge_cpswRegs *hCpswRegs)</td></tr>
<tr class="separator:ga8c7cb04f40c422c713eaa4cc6826fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63a72d35079160fcc44a955b99e9c4e"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gad63a72d35079160fcc44a955b99e9c4e">CSL_CPSW_getCppiRxPacketsPriority</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 priority)</td></tr>
<tr class="separator:gad63a72d35079160fcc44a955b99e9c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f4207a952a9e86ca96d12bbe471c6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gae0f4207a952a9e86ca96d12bbe471c6e">CSL_CPSW_setCppiRxPacketsPriority</a> (CSL_Xge_cpswRegs *hCpswRegs, Uint32 priority, Uint32 rxPackets)</td></tr>
<tr class="separator:gae0f4207a952a9e86ca96d12bbe471c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b7ad557c1057c793ac3952b2075bc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga27b7ad557c1057c793ac3952b2075bc4">CSL_CPSW_getCppiRxGapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___r_x_g_a_p.html">CSL_CPSW_CPPI_P0_RXGAP</a> *pCppiRxGap)</td></tr>
<tr class="separator:ga27b7ad557c1057c793ac3952b2075bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd7654f3a817f7adc79d40075b8178ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gabd7654f3a817f7adc79d40075b8178ff">CSL_CPSW_setCppiRxGapReg</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___r_x_g_a_p.html">CSL_CPSW_CPPI_P0_RXGAP</a> *pCppiRxGap)</td></tr>
<tr class="separator:gabd7654f3a817f7adc79d40075b8178ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf438c99196bec01a0a2be8db19ac6429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#gaf438c99196bec01a0a2be8db19ac6429">CSL_CPSW_getP0FifoStatus</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___f_i_f_o_s_t_a_t_u_s.html">CSL_CPSW_CPPI_P0_FIFOSTATUS</a> *pCppiFifoStats)</td></tr>
<tr class="separator:gaf438c99196bec01a0a2be8db19ac6429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b689ad7b82f1f9a5b90c1a5bedf4189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga6b689ad7b82f1f9a5b90c1a5bedf4189">CSL_CPSW_getP0HostBlksPri</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___h_o_s_t_b_l_k_s_p_r_i.html">CSL_CPSW_CPPI_P0_HOSTBLKSPRI</a> *pCppiHostBlksPri)</td></tr>
<tr class="separator:ga6b689ad7b82f1f9a5b90c1a5bedf4189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d721a1e9332a798191d27d653aa5bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___f_u_n_c_t_i_o_n.html#ga8d721a1e9332a798191d27d653aa5bb3">CSL_CPSW_setP0HostBlksPri</a> (CSL_Xge_cpswRegs *hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___h_o_s_t_b_l_k_s_p_r_i.html">CSL_CPSW_CPPI_P0_HOSTBLKSPRI</a> *pCppiHostBlksPri)</td></tr>
<tr class="separator:ga8d721a1e9332a798191d27d653aa5bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6a55b25144f93f132a4c2d1ddf5e67f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_clearAleEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_clearAleEntry</b> </p>
<p><b>Description</b> <br />
 This function clears the ALE entry corresponding to the index specified</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0=0, ALE_TABLE_WORD1=0, ALE_TABLE_WORD2=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;

       index   =   0;

       CSL_CPSW_clearAleEntry (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab305c646fdd1139657a40bd5bb171b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_clearAleTable </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_clearAleTable</b> </p>
<p><b>Description</b> <br />
 This function initiates a full ALE table cleanup. The ALE hardware clears all table entries.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_CLEAR_TABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_clearAleTable ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7fc0f5fd57ededbc9a6f135fc000625f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAle </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAle</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable ALE processing.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_ALE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaeac18f372e7526a04d90c44d810907c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleBypass </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleBypass</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_BYPASS=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleBypass ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa33489b6a734ab28c48a5bcc09ac9299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleLearnNoVID </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleLearnNoVID</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN Id learning.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_LEARN_NO_VLANID=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleLearnNoVID ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4ad4a0e625dc6422a33a7f198dc9d06a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleMacAuthMode </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleMacAuthMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable MAC authorization mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_AUTH_MODE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleMacAuthMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae4a6fc0daa35f58bca082dd76b06c4b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleOUIDenyMode </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleOUIDenyMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_OUI_DENY=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleOUIDenyMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga27b50eec2825e9b38ca8d5644b02d485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleRateLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable multicast, broadcast rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_RATE_LIMIT=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf784c546c74eaaae98e9608b2d5a5d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleTxRateLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleTxRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to select Rx-port based multicast, broadcast rate limiting</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_BCAST_MCAST_CTL=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleTxRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3a59c7c1444c2c835e2bcb293ca342b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleUUNIToHost </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleUUNIToHost</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable forwarding unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_EN_HOST_UNI_FLOOD=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleUUNIToHost ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaf3e0abc2c3861248e60f815c0325521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleUVLANNoLearn </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleUVLANNoLearn</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable unknown VLAN No Learn mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 ALE_ALE_CONTROL_ENABLE_ALE = 1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_UVLAN_NO_LEARN=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleUVLANNoLearn ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6adff81ed7c79d3888cbd14b6633c302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleVID0Mode </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleVID0Mode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable VID0 mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_VID0_MODE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleVID0Mode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gade35edb6c5ad3b7eff1e12f6119a37b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableAleVlanAware </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ALE_VLAN_AWARE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa8769f843e6e792cab042eb8c6f844ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableP0TxCastagnoliCRC </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableP0TxCastagnoliCRC</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable Castagnoli CRC for host port.</p>
<p><b>Return</b> Value <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga2810fdaabae4bf44a127ee7fb38dd8d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disablePort0 </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort0</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P0_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort0 ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa09c50cf52764b7b8395e63efc9b8bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disablePort0PassPriTag </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort0PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort0PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4890dd216951fc98a84b7f5e880bb39a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disablePortPassPriTag </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort1PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort1PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabe91e62d9151eea69158e979e64ed0d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableSoftIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW Soft Idle register to disable Software Idle mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_SOFT_IDLE_REG_SOFT_IDLE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableSoftIdle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga010d7114304e9faf49a8c0ad1a701db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_disableVlanAware </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_VLAN_AWARE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9cc26d47e96993b27ba4ae00ecbec21d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_EEEPortStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___s_t_a_t_u_s.html">CSL_CPSW_EEE_PORT_STATUS</a> *&#160;</td>
          <td class="paramname"><em>pPortStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEEEPortStatus</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the EEE port-specific Status register corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the EEE status
                               must be retrieved.
       pPortStatus             CSL_CPSW_EEE_PORT_STATUS structure holds the EEE Port Status.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_EEE_STATUS_REG_WAIT_IDLE2LPI, XGE_CPSW_P0_EEE_STATUS_REG_RX_LPI, XGE_CPSW_P0_EEE_STATUS_REG_TX_LPI, XGE_CPSW_P0_EEE_STATUS_REG_TX_WAKE, XGE_CPSW_P0_EEE_STATUS_REG_TX_FIFO_HOLD, XGE_CPSW_P0_EEE_STATUS_REG_TX_FIFO_EMPTY, XGE_CPSW_P0_EEE_STATUS_REG_RX_FIFO_EMPTY,</p>
<p>XGE_CPSW_PN_EEE_STATUS_REG_WAIT_IDLE2LPI, XGE_CPSW_PN_EEE_STATUS_REG_RX_LPI, XGE_CPSW_PN_EEE_STATUS_REG_TX_LPI, XGE_CPSW_PN_EEE_STATUS_REG_TX_WAKE, XGE_CPSW_PN_EEE_STATUS_REG_TX_FIFO_HOLD, XGE_CPSW_PN_EEE_STATUS_REG_TX_FIFO_EMPTY, XGE_CPSW_PN_EEE_STATUS_REG_RX_FIFO_EMPTY</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32                      portNum;
       CSL_CPSW_EEE_PORT_STATUS    portStatus;

       portNum =   1;

       CSL_CPSW_getEEEPortStatus (portNum, &amp;portStatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7bdf7b22acaae33633d2af87e4e319b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAle </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAle</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable ALE processing.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_ALE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4e7f0f1cf09d9edd3fcb9c173754d8be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleBypass </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleBypass</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_BYPASS=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleBypass ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga949881e581f42100d2da685a31152eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleLearnNoVID </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleLearnNoVID</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN Id No Learn, i.e., disable VLAN Id learning.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_LEARN_NO_VLANID=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleLearnNoVID ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1d3138f3d3d25a2668f31e1e644cb631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleMacAuthMode </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleMacAuthMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable MAC authorization mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_AUTH_MODE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleMacAuthMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabfba08545b0305d835f6a10b26562a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleOUIDenyMode </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleOUIDenyMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_OUI_DENY=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleOUIDenyMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab4756fd5faea6eaf631a1a32e6b82df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleRateLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable multicast, broadcast rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_RATE_LIMIT=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0880a0988baf93d3604b9276b59c1264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleTxRateLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleTxRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to select Tx-port based multicast, broadcast rate limiting</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 ALE_ALE_CONTROL_ENABLE_RATE_LIMIT=1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_BCAST_MCAST_CTL=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleTxRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga048d7a2b3ac8204399b5de1574105cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleUUNIToHost </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleUUNIToHost</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable forwarding unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_EN_HOST_UNI_FLOOD=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleUUNIToHost ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1e2d293230879ca8f4f177e4bd16756c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleUVLANNoLearn </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleUVLANNoLearn</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable Unknown VLAN No Learn mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 ALE_ALE_CONTROL_ENABLE_ALE = 1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_UVLAN_NO_LEARN=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleUVLANNoLearn ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaadf621862622daf5b33b2be9b8478899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleVID0Mode </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleVID0Mode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VID0 mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ENABLE_VID0_MODE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleVID0Mode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga67d0b2fd09bb593c9b74a9987b9385b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableAleVlanAware </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_ALE_VLAN_AWARE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa062318fad0a5e55ab4f64136b63faa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableP0TxCastagnoliCRC </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableP0TxCastagnoliCRC</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable Castagnoli CRC for host port specified.</p>
<p><b>Return</b> Value <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga8303adc68a59678aac5d2013e1e0bd3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enablePort0 </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort0</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P0_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort0 ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa279eaaaaf5215787051ff4bc71151cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enablePort0PassPriTag </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort0PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort0PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf10a81f822d2370892c815b166666b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enablePortPassPriTag </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort1PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort1PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga12b6149272df7e9d4cf35d5e36033d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableSoftIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW Soft Idle register to enable Software Idle mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_SOFT_IDLE_REG_SOFT_IDLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableSoftIdle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0c914725fe256b446a0610b55d10a36f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_enableVlanAware </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_VLAN_AWARE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9d507df53333e9aed89d4516e903685b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_extractVid </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>word1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_extractVid</b> </p>
<p><b>Description</b> <br />
 This function extracts the vlan id field from the ALE table word 1 <b>Arguments</b> </p><pre class="fragment">       word1                   ALE table word 1 value for a VLAN entry
       aleType                 ALE type(4-Port/9-Port)
*   </pre><p><b>Return</b> Value <br />
 vid Extracted vlan id </p><hr/>
 
</div>
</div>
<a class="anchor" id="gaa7a6d882933f74e1059ab2ba464e66c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#gac08366dceb5ccaea33ad2555f63471d5">CSL_CPSW_ALE_ADDRTYPE</a> CSL_CPSW_getALEAddressType </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getALEAddressType</b> </p>
<p><b>Description</b> <br />
 This function returns the address type of an ALE entry.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> CSL_CPSW_ALE_ADDRTYPE <br />
 ALE_ADDRTYPE_UCAST Address at this entry is unicast <br />
 ALE_ADDRTYPE_MCAST Address at this entry is multicast <br />
 ALE_ADDRTYPE_OUI Address at this entry is OUI address</p>
<p><b> Pre Condition </b> <br />
 This function must be called only for an ALE address entry, i.e., if <em>CSL_XGE_CPSW_getALEEntryType</em> () returns ALE_ENTRYTYPE_ADDRESS or ALE_ENTRYTYPE_VLANADDRESS only.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0_REG, ALE_TABLE_WORD1_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Unicast address
           }
       }
       else
       {
           // Do nothing
       }

       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga81e8dbd43d07faf3f3f497a6dd6cff37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleAgingTimerReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAgingPrescale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAgingPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleAgingTimerReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Aging Timer register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pAgingPrescale          Aging Timer prescale (1, 1000, 1000000)
       pAgingPeriod            Aging period in units of prescale.
                               When non-zero, auto-aging is enabled.
                               This value (minus 1) times prescale is the number
                               of clock cycles after which auto-aging will automatically
                               be initiated.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_AGING_CTRL_ALE_AGING_TIMER ALE_ALE_AGING_CTRL_PRESCALE_1_DISABLE ALE_ALE_AGING_CTRL_PRESCALE_2_DISABLE</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      aleAgingPrescale;
       Uint32      aleAgingPeriod

       CSL_CPSW_getAleAgingTimerReg (&amp;aleAgingPrescale,
                                     &amp;aleAgingPeriod);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9db9ca6941cef5ae1224f8323d117082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getAleControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 ALE control register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_CONTROL_REG</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      aleCtrlVal;

     aleCtrlVal  =   CSL_CPSW_getAleControlReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5eaf96500e2015b4d91f835d18e68a54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga6ea23133eb6b1517c106ca3f1a8b7729">CSL_CPSW_ALE_ENTRYTYPE</a> CSL_CPSW_getALEEntryType </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getALEEntryType</b> </p>
<p><b>Description</b> <br />
 This function returns the ALE entry type for any given ALE table entry index.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> CSL_CPSW_ALE_ENTRYTYPE <br />
 ALE_ENTRYTYPE_FREE ALE entry is free. <br />
 ALE_ENTRYTYPE_ADDRESS ALE entry contains a unicast/multicast address. <br />
 ALE_ENTRYTYPE_VLAN ALE entry contains a VLAN. <br />
 ALE_ENTRYTYPE_VLANADDRESS ALE entry contains a VLAN and a unicast/multicast address.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD1_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;
       if (CSL_CPSW_getALEEntryType () == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry free
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga885f776b19bc55df2f786c94dffefbe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleEthertypeEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pEthertypeCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleEthertypeEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Ethertype configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pEthertypeCfg           ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_ETHERTYPE_ENTRY            ethertypeCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_ETHERTYPE)
           {
               // Read Ethertype config from hardware
               CSL_CPSW_getAleEthertypeEntry (index, &amp;ethertypeCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2be1d89f43c9c29c18b2f12be2eafd05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleIPv4Entry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv4Cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv4Entry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with IPv4 configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pIPv4Cfg                ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv4_ENTRY                 ipv4Cfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_IPV4)
           {
               // Read IPv4 config from hardware
               CSL_CPSW_getAleIPv4Entry (index, &amp;ipv4Cfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4b4b2bcb2016369ef8320240c684d236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleIPv6Entry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv6Cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv6Entry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Ipv6 configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pIPv6Cfg                ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv6_ENTRY                 ipv6Cfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_IPV6)
           {
               // Read Ipv6 config from hardware
               CSL_CPSW_getAleIPv6Entry (index, &amp;ipv6Cfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaba148c4b480f8bcc74a4f5d20b0761c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getAleIPv6HighEntryIndex </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>entryIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv6HighEntryIndex</b> </p>
<p><b>Description</b> <br />
 This function returns the higher 64bit offset of IPv6 entry given the lower 64bit ALE table entry index</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
*        </pre><p><b> Return Value </b> <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga0ab9b5a8feb2e3d9e9599a6026e75142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getAleIPv6HighEntryOffset </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv6HighEntryOffset</b> </p>
<p><b>Description</b> <br />
 This function returns the offset of the higher 64bit offset of IPv6 entry for the specific ALE type</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
*        </pre><p><b> Return Value </b> <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="gad5e4bb31b1cdbd44b73f514be762a788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getAleIPv6LowEntryIndex </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>entryIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv6LowEntryIndex</b> </p>
<p><b>Description</b> <br />
 This function returns the lower 64bit ALE entry index of IPv6 entry given the higher 64bit ALE table entry index</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
*        </pre><p><b> Return Value </b> <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="gaf2fa1ccc58b6ecf658961b8f6ce1e894"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pMcastAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Multicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pMcastAddrCfg           ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                     index;
       CSL_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
           {
               // Read Multicast address config from hardware
               CSL_CPSW_getAleMcastAddrEntry (index, &amp;mcastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa5680c4b6086e4495cab211a8361dce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleOUIAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOUIAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleOUIAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with OUI address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pOUIAddrCfg             ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUIADDR_ENTRY          ouiAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_OUI)
           {
               // Read Unicast address config from hardware
               CSL_CPSW_getAleOUIAddrEntry (index, &amp;ouiAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga694509502153b42b07268f179a8dc9f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleOutVlanEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOutVlanCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleOutVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Outer VLAN configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pOutValnCfg             ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUTER_VLAN_ENTRY           outVlanCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_OVLAN)
           {
               // Read outer VALN config from hardware
               CSL_CPSW_getAleOutVlanEntry (index, &amp;outVlanCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaced6795d975d6da7d4738fab21708fc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAlePolicerEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___e_n_t_r_y.html">CSL_CPSW_ALE_POLICER_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pPolCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePolicerEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE Policer table entry for the index specified and fills the output parameter structure with Policer configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE Policer table index to be read.
       pPolCfg                 ALE Policer entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_POLICETBLCTL_POL_TBL_IDX ALE_POLICETBLCTL_WRITE_ENABLE=0 ALE_THREADMAPCTL_CLASSINDEX</p>
<p><b>Reads</b> <br />
 ALE_POLICECFG0_PORT_MEN, ALE_POLICECFG0_PORT_NUM, ALE_POLICECFG0_PRI_MEN, ALE_POLICECFG0_PRI_VAL, ALE_POLICECFG0_ONU_MEN, ALE_POLICECFG0_ONU_INDEX, ALE_POLICECFG1_DST_MEN, ALE_POLICECFG1_DST_INDEX, ALE_POLICECFG1_SRC_MEN, ALE_POLICECFG1_SRC_INDEX, ALE_POLICECFG2_OVLAN_MEN, ALE_POLICECFG2_OVLAN_INDEX, ALE_POLICECFG2_IVLAN_MEN, ALE_POLICECFG2_IVLAN_INDEX, ALE_POLICECFG3_ETHERTYPE_MEN, ALE_POLICECFG3_ETHERTYPE_INDEX, ALE_POLICECFG3_IPSRC_MEN, ALE_POLICECFG3_IPSRC_INDEX, ALE_POLICECFG4_IPDST_MEN, ALE_POLICECFG4_IPDST_INDEX, ALE_THREADMAPVAL_THREAD_EN, ALE_THREADMAPVAL_THREADVAL</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_POLICER_ENTRY              polCfg;

       index   =   0;

        // Read Policer Entry config from hardware
        CSL_CPSW_getAlePolicerEntry (index, &amp;polCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9e579f2de8c8b4e645066d285db4250d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga13963cf3e07219d0a5b09cfb6c376b27">CSL_CPSW_ALE_POLICER_ENTRYTYPE</a> CSL_CPSW_getALEPolicerEntryType </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getALEPolicerEntryType</b> </p>
<p><b>Description</b> <br />
 This function returns the entry type of an ALE Policer entry.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       aleType                 ALE type(4-Port/9-Port)

*        </pre><p><b> Return Value </b> CSL_CPSW_ALE_POLICER_ENTRYTYPE <br />
 ALE_POLICER_ENTRYTYPE_VLAN (Inner) VLAN Entry <br />
 ALE_POLICER_ENTRYTYPE_OVLAN Outer VLAN entry <br />
 ALE_POLICER_ENTRYTYPE_ETHERTYPEI Ether Type entry <br />
 ALE_POLICER_ENTRYTYPE_IPV4 IPv4 Address entry <br />
 ALE_POLICER_ENTRYTYPE_IPV6 IPv6 Address entry</p>
<p><b> Pre Condition </b> <br />
 This function must be called only for an ALE address entry, i.e., if <em>CSL_XGE_CPSW_getALEEntryType</em> () returns ALE_ENTRYTYPE_POLICER.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD1_REG, ALE_TABLE_WORD2_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_IPV4)
           {
               // IPv4 address
           }

       }
       else
       {
           // Do nothing
       }

       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa29df9d206921605a42a5109b848a38b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAlePolicerGlobConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_ALE_POLICER_GLOB_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pGlobConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePolicerGlobConfig</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW ALE Policer/Classifier Global Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pGlobConfig             CSL_CPSW_ALE_POLICER_GLOB_CONFIG structure that needs to
                               be populated with the contents of the corresponging ALE Policer
                               global control registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_THREADMAPDEF_DEFTHREAD_EN, ALE_THREADMAPDEF_DEFTHREADVAL</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       CSL_CPSW_ALE_POLICER_GLOB_CONFIG    globConfig;

       CSL_CPSW_getAlePolicerGlobConfig (&amp;globConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga57e5bfaacacef1d37a1d1be46ca1cf67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAlePortControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *&#160;</td>
          <td class="paramname"><em>pPortControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePortControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of ALE Port control register corresponding to the port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNo                  Port number for which the ALE port control register
                               must be read.
       pPortControlInfo        CSL_CPSW_ALE_PORTCONTROL structure that needs to be
                               filled with Port control register info read from
                               the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_I0_ALE_PORTCTL0_I0_REG_P0_PORTSTATE, ALE_I0_ALE_PORTCTL0_I0_REG_P0_DROP_UN_TAGGED, ALE_I0_ALE_PORTCTL0_I0_REG_P0_VID_INGRESS_CHECK, ALE_I0_ALE_PORTCTL0_I0_REG_P0_NO_LEARN, ALE_I0_ALE_PORTCTL0_I0_REG_P0_NO_SA_UPDATE, ALE_I0_ALE_PORTCTL0_I0_REG_P0_MACONLY, ALE_I0_ALE_PORTCTL0_I0_REG_P0_DIS_PAUTHMOD, ALE_I0_ALE_PORTCTL0_I0_REG_P0_MACONLY_CAF, ALE_I0_ALE_PORTCTL0_I0_REG_P0_MCAST_LIMIT, ALE_I0_ALE_PORTCTL0_I0_REG_P0_BCAST_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                          index;
       CSL_CPSW_ALE_PORTCONTROL    portControlInfo;

       index   =   0;

       CSL_CPSW_getAlePortControlReg (index, &amp;portControlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8e81788b963d534cd978ed0d34e3de6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAlePortState </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga9d09a0a21ede770428dfeec9661f2db6">CSL_CPSW_ALE_PORTSTATE</a> *&#160;</td>
          <td class="paramname"><em>pPortState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePortControlReg</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga8cc4e6007bc13443e2b1f8597d98d604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getAlePrescaleReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePrescaleReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Prescale register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 ALE prescale register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_PRESCALE_ALE_PRESCALE</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      alePrescaleVal;

     alePrescaleVal  =   CSL_CPSW_getAlePrescaleReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga24543bac1ec2cb4a9cd70ba653794a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleStatusReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pNumPolicers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pNumEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleStatusReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Status register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pNumPolicers            Number of policers the ALE implements (multiple of 8)
       pNumEntries             Number of total table entries supported (multiple of 1024).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_STATUS_KLUENTRIES ALE_ALE_STATUS_POLCNTDIV8</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      numPolicers, numEntries;

       CSL_CPSW_getAleStatusReg (&amp;numPolicers,
                                 &amp;numEntries);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9c8eb89e1bc65c314bb1c4338e53389f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleTableEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleTableEntry</b> </p>
<p><b>Description</b> <br />
 This function retrieves an ALE table entry corresponding to the ALE entry index specified in 'index' input parameter. The ALE entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and ALE_TBLW2 registers are returned in 'pAleInfoWd0', 'pAleInfoWd1', 'pAleInfoWd2' output parameters.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pAleInfoWd0             Contents of ALE Table Word 0 Register (ALE_TBLW0).
       pAleInfoWd1             Contents of ALE Table Word 1 Register (ALE_TBLW1).
       pAleInfoWd2             Contents of ALE Table Word 2 Register (ALE_TBLW2).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_ALE_TBLW0_TABLEWRD0, ALE_ALE_TBLW1_TABLEWRD1, ALE_ALE_TBLW2_TABLEWRD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      index, info0, info1, info2;

       index   =   0;

       CSL_CPSW_getAleTableEntry (index,
                                  &amp;info0,
                                  &amp;info1,
                                  &amp;info2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4d72e78becfdead73d1177612c044b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pUcastAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Unicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pUcastAddrCfg           ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read Unicast address config from hardware
               CSL_CPSW_getAleUnicastAddrEntry (index, &amp;ucastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1fab533264233ad7110fb1b5c3e49c7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleUnkownVlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnVlanMemList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnRegMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnForceUntagEgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleUnkownVlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Unknown VLAN and etc registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pUnVlanMemList          Unknown VLAN member list.
       pUnMcastFloodMask       Unknown VLAN Multicast flood mask.
       pUnRegMcastFloodMask    Unknown VLAN Registered Multicast Flood mask.
       pUnForceUntagEgress     Unknown VLAN Force Untagged Egress.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_UNKNOWN_VLAN_REG_UNKNOWN_LIST, ALE_UNKNOWN_MCAST_FLOOD_REG_MASK, ALE_UNKNOWN_REG_MCAST_FLOOD_REG_MASK, ALE_ALE_UVLAN_UNTAG_UVLAN_FORCE_UNTAGGED_EGRESS</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

       CSL_CPSW_getAleUnkownVlanReg (&amp;unVlanMemList,
                                     &amp;unMcastFloodMask,
                                     &amp;unRegMcastFloodMask,
                                     &amp;unForceUntagEgress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7d668aa04fa45f1f2316aa9b1111c035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getAleUpdateBW </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleUpdateBW</b> </p>
<p><b>Description</b> <br />
 This function extracts the ALE Update Bandwidth of the ALE control register</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 aleUpdBW ALE Update Bandwidth</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_UPD_BW_CTRL</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32  aleUpdBW;

     aleUpdBW = CSL_CPSW_getAleUpdateBW();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga08b1ea6766b6c4421fc7e1b7cf3b7862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleVersionInfo </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_e_r_s_i_o_n.html">CSL_CPSW_ALE_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the ALE submodule identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVersionInfo        CSL_CPSW_ALE_VERSION structure that needs to be populated
                           with the ALE version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_MOD_VER_MINOR_REVISION, ALE_MOD_VER_MAJOR_REVISION, ALE_MOD_VER_RTL_VERSION, ALE_MOD_VER_MODULE_ID</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_ALE_VERSION    versionInfo;

       CSL_CPSW_getAleVersionInfo (&amp;versionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaead22a8d0db17beef4363368a380cba8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleVlanEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE entry info for inner vlan entry</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pVlanCfg                ALE entry info for VLAN populated by this function
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga9ba937013cadabc0da5c310b56e52771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleVlanMaskMuxEntryReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>maskMuxIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>vlanMaskMuxPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanMaskMuxEntryReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE VLAN Mask Mux registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       vlanMaskMux             Array of VLAN Mask Mux which is indexed by
                               the unreg_mcast_flood_index and reg_mcast_flood_
                               index values from the VLAN table entry to determine
                               the registered and unregistered multicast flood masks
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_VLAN_MASK_MUX_REG_MASK</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      vlanMaskMux[4];

       CSL_CPSW_getAleVlanMaskMuxReg (vlanMaskMux);</pre><p> <b>Note</b> <br />
 The value of VLAN_Mask_MUX_0 is read only and all ones (all ports are one). </p><hr/>
 
</div>
</div>
<a class="anchor" id="gaca3daad62fede44583e16111e2f2ff15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleVlanMaskMuxReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>vlanMaskMux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanMaskMuxReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE VLAN Mask Mux registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">     vlanMaskMux             Array of VLAN Mask Mux which is indexed by
                             the unreg_mcast_flood_index and reg_mcast_flood_
                             index values from the VLAN table entry to determine
                             the registered and unregistered multicast flood masks</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_VLAN_MASK_MUX_REG_MASK</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      vlanMaskMux[4];

     CSL_CPSW_getAleVlanMaskMuxReg (vlanMaskMux);</pre><p><b>Note</b> <br />
 The value of VLAN_Mask_MUX_0 is read only and all ones (all ports are one). </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga5d066681b82a1eb7c7d789b592c41ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleVlanMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanMcastAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN Multicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pVlanMcastAddrCfg       ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
       {
           // ALE entry has a VLAN address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
           {
               // Read VLAN Multicast address config from hardware
               CSL_CPSW_getAleVlanMcastAddrEntry (index, &amp;vlanMcastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac8c18bd7e46874aa1f74b9f2d445f286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getAleVlanUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanUcastAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN Unicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index to be read.
       pVlanUcastAddrCfg       ALE entry contents read.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
       {
           // ALE entry has a VLAN address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read VLAN Unicast address config from hardware
               CSL_CPSW_getAleVlanUnicastAddrEntry (index, &amp;ucvlanUcastAddrCfgastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8fed817472e50bc131635dd2f944c3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getCppiP0Control </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___c_o_n_t_r_o_l.html">CSL_CPSW_CPPI_P0_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pCppiP0ControlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCppiP0Control</b> </p>
<p><b>Description</b> <br />
 This function gets the P0_CONTROL_REG register contents.</p>
<p><b>Arguments</b> </p><pre class="fragment">*       pCppiP0ControlCfg   P0_CONTROL_REG configuration structure
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga27b7ad557c1057c793ac3952b2075bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getCppiRxGapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___r_x_g_a_p.html">CSL_CPSW_CPPI_P0_RXGAP</a> *&#160;</td>
          <td class="paramname"><em>pCppiRxGap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCppiRxGapReg</b> </p>
<p><b>Description</b> <br />
 This function gets CPPI_P0_Rx_Gap This function is applicable for 2 port switch</p>
<p><b>Arguments</b> </p><pre class="fragment">*       pCppiRxGap  CPPI_P0_Rx_Gap register configuration
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="gad63a72d35079160fcc44a955b99e9c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getCppiRxPacketsPriority </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCppiRxPacketsPriority</b> </p>
<p><b>Description</b> <br />
 This function gets Port 0 Receive (same as Port 1 Transmit) Packets Per Priority This function is applicable for 2 port switch</p>
<p><b>Arguments</b> </p><pre class="fragment">*       priority  Priority for which number of rx packets is queried
*   </pre><p><b> Return Value </b> <br />
 rxPackets Number of rx packets for queried priority </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga8c7cb04f40c422c713eaa4cc6826fe1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getCppiRxPType </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCppiRxPType</b> </p>
<p><b>Description</b> <br />
 This function gets the P0 Receive priority type</p>
<p><b>Arguments</b> </p><pre class="fragment">*       none
*   </pre><p><b> Return Value </b> <br />
 p0RxPtype Receive Priority Type 0 - Fixed priority 1 - Round Robin priority </p><hr/>
 
</div>
</div>
<a class="anchor" id="gace7562d1a580779af9a669223dbbd120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getCppiSourceIdReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxSrcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCppiSourceIdReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPPI Source Identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTxSrcId[8]         CPPI Info Word0 Source Id Value on Tx Ports respectively.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_SRC_ID_A_REG_PORT1</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      txSrcId[8];

       CSL_CPSW_getCppiSourceIdReg (txSrcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2bb3e539e0d0f42121a1aa2cf3914aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getCpswControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlRegInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCpswControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pControlRegInfo     CSL_CPSW_CONTROL structure that needs to be populated
                           with the control register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_VLAN_AWARE, XGE_CPSW_CONTROL_REG_P0_ENABLE, XGE_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED, XGE_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED, XGE_CPSW_CONTROL_REG_P0_RX_PAD, XGE_CPSW_CONTROL_REG_P0_RX_PASS_CRC_ERR, XGE_CPSW_CONTROL_REG_EEE_ENABLE</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       CSL_CPSW_CONTROL    controlRegInfo;

       CSL_CPSW_getCpswControlReg (&amp;controlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga98716c4add3fb3138807bd552e8ff0f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getCpswVersionInfo </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___v_e_r_s_i_o_n.html">CSL_CPSW_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_nGF_getCpswVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the CPSW identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVersionInfo        CSL_CPSW_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CPSW_ID_VER_REG_CPSW_5GF_MINOR_VER, XGE_CPSW_CPSW_ID_VER_REG_CPSW_5GF_MAJ_VER, XGE_CPSW_CPSW_ID_VER_REG_CPSW_5GF_RTL_VER, XGE_CPSW_CPSW_ID_VER_REG_CPSW_5GF_IDENT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_VERSION    versionInfo;

       CSL_CPSW_getCpswVersionInfo (&amp;versionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1e50213762210c88094c92d1d12d2a38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getEEEGlobConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_EEE_GLOB_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pGlobConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEEEGlobConfig</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW EEE Global Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pGlobConfig             CSL_CPSW_EEE_GLOB_CONFIG structure that needs to be populated
                               with the contents of the corresponging EEE global control
                               registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_EEE_PRESCALE_REG_EEE_PRESCALE XGE_CPSW_CONTROL_REG_EEE_ENABLE</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       CSL_CPSW_EEE_GLOB_CONFIG    globConfig;

       CSL_CPSW_getEEEGlobConfig (&amp;globConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga025f37f1e325cc1c178e69a15099270e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getEEEPortConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___c_o_n_f_i_g.html">CSL_CPSW_EEE_PORT_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pPortConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEEEPortConfig</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW EEE Port Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the EEE Port Control
                               registers must be retrieved.
       pPortConfig             CSL_CPSW_EEE_PORT_CONFIG structure that needs to be populated
                               with the contents of the corresponging EEE port-specific control
                               registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_IDLE2LPI_REG_COUNT XGE_CPSW_P0_LPI2WAKE_REG_COUNT</p>
<p>XGE_CPSW_PN_IDLE2LPI_REG_COUNT XGE_CPSW_PN_LPI2WAKE_REG_COUNT XGE_CPSW_PN_CONTROL_REG_TX_LPI_CLKSTOP_EN</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                      portNum;
       CSL_CPSW_EEE_PORT_CONFIG    portConfig;

       portNum = 1;
       CSL_CPSW_getEEEPortConfig (portNum, &amp;portConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4c729944ab6a9656edbef8627de2d6eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getEmulationControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pFree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pSoft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEmulationControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Emulation Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFree                   Emulation free bit read from the hardware.
       pSoft                   Emulation soft bit read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_EM_CONTROL_REG_FREE, XGE_CPSW_EM_CONTROL_REG_SOFT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  free, soft;

       CSL_CPSW_getEmulationControlReg (&amp;free, &amp;soft);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab37095a6ca853c669810a74b7aec4f4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getEthertypeMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEthertypeMax</b> </p>
<p><b>Description</b> <br />
 This function returns the max value of EtherType field in ALE table <b>Arguments</b> </p><pre class="fragment">       aleType                 ALE type(4-Port/9-Port)
*   </pre><p><b>Return</b> Value <br />
 Maximum value of Ethertype field in ALE table </p><hr/>
 
</div>
</div>
<a class="anchor" id="gaa4dfca18ecce1f026c74f22b89f1ce07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getGapThreshold </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getGapThreshold</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the GAP_THRESH_REG register.</p>
<p>The Ethernet port transmit inter-packet gap (IPG) may be shortened by eight bit times when short gap is enabled and triggered. Setting the pn_tx_short_gap_en bit each Enet_Pn_Mac_Control register enables the gap to be shortened when triggered. The condition is triggered when the ports associated transmit packet FIFO has a user defined number of FIFO blocks used. The associated transmit FIFO blocks used value determines if the gap is shortened, and so on. The Gap_Thresh register value determines the short gap threshold. If the FIFO blocks used is greater than or equal to the Gap_Thresh value then short gap is triggered <b>Arguments</b> </p><pre class="fragment">*       none
*   </pre><p><b> Return Value </b> <br />
 Gap threshold configured </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga01d40354608b8493bb31ff2353fd6ac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getIpv4IgnBitsMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getIpv4IgnBitsMax</b> </p>
<p><b>Description</b> <br />
 This function returns the max value of IPv4 ignore bits field in ALE table <b>Arguments</b> </p><pre class="fragment">       aleType                 ALE type(4-Port/9-Port)
*   </pre><p><b>Return</b> Value <br />
 Maximum value of max value of IPv4 ignore bits field in ALE table </p><hr/>
 
</div>
</div>
<a class="anchor" id="gadeb6066891f0da90b8ff9f2a3cafa752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getIpv6IgnBitsMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getIpv6IgnBitsMax</b> </p>
<p><b>Description</b> <br />
 This function returns the max value of IPv6 ignore bits field in ALE table <b>Arguments</b> </p><pre class="fragment">       aleType                 ALE type(4-Port/9-Port)
*   </pre><p><b>Return</b> Value <br />
 Maximum value of max value of IPv4 ignore bits field in ALE table </p><hr/>
 
</div>
</div>
<a class="anchor" id="gaf438c99196bec01a0a2be8db19ac6429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getP0FifoStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___f_i_f_o_s_t_a_t_u_s.html">CSL_CPSW_CPPI_P0_FIFOSTATUS</a> *&#160;</td>
          <td class="paramname"><em>pCppiFifoStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getP0FifoStatus</b> </p>
<p><b>Description</b> <br />
 This function gets CPPI_P0_FIFO_Status register This function is will return 0 for 2 port switch as there is no Tx FIFO</p>
<p><b>Arguments</b> </p><pre class="fragment">*       pCppiFifoStats  CPPI_P0_FIFO_Status register configuration
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga6b689ad7b82f1f9a5b90c1a5bedf4189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getP0HostBlksPri </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___h_o_s_t_b_l_k_s_p_r_i.html">CSL_CPSW_CPPI_P0_HOSTBLKSPRI</a> *&#160;</td>
          <td class="paramname"><em>pCppiHostBlksPri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getP0HostBlksPri</b> </p>
<p><b>Description</b> <br />
 This function gets CPPI_P0_Host_Blks_Pri register This function is not applicable to two port switch</p>
<p><b>Arguments</b> </p><pre class="fragment">*       pCppiHostBlksPri  CPPI_P0_Host_Blks_Pri register configuration
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga99f1b10a7fb7126b1295f9e6e38141ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getPort0FlowIdOffset </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0FlowIdOffset</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Flow ID Offset Register, which is added to the thread/Flow_ID in CPPI transmit PSI Info Word 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_FLOW_ID_OFFSET_REG_VALUE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      flowIdOffset;

       flowIdOffset    =   CSL_CPSW_getPort0FlowIdOffset ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga47f34a50e105b1448d480fbfadde60ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getPort0RxMaxLen </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0RxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Receive Maximum Length Register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxLen;

       rxMaxLen    =   CSL_CPSW_getPort0RxMaxLen ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad5ad7f0902052a675e63dc60e8ae9aa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPort0RxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0RxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortRxPriMap           Array of Port 0 Rx priority map priority values
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortRxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_RX_PRI_MAP_REG_PRI0, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI1, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI2, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI3, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI4, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI5, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI6, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      port0RxPriMap [8];

       CSL_CPSW_getPort0RxPriMapReg (port0RxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafadc027a511a2662e9e469d875bda89f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPort0VlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0VlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 VLAN Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortVID                Port VLAN Id
       pPortCFI                Port CFI bit
       pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_PORT_VLAN_REG_PORT_VID, XGE_CPSW_P0_PORT_VLAN_REG_PORT_CFI, XGE_CPSW_P0_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI;

       CSL_CPSW_getPort0VlanReg (&amp;portVID, &amp;portCFI, &amp;portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab8bdf915ba9965ef0c3c50dfe8a237fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortBlockCountReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxBlkCnt_e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxBlkCnt_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxBlkCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortBlockCountReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Block Count register corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the block count
                               must be retrieved.
       pRxBlkCnt_e             Receive block count usage read for express MAC for this port.
       pRxBlkCnt_p             Receive block count usage read for preempt MAC for this port.
       pTxBlkCnt               Transmit block count usage read for this port.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_BLK_CNT_REG_RX_BLK_CNT_E, XGE_CPSW_PN_BLK_CNT_REG_RX_BLK_CNT_P, XGE_CPSW_PN_BLK_CNT_REG_TX_BLK_CNT, XGE_CPSW_P0_BLK_CNT_REG_RX_BLK_CNT, XGE_CPSW_P0_BLK_CNT_REG_TX_BLK_CNT,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxBlkCnt_e, rxBlkCnt_p, txBlkCnt, portNum;

       portNum =   1;

       CSL_CPSW_getPortBlockCountReg (portNum, &amp;rxBlkCnt, &amp;rxBlkCnt_p,
                                      &amp;txBlkCnt);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9c6ba5cacc13be9dee3456fa0bfbb3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t___c_o_n_t_r_o_l.html">CSL_CPSW_PORT_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Control Register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register contents
                               must be read and returned.
       pControlInfo            CSL_CPSW_PORT_CONTROL structure that needs to be populated
                               with the control register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 none</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_CONTROL_REG_DSCP_IPV4_EN, XGE_CPSW_P0_CONTROL_REG_DSCP_IPV6_EN,</p>
<p>XGE_CPSW_PN_CONTROL_REG_DSCP_IPV4_EN, XGE_CPSW_PN_CONTROL_REG_DSCP_IPV6_EN, XGE_CPSW_PN_CONTROL_REG_TX_LPI_CLKSTOP_EN,</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32                      portNum;
       CSL_CPSW_PORT_CONTROL       controlInfo;

       portNum =   1;

       CSL_CPSW_getPortControlReg (portNum, &amp;controlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga802cc18464ae9f9e3cda4c20683d95ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortMACAddress </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortMACAddress</b> </p>
<p><b>Description</b> <br />
 This function retreives the source MAC address of the Tx Pause Frame corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the source MAC address
                               must be read and returned. (1-8)
       pMacAddress             6 byte Source MAC address read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacAddres' must be large enough the 6 byte MAC address returned by this API.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_SA_L_REG_MACSRCADDR_7_0, XGE_CPSW_PN_SA_L_REG_MACSRCADDR_15_8, XGE_CPSW_PN_SA_H_REG_MACSRCADDR_23_16, XGE_CPSW_PN_SA_H_REG_MACSRCADDR_31_24, XGE_CPSW_PN_SA_H_REG_MACSRCADDR_39_32, XGE_CPSW_PN_SA_H_REG_MACSRCADDR_47_40</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint8   macAddress [6], portNum;

       portNum =   1;

       CSL_CPSW_getPortMACAddress (portNum, macAddress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3ef635d6f53c29371f2dd968b8709e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortMaxBlksReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortMaxBlksReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Maxmium Block register corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the max block value
                               must be retrieved.
       pRxMaxBlks              Receive FIFO Maximum Blocks - This value is the
                               maximum number of 1k memory blocks that may be
                               allocated to the FIFO's logical receive queue.
                               This value must be greater than or equal to 0x3.
                               The recommended value of rx_max_blks is 0x9

       pTxMaxBlks              Transmit FIFO Maximum Blocks - This value is the
                               maximum number of 1k memory blocks that may be
                               allocated to the FIFO's logical transmit
                               priority queues.  The recommended value of
                               tx_max_blks is 0x3.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAX_BLKS_REG_RX_MAX_BLKS, XGE_CPSW_PN_MAX_BLKS_REG_TX_MAX_BLKS,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum =   1;

       CSL_CPSW_getPortMaxBlksReg (portNum, &amp;rxMaxBlks, &amp;txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4314a49009ed3d4fbce2d88232496954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortRxDscpMap </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxDscpPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortRxDscpMap</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port DSCP to Priority Mapping Registers corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the DSCP mapping
                               registers must be retrieved.
       pRxDscpPriMap           Array of Port Rx DSCP to priority mapping values
                               read from the registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pRxDscpPriMap' must be large enough to hold all the 64 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI0, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI1, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI2, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI3, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI4, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI5, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI6, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI0, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI1, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI2, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI3, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI4, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI5, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI6, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI7</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32      rxDscpPriMap [64], portNum;

       portNum = 1;
       CSL_CPSW_getPortRxDscpMap (portNum, rxDscpPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabfcd08f9f04573738126bf24070473e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getPortRxMaxLen </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortRxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Port Receive Maximum Length Register.</p>
<p><b>Arguments</b> portNum CPSW port number for which the Receive Maximum Length must be retrieved.</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_RX_MAXLEN_REG_RX_MAXLEN XGE_CPSW_PN_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum, rxMaxLen;

       portNum = 1;
       rxMaxLen    =   CSL_CPSW_getPortRxMaxLen (portNum);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4b2c150f76c9861775c92ddea3a8c6f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortRxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortRxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the block count
                               must be retrieved.
       pPortRxPriMap           Array of Port Rx priority map priority values
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortRxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_RX_PRI_MAP_REG_PRI0, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI1, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI2, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI3, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI4, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI5, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI6, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_RX_PRI_MAP_REG_PRI0, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI1, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI2, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI3, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI4, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI5, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI6, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum = 1;
*      Uint32      portRxPriMap [8];

       CSL_CPSW_getPortRxPriMapReg (portNum, portRxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaff737247b28ae9e74c89cd2d1b1aabcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortStatsEnableReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *&#160;</td>
          <td class="paramname"><em>pPortStatsCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortStatsEnableReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Port Statistics Enable register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortStatsCfg       CSL_XGE_CPSW_PORTSTAT structure that needs to be populated
                           with the port statistics enable register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_STAT_PORT_EN_REG_P0_STAT_EN, XGE_CPSW_STAT_PORT_EN_REG_P1_STAT_EN,</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PORTSTAT       portStatsCfg;

       CSL_CPSW_getPortStatsEnableReg (&amp;portStatsCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga40f3bbb4ce0f52167e0c8da545ea42e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortTimeSyncCntlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_n_t_l.html">CSL_CPSW_TSCNTL</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncCntlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTimeSyncCntlReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time sync control register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register must be read. (1-8)
       pTimeSyncCntlCfg        CSL_CPSW_TSCNTL that needs to be populated with
                               contents of time sync control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_HOST_TS_EN, XGE_CPSW_PN_TS_CTL_REG_TS_MSG_TYPE_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_TSCNTL     tsCtlCfg;

       portNum =   1;

       CSL_CPSW_getPortTimeSyncCntlReg (portNum, &amp;tsCtlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga78167e64460fc3c25e25409c6a8ab550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortTimeSyncConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_o_n_f_i_g.html">CSL_CPSW_TSCONFIG</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTimeSyncCntlReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time sync configuration from time sync control registers corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the registers must be read. (1-8)
       pTimeSyncConfig         CSL_CPSW_TSCONFIG that needs to be populated with
                               contents of time sync control registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_HOST_TS_EN, XGE_CPSW_PN_TS_CTL_REG_TS_MSG_TYPE_EN,</p>
<p>XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_LTYPE1, XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET,</p>
<p>XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2,</p>
<p>XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_LTYPE2, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_107, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_129, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_130, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_131, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_132, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_319, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_330, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_TTL_NONZERO, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_UNI_EN,</p>
<p>XGE_CPSW_PN_TS_CTL2_REG_TS_MCAST_TYPE_EN, XGE_CPSW_PN_TS_CTL2_REG_TS_DOMAIN_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_TSCONFIG   tsConfig;

       portNum =   1;

       CSL_CPSW_getPortTimeSyncCntlReg (portNum, &amp;tsConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae1b17b3c29530336aeeb0d10235b7000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortTimeSyncSeqIdReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsLtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsSeqIdOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTimeSyncSeqIdReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time Sync Sequence Id and LTYPE register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register must be read. (1-8)
       pTsLtype                Time sync LTYPE read.
       pTsSeqIdOffset          Time sync sequence Id offset read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_LTYPE1, XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype, tsSeqIdOffset;

       portNum =   1;

       CSL_CPSW_getPortTimeSyncSeqIdReg (portNum, &amp;tsLtype, &amp;tsSeqIdOffset);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga975e0f0f872803de9fd8d2e0d39b57a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortTimeSyncVlanLTypeReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsVlanLtype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsVlanLtype2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTimeSyncVlanLTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time Sync VLAN LTYPE register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register must be read. (1-8)
       pTsVlanLtype1           Time sync VLAN LTYPE1 value read.
       pTsVlanLtype2           Time sync VLAN LTYPE2 value read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype1, tsLtype2;

       portNum =   1;

       CSL_CPSW_getPortTimeSyncVlanLTypeReg (portNum, &amp;tsLtype1, &amp;tsLtype2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaba2fa2f44eb06cebeeb1bb874fb1bb00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortTxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Transmit Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the block count
                               must be retrieved.
       pPortRxPriMap           Array of Port Rx priority map priority values
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortRxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_TX_PRI_MAP_REG_PRI0, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI1, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI2, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI3, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI4, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI5, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI6, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_TX_PRI_MAP_REG_PRI0, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI1, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI2, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI3, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI4, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI5, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI6, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum = 1;
*      Uint32      portRxPriMap [8];

       CSL_CPSW_getPortTxPriMapReg (portNum, portRxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4bd2c3c3e44100633c826f0a9a442ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPortVlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortVlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the VLAN Register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the VLAN register
                               contents must be read
       pPortVID                Port VLAN Id
       pPortCFI                Port CFI bit
       pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_PORT_VLAN_REG_PORT_VID, XGE_CPSW_P0_PORT_VLAN_REG_PORT_CFI, XGE_CPSW_P0_PORT_VLAN_REG_PORT_PRI,</p>
<p>XGE_CPSW_PN_PORT_VLAN_REG_PORT_VID, XGE_CPSW_PN_PORT_VLAN_REG_PORT_CFI, XGE_CPSW_PN_PORT_VLAN_REG_PORT_PRI,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI, portNum;

       portNum =   1;

       CSL_CPSW_getPortVlanReg (portNum, &amp;portVID, &amp;portCFI, &amp;portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga82f87508de725dc304d8d9b0d2fee22d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getPTypeReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *&#160;</td>
          <td class="paramname"><em>pPtypeCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW PTYPE register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPtypeCfg       CSL_CPSW_PTYPE structure that needs to be populated
                       with the CPSW PTYPE register contents.
*        </pre><p><b> Return Value </b> <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="gaa6cc15c7d0888060e88e6afabdd897a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getRawStats </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *&#160;</td>
          <td class="paramname"><em>pCpswStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getRawStats</b> </p>
<p><b>Description</b> <br />
 The CPSW stats are divided into 9 blocks, i.e., Stats for Host port (switch Port 0) and Stats for MAC ports (Port 1-8). This function retreives snapshot of hardware statistics for all the stat blocks. In the case of Linux ARM master use case all CPSW stats is recommended to be accessed from Linux.</p>
<p>Since this function does not clear the stats, its possible to have non-exclusive ownership of the switch and use this function without corrupting other caller's view of the stats.</p>
<p>Additional Note: In order to avoid stats loss due to rollovers, application would need to poll the stats by determining the correct interval. The stat CPSW_NETOCTETS would be first one to roll over The software must poll and accumulate the stats faster than this rate. On a 1 gigabit network, it takes approximately (0x100000000/(1000000000/8)/2)=17 seconds to roll over (the /2 is because this stat contains both tx and rx, both of which run at gigabit). A good rule of thumb is to poll at twice this rate (8-9 seconds).</p>
<p>If it is really necessary for application to have multiple nonexclusive owners of the switch, it is possible for all callers to have a view of the accumulated statistics if they (including Linux) follows the differential accumulation of the stats defiened below: uint64_t accum_CPSW_NETOCTETS; uint32_t old_CPSW_NETOCTETS, new_CPSW_NETOCTETS, diff_CPSW_NETOCTETS;</p>
<p>diff_CPSW_NETOCTETS = new_CPSW_NETOCTETS - old_CPSW_NETOCTETS; // let rollover occur, no "if" required old_CPSW_NETOCTETS = new_CPSW_NETOCTETS; accum_CPSW_NETOCTETS += diff_CPSW_NETOCTETS</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCpswStats              Array of CSL_CPSW_STATS structure that needs to be filled
                               with the stats read from the hardware. This function expects
                               that the array passed to it is big enough to hold the stats
                               for both stat blocks, i.e., size of array passed to this
                               function must be 5 or 9 for 5-port/9-port switch respectively.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_RXGOODFRAMES, CPSW_RXBROADCASTFRAMES, CPSW_RXMULTICASTFRAMES, CPSW_RXPAUSEFRAMES, CPSW_RXCRCERRORS, CPSW_RXALIGNCODEERRORS, CPSW_RXOVERSIZEDFRAMES, CPSW_RXJABBERFRAMES, CPSW_RXUNDERSIZEDFRAMES, CPSW_RXFRAGMENTS, CPSW_ALE_DROP, CPSW_ALE_OVERRUN_DROP, CPSW_RXOCTETS, CPSW_TXGOODFRAMES, CPSW_TXBROADCASTFRAMES, CPSW_TXMULTICASTFRAMES, CPSW_TXPAUSEFRAMES, CPSW_TXDEFERREDFRAMES, CPSW_TXCOLLISIONFRAMES, CPSW_TXSINGLECOLLFRAMES, CPSW_TXMULTCOLLFRAMES, CPSW_TXEXCESSIVECOLLISIONS, CPSW_TXLATECOLLISIONS, CPSW_TXUNDERRUN, CPSW_TXCARRIERSENSEERRORS, CPSW_TXOCTETS, CPSW_OCTETFRAMES64, CPSW_OCTETFRAMES65T127, CPSW_OCTETFRAMES128T255, CPSW_OCTETFRAMES256T511, CPSW_OCTETFRAMES512T1023, CPSW_OCTETFRAMES1024TUP, CPSW_NETOCTETS, CPSW_RX_BOTTOM_OF_FIFO_DROP, CPSW_PORTMASK_DROP, CPSW_RX_TOP_OF_FIFO_DROP, CPSW_ALE_ALE_RATE_LIMIT_DROP, CPSW_ALE_VID_INGRESS_DROP, CPSW_ALE_DA_EQ_SA_DROP, CPSW_ALE_UNKN_UNI, CPSW_ALE_UNKN_UNI_BCNT, CPSW_ALE_UNKN_MLT, CPSW_ALE_UNKN_MLT_BCNT, CPSW_ALE_UNKN_BRD, CPSW_ALE_UNKN_BRD_BCNT, CPSW_ALE_POLL_MATCH, CPSW_TX_MEMORY_PROTECT_ERROR</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_STATS     stats [9];

       CSL_CPSW_getRawStats (stats);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga79eeb5bb32872fd76c5b6526871b0d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getStats </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *&#160;</td>
          <td class="paramname"><em>pCpswStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getStats</b> </p>
<p><b>Description</b> <br />
 The CPSW stats are divided into 9 blocks, i.e., Stats for Host port (switch Port 0) and Stats for CPSW ports (Port 1-8 ). This function</p><ul>
<li>retreives hardware statistics for both the stat blocks.</li>
<li>Clear out the stats by the count being returned to application</li>
<li>Accumulates the stats count before returning to Application Function requires appplication to memset the stats (once before first use for accumulator, or once per use without accumulation) In the case of Linux ARM master use case all CPSW stats is recommended to be accessed from Linux. This function unconditionally clears the stats, so it requires the caller have exclusive ownership of the switch. Otherwise, none of the callers (including Linux) will have complete accumulated stats. This function can be used to clear the stats by memesetting pCpswStats to 0 and discarding the returned stats.</li>
</ul>
<pre class="fragment">@b Arguments
</pre> <pre class="fragment">       pCpswStats              Array of CSL_CPSW_STATS structure that needs to be filled
                               with the stats read from the hardware. This function expects
                               that the array passed to it is big enough to hold the stats
                               for all stat blocks, i.e., size of array passed to this
                               function must be 5 or 9 for 5/9 port switch respectively.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_RXGOODFRAMES, CPSW_RXBROADCASTFRAMES, CPSW_RXMULTICASTFRAMES, CPSW_RXPAUSEFRAMES, CPSW_RXCRCERRORS, CPSW_RXALIGNCODEERRORS, CPSW_RXOVERSIZEDFRAMES, CPSW_RXJABBERFRAMES, CPSW_RXUNDERSIZEDFRAMES, CPSW_RXFRAGMENTS, CPSW_ALE_DROP, CPSW_ALE_OVERRUN_DROP, CPSW_RXOCTETS, CPSW_TXGOODFRAMES, CPSW_TXBROADCASTFRAMES, CPSW_TXMULTICASTFRAMES, CPSW_TXPAUSEFRAMES, CPSW_TXDEFERREDFRAMES, CPSW_TXCOLLISIONFRAMES, CPSW_TXSINGLECOLLFRAMES, CPSW_TXMULTCOLLFRAMES, CPSW_TXEXCESSIVECOLLISIONS, CPSW_TXLATECOLLISIONS, CPSW_TXUNDERRUN, CPSW_TXCARRIERSENSEERRORS, CPSW_TXOCTETS, CPSW_OCTETFRAMES64, CPSW_OCTETFRAMES65T127, CPSW_OCTETFRAMES128T255, CPSW_OCTETFRAMES256T511, CPSW_OCTETFRAMES512T1023, CPSW_OCTETFRAMES1024TUP, CPSW_NETOCTETS, CPSW_RX_BOTTOM_OF_FIFO_DROP, CPSW_PORTMASK_DROP, CPSW_RX_TOP_OF_FIFO_DROP, CPSW_ALE_ALE_RATE_LIMIT_DROP, CPSW_ALE_VID_INGRESS_DROP, CPSW_ALE_DA_EQ_SA_DROP, CPSW_ALE_UNKN_UNI, CPSW_ALE_UNKN_UNI_BCNT, CPSW_ALE_UNKN_MLT, CPSW_ALE_UNKN_MLT_BCNT, CPSW_ALE_UNKN_BRD, CPSW_ALE_UNKN_BRD_BCNT, CPSW_ALE_POLL_MATCH, CPSW_TX_MEMORY_PROTECT_ERROR</p>
<p><b>Affects</b> <br />
 CPSW_RXGOODFRAMES=0, CPSW_RXBROADCASTFRAMES=0, CPSW_RXMULTICASTFRAMES=0, CPSW_RXPAUSEFRAMES=0, CPSW_RXCRCERRORS=0, CPSW_RXALIGNCODEERRORS=0, CPSW_RXOVERSIZEDFRAMES=0, CPSW_RXJABBERFRAMES=0, CPSW_RXUNDERSIZEDFRAMES=0, CPSW_RXFRAGMENTS=0, CPSW_ALE_DROP=0, CPSW_ALE_OVERRUN_DROP=0, CPSW_RXOCTETS=0, CPSW_TXGOODFRAMES=0, CPSW_TXBROADCASTFRAMES=0, CPSW_TXMULTICASTFRAMES=0, CPSW_TXPAUSEFRAMES=0, CPSW_TXDEFERREDFRAMES=0, CPSW_TXCOLLISIONFRAMES=0, CPSW_TXSINGLECOLLFRAMES=0, CPSW_TXMULTCOLLFRAMES=0, CPSW_TXEXCESSIVECOLLISIONS=0, CPSW_TXLATECOLLISIONS=0, CPSW_TXUNDERRUN=0, CPSW_TXCARRIERSENSEERRORS=0, CPSW_TXOCTETS=0, CPSW_OCTETFRAMES64=0, CPSW_OCTETFRAMES65T127=0, CPSW_OCTETFRAMES128T255=0, CPSW_OCTETFRAMES256T511=0, CPSW_OCTETFRAMES512T1023=0, CPSW_OCTETFRAMES1024TUP=0, CPSW_NETOCTETS=0, CPSW_RX_BOTTOM_OF_FIFO_DROP=0, CPSW_PORTMASK_DROP=0, CPSW_RX_TOP_OF_FIFO_DROP=0, CPSW_ALE_ALE_RATE_LIMIT_DROP=0, CPSW_ALE_VID_INGRESS_DROP=0, CPSW_ALE_DA_EQ_SA_DROP=0, CPSW_ALE_UNKN_UNI=0, CPSW_ALE_UNKN_UNI_BCNT=0, CPSW_ALE_UNKN_MLT=0, CPSW_ALE_UNKN_MLT_BCNT=0, CPSW_ALE_UNKN_BRD=0, CPSW_ALE_UNKN_BRD_BCNT=0, CPSW_ALE_POLL_MATCH=0, CPSW_TX_MEMORY_PROTECT_ERROR=0</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_STATS     stats [9];

       CSL_CPSW_getStats (stats);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3e0b47b05422ee0c53639055d675b9d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_getThruRateReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_h_r_u_r_a_t_e.html">CSL_CPSW_THRURATE</a> *&#160;</td>
          <td class="paramname"><em>pThruRateCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getThruRateReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW_THRU_RATE register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pThruRateCfg    CSL_CPSW_THRURATE structure that needs to be populated
                       with the CPSW_THRU_RATE register contents.
*        </pre><p><b> Return Value </b> <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga756fe2bbb77d4efcc02f2f6eed60e8f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getTxMaxLenPerPriority </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getTxMaxLenPerPriority</b> </p>
<p><b>Description</b> <br />
 This function retrieves the max tx packet length per switch priority.</p>
<p><b>Arguments</b> </p><pre class="fragment">*       priority   Priority for which tx max packet length is queried (0 -7)
*   </pre><p><b> Return Value </b> <br />
 Max tx packet length for given priority </p><hr/>
 
</div>
</div>
<a class="anchor" id="gaa117936301e5edac26635cc4c0215008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_getTxStartWords </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getTxStartWdsReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the TX_START_WDS_REG register.</p>
<p>FIFO Packet Transmit (egress) Start Words. This value is the number of required 32-byte packet words in an Ethernet transmit FIFO before the packet egress will begin. This value is non-zero to preclude Ethernet transmit underrun. Decimal 8 is the recommended value. It should not be increased unnecessarily to prevent adding to the switch latency</p>
<p><b>Arguments</b> </p><pre class="fragment">*       none
*   </pre><p><b> Return Value </b> <br />
 Gap threshold configured </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga47249c2830bb22d4334d380ea4f8e3d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleAgeOutDone </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleAgeOutDone</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE control register's AGE_OUT_NOW bit to check if the ALE ageable entry cleanup process is done.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE age out process done. <br />
 FALSE ALE age out process not yet completed.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_AGE_OUT_NOW</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleAgeOutDone ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaca6ba8f673a412be138080a6b6756c1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleBypassEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleBypassEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Bypass mode enabled. <br />
 FALSE ALE Bypass mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_ENABLE_BYPASS</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleBypassEnabled () == TRUE)
     {
         // ALE Bypass mode on
     }
     else
     {
         // ALE Bypass mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga53272fad54a7a3ee110f044f2cd41663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE processing is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE enabled. ALE packet processing will be done. <br />
 FALSE ALE disabled. All packets are dropped by ALE.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_ENABLE_ALE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleEnabled () == TRUE)
     {
         // ALE enabled
     }
     else
     {
         // ALE disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae53db7587a638dfcf13e88deca37e9d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleLearnNoVIDEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleLearnNoVIDEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to not learn VLAN Ids.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Learn no VID enabled. VLAN Id is not learned with source address (source address is not tied to VID) <br />
 FALSE ALE VID learning mode enabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_LEARN_NO_VLANID</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleLearnNoVIDEnabled () == TRUE)
     {
         // ALE VID learning disabled
     }
     else
     {
         // ALE VID learning enabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaeb5ea095c2878b1cafa8f6c866751377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleMacAuthModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleMacAuthModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE MAC Authorization mode is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE is in MAC authorization mode. <br />
 FALSE ALE not in MAC authorization mode.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_ENABLE_AUTH_MODE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleMacAuthModeEnabled () == TRUE);
     {
         // ALE  is in MAC authorization mode
     }
     else
     {
         // ALE not in MAC authorization mode
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga95212faaf707746a85b1e999bb4144ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleOUIDenyModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleOUIDenyModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE OUI deny mode enabled. <br />
 FALSE ALE OUI deny mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_ENABLE_OUI_DENY</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleOUIDenyModeEnabled () == TRUE)
     {
         // ALE OUI deny mode on
     }
     else
     {
         // ALE OUI deny mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf4247ae0d57ae2f43495def6125a987f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleRateLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleRateLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE Broadcast and Multicast Rate Limit is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Broadcast and multicast rate limit enabled. Broadcast/multicast packet reception limited to port control register rate limit fields. <br />
 FALSE ALE Broadcast and multicast rate limit disabled. Broadcast/multicast rates not limited.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_ENABLE_RATE_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleRateLimitEnabled () == TRUE)
     {
         // ALE Broadcast/Multicast rate limit enabled
     }
     else
     {
         // ALE Broadcast/Multicast rate limit disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9f52a0aee2807781949e6e9930fa25d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleTxRateLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleTxRateLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be Tx-port based multicast, broadcast rate limited.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Tx rate limit enabled. Broadcast, multicast rate limit counters are transmit port based. <br />
 FALSE ALE Tx rate limit disabled. Broadcast, multicast rate limit counters are receive port based.</p>
<p><b> Pre Condition </b> <br />
 ALE_ALE_CONTROL_ENABLE_RATE_LIMIT=1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_BCAST_MCAST_CTL</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleTxRateLimitEnabled () == TRUE)
     {
         // ALE Tx rate limit on
     }
     else
     {
         // ALE Tx rate limit off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9ef5073e9c145d57fb682ca2617145bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleUUNIToHostEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleUUNIToHostEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to forward unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Unknown unicast packets flood to host also. <br />
 FALSE Unknown unicast packets are dropped to the host.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_EN_HOST_UNI_FLOOD</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleUUNIToHostEnabled () == TRUE)
     {
         // ALE Unknown UNI packets forwarded to host
     }
     else
     {
         // ALE Unknown UNI packets dropped to host
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac2e198591ca3268ec97d8cff71a45cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleUVLANNoLearnEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleUVLANNoLearnEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to disable learning of the packets with unknown VLAN.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Unknown VLAN No Learn enabled. Source addresses of unknown VLANIDs are not added into the look up table even if learning is enabled. <br />
 FALSE Unknown VLAN No Learn disabled. Source addresses of unknown VLANIDs are added into the look up table if learning is enabled.</p>
<p><b> Pre Condition </b> <br />
 ALE_ALE_CONTROL_ENABLE_ALE = 1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_UVLAN_NO_LEARN</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleUVLANNoLearnEnabled () == TRUE)
     {
         // Unknown VLAN No Learn disabled
     }
     else
     {
         // Unknown VLAN No Learn enabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga82f0b4d91a8a9e4d4723e0eb93e97fc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleVID0ModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleVID0ModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in VID0 (VLAN ID=0) mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE VID0 mode enabled. Process the packet with VLAN Id = 0 <br />
 FALSE ALE VID0 mode disabled. Process the packet with VLAN Id =PORT_VLAN[11-0]</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_ENABLE_VID0_MODE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleVID0ModeEnabled () == TRUE)
     {
         // ALE VID0 mode on
     }
     else
     {
         // ALE VID0 mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaeafe07c2b288d4c9e48da656513cff5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isAleVlanAwareEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleVlanAwareEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be VLAN aware.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE VLAN aware. ALE drops packets if VLAN not found. <br />
 FALSE ALE not VLAN aware. Floods if VLAN not found.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_ALE_CONTROL_ALE_VLAN_AWARE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleVlanAwareEnabled () == TRUE)
     {
         // ALE VLAN aware
     }
     else
     {
         // ALE not VLAN aware
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac4879425499d9f3a99199d89cfccfccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isP0TxCastagnoliCRCEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isP0TxCastagnoliCRCEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if Castagnoli CRC is enabled in the CPSW control register for host port.</p>
<p><b> Return Value </b> <br />
 TRUE Castagnoli CRC enabled <br />
 FALSE Castagnoli CRC disabled. </p><hr/>
 
</div>
</div>
<a class="anchor" id="gabf464239bf5869ace763c84c2218461a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isPort0Enabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort0Enabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if CPPI Port (Port 0) is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 0 enabled. <br />
 FALSE Port 0 disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P0_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort0Enabled (portNum) == TRUE)
     {
         // Port 0 enabled
     }
     else
     {
         // Port 0 disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaae2f09fbfe387096fb2bbd49d4b5b273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isPort0PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort0PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 0 ingress priority tagging enabled. <br />
 FALSE Port 0 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort0PassPriTagEnabled () == TRUE)
     {
         // Port 0 pass priority tagging enabled
     }
     else
     {
         // Port 0 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa291f4716a36ecb25b1a623b39e8ea6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isPort1PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort1PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 1 ingress priority tagging enabled. <br />
 FALSE Port 1 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort1PassPriTagEnabled () == TRUE)
     {
         // Port 1 pass priority tagging enabled
     }
     else
     {
         // Port 1 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8accb9ec8727af6e80e8aa206d9aebcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isSoftIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function indicates if the CPSW is at Software Idle mode where no packets will be started to be unloaded from ports.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Software Idle mode enabled. <br />
 FALSE Software Idle mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_SOFT_IDLE_REG_SOFT_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isSoftIdle () == TRUE)
     {
         // Software Idle mode enabled
     }
     else
     {
         // Software Idle mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7c59c4bffd6f0a2810a2dd99887c1a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_CPSW_isVlanAwareEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isVlanAwareEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if VLAN aware mode is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE VLAN aware mode enabled. <br />
 FALSE VLAN aware mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_VLAN_AWARE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isVlanAwareEnabled (portNum) == TRUE)
     {
         // VLAN aware mode enabled
     }
     else
     {
         // VLAN aware mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafcc8d45fdbebd2e36655777cfc9dddeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_mapMacAddr2TableWord </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>word0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>word1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>macAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_mapMacAddr2TableWord</b> </p>
<p><b>Description</b> <br />
 This function populates the ALE table word 0 and word 1 with the mac address passed <b>Arguments</b> </p><pre class="fragment">       word0                   Pointer to ALE table word 0 to be populated
       word1                   Pointer to ALE table word 1 to be populated
       macAddr                 input mac address 
       aleType                 ALE type(4-Port/9-Port)
*   </pre> <hr/>
 
</div>
</div>
<a class="anchor" id="ga60f7224a0625bcfa656cc3c17b9b06f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_mapTableWord2MacAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>word0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>word1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>macAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_mapTableWord2MacAddr</b> </p>
<p><b>Description</b> <br />
 This function extracts the mac address from the ALE table word0 and word 1 <b>Arguments</b> </p><pre class="fragment">       word0                   ALE table word 0 value
       word1                   ALE table word 0 value
       macAddr                 mac address which will be populated
       aleType                 ALE type(4-Port/9-Port)
*        </pre> <hr/>
 
</div>
</div>
<a class="anchor" id="ga32dad5a1a11c8a75bc3f34b271cde160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleAgingTimerReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>agingPrescale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>agingPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleAgingTimerReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE Aging Timer register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       agingPrescale           Aging Timer prescale (1, 1000, 1000000)
       agingPeriod             Aging period in units of prescale.
                               When non-zero, auto-aging is enabled.
                               This value (minus 1) times prescale is the number
                               of clock cycles after which auto-aging will automatically
                               be initiated.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_AGING_CTRL_ALE_AGING_TIMER ALE_ALE_AGING_CTRL_PRESCALE_1_DISABLE ALE_ALE_AGING_CTRL_PRESCALE_2_DISABLE</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      aleAgingPrescale;
       Uint32      aleAgingPeriod;

       aleAgingPrescale = (Uint32)ALE_AGT_PRESACLE_1M;
       aleAgingPeriod = 1000;

       CSL_CPSW_setAleAgingTimerReg (aleAgingPrescale,
                                     aleAgingPeriod);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga59db759abfffcc2643cca9ddc9f9cf87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleCtrlVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       aleCtrlVal          Value to be configured to the ALE control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_CONTROL_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          aleCtrlVal = 0;

       aleCtrlVal      =   CSL_CPSW_getAleControlReg ();
       aleCtrlVal      |=  CSL_XGE_CPSW_ALECONTROL_CLRTABLE_EN;

       CSL_CPSW_setAleControlReg (&amp;aleCtrlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacf10a7dfee1cdac2465294b22d0aeb81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleCtrl2IPPktFilterConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_CPSW_ALE_CTRL2_IPPKTFLT_CONFIG *&#160;</td>
          <td class="paramname"><em>ipPktFltCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleCtrl2IPPktFilterConfig</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga72d92131168eb2541b4ba128257eb7fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleCtrl2MalformedFrameConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_CPSW_ALE_CTRL2_MALFORMEDFRAME_CONFIG *&#160;</td>
          <td class="paramname"><em>badFrmCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleCtrl2MalformedPktConfig</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="gac4c9bcf9e6f3b368427b266201b63158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleCtrl2MirrorMatchIndex </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>mirrorMatchIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleCtrl2MirrorMatchIndex</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga58fa0bc55e92da26dd2aa20caaf055f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleCtrl2TrunkParams </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_CPSW_ALE_CTRL2_TRUNK_CONFIG *&#160;</td>
          <td class="paramname"><em>trunkCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleCtrl2MirrorMatchIndex</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga3a49e60cdb50a1e7c8e3a912370d4052"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleEthertypeEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pEthertypeCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleEthertypeEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Ethertype configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pEthertypeCfg           ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_ETHERTYPE_ENTRY            ethertypeCfg;

       index   =   0;
       ethertypeCfg.ethertype = 0x0800;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Ethertype entry
           CSL_CPSW_setAleEthertypeEntry (index, &amp;ethertypeCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae7a7b496bf725c1292d9f6e8f55a53d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleIPNxtHdrWhitelist </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>ipNxtHdr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>ipNxtHdr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>ipNxtHdr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>ipNxtHdr3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setIPNxtHdrList</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga20ca6fbf927b8666a4d22cbfca1bf020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleIPv4Entry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv4Cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleIPv4Entry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with IPv4 configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pIPv4Cfg                ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv4_ENTRY                 ipv4Cfg;

       index   =   0;
       ipv4Cfg.ethertype = 0x0800;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add IPv4 entry
           CSL_CPSW_setAleIPv4Entry (index, &amp;ipv4Cfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaceb0a2df2f4afbf65575d6700761e1f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleIPv6Entry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv6Cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleIPv6Entry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with IPv6 configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pIPv6Cfg                ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv6_ENTRY                 ipv4Cfg;

       index   =   0;
       ipv4Cfg.ethertype = 0x0800;
       ...

       if ((CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE &amp;&amp;
           (CSL_CPSW_getALEEntryType (index+1) == ALE_ENTRYTYPE_FREE))
       {
           // ALE entry is free

           // Add IPv6 entry
           CSL_CPSW_setAleIPv6Entry (index, &amp;ipv4Cfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabe1717c120d3b9944a488e4a2ee64a1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pMcastAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Multicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pMcastAddrCfg           ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;
       CSL_CPSW_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

       index   =   0;
       mcastAddrCfg.macAddress [0] = 0x00;
       mcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Multicast address entry
           CSL_CPSW_setAleMcastAddrEntry (index, &amp;mcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8c3ee95b299aff1dcfb1c06404c4768a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleOAMLpbkControl </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>lpbkEnablePortMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleOAMLpbkControl</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga3bb0bc72164cd43831b2f662bcbef0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleOUIAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOUIAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleOUIAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with OUI address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pOUIAddrCfg             ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUIADDR_ENTRY          ouiAddrCfg;

       index   =   0;
       ouiAddrCfg.ouiAddress [0] = 0x00;
       ouiAddrCfg.ouiAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add OUI address entry
           CSL_CPSW_setAleOUIAddrEntry (index, &amp;ouiAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf8b64c241ff5590a81dcc3bd59af8f95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleOutVlanEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOutVlanCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleOutVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Outer VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pOutValnCfg             ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)

*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUTER_VLAN_ENTRY           outVlanCfg;

       index   =   0;
       outVlanCfg.vlanId = 0x0123;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Outer VLAN entry
           CSL_CPSW_setAleOutValnEntry (index, &amp;outVlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga53e9d55aba3df44153c50e7c819667f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAlePolicerEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___e_n_t_r_y.html">CSL_CPSW_ALE_POLICER_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pPolCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePolicerEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pPolCfg                 ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_POLICETBLCTL_POL_TBL_IDX ALE_POLICETBLCTL_WRITE_ENABLE=1 ALE_THREADMAPCTL_CLASSINDEX ALE_POLICECFG0_PORT_MEN, ALE_POLICECFG0_PORT_NUM, ALE_POLICECFG0_PRI_MEN, ALE_POLICECFG0_PRI_VAL, ALE_POLICECFG0_ONU_MEN, ALE_POLICECFG0_ONU_INDEX, ALE_POLICECFG1_DST_MEN, ALE_POLICECFG1_DST_INDEX, ALE_POLICECFG1_SRC_MEN, ALE_POLICECFG1_SRC_INDEX, ALE_POLICECFG2_OVLAN_MEN, ALE_POLICECFG2_OVLAN_INDEX, ALE_POLICECFG2_IVLAN_MEN, ALE_POLICECFG2_IVLAN_INDEX, ALE_POLICECFG3_ETHERTYPE_MEN, ALE_POLICECFG3_ETHERTYPE_INDEX, ALE_POLICECFG3_IPSRC_MEN, ALE_POLICECFG3_IPSRC_INDEX, ALE_POLICECFG4_IPDST_MEN, ALE_POLICECFG4_IPDST_INDEX, ALE_THREADMAPVAL_THREAD_EN, ALE_THREADMAPVAL_THREADVAL</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_POLICER_ENTRY              polCfg;

       index   =   0;
       polCfg.vlanId  = 0x10;
       ...

       // Add ALE Policer entry
       CSL_CPSW_setAlePolicerEntry (index, &amp;polCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga719be1ef2e7af2d3f01bd8fc7cbb06c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAlePolicerGlobConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_ALE_POLICER_GLOB_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pGlobConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePolicerGlobConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW ALE Policer/Classifier global registers per user-specified ALE Policer Global Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pGlobConfig         CSL_CPSW_ALE_POLICER_GLOB_CONFIG structure that holds the values
                           that need to be configured to the ALE Policer global control
                           registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CPSW ALE Policer Global control register modified with values provided.</p>
<p><b>Writes</b> <br />
 ALE_THREADMAPDEF_DEFTHREAD_EN, ALE_THREADMAPDEF_DEFTHREADVAL</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_ALE_POLICER_GLOB_CONFIG    globConfig;

       globConfig.defThreadEnable  =   1;
       ...

       CSL_CPSW_setAlePolicerGlobConfig (&amp;globConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9d6b638d2fe79f91254880e710942d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAlePortControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *&#160;</td>
          <td class="paramname"><em>pPortControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePortControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of ALE Port control register corresponding to the port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNo                  Port number for which the ALE port control register
                               must be configured.
       pPortControlInfo        CSL_CPSW_ALE_PORTCONTROL structure that contains
                               port control register settings to be written.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_I0_ALE_PORTCTL0_I0_REG_P0_PORTSTATE, ALE_I0_ALE_PORTCTL0_I0_REG_P0_DROP_UN_TAGGED, ALE_I0_ALE_PORTCTL0_I0_REG_P0_VID_INGRESS_CHECK, ALE_I0_ALE_PORTCTL0_I0_REG_P0_NO_LEARN, ALE_I0_ALE_PORTCTL0_I0_REG_P0_NO_SA_UPDATE, ALE_I0_ALE_PORTCTL0_I0_REG_P0_MACONLY, ALE_I0_ALE_PORTCTL0_I0_REG_P0_DIS_PAUTHMOD, ALE_I0_ALE_PORTCTL0_I0_REG_P0_MACONLY_CAF, ALE_I0_ALE_PORTCTL0_I0_REG_P0_MCAST_LIMIT, ALE_I0_ALE_PORTCTL0_I0_REG_P0_BCAST_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                          index;
       CSL_CPSW_ALE_PORTCONTROL    portControlInfo;

       index   =   0;
       portControlInfo.portState   =   ALE_PORTSTATE_FORWARD |
                                       ALE_PORTSTATE_LEARN;

       CSL_CPSW_setAlePortControlReg (index, &amp;portControlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga30af57bb4fbbda8ce2089a9dbde9e8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAlePortMirrorSouce </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableMirror</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePortControlReg</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga98ed589beb125f41729c6f38851325cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAlePortState </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga9d09a0a21ede770428dfeec9661f2db6">CSL_CPSW_ALE_PORTSTATE</a>&#160;</td>
          <td class="paramname"><em>portState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePortControlReg</b> </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga14f4d2955fb79ddb7922eec47ffebaaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAlePrescaleReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>alePrescaleVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePrescaleReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE prescale register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       alePrescaleVal      Value to be configured to the ALE Prescale register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_PRESCALE_ALE_PRESCALE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          alePrescaleVal = 0;

       alePrescaleVal  =   10;

       CSL_CPSW_setAlePrescaleReg (&amp;aleCtrlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabf47f5c3dc8350770130b28b61c98d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleTableEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleTableEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up an ALE table entry corresponding to the ALE entry index specified in 'index' input parameter. The ALE entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and ALE_TBLW2 registers msut be specified in 'aleInfoWd0', 'aleInfoWd1', 'aleInfoWd2' input parameters.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be written.
       aleInfoWd0              Value to write to ALE Table Word 0 Register (ALE_TBLW0).
       aleInfoWd1              Value to write to ALE Table Word 1 Register (ALE_TBLW1).
       aleInfoWd2              Value to write to ALE Table Word 2 Register (ALE_TBLW2).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLW0_TABLEWRD0, ALE_ALE_TBLW1_TABLEWRD1, ALE_ALE_TBLW2_TABLEWRD2, ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       Uint32      index, info0, info1, info2;

       index   =   0;
       info0   =   ...;
       info1   =   ...;
       info2   =   ...;

       CSL_CPSW_setAleTableEntry (index,
                                         info0,
                                         info1,
                                         info2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga09c8d0098f0bd62caacb7436db4fd289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pUcastAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with unicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pUcastAddrCfg           ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

       index   =   0;
       ucastAddrCfg.macAddress [0] = 0x00;
       ucastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Unicast address entry
           CSL_CPSW_setAleUnicastAddrEntry (index, &amp;ucastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0c4941fedc5bdddf43bc204a58bb1916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleUnknwnVlanMemberReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleUnknwnVlanMemberVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUnknwnVlanMemberReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE unknown vlan register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       aleUnknwnVlanVal  Value to be configured to the ALE unknown vlan reg
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 UNKNOWN_VLAN_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          aleUnknwnVlanVal = 0;

       CSL_CPSW_getAleUnknwnVlanReg (&amp;aleUnknwnVlanVal);
       aleUnknwnVlanVal      |=  CSL_XGE_CPSW_ALECONTROL_CLRTABLE_EN;

       CSL_CPSW_setAleUnknwnVlanReg (aleUnknwnVlanVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaeba9867fa93a71e9eadd419738e07488"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleUnknwnVlanUntagReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleUnknwnVlanUntagVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUnknwnVlanUntagReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE unknown vlan register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       aleUnknwnVlanVal  Value to be configured to the ALE unknown vlan reg
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 UNKNOWN_VLAN_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          aleUnknwnVlanVal = 0;

       CSL_CPSW_getAleUnknwnVlanReg (&amp;aleUnknwnVlanVal);
       aleUnknwnVlanVal      |=  CSL_XGE_CPSW_ALECONTROL_CLRTABLE_EN;

       CSL_CPSW_setAleUnknwnVlanReg (aleUnknwnVlanVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6e42239f1bb2d394395fe03b629d5838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleUnkownVlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unVlanMemList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unRegMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unForceUntagEgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUnkownVlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE Unknown VLAN and etc. register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       unVlanMemList           Unknown VLAN member list.
       unMcastFloodMask        Unknown VLAN Multicast flood mask.
       unRegMcastFloodMask     Unknown VLAN Registered Multicast Flood mask.
       unForceUntagEgress      Unknown VLAN Force Untagged Egress.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_UNKNOWN_VLAN_REG_UNKNOWN_LIST, ALE_UNKNOWN_MCAST_FLOOD_REG_MASK, ALE_UNKNOWN_REG_MCAST_FLOOD_REG_MASK, ALE_ALE_UVLAN_UNTAG_UVLAN_FORCE_UNTAGGED_EGRESS</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

       unVlanMemList           =   0;
       unMcastFloodMask        =   3;
       unRegMcastFloodMask     =   0;
       unForceUntagEgress      =   0;

       CSL_CPSW_setAleUnkownVlanReg (unVlanMemList,
                                     unMcastFloodMask,
                                     unRegMcastFloodMask,
                                     unForceUntagEgress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab70f248087266b0552b36b7db579c1f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleUpdateBW </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleUpdBW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUpdateBW</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE Update Bandwidth of the ALE control register.</p>
<p><b>Arguments</b> <br />
 aleUpdBW ALE Update Bandwidth</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_UPD_BW_CTRL</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_setAleUpdateBW ((Uint32)ALE_UPD_BW_350MHZ_5M);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6baf814cad5ff96a7a74773b8869928e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleVlanEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pVlanCfg                ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLAN_ENTRY             vlanCfg;

       index   =   0;
       vlanCfg.vlanId  = 0x10;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN entry
           CSL_CPSW_setAleVlanEntry (index, &amp;vlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga765391dfa6e3300acf7e9bf2a83e6a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleVlanMaskMuxEntryReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>maskMuxIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>vlanMaskMuxVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanMaskMuxEntryReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE VLAN Mask Mux registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       vlanMaskMux             Array of VLAN Mask Mux which is indexed by
                               the unreg_mcast_flood_index and reg_mcast_flood_
                               index values from the VLAN table entry to determine
                               the registered and unregistered multicast flood masks
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_VLAN_MASK_MUX_REG_MASK</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      vlanMaskMux[4];

       vlanMaskMux[0] = 0x3;
       vlanMaskMux[1] = 0;
       ...

       CSL_CPSW_setAleVlanMaskMuxReg (vlanMaskMux);</pre><p> <b>Note</b> <br />
 The value of VLAN_Mask_MUX_0 is read only and all ones (all ports are one). </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga4a4d34df05c5e8dec6ea76841f2dc21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleVlanMaskMuxReg </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>vlanMaskMux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanMaskMuxReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE VLAN Mask Mux registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       vlanMaskMux             Array of VLAN Mask Mux which is indexed by
                               the unreg_mcast_flood_index and reg_mcast_flood_
                               index values from the VLAN table entry to determine
                               the registered and unregistered multicast flood masks
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_VLAN_MASK_MUX_REG_MASK</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      vlanMaskMux[4];

       vlanMaskMux[0] = 0x3;
       vlanMaskMux[1] = 0;
       ...

       CSL_CPSW_setAleVlanMaskMuxReg (vlanMaskMux);</pre><p> <b>Note</b> <br />
 The value of VLAN_Mask_MUX_0 is read only and all ones (all ports are one). </p><hr/>
 
</div>
</div>
<a class="anchor" id="gad17bb3469a70072fad86a2cf1502584f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleVlanMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanMcastAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN Multicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pVlanMcastAddrCfg       ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

       index   =   0;
       vlanMcastAddrCfg.macAddress [0] = 0x00;
       vlanMcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN Multicast address entry
           CSL_CPSW_setAleVlanMcastAddrEntry (index, &amp;vlanMcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga20cbfc51f9a5fc2c7007e4b18e1aefa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setAleVlanUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanUcastAddrCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga77ac42ded816e7c3a780f92e5c96b0c8">CSL_CPSW_ALETABLE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aleType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN unicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       hCpswAleRegs            ALE register overlay
       index                   ALE table index.
       pVlanUcastAddrCfg       ALE entry contents to be configured.
       aleType                 ALE type(4-Port/9-Port)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_TBLCTL_TABLEIDX, ALE_ALE_TBLCTL_TABLEWR=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

       index   =   0;
       vlanUcastAddrCfg.macAddress [0] = 0x00;
       vlanUcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN Unicast address entry
           CSL_CPSW_setAleVlanUnicastAddrEntry (index, &amp;vlanUcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga008e20f33754ef6e73add333f0162fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setCppiP0Control </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___c_o_n_t_r_o_l.html">CSL_CPSW_CPPI_P0_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pCppiP0ControlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCppiP0Control</b> </p>
<p><b>Description</b> <br />
 This function sets the P0_CONTROL_REG register contents.</p>
<p><b>Arguments</b> </p><pre class="fragment">*       pCppiP0ControlCfg   P0_CONTROL_REG configuration structure
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="gabd7654f3a817f7adc79d40075b8178ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setCppiRxGapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___r_x_g_a_p.html">CSL_CPSW_CPPI_P0_RXGAP</a> *&#160;</td>
          <td class="paramname"><em>pCppiRxGap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCppiRxGapReg</b> </p>
<p><b>Description</b> <br />
 This function sets CPPI_P0_Rx_Gap This function is applicable for 2 port switch</p>
<p><b>Arguments</b> </p><pre class="fragment">*       pCppiRxGap  CPPI_P0_Rx_Gap register configuration
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="gae0f4207a952a9e86ca96d12bbe471c6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setCppiRxPacketsPriority </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxPackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCppiRxPacketsPriority</b> </p>
<p><b>Description</b> <br />
 This function gets Port 0 Receive (same as Port 1 Transmit) Packets Per Priority This function is applicable for 2 port switch</p>
<p><b>Arguments</b> </p><pre class="fragment">*       priority  Priority for which number of rx packets is to be set
*       rxPackets Number of rx packets to be set
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga61e12cdd76450a2d2f4363c3e09ffd0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setCppiRxPType </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>p0RxPtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCppiRxPType</b> </p>
<p><b>Description</b> <br />
 This function sets the P0 Receive priority type</p>
<p><b>Arguments</b> </p><pre class="fragment">*       p0RxPtype   Receive Priority Type
*                   0 - Fixed priority
*                   1 - Round Robin priority
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="gac5a5180dc3d7ef00963b88d74b9275bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setCppiSourceIdReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxSrcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCppiSourceIdReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPPI Source Identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTxSrcId[8]         CPPI Info Word0 Source Id Value on Tx Ports respectively.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_SRC_ID_A_REG_PORT1</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      txSrcId[8];

       txSrcId[0]    =   1;
       ...

       CSL_CPSW_setCppiSourceIdReg (txSrcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad03d3bf68535356a82dfcdfbdd8743bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setCpswControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlRegInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCpswControlReg</b> </p>
<p><b>Description</b> <br />
 This function populates the contents of the CPSW Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pControlRegInfo     CSL_CPSW_CONTROL structure that holds the values
                           that need to be configured to the CPSW control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CPSW control register modified with values provided.</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_VLAN_AWARE, XGE_CPSW_CONTROL_REG_P0_ENABLE, XGE_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED, XGE_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED, XGE_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED, XGE_CPSW_CONTROL_REG_P0_TX_CRC_REMOVE, XGE_CPSW_CONTROL_REG_P0_RX_PAD, XGE_CPSW_CONTROL_REG_P0_RX_PASS_CRC_ERR, XGE_CPSW_CONTROL_REG_EEE_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_CONTROL    controlRegInfo;

       controlRegInfo.vlanAware    =   0;
       ...

       CSL_CPSW_setCpswControlReg (&amp;controlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0514d5a95053b63431bdb79dbe7e639e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setEEEGlobConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_EEE_GLOB_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pGlobConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setEEEGlobConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW EEE related global registers per user-specified EEE Global Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pGlobConfig         CSL_CPSW_EEE_GLOB_CONFIG structure that holds the values
                           that need to be configured to the EEE global control
                           registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CPSW EEE Global control register modified with values provided.</p>
<p><b>Writes</b> <br />
 XGE_CPSW_EEE_PRESCALE_REG_EEE_PRESCALE XGE_CPSW_CONTROL_REG_EEE_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_EEE_GLOB_CONFIG    globConfig;

       globConfig.enable       =   1;
       globalConfig.prescale   =   100;
       ...

       CSL_CPSW_setEEEGlobConfig (&amp;globConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac1d3707160244a0a100bf31f58262d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setEEEPortConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___c_o_n_f_i_g.html">CSL_CPSW_EEE_PORT_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pPortConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setEEEPortConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW EEE port-specific control registers per user-specified EEE Port Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the EEE Port Control
                               registers must be configured.
       pPortConfig             CSL_CPSW_EEE_PORT_CONFIG structure holds the value
                               that needs to be configured to the EEE port-specific
                               control registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_IDLE2LPI_REG_COUNT XGE_CPSW_P0_LPI2WAKE_REG_COUNT</p>
<p>XGE_CPSW_PN_IDLE2LPI_REG_COUNT XGE_CPSW_PN_LPI2WAKE_REG_COUNT XGE_CPSW_PN_CONTROL_REG_TX_LPI_CLKSTOP_EN</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                      portNum;
       CSL_CPSW_EEE_PORT_CONFIG    portConfig;

       portNum = 1;
       portConfig.idle2lpi = 10;
       portConfig.lpi2wake = 10;
       portConfig.txLpiClkstopEnable = 1;
       CSL_CPSW_setEEEPortConfig (portNum, &amp;portConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga553ac7798956eb6f078bb83ba7e41e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setEmulationControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>soft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setEmulationControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Emulation Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       free                   Emulation free bit configuration
       soft                   Emulation soft bit configuration
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_EM_CONTROL_REG_FREE, XGE_CPSW_EM_CONTROL_REG_SOFT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 free, soft;

       free   =   0;
       soft   =   1;

       CSL_CPSW_setEmulationControlReg (free, soft);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga874fbde8401a182b651e2a55f53feb10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setGapThreshold </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>gapThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setGapThreshold</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the GAP_THRESH_REG register.</p>
<p>The Ethernet port transmit inter-packet gap (IPG) may be shortened by eight bit times when short gap is enabled and triggered. Setting the pn_tx_short_gap_en bit each Enet_Pn_Mac_Control register enables the gap to be shortened when triggered. The condition is triggered when the ports associated transmit packet FIFO has a user defined number of FIFO blocks used. The associated transmit FIFO blocks used value determines if the gap is shortened, and so on. The Gap_Thresh register value determines the short gap threshold. If the FIFO blocks used is greater than or equal to the Gap_Thresh value then short gap is triggered <b>Arguments</b> </p><pre class="fragment">*       gapThreshold     Ethernet Port  Short Gap Threshold -
*                        This is the Ethernet port associated FIFO transmit
*                        block usage value for triggering transmit short gap
*                        (when short gap is enabled)
*   </pre><p><b> Return Value </b> <br />
 Gap threshold configured </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga8d721a1e9332a798191d27d653aa5bb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setP0HostBlksPri </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_p_p_i___p0___h_o_s_t_b_l_k_s_p_r_i.html">CSL_CPSW_CPPI_P0_HOSTBLKSPRI</a> *&#160;</td>
          <td class="paramname"><em>pCppiHostBlksPri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setP0HostBlksPri</b> </p>
<p><b>Description</b> <br />
 This function sets CPPI_P0_Host_Blks_Pri register This function is not applicable to two port switch</p>
<p><b>Arguments</b> </p><pre class="fragment">*       pCppiHostBlksPri  CPPI_P0_Host_Blks_Pri register configuration
*   </pre><p><b> Return Value </b> <br />
 none </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga7f0412fd6b86de66f81c7574fb0ddd71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPort0FlowIdOffset </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>flowIdOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0FlowIdOffset</b> </p>
<p><b>Description</b> <br />
 This function sets up the Port0 Flow ID Offset register. which is added to the thread/Flow_ID in CPPI transmit PSI Info Word 0.</p>
<p><b>Arguments</b> </p><pre class="fragment">       flowIdOffset            CPPI Flow ID offset to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_FLOW_ID_OFFSET_REG_VALUE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      flowIdOffset;

       flowIdOffset    =   0;

       CSL_CPSW_setPort0FlowIdOffset (flowIdOffset);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga039462f7c97da5e516759cde7796b714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPort0RxMaxLen </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0RxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function sets up the Port0 Receive Maximum length register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       rxMaxLen            Maximum receive frame length to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxLen;

       rxMaxLen    =   1518;

       CSL_CPSW_setPort0RxMaxLen (rxMaxLen);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac34e5d352f5717763756354daadffe97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPort0RxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0RxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port 0 Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortRxPriMap           Array of Port 0 Rx priority map priority values
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_RX_PRI_MAP_REG_PRI0, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI1, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI2, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI3, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI4, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI5, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI6, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      i, port0RxPriMap [8];

       for (i = 0; i &lt; 8; i ++)
           port0RxPriMap [i] = i;

       CSL_CPSW_setPort0RxPriMapReg (port0RxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gada614cf2b30040359fac45b1361429e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPort0VlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0VlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port 0 VLAN Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portVID                 Port VLAN Id to be configured
       portCFI                 Port CFI bit to be configured
       portPRI                 Port VLAN priority to be configured
                               (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_PORT_VLAN_REG_PORT_VID, XGE_CPSW_P0_PORT_VLAN_REG_PORT_CFI, XGE_CPSW_P0_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI;

       portVID     =   1;
       portCFI     =   0;
       portPRI     =   7;

       CSL_CPSW_setPort0VlanReg (portVID, portCFI, portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7a9a75a9bce93f38ff6bb85362bf20df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t___c_o_n_t_r_o_l.html">CSL_CPSW_PORT_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Control Register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register contents
                               must be read and returned.
       pControlInfo            CSL_CPSW_PORT_CONTROL structure that holds the values
                               that need to be configured to the CPSW Port
                               control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 none</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_CONTROL_REG_DSCP_IPV4_EN, XGE_CPSW_P0_CONTROL_REG_DSCP_IPV6_EN,</p>
<p>XGE_CPSW_PN_CONTROL_REG_DSCP_IPV4_EN, XGE_CPSW_PN_CONTROL_REG_DSCP_IPV6_EN, XGE_CPSW_PN_CONTROL_REG_TX_LPI_CLKSTOP_EN,</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32                      portNum;
       CSL_CPSW_PORT_CONTROL       controlInfo;

       portNum =   1;

       controlInfo.dscpIpv4Enable = 1;
       controlInfo.dscpIpv6Enable = 1;
       controlInfo.txLpiClkstopEnable = 0;


       CSL_CPSW_setPortControlReg (portNum, &amp;controlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8077fee6ab9228d0f423fc122bb155f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortMACAddress </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortMACAddress</b> </p>
<p><b>Description</b> <br />
 This function sets up the source MAC address the Tx Pause Frame corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the source MAC address
                               must be setup. (1-8)
       pMacAddress             6 byte Source MAC address to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacAddres' is expected to be 6 bytes long.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_SA_L_REG_MACSRCADDR_7_0, XGE_CPSW_PN_SA_L_REG_MACSRCADDR_15_8, XGE_CPSW_PN_SA_H_REG_MACSRCADDR_23_16, XGE_CPSW_PN_SA_H_REG_MACSRCADDR_31_24, XGE_CPSW_PN_SA_H_REG_MACSRCADDR_39_32, XGE_CPSW_PN_SA_H_REG_MACSRCADDR_47_40</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint8   macAddress [6], portNum;

       portNum         =   1;
       macAddress [0]  =   0x01;
       macAddress [1]  =   0x02;
       macAddress [2]  =   0x03;
       macAddress [3]  =   0x04;
       macAddress [4]  =   0x05;
       macAddress [5]  =   0x06;

       CSL_CPSW_setPortMACAddress (portNum, macAddress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa6edcedc354331ea18997e69676e0209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortMaxBlksReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortMaxBlksReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Maxmium Block register corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the max block value
                               must be retrieved.
       rxMaxBlks               Receive FIFO Maximum Blocks - This value is the
                               maximum number of 1k memory blocks that may be
                               allocated to the FIFO's logical receive queue.
                               This value must be greater than or equal to 0x3.
                               The recommended value of rx_max_blks is 0x9

       txMaxBlks               Transmit FIFO Maximum Blocks - This value is the
                               maximum number of 1k memory blocks that may be
                               allocated to the FIFO's logical transmit
                               priority queues.  The recommended value of
                               tx_max_blks is 0x3.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAX_BLKS_REG_RX_MAX_BLKS, XGE_CPSW_PN_MAX_BLKS_REG_TX_MAX_BLKS,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum =   1;

       CSL_CPSW_setPortMaxBlksReg (portNum, rxMaxBlks, txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9a6e0be8ea9d1dfe772ebd6a95fc2127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortRxDscpMap </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxDscpPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortRxDscpMap</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port DSCP to Priority Mapping Registers corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the DSCP mapping
                               registers must be configured.
       pRxDscpPriMap           Array of Port Rx DSCP to priority mapping values
                               that must be configured to the registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pRxDscpPriMap' must be large enough to hold all the 64 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI0, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI1, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI2, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI3, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI4, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI5, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI6, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI0, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI1, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI2, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI3, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI4, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI5, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI6, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI7</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32      rxDscpPriMap [64], portNum;

       portNum = 1;

       for (i = 0; i &lt; 64; i ++)
           port0RxPriMap [i] = i/8;

       CSL_CPSW_setPortRxDscpMap (portNum, rxDscpPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0bfa6c1f39b92700a9222be3db281508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortRxMaxLen </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortRxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function sets up the Port Receive Maximum length register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             CPSW port number for which the Receive Maximum Length
                           must be retrieved.
       rxMaxLen            Maximum receive frame length to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_RX_MAXLEN_REG_RX_MAXLEN XGE_CPSW_PN_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum, rxMaxLen;

       portNum     =   1;
       rxMaxLen    =   1518;

       CSL_CPSW_setPortRxMaxLen (portNum, rxMaxLen);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2af707049c91e40f09e7922710d7c8be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortRxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortRxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the priority mapping
                               registers must be configured.
       pPortRxPriMap           Array of Port Rx priority map priority values
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_RX_PRI_MAP_REG_PRI0, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI1, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI2, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI3, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI4, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI5, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI6, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_RX_PRI_MAP_REG_PRI0, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI1, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI2, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI3, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI4, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI5, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI6, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum = 1;
*      Uint32      i, port0RxPriMap [8];

       for (i = 0; i &lt; 8; i ++)
           port0RxPriMap [i] = i;

       CSL_CPSW_setPortRxPriMapReg (port0RxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2114a6cefe1d8168a09dcadd2dbd6738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortStatsEnableReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *&#160;</td>
          <td class="paramname"><em>pPortStatsCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortStatsEnableReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Port Statistics Enable register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortStatsCfg       CSL_CPSW_PORTSTAT structure that contains the values
                           to be used to setup port statistics enable register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_STAT_PORT_EN_REG_P0_STAT_EN, XGE_CPSW_STAT_PORT_EN_REG_P1_STAT_EN,</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PORTSTAT       portStatsCfg;

       portStatsCfg.p0StatEnable  =   1;
       portStatsCfg.p1StatEnable  =   1;
       ...

       CSL_CPSW_setPortStatsEnableReg (&amp;portStatsCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8bd36f2ff4288c2921483414ca6d4033"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortTimeSyncCntlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_n_t_l.html">CSL_CPSW_TSCNTL</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncCntlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTimeSyncCntlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time sync control register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register must be
                               configured.
       pTimeSyncCntlCfg        CSL_CPSW_TSCNTL containing settings for time
                               sync control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_HOST_TS_EN, XGE_CPSW_PN_TS_CTL_REG_TS_MSG_TYPE_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_TSCNTL     tsCtlCfg;

       portNum =   1;

       tsCtlCfg.tsRxVlanLType1Enable   =   0;
       tsCtlCfg.tsRxVlanLType2Enable   =   0;
       ...

       CSL_CPSW_setPortTimeSyncCntlReg (portNum, &amp;tsCtlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga32c8ccd121d500c8080b25bb15b619ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortTimeSyncConfig </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_o_n_f_i_g.html">CSL_CPSW_TSCONFIG</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTimeSyncConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time sync control registers corresponding to the CPSW port number specified per user configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the registers must be
                               configured.
       pTimeSyncConfig         CSL_CPSW_TSCONFIG containing settings for time
                               sync control registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_HOST_TS_EN, XGE_CPSW_PN_TS_CTL_REG_TS_MSG_TYPE_EN</p>
<p>XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_LTYPE1, XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET,</p>
<p>XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2,</p>
<p>XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_LTYPE2, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_107, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_129, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_130, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_131, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_132, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_319, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_330, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_TTL_NONZERO, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_UNI_EN,</p>
<p>XGE_CPSW_PN_TS_CTL2_REG_TS_MCAST_TYPE_EN, XGE_CPSW_PN_TS_CTL2_REG_TS_DOMAIN_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_TSCONFIG   tsConfig;

       portNum =   1;

       tsConfig.tsRxVlanLType1Enable   =   0;
       tsConfig.tsRxVlanLType2Enable   =   0;
       ...

       CSL_CPSW_setPortTimeSyncConfig (portNum, &amp;tsConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga00f019a8c0aea97581dfe70f7f7ad49e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortTimeSyncSeqIdReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsLtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsSeqIdOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTimeSyncSeqIdReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time Sync Sequence Id and LTYPE register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register must be
                               configured. (1-8)
       tsLtype                 Time sync LTYPE to be configured.
       tsSeqIdOffset           Time sync sequence Id offset to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_LTYPE1, XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype, tsSeqIdOffset;

       portNum         =   1;
       tsLtype         =   0;
       tsSeqIdOffset   =   30;

       CSL_CPSW_getPortTimeSyncSeqIdReg (portNum, tsLtype, tsSeqIdOffset);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3164c2d6fc6c2dce7a5619a626b51d0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortTimeSyncVlanLTypeReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsVlanLtype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsVlanLtype2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTimeSyncVlanLTypeReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time Sync VLAN LTYPE register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register must be read. (1-8)
       tsVlanLtype1            Time sync VLAN LTYPE1 value to be configured.
       tsVlanLtype2            Time sync VLAN LTYPE2 value to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype1, tsLtype2;

       portNum     =   1;
       tsLtype1    =   0x8100;
       tsLtype2    =   0x8100;

       CSL_CPSW_setPortTimeSyncVlanLTypeReg (portNum, &amp;tsLtype1, &amp;tsLtype2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8fe7a0eb133c7cec5105795746fad709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortTxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Transmit Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the priority mapping
                               registers must be configured.
       pPortRxPriMap           Array of Port Rx priority map priority values
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_TX_PRI_MAP_REG_PRI0, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI1, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI2, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI3, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI4, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI5, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI6, XGE_CPSW_P0_TX_PRI_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_TX_PRI_MAP_REG_PRI0, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI1, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI2, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI3, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI4, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI5, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI6, XGE_CPSW_PN_TX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum = 1;
*      Uint32      i, port0RxPriMap [8];

       for (i = 0; i &lt; 8; i ++)
           port0TxPriMap [i] = i;

       CSL_CPSW_setPortTxPriMapReg (port0TxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabc4b869d60a6fc6ddd3e58f3c1257500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPortVlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortVlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the VLAN Register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the VLAN register
                               must be configured.
       portVID                 Port VLAN Id to be configured
       portCFI                 Port CFI bit to be configured
       portPRI                 Port VLAN priority to be configured
                               (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_PORT_VLAN_REG_PORT_VID, XGE_CPSW_P0_PORT_VLAN_REG_PORT_CFI, XGE_CPSW_P0_PORT_VLAN_REG_PORT_PRI,</p>
<p>XGE_CPSW_PN_PORT_VLAN_REG_PORT_VID, XGE_CPSW_PN_PORT_VLAN_REG_PORT_CFI, XGE_CPSW_PN_PORT_VLAN_REG_PORT_PRI,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI, portNum;

       portNum     =   1;
       portVID     =   1;
       portCFI     =   0;
       portPRI     =   7;

       CSL_CPSW_setPortVlanReg (portNum, portVID, portCFI, portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4bd4f3820efd9036614c813a8eea8dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setPTypeReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *&#160;</td>
          <td class="paramname"><em>pPtypeCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW PTYPE register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPtypeCfg       CSL_CPSW_PTYPE structure that has the
                       CPSW PTYPE register configuration.
*        </pre><p><b> Return Value </b> <br />
 None </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga9396b5b5ced99a2b18e1a70d7817feef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setTxMaxLenPerPriority </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>maxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setTxMaxLenPerPriority</b> </p>
<p><b>Description</b> <br />
 This function sets the max tx packet length per switch priority.</p>
<p><b>Arguments</b> </p><pre class="fragment">*       priority   Priority for which tx max packet length is set (0 -7)
*       maxLen     Tx max packet length to be set
*   </pre><p><b> Return Value </b> <br />
 Max tx packet length for given priority </p><hr/>
 
</div>
</div>
<a class="anchor" id="ga939d9a8afd1a5b0e726e95b17ed23317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_setVlanLTypeReg </td>
          <td>(</td>
          <td class="paramtype">CSL_Xge_cpswRegs *&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pVlanLtypeInner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pVlanLtypeOuter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setVlanLTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of VLAN_LTYPE_REG register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVlanLtype1           VLAN LTYPE1 value read.
       pVlanLtype2           VLAN LTYPE2 value read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_VLAN_LTYPE_REG_VLAN_LTYPE_INNER, XGE_CPSW_VLAN_LTYPE_REG_VLAN_LTYPE_OUTER</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype1, tsLtype2;

       portNum =   1;

       CSL_CPSW_setVlanLTypeReg (portNum, &amp;tsLtype1, &amp;tsLtype2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1b16dcecede268baba9e2a033866374e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_CPSW_startAleAgeOutNow </td>
          <td>(</td>
          <td class="paramtype">CSL_AleRegs *&#160;</td>
          <td class="paramname"><em>hCpswAleRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_startAleAgeOutNow</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to initiate an ALE ageable entry cleanup. This enables the ALE hardware to remove any ageable table entry that does not have a set touch bit.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_ALE_CONTROL_AGE_OUT_NOW=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_startAleAgeOutNow ();</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
