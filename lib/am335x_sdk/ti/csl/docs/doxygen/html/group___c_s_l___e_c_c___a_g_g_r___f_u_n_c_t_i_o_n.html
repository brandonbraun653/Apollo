<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ECC_AGGR Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ECC_AGGR Functions<div class="ingroups"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___a_p_i.html">ECC Aggregator (ECC_AGGR)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga73d29ba1910a9352f504a4ad6bcadbb7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga73d29ba1910a9352f504a4ad6bcadbb7">CSL_ecc_aggrGetRevision</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t *pRev)</td></tr>
<tr class="separator:ga73d29ba1910a9352f504a4ad6bcadbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga019fe2a586bea2d0c8035f6d252d102d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t *pNumRams)</td></tr>
<tr class="separator:ga019fe2a586bea2d0c8035f6d252d102d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5e6764e6f5418e6a87f38240aa8e0e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga6a5e6764e6f5418e6a87f38240aa8e0e">CSL_ecc_aggrReadEccRamReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t regOffset, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga6a5e6764e6f5418e6a87f38240aa8e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3bbb0e4f520bd6365b005901d1c73f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gaae3bbb0e4f520bd6365b005901d1c73f">CSL_ecc_aggrReadEccRamWrapRevReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t *pRegVal)</td></tr>
<tr class="separator:gaae3bbb0e4f520bd6365b005901d1c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1453856a9cccb89e42d47823eabc5089"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga1453856a9cccb89e42d47823eabc5089">CSL_ecc_aggrReadEccRamCtrlReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga1453856a9cccb89e42d47823eabc5089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86faae03c51b82c7b719edfd06db978d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga86faae03c51b82c7b719edfd06db978d">CSL_ecc_aggrReadEccRamErrCtrlReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga86faae03c51b82c7b719edfd06db978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403976029d7892fd21346f103e8507aa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga403976029d7892fd21346f103e8507aa">CSL_ecc_aggrReadEccRamErrStatReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga403976029d7892fd21346f103e8507aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c8ba8cbac2e25c842b4cba1d5c9d28"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga46c8ba8cbac2e25c842b4cba1d5c9d28">CSL_ecc_aggrWriteEccRamReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t regOffset, uint32_t val)</td></tr>
<tr class="separator:ga46c8ba8cbac2e25c842b4cba1d5c9d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8179eeab0379a33e3e5cad3c7c81faaa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga8179eeab0379a33e3e5cad3c7c81faaa">CSL_ecc_aggrWriteEccRamCtrlReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t val)</td></tr>
<tr class="separator:ga8179eeab0379a33e3e5cad3c7c81faaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36fae43c003c625cdfcf085a06b1f64f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga36fae43c003c625cdfcf085a06b1f64f">CSL_ecc_aggrWriteEccRamErrCtrlReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t val)</td></tr>
<tr class="separator:ga36fae43c003c625cdfcf085a06b1f64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9467420d2ac096c83e39956a782f1b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga4f9467420d2ac096c83e39956a782f1b">CSL_ecc_aggrWriteEccRamErrStatReg</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t val)</td></tr>
<tr class="separator:ga4f9467420d2ac096c83e39956a782f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a170ff6ba6f492e4f2571d5e71f456"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gae5a170ff6ba6f492e4f2571d5e71f456">CSL_ecc_aggrConfigEccRam</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, bool bEnable, bool bEccCheck, bool bEnableRMW)</td></tr>
<tr class="separator:gae5a170ff6ba6f492e4f2571d5e71f456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf25178d67ddc7ead8d027387942fedde"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gaf25178d67ddc7ead8d027387942fedde">CSL_ecc_aggrVerifyConfigEccRam</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, bool bEnable, bool bEccCheck, bool bEnableRMW)</td></tr>
<tr class="separator:gaf25178d67ddc7ead8d027387942fedde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb449a48a71be3b28af5c58f818f7a4f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gabb449a48a71be3b28af5c58f818f7a4f">CSL_ecc_aggrGetEccRamGetErrorStatus</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, <a class="el" href="struct_c_s_l___ecc___aggr_error_info.html">CSL_Ecc_AggrErrorInfo</a> *pEccErrorStatus)</td></tr>
<tr class="separator:gabb449a48a71be3b28af5c58f818f7a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7dba5f2838b2a7616d0ff764072e89d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gaa7dba5f2838b2a7616d0ff764072e89d">CSL_ecc_aggrForceEccRamError</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, const <a class="el" href="struct_c_s_l___ecc___aggr_error_info.html">CSL_Ecc_AggrErrorInfo</a> *pEccForceError)</td></tr>
<tr class="separator:gaa7dba5f2838b2a7616d0ff764072e89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b0f6e46c5eb4d4cc1db89a9cd94263"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gab3b0f6e46c5eb4d4cc1db89a9cd94263">CSL_ecc_aggrAckIntr</a> (CSL_ecc_aggrRegs *pEccAggrRegs, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gab3b0f6e46c5eb4d4cc1db89a9cd94263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6394cd4c1d5f01ec828ad3fc83f9a1a7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga6394cd4c1d5f01ec828ad3fc83f9a1a7">CSL_ecc_aggrIsEccRamIntrPending</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc, bool *pIsPend)</td></tr>
<tr class="separator:ga6394cd4c1d5f01ec828ad3fc83f9a1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa85424e469f621ceb5904df64aea25e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gaaa85424e469f621ceb5904df64aea25e">CSL_ecc_aggrSetEccRamIntrPending</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gaaa85424e469f621ceb5904df64aea25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade401be0e69596ea468f988ebd03e2cf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gade401be0e69596ea468f988ebd03e2cf">CSL_ecc_aggrClrEccRamIntrPending</a> (CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gade401be0e69596ea468f988ebd03e2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab882adcde277b4d06bcdc8bbca5a23a9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gab882adcde277b4d06bcdc8bbca5a23a9">CSL_ecc_aggrIsIntrPending</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc, bool *pIsPend)</td></tr>
<tr class="separator:gab882adcde277b4d06bcdc8bbca5a23a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2401cb56e629b93f8ad80f60b75c7446"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga2401cb56e629b93f8ad80f60b75c7446">CSL_ecc_aggrIsAnyIntrPending</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, bool *pIsPend)</td></tr>
<tr class="separator:ga2401cb56e629b93f8ad80f60b75c7446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b3c3f0d573030e55b80198b40f4d10e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga3b3c3f0d573030e55b80198b40f4d10e">CSL_ecc_aggrEnableIntr</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga3b3c3f0d573030e55b80198b40f4d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec3bcb707a45ff67967c39387a4cbe3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga2ec3bcb707a45ff67967c39387a4cbe3">CSL_ecc_aggrDisableIntr</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga2ec3bcb707a45ff67967c39387a4cbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga430e572be1e60d2e26075e951d9fa421"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga430e572be1e60d2e26075e951d9fa421">CSL_ecc_aggrEnableAllIntr</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId)</td></tr>
<tr class="separator:ga430e572be1e60d2e26075e951d9fa421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ac8454f4adcb85050f920ee348650b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga69ac8454f4adcb85050f920ee348650b">CSL_ecc_aggrDisableAllIntr</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, uint32_t ramId)</td></tr>
<tr class="separator:ga69ac8454f4adcb85050f920ee348650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cbc21425978114aa14f59bb8dda707b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga9cbc21425978114aa14f59bb8dda707b">CSL_ecc_aggrEnableIntrs</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga9cbc21425978114aa14f59bb8dda707b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae504fea1f4e3f0d9088ae37bab2f0e9c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gae504fea1f4e3f0d9088ae37bab2f0e9c">CSL_ecc_aggrDisableIntrs</a> (const CSL_ecc_aggrRegs *pEccAggrRegs, <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gae504fea1f4e3f0d9088ae37bab2f0e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff24327668b15e55b68e82335354919e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gaff24327668b15e55b68e82335354919e">CSL_ecc_aggrEnableAllIntrs</a> (const CSL_ecc_aggrRegs *pEccAggrRegs)</td></tr>
<tr class="separator:gaff24327668b15e55b68e82335354919e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8034120ec9b3751772a6f1ff5683903"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gac8034120ec9b3751772a6f1ff5683903">CSL_ecc_aggrDisableAllIntrs</a> (const CSL_ecc_aggrRegs *pEccAggrRegs)</td></tr>
<tr class="separator:gac8034120ec9b3751772a6f1ff5683903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa905e7a6030679a05c8ac55088e1601d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gaa905e7a6030679a05c8ac55088e1601d">CSL_ecc_aggrReadStaticRegs</a> (CSL_ecc_aggrRegs *pEccAggrRegs, <a class="el" href="struct_c_s_l__ecc__aggr_static_regs.html">CSL_ecc_aggrStaticRegs</a> *pEccAggrStaticRegs)</td></tr>
<tr class="separator:gaa905e7a6030679a05c8ac55088e1601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab3b0f6e46c5eb4d4cc1db89a9cd94263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrAckIntr </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrAckIntr</b> </p>
<p><b>Description</b> <br />
 This function is used to acknowledged a pending interrupt and to send the next interrupt to the host</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT or CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT) to acknowledge</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*
*      CSL_ecc_aggrAckIntr(pEccAggrRegs, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT);
*   </pre> 
</div>
</div>
<a class="anchor" id="gade401be0e69596ea468f988ebd03e2cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrClrEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrClrEccRamIntrPending</b> </p>
<p><b>Description</b> <br />
 This function is used to clear the pending status of the specified interrupt source on the specified ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or CSL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*
*      CSL_ecc_aggrClrEccRamIntrPending(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT);
*      CSL_ecc_aggrClrEccRamIntrPending(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT);
*      CSL_ecc_aggrClrEccRamIntrPending(pEccAggrRegs, ramId, CSL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS);
*   </pre> 
</div>
</div>
<a class="anchor" id="gae5a170ff6ba6f492e4f2571d5e71f456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrConfigEccRam </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableRMW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrConfigEccRam</b> </p>
<p><b>Description</b> <br />
 This function is used to configure the ECC capabilities of the specified ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 bEnable If true, then enable ECC generation. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br />
 bEccCheck If true, then enable ECC check. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br />
 bfEnableRMW If true, then enable read-modify-write on partial word writes</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t      ramId 0;
*      int32_t       cslRetValue;
*
*      cslRetValue CSL_ecc_aggrConfigEccRam(pEccAggrRegs, ramId, true, true, false);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga69ac8454f4adcb85050f920ee348650b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrDisableAllIntr </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrDisableAllIntr</b> </p>
<p><b>Description</b> <br />
 This function disables the interrupts for all of the available interrupt sources on the RAM specified by ramId</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*
*      CSL_ecc_aggrDisableAllIntr(pEccAggrRegs, ramId);
*   </pre> 
</div>
</div>
<a class="anchor" id="gac8034120ec9b3751772a6f1ff5683903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrDisableAllIntrs </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrDisableAllIntrs</b> </p>
<p><b>Description</b> <br />
 This function disables the interrupts for all of the available interrupt sources on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*
*      CSL_ecc_aggrDisableAllIntrs(pEccAggrRegs);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga2ec3bcb707a45ff67967c39387a4cbe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrDisableIntr </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrDisableIntr</b> </p>
<p><b>Description</b> <br />
 This function disables the interrupt for the specified interrupt source on the RAM specified by ramId</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT or CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*
*      CSL_ecc_aggrDisableIntr(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT);
*      CSL_ecc_aggrDisableIntr(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT);
*   </pre> 
</div>
</div>
<a class="anchor" id="gae504fea1f4e3f0d9088ae37bab2f0e9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrDisableIntrs </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrDisableIntrs</b> </p>
<p><b>Description</b> <br />
 This function disables the interrupts for the specified interrupt source on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT or CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*
*      CSL_ecc_aggrDisableIntrs(pEccAggrRegs, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT);
*      CSL_ecc_aggrDisableIntrs(pEccAggrRegs, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga430e572be1e60d2e26075e951d9fa421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrEnableAllIntr </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrEnableAllIntr</b> </p>
<p><b>Description</b> <br />
 This function enables the interrupts for all of the available interrupt sources on the RAM specified by ramId</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*
*      CSL_ecc_aggrEnableAllIntr(pEccAggrRegs, ramId);
*   </pre> 
</div>
</div>
<a class="anchor" id="gaff24327668b15e55b68e82335354919e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrEnableAllIntrs </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrEnableAllIntrs</b> </p>
<p><b>Description</b> <br />
 This function enables the interrupts for all of the available interrupt sources on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*
*      CSL_ecc_aggrEnableAllIntrs(pEccAggrRegs);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga3b3c3f0d573030e55b80198b40f4d10e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrEnableIntr </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrEnableIntr</b> </p>
<p><b>Description</b> <br />
 This function enables the interrupt for the specified interrupt source on the RAM specified by ramId</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT or CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*
*      CSL_ecc_aggrEnableIntr(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT);
*      CSL_ecc_aggrEnableIntr(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga9cbc21425978114aa14f59bb8dda707b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrEnableIntrs </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrEnableIntrs</b> </p>
<p><b>Description</b> <br />
 This function enables the interrupt for the specified interrupt source on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT or CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*
*      CSL_ecc_aggrEnableIntrs(pEccAggrRegs, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT);
*      CSL_ecc_aggrEnableIntrs(pEccAggrRegs, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT);
*   </pre> 
</div>
</div>
<a class="anchor" id="gaa7dba5f2838b2a7616d0ff764072e89d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrForceEccRamError </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___ecc___aggr_error_info.html">CSL_Ecc_AggrErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccForceError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrForceEccRamError</b> </p>
<p><b>Description</b> <br />
 This function is used to force an ECC error on the specified ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 pEccForceError A pointer to a CSL_Ecc_AggrIntrSrc structure containing force error information</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs      *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t              ramId 0;
*      CSL_Ecc_AggrIntrSrc   forceErrorInfo;
*
*      forceErrorInfo.Type         CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT;
*      forceErrorInfo.Row          0;        // Ignored since bNextRow is true
*      forceErrorInfo.Bit1         4;        // Force sec at bit 4
*      forceErrorInfo.Bit2         0;        // Ignored since this is a sec forced error
*      forceErrorInfo.bNextRow     true;
*      forceErrorInfo.bOneShotMode true;
*      CSL_ecc_aggrForceEccRamError(pEccAggrRegs, ramId, &amp;forceErrorInfo);
*   </pre> 
</div>
</div>
<a class="anchor" id="gabb449a48a71be3b28af5c58f818f7a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrGetEccRamGetErrorStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___ecc___aggr_error_info.html">CSL_Ecc_AggrErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccErrorStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrGetEccRamGetErrorStatus</b> </p>
<p><b>Description</b> <br />
 This function is used to get the error status of the specified ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 pEccErrorStatus A pointer to a CSL_Ecc_AggrIntrSrc structure containing returned error information</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs      *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t              ramId 0;
*      CSL_Ecc_AggrIntrSrc   ErrorStatus;
*
*      CSL_ecc_aggrGetEccRamGetErrorStatus(pEccAggrRegs, ramId, &amp;ErrorStatus);
*      printf( "Error type: %u\n", ErrorStatus.Type );
*   </pre> 
</div>
</div>
<a class="anchor" id="ga019fe2a586bea2d0c8035f6d252d102d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrGetNumRams </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pNumRams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrGetNumRams</b> </p>
<p><b>Description</b> <br />
 This function returns the number of RAMs serviced by this ECC Aggregator</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 pNumRams A pointer (of type uint32_t) to hold the value of number of RAMs serviced by this ECC Aggregator</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t         NumRams;
*      int32_t          retValue;
*
*      retValue CSL_ecc_aggrGetNumRams(pEccAggrRegs, &amp;NumRams);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga73d29ba1910a9352f504a4ad6bcadbb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrGetRevision </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrGetRevision</b> </p>
<p><b>Description</b> <br />
 This function returns the revision information for the ECC Aggregator</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 pRev A pointer (of type uint32_t) to hold the rev ID value of the ECC Aggregator module Revision information. See design specification for details.</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t rev;
*      int32_t  retValue;
*
*      retValue CSL_ecc_aggrGetRevision(pEccAggrRegs, &amp;rev);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga2401cb56e629b93f8ad80f60b75c7446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrIsAnyIntrPending </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrIsAnyIntrPending</b> </p>
<p><b>Description</b> <br />
 This function returns the pending interrupt status for any interrupt source from the ECC RAM specified by ramId.</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t             ramId 0;
*      bool                 bIntrPending;
*
*      cslRetVal CSL_ecc_aggrIsAnyIntrPending(pEccAggrRegs, ramId, &amp;bIntrPending);
*      printf("One or more interrupts are %s for RAM ID %u is %s\n", ramId, bIntrPending ? "pending" : "not pending" );
*   </pre> 
</div>
</div>
<a class="anchor" id="ga6394cd4c1d5f01ec828ad3fc83f9a1a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrIsEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrIsEccRamIntrPending</b> </p>
<p><b>Description</b> <br />
 This function returns the pending interrupt status of the specified interrupt source from the specified ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or CSL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><br />
 pIsPend A Pointer (of type bool) to hold the state as below true An interrupt of the specified type is pending false An interrupt of the specified type is not pending, or the ramId and/or intrSrc arguments are invalid</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*      bool                bIntrPending;
*      int32_t             cslRetVal;
*
*      cslRetVal CSL_ecc_aggrIsEccRamIntrPending(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT, &amp;bIntrPending);
*      printf("SEC interrupt for RAM ID %u is %s\n", ramId, bIntrPending ? "pending" : "not pending" );
*   </pre> 
</div>
</div>
<a class="anchor" id="gab882adcde277b4d06bcdc8bbca5a23a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrIsIntrPending </td>
          <td>(</td>
          <td class="paramtype">const CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrIsIntrPending</b> </p>
<p><b>Description</b> <br />
 This function returns the pending interrupt status for the specified ECC interrupt source from the ECC RAM specified by ramId.</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT or CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT; valid only for the CSL_ecc_aggrIsIntrPending function)</p>
<p><br />
 pIsPend A pointer (of type bool) to hold the status as below true An interrupt of the specified type is pending false An interrupt of the specified type is not pending, or the ramId and/or intrSrc arguments are invalid</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t             ramId 0;
*      bool                 bIntrPending;
*      int32_t              cslRetVal;
*
*      cslRetVal CSL_ecc_aggrIsIntrPending(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT, &amp;bIntrPending);
*      printf("SEC interrupt for RAM ID %u is %s\n", ramId, bIntrPending ? "pending" : "not pending" );
*   </pre> 
</div>
</div>
<a class="anchor" id="ga1453856a9cccb89e42d47823eabc5089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrReadEccRamCtrlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrReadEccRamCtrlReg</b> </p>
<p><b>Description</b> <br />
 This function reads the specified ECC wrapper control register from the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1)</p>
<p><br />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC control register</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<pre class="fragment">&lt;b&gt; Pre Condition &lt;/b&gt;
@n  None

&lt;b&gt; Post Condition &lt;/b&gt;
@n  None


@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*      uint32_t            EccCtrlRegVal;
*      int32_t             cslRetValue;
*
*      cslRetValue CSL_ecc_aggrReadEccRamCtrlReg(pEccAggrRegs, ramId, &amp;EccCtrlRegVal);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga86faae03c51b82c7b719edfd06db978d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrReadEccRamErrCtrlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrReadEccRamErrCtrlReg</b> </p>
<p><b>Description</b> <br />
 This function reads the specified ECC wrapper error control register from the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 instSelect Instance selector (0..1) of the specified register to read</p>
<p><br />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC Error control register</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*      uint32_t            regVal;
*      int32_t             cslRetValue;
*      cslRetValue CSL_ecc_aggrReadEccRamErrCtrlReg(pEccAggrRegs, ramId, 0, &amp;regVal);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga403976029d7892fd21346f103e8507aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrReadEccRamErrStatReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrReadEccRamErrStatReg</b> </p>
<p><b>Description</b> <br />
 This function reads the specified ECC wrapper error status register from the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 instSelect Instance selector (0..1) of the specified register to read</p>
<p><br />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC error status register</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*      uint32_t            regVal;
*      int32_t             cslRetValue;
*
*      cslRetValue CSL_ecc_aggrReadEccRamErrStatReg(pEccAggrRegs, ramId, 1, &amp;regVal);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga6a5e6764e6f5418e6a87f38240aa8e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrReadEccRamReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrReadEccRamReg</b> </p>
<p><b>Description</b> <br />
 This function reads the specified ECC wrapper register from the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 regOffset Byte offset of the ECC wrapper register to read (must be in the range of 0x10..0x24) <br />
 pRegVal A pointer (of uint32_t) to hold the value of the specified ECC wrapper register</p>
<pre class="fragment">&lt;b&gt; Return Value &lt;/b&gt;
@n  CSL_PASS      Success
@n  CSL_EBADARGS  Failure, indicate the arguments such as ramId and/or regOffset are invalid

&lt;b&gt; Pre Condition &lt;/b&gt;
@n  None

&lt;b&gt; Post Condition &lt;/b&gt;
@n  None


@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*      uint32_t            EccWrapperRegVal;
*      int32_t             retStatus;
*
*      retStatus CSL_ecc_aggrReadEccRamReg(pEccAggrRegs, ramId, CSL_ECC_RAM_WRAP_REV, &amp;EccWrapperRegVal);
*   </pre> 
</div>
</div>
<a class="anchor" id="gaae3bbb0e4f520bd6365b005901d1c73f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrReadEccRamWrapRevReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrReadEccRamWrapRevReg</b> </p>
<p><b>Description</b> <br />
 This function reads the ECC wrapper revision register from the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1)</p>
<p><br />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC wrapper revision register</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*      uint32_t            EccWrapperRegVal;
*      uint32_t            cslRetValue;
*
*      cslRetValue CSL_ecc_aggrReadEccRamWrapRevReg(pEccAggrRegs, ramId, &amp;EccWrapperRegVal);
*   </pre> 
</div>
</div>
<a class="anchor" id="gaa905e7a6030679a05c8ac55088e1601d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrReadStaticRegs </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l__ecc__aggr_static_regs.html">CSL_ecc_aggrStaticRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrStaticRegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrReadStaticRegs</b> </p>
<p><b>Description</b> <br />
 This function reads the static registers for ECC aggregator</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 pEccAggrStaticRegs A pointer (of type CSL_ecc_aggrStaticRegs*) to hold the static register values</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      CSL_ecc_aggrStaticRegs  eccAggrStaticRegs;
*
*      cslRet CSL_ecc_aggrReadStaticRegs(pEccAggrRegs, &amp;eccAggrStaticRegs);
*   </pre> 
</div>
</div>
<a class="anchor" id="gaaa85424e469f621ceb5904df64aea25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrSetEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_c_c___a_g_g_r___e_n_u_m.html#ga88b7b66a31243d85c47ad13e4fdfec7e">CSL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrSetEccRamIntrPending</b> </p>
<p><b>Description</b> <br />
 This function is used to forceably set the pending status of the specified interrupt source on the specified ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 intrSrc The interrupt source (CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or CSL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*
*      CSL_ecc_aggrSetEccRamIntrPending(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_SINGLE_BIT);
*      CSL_ecc_aggrSetEccRamIntrPending(pEccAggrRegs, ramId, CSL_ECC_AGGR_INTR_SRC_DOUBLE_BIT);
*      CSL_ecc_aggrSetEccRamIntrPending(pEccAggrRegs, ramId, CSL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS);
*   </pre> 
</div>
</div>
<a class="anchor" id="gaf25178d67ddc7ead8d027387942fedde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrVerifyConfigEccRam </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableRMW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrVerifyConfigEccRam</b> </p>
<p><b>Description</b> <br />
 This function is used to verify the configure the ECC capabilities of the specified ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 bEnable If true, then enable ECC generation. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br />
 bEccCheck If true, then enable ECC check. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br />
 bfEnableRMW If true, then enable read-modify-write on partial word writes</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success, indicates the configuration is successful <br />
 CSL_EFAIL Failure, indicates the expected configuration failed <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#gae5a170ff6ba6f492e4f2571d5e71f456">CSL_ecc_aggrConfigEccRam()</a> is called previously with the same arguments</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t      ramId 0;
*      int32_t       cslRetValue;
*
*      cslRetValue CSL_ecc_aggrVerifyConfigEccRam(pEccAggrRegs, ramId, true, true, false);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga8179eeab0379a33e3e5cad3c7c81faaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrWriteEccRamCtrlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrWriteEccRamCtrlReg</b> </p>
<p><b>Description</b> <br />
 This function write a value into the ECC wrapper control register in the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*
*      CSL_ecc_aggrWriteEccRamCtrlReg(pEccAggrRegs, ramId, 0);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga36fae43c003c625cdfcf085a06b1f64f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrWriteEccRamErrCtrlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrWriteEccRamErrCtrlReg</b> </p>
<p><b>Description</b> <br />
 This function writes a value into the specified ECC wrapper error control register in the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 instSelect Instance selector (0..1) of the specified register to write <br />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*      int32_t             cslRetValue;
*
*      cslRetValue CSL_ecc_aggrWriteEccRamErrCtrlReg(pEccAggrRegs, ramId, 0, 0);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga4f9467420d2ac096c83e39956a782f1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrWriteEccRamErrStatReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrWriteEccRamErrStatReg</b> </p>
<p><b>Description</b> <br />
 This function write a value into the specified ECC wrapper error status register in the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 instSelect Instance selector (0..1) of the specified register to write <br />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*      int32_t             cslRetValue;
*
*      cslRetValue CSL_ecc_aggrWriteEccRamErrStatReg(pEccAggrRegs, ramId, 1, 0);
*   </pre> 
</div>
</div>
<a class="anchor" id="ga46c8ba8cbac2e25c842b4cba1d5c9d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ecc_aggrWriteEccRamReg </td>
          <td>(</td>
          <td class="paramtype">CSL_ecc_aggrRegs *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_ecc_aggrWriteEccRamReg</b> </p>
<p><b>Description</b> <br />
 This function writes a value into the specified ECC wrapper register in the specific ECC RAM</p>
<p><b>Arguments</b> <br />
 pEccAggrRegs A pointer (of type CSL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br />
 ramId RAM identifier (0..<a class="el" href="group___c_s_l___e_c_c___a_g_g_r___f_u_n_c_t_i_o_n.html#ga019fe2a586bea2d0c8035f6d252d102d">CSL_ecc_aggrGetNumRams()</a>-1) <br />
 regOffset Byte offset of the ECC wrapper register to write (must be in the range of 0x10..0x24) <br />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br />
 CSL_PASS Success <br />
 CSL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_ecc_aggrRegs    *pEccAggrRegs (CSL_ecc_aggrRegs *)ECC_AGGR_BASE_ADDRESS;
*      uint32_t            ramId 0;
*
*      cslRetValue CSL_ecc_aggrWriteEccRamReg(pEccAggrRegs, ramId, CSL_ECC_RAM_CTRL, 0);
*   </pre> 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
