<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FSS Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FSS Functions<div class="ingroups"><a class="el" href="group___c_s_l___f_s_s___a_p_i.html">FSS</a><a class="el" href="group___c_s_l___f_s_s___a_p_i.html">FSS</a> &raquo;  &#124; <a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html">FSS Enumerated Data Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaede240fae71e47821df6aca438b5e015"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaede240fae71e47821df6aca438b5e015">CSL_fssGetRevision</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t *pRev)</td></tr>
<tr class="memdesc:gaede240fae71e47821df6aca438b5e015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return revision of the FSS IP module.  <a href="#gaede240fae71e47821df6aca438b5e015">More...</a><br /></td></tr>
<tr class="separator:gaede240fae71e47821df6aca438b5e015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf771f03c4e1257a2bd2c10f78eaef908"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaf771f03c4e1257a2bd2c10f78eaef908">CSL_fssSelectInterfacePath</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t pathSelect)</td></tr>
<tr class="memdesc:gaf771f03c4e1257a2bd2c10f78eaef908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the path (OSPI0 or HYPERBUS) for the interface to OSPI0 or HYPERBUS.  <a href="#gaf771f03c4e1257a2bd2c10f78eaef908">More...</a><br /></td></tr>
<tr class="separator:gaf771f03c4e1257a2bd2c10f78eaef908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc29903c2348cd316495714f5942601"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gafcc29903c2348cd316495714f5942601">CSL_fssCfgEcc</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, bool bEccEnable, bool bIncludeBlockAddrInEcc)</td></tr>
<tr class="memdesc:gafcc29903c2348cd316495714f5942601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure ECC support for an interface.  <a href="#gafcc29903c2348cd316495714f5942601">More...</a><br /></td></tr>
<tr class="separator:gafcc29903c2348cd316495714f5942601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741073102dc6292d5c7d3925448bba55"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga741073102dc6292d5c7d3925448bba55">CSL_fssCfgHyperBusFragmentation</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t fragAddr, bool bFragLo, bool bFragHi)</td></tr>
<tr class="memdesc:ga741073102dc6292d5c7d3925448bba55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure fragmentation for HyperBus.  <a href="#ga741073102dc6292d5c7d3925448bba55">More...</a><br /></td></tr>
<tr class="separator:ga741073102dc6292d5c7d3925448bba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b9558ba5f597f4e0aa2b04c73a595e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaf5b9558ba5f597f4e0aa2b04c73a595e">CSL_fssCfgEccRegion</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, uint32_t regionNum, uint32_t regionAddrStart, uint32_t regionSizeBytes)</td></tr>
<tr class="memdesc:gaf5b9558ba5f597f4e0aa2b04c73a595e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a memory region for ECC protection.  <a href="#gaf5b9558ba5f597f4e0aa2b04c73a595e">More...</a><br /></td></tr>
<tr class="separator:gaf5b9558ba5f597f4e0aa2b04c73a595e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35c3983fb77f3d0f495521c83253a22"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaf35c3983fb77f3d0f495521c83253a22">CSL_fssSetIntrEnable</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, uint32_t intrSelect, bool bEnable)</td></tr>
<tr class="memdesc:gaf35c3983fb77f3d0f495521c83253a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the specified interrupt.  <a href="#gaf35c3983fb77f3d0f495521c83253a22">More...</a><br /></td></tr>
<tr class="separator:gaf35c3983fb77f3d0f495521c83253a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7280a33a1eca9fda9c603a150e7eb0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga6c7280a33a1eca9fda9c603a150e7eb0">CSL_fssSetIntrPendingStatus</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, uint32_t intrSelect, bool bPend)</td></tr>
<tr class="memdesc:ga6c7280a33a1eca9fda9c603a150e7eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or clear the specified interrupt pending status.  <a href="#ga6c7280a33a1eca9fda9c603a150e7eb0">More...</a><br /></td></tr>
<tr class="separator:ga6c7280a33a1eca9fda9c603a150e7eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048c4b4d2123a37f2e4116503f226ea6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga048c4b4d2123a37f2e4116503f226ea6">CSL_fssIsIntrPending</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, uint32_t intrSelect)</td></tr>
<tr class="memdesc:ga048c4b4d2123a37f2e4116503f226ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified masked interrupt is pending.  <a href="#ga048c4b4d2123a37f2e4116503f226ea6">More...</a><br /></td></tr>
<tr class="separator:ga048c4b4d2123a37f2e4116503f226ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bec4e87670001ab9cc0257790bf9c70"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga7bec4e87670001ab9cc0257790bf9c70">CSL_fssIsRawIntrPending</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, uint32_t intrSelect)</td></tr>
<tr class="memdesc:ga7bec4e87670001ab9cc0257790bf9c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified raw interrupt is pending.  <a href="#ga7bec4e87670001ab9cc0257790bf9c70">More...</a><br /></td></tr>
<tr class="separator:ga7bec4e87670001ab9cc0257790bf9c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd65a7cdd78d3c89ca8cb00ac1cd266"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga4bd65a7cdd78d3c89ca8cb00ac1cd266">CSL_fssAckIntr</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, uint32_t outIntrSelect)</td></tr>
<tr class="memdesc:ga4bd65a7cdd78d3c89ca8cb00ac1cd266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge completion of an ouput interrupt.  <a href="#ga4bd65a7cdd78d3c89ca8cb00ac1cd266">More...</a><br /></td></tr>
<tr class="separator:ga4bd65a7cdd78d3c89ca8cb00ac1cd266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6851b49ace9a203e022022b2c8afaf7c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga6851b49ace9a203e022022b2c8afaf7c">CSL_fssGetEccBlockErrorInfo</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, <a class="el" href="struct_c_s_l___fss_ecc_block_error_info.html">CSL_FssEccBlockErrorInfo</a> *pEccErrorInfo)</td></tr>
<tr class="memdesc:ga6851b49ace9a203e022022b2c8afaf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about an ECC block error.  <a href="#ga6851b49ace9a203e022022b2c8afaf7c">More...</a><br /></td></tr>
<tr class="separator:ga6851b49ace9a203e022022b2c8afaf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccca99cf1b711815c5b9be5974c9dcad"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaccca99cf1b711815c5b9be5974c9dcad">CSL_fssGetWrErrorInfo</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, <a class="el" href="struct_c_s_l___fss_wr_error_info.html">CSL_FssWrErrorInfo</a> *pWrErrorInfo)</td></tr>
<tr class="memdesc:gaccca99cf1b711815c5b9be5974c9dcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a write error.  <a href="#gaccca99cf1b711815c5b9be5974c9dcad">More...</a><br /></td></tr>
<tr class="separator:gaccca99cf1b711815c5b9be5974c9dcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aee095dcbf71c02e5a4801d03cfcb7d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga3aee095dcbf71c02e5a4801d03cfcb7d">CSL_fssOspiSetXipPrefetchEnable</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, bool bEnable)</td></tr>
<tr class="memdesc:ga3aee095dcbf71c02e5a4801d03cfcb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable OSPI XIP prefetching.  <a href="#ga3aee095dcbf71c02e5a4801d03cfcb7d">More...</a><br /></td></tr>
<tr class="separator:ga3aee095dcbf71c02e5a4801d03cfcb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93d8c3133f035af25e34540ff3bccda"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaf93d8c3133f035af25e34540ff3bccda">CSL_fssOspiSetDdrModeEnable</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t ifSelect, bool bEnable)</td></tr>
<tr class="memdesc:gaf93d8c3133f035af25e34540ff3bccda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable OSPI DDR mode.  <a href="#gaf93d8c3133f035af25e34540ff3bccda">More...</a><br /></td></tr>
<tr class="separator:gaf93d8c3133f035af25e34540ff3bccda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4050f9bed925f81e4e68df07d49c93b5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga4050f9bed925f81e4e68df07d49c93b5">CSL_fssOtfaGetRevision</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t *pRev)</td></tr>
<tr class="memdesc:ga4050f9bed925f81e4e68df07d49c93b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return revision of the FSS OTFA module.  <a href="#ga4050f9bed925f81e4e68df07d49c93b5">More...</a><br /></td></tr>
<tr class="separator:ga4050f9bed925f81e4e68df07d49c93b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b89001626477e809b9b1d3ae96666c5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga8b89001626477e809b9b1d3ae96666c5">CSL_fssOtfaIsCryptoAvailable</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg)</td></tr>
<tr class="memdesc:ga8b89001626477e809b9b1d3ae96666c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the encryption/authentication function is enabled.  <a href="#ga8b89001626477e809b9b1d3ae96666c5">More...</a><br /></td></tr>
<tr class="separator:ga8b89001626477e809b9b1d3ae96666c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5420358e767ee7a44f129ac315b5a637"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga5420358e767ee7a44f129ac315b5a637">CSL_fssOtfaIsBusy</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg)</td></tr>
<tr class="memdesc:ga5420358e767ee7a44f129ac315b5a637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the OTFA is busy.  <a href="#ga5420358e767ee7a44f129ac315b5a637">More...</a><br /></td></tr>
<tr class="separator:ga5420358e767ee7a44f129ac315b5a637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f18239003cb268ea681799c889267b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga99f18239003cb268ea681799c889267b">CSL_fssOtfaIsCryptoBusy</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg)</td></tr>
<tr class="memdesc:ga99f18239003cb268ea681799c889267b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the OTFA crypto engine is busy.  <a href="#ga99f18239003cb268ea681799c889267b">More...</a><br /></td></tr>
<tr class="separator:ga99f18239003cb268ea681799c889267b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffeb1c6c7c67af1a9f176ce5170bbb92"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaffeb1c6c7c67af1a9f176ce5170bbb92">CSL_fssOtfaGetPipeStallEventCnts</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t *pRdStallEventCnt, uint32_t *pWrStallEventCnt)</td></tr>
<tr class="memdesc:gaffeb1c6c7c67af1a9f176ce5170bbb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read pipe stall event counters.  <a href="#gaffeb1c6c7c67af1a9f176ce5170bbb92">More...</a><br /></td></tr>
<tr class="separator:gaffeb1c6c7c67af1a9f176ce5170bbb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cae9ce04bd2be076d4ea1a3a93c2d69"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga2cae9ce04bd2be076d4ea1a3a93c2d69">CSL_fssOtfaCfgCrypto</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, const <a class="el" href="struct_c_s_l___fss_otfa_crypto_cfg.html">CSL_FssOtfaCryptoCfg</a> *pCryptoCfg)</td></tr>
<tr class="memdesc:ga2cae9ce04bd2be076d4ea1a3a93c2d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the OTFA crypto engine.  <a href="#ga2cae9ce04bd2be076d4ea1a3a93c2d69">More...</a><br /></td></tr>
<tr class="separator:ga2cae9ce04bd2be076d4ea1a3a93c2d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbcc45a979147b9354eafb280f26fcc1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gacbcc45a979147b9354eafb280f26fcc1">CSL_fssOtfaCfgCryptoRegion</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t regionNum, const <a class="el" href="struct_c_s_l___fss_otfa_crypto_region_cfg.html">CSL_FssOtfaCryptoRegionCfg</a> *pRegionCfg)</td></tr>
<tr class="memdesc:gacbcc45a979147b9354eafb280f26fcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a crypto memory region.  <a href="#gacbcc45a979147b9354eafb280f26fcc1">More...</a><br /></td></tr>
<tr class="separator:gacbcc45a979147b9354eafb280f26fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cecd93fccac9a1041efb68d25c17a6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga14cecd93fccac9a1041efb68d25c17a6">CSL_fssOtfaSetCryptoEnable</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, bool bEnable)</td></tr>
<tr class="memdesc:ga14cecd93fccac9a1041efb68d25c17a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the OTFA crypto functionality.  <a href="#ga14cecd93fccac9a1041efb68d25c17a6">More...</a><br /></td></tr>
<tr class="separator:ga14cecd93fccac9a1041efb68d25c17a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8591ec759fec1c4b823d10ee49c853d2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga8591ec759fec1c4b823d10ee49c853d2">CSL_fssOtfaSetCryptoPause</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, bool bPause)</td></tr>
<tr class="memdesc:ga8591ec759fec1c4b823d10ee49c853d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause or resume the OTFA crypto functionality.  <a href="#ga8591ec759fec1c4b823d10ee49c853d2">More...</a><br /></td></tr>
<tr class="separator:ga8591ec759fec1c4b823d10ee49c853d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a602956721605ecf0f41241184d9fec"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga0a602956721605ecf0f41241184d9fec">CSL_fssOtfaIsCryptoEnabled</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg)</td></tr>
<tr class="memdesc:ga0a602956721605ecf0f41241184d9fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the OTFA crypto functionality is enabled.  <a href="#ga0a602956721605ecf0f41241184d9fec">More...</a><br /></td></tr>
<tr class="separator:ga0a602956721605ecf0f41241184d9fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8f2481b02beda05fb8907113aca92b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gada8f2481b02beda05fb8907113aca92b">CSL_fssOtfaSetIntrEnable</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t regionSelect, uint32_t intrSelect, bool bEnable)</td></tr>
<tr class="memdesc:gada8f2481b02beda05fb8907113aca92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the specified OTFA interrupt.  <a href="#gada8f2481b02beda05fb8907113aca92b">More...</a><br /></td></tr>
<tr class="separator:gada8f2481b02beda05fb8907113aca92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d9b9024a956a5218932da7496e3c4b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaf3d9b9024a956a5218932da7496e3c4b">CSL_fssOtfaSetIntrPendingStatus</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t regionSelect, uint32_t intrSelect, bool bPend)</td></tr>
<tr class="memdesc:gaf3d9b9024a956a5218932da7496e3c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or clear the specified OTFA interrupt pending status.  <a href="#gaf3d9b9024a956a5218932da7496e3c4b">More...</a><br /></td></tr>
<tr class="separator:gaf3d9b9024a956a5218932da7496e3c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8cba62de0dfb98e69d9ccd511cae33"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga5a8cba62de0dfb98e69d9ccd511cae33">CSL_fssOtfaIsIntrPending</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t regionSelect, uint32_t intrSelect)</td></tr>
<tr class="memdesc:ga5a8cba62de0dfb98e69d9ccd511cae33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified OTFA masked interrupt is pending.  <a href="#ga5a8cba62de0dfb98e69d9ccd511cae33">More...</a><br /></td></tr>
<tr class="separator:ga5a8cba62de0dfb98e69d9ccd511cae33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecb103fe3a8d83325f2ed4a959010644"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gaecb103fe3a8d83325f2ed4a959010644">CSL_fssOtfaIsRawIntrPending</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, uint32_t regionSelect, uint32_t intrSelect)</td></tr>
<tr class="memdesc:gaecb103fe3a8d83325f2ed4a959010644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified OTFA raw interrupt is pending.  <a href="#gaecb103fe3a8d83325f2ed4a959010644">More...</a><br /></td></tr>
<tr class="separator:gaecb103fe3a8d83325f2ed4a959010644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe21de3d6ee3a4d90eba2ba709eb782d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#gabe21de3d6ee3a4d90eba2ba709eb782d">CSL_fssOtfaGetIrqInfo</a> (const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, <a class="el" href="struct_c_s_l___fss_otfa_irq_info.html">CSL_FssOtfaIrqInfo</a> *pIrqInfo)</td></tr>
<tr class="memdesc:gabe21de3d6ee3a4d90eba2ba709eb782d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get additional OTFA IRQ information.  <a href="#gabe21de3d6ee3a4d90eba2ba709eb782d">More...</a><br /></td></tr>
<tr class="separator:gabe21de3d6ee3a4d90eba2ba709eb782d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f38d37a719b01263edf5ec89441280"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga19f38d37a719b01263edf5ec89441280">CSL_fssOtfaGetStats</a> (<a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *pFssCfg, <a class="el" href="struct_c_s_l___fss_otfa_stats.html">CSL_FssOtfaStats</a> *pStats)</td></tr>
<tr class="memdesc:ga19f38d37a719b01263edf5ec89441280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OTFA statistics.  <a href="#ga19f38d37a719b01263edf5ec89441280">More...</a><br /></td></tr>
<tr class="separator:ga19f38d37a719b01263edf5ec89441280"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>===========================================================================</p>
<hr/>
 <h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4bd65a7cdd78d3c89ca8cb00ac1cd266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssAckIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>outIntrSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge completion of an ouput interrupt. </p>
<p>This function is used to acknowledge completion of the specified interface's output interrupt. Another output interrupt will be triggered if enabled and one or more of the output interrupt's sources remain active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">outIntrSelect</td><td>[IN] Output interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssOutputInterruptSelect">CSL_FssOutputInterruptSelect</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL CSL_EOUT_OF_RANGE The ifSelect and/or outIntrSelect arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="gafcc29903c2348cd316495714f5942601"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssCfgEcc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeBlockAddrInEcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure ECC support for an interface. </p>
<p>This function configures the ECC support for the interface specified by ifSelect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">bEccEnable</td><td>[IN] If true, ECC is enabled for this interface. Otherwise, ECC is disabled. </td></tr>
    <tr><td class="paramname">bIncludeBlockAddrInEcc</td><td>[IN] If true, the block address is included within the ECC calculation. Otherwise, the block address is excluded from the ECC calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL CSL_EOUT_OF_RANGE The ifSelect argument is out-of-range. See <a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5b9558ba5f597f4e0aa2b04c73a595e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssCfgEccRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionAddrStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionSizeBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a memory region for ECC protection. </p>
<p>This function configures the specified interface's memory region for ECC protection. Up to 4 ECC protected memory regions can be configured.</p>
<p>This function will automatically truncate the regionAddrStart parameter to the required 4Kbyte aligned boundary.</p>
<p>This function will automatically round up the regionSizeBytes value to the required multiple of 4Kbytes size. Specifying a regionSizeBytes of 0 will disable the region from ECC protection.</p>
<p>An CSL_EINVALID_PARAMS error is returned if the truncated regionAddrStart</p><ul>
<li>rounded-up regionSizeBytes is &gt; 4Gbytes, as wrap-around addressing is not supported.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">regionNum</td><td>[IN] Region number (0..(CSL_FSS_MAX_ECC_PROTECTED_MEMORY_REGIONS-1)) </td></tr>
    <tr><td class="paramname">regionAddrStart</td><td>[IN] The starting byte address of the ECC protected memory region </td></tr>
    <tr><td class="paramname">regionSizeBytes</td><td>[IN] The size in bytes of the ECC protected memory region</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL CSL_EINVALID_PARAMS regionAddrStart + regionSizeBytes is &gt; 4Gbytes CSL_EOUT_OF_RANGE The ifSelect and/or regionNum arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="ga741073102dc6292d5c7d3925448bba55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssCfgHyperBusFragmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fragAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFragLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFragHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure fragmentation for HyperBus. </p>
<p>This function configures the Dynamic Fragmenter module for HyperBus.</p>
<p>The Dynamic Fragmenter module is responsible for fragmenting write data to the HyperBus (it will pass all other transactions through unaffected).</p>
<p>HyperBus Flash has a requirement that all writes to the flash region are done in 16bit chunks. HyperBus SRAM does not have this write fragmentation requirement.</p>
<p>The Dynamic Fragmenter module is configured to fragment all addresses by default. You can use this function to disable fragmentation for HyperBus SRAM areas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">fragAddr</td><td>[IN] This is the address of a request that the bFragLo or bFragHi boundary determination occurs </td></tr>
    <tr><td class="paramname">bFragLo</td><td>[IN] If true, any address less than frag_addr will be fragmented to 16 bits </td></tr>
    <tr><td class="paramname">bFragHi</td><td>[IN] If true, any address greater than or equal to fragAddr will be fragmented to 16 bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga6851b49ace9a203e022022b2c8afaf7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssGetEccBlockErrorInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_ecc_block_error_info.html">CSL_FssEccBlockErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccErrorInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about an ECC block error. </p>
<p>This function returns information about an ECC block error (if such an error exists) on the specified interface.</p>
<p>If error information exists, this function will automatically pop this error information off the top of the error stack in preparation for the next error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">pEccErrorInfo</td><td>[OUT] Pointer to a <a class="el" href="struct_c_s_l___fss_ecc_block_error_info.html">CSL_FssEccBlockErrorInfo</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully and error information is returned in the <a class="el" href="struct_c_s_l___fss_ecc_block_error_info.html" title="This structure contains information about an ECC block error. ">CSL_FssEccBlockErrorInfo</a> structure CSL_EBADARGS pFssCfg and/or pEccErrorInfo are NULL CSL_EFAIL No error information was available. The <a class="el" href="struct_c_s_l___fss_ecc_block_error_info.html" title="This structure contains information about an ECC block error. ">CSL_FssEccBlockErrorInfo</a> structure is not updated. CSL_EOUT_OF_RANGE The ifSelect argument is out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="gaede240fae71e47821df6aca438b5e015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssGetRevision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return revision of the FSS IP module. </p>
<p>This function returns the contents of the FSS revision register. Consult the FSS module documentation for a description of the contents of the revision register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">pRev</td><td>[OUT] Pointer to uint32_t where revision is returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg and/or pRev are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaccca99cf1b711815c5b9be5974c9dcad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssGetWrErrorInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_wr_error_info.html">CSL_FssWrErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>pWrErrorInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about a write error. </p>
<p>This function returns information about a write error (if such an error exists) on the specified interface.</p>
<p>If error information exists, this function will automatically pop this error information off the top of the error stack in preparation for the next error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">pWrErrorInfo</td><td>[OUT] Pointer to a <a class="el" href="struct_c_s_l___fss_wr_error_info.html">CSL_FssWrErrorInfo</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully and error information is returned in the <a class="el" href="struct_c_s_l___fss_wr_error_info.html" title="This structure contains information about a write error. ">CSL_FssWrErrorInfo</a> structure CSL_EBADARGS pFssCfg and/or pWrErrorInfo are NULL CSL_EFAIL No error information was available. The <a class="el" href="struct_c_s_l___fss_wr_error_info.html" title="This structure contains information about a write error. ">CSL_FssWrErrorInfo</a> structure is not updated. CSL_EOUT_OF_RANGE The ifSelect argument is out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="ga048c4b4d2123a37f2e4116503f226ea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssIsIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified masked interrupt is pending. </p>
<p>This function returns the pending masked interrupt status of the specified interface's interrupt. Note that this indication takes into account both the raw interrupt status and the interrupt enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">intrSelect</td><td>[IN] Interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterruptSourceSelect">CSL_FssInterruptSourceSelect</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Masked interrupt is not pending 1 Masked interrupt is pending CSL_EBADARGS pFssCfg is NULL CSL_EOUT_OF_RANGE The ifSelect and/or intrSelect arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bec4e87670001ab9cc0257790bf9c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssIsRawIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified raw interrupt is pending. </p>
<p>This function returns the pending raw interrupt status of the specified interface's interrupt. Note that this indication takes into account only the raw interrupt status and not the interrupt enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">intrSelect</td><td>[IN] Interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterruptSourceSelect">CSL_FssInterruptSourceSelect</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Raw interrupt is not pending 1 Raw interrupt is pending CSL_EBADARGS pFssCfg is NULL CSL_EOUT_OF_RANGE The ifSelect and/or intrSelect arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="gaf93d8c3133f035af25e34540ff3bccda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOspiSetDdrModeEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable OSPI DDR mode. </p>
<p>This function enables or disables OSPI DDR mode.</p>
<p>When OSPI DDR mode is enabled, all OSPI read requests are turned into 2- byte aligned, even length, requests due to the OSPI limitation on DDR mode. In other words, the fss makes the OSPI address and length even and inclusive of the requested bytes.</p>
<p>When OSPI DDR mode is disabled, all OSPI read requests are passed through unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, OSPI DDR mode is enabled. If false, it is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL CSL_EFAIL This feature is not available in this version of the FSS CSL_EOUT_OF_RANGE The ifSelect argument is out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="ga3aee095dcbf71c02e5a4801d03cfcb7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOspiSetXipPrefetchEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable OSPI XIP prefetching. </p>
<p>This function enables or disables OSPI execute-in-place (XIP) prefetching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, XIP prefetching is enabled. If false, it is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL CSL_EFAIL This feature is not available in this version of the FSS CSL_EOUT_OF_RANGE The ifSelect argument is out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="ga2cae9ce04bd2be076d4ea1a3a93c2d69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaCfgCrypto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_otfa_crypto_cfg.html">CSL_FssOtfaCryptoCfg</a> *&#160;</td>
          <td class="paramname"><em>pCryptoCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the OTFA crypto engine. </p>
<p>This function is used to configure the OTFA crypto engine. It must be called before enabling the crypto engine via the <a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga14cecd93fccac9a1041efb68d25c17a6">CSL_fssOtfaSetCryptoEnable</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">pCryptoCfg</td><td>[IN] Pointer to a <a class="el" href="struct_c_s_l___fss_otfa_crypto_cfg.html">CSL_FssOtfaCryptoCfg</a> structure containing configuration parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg, pFssCfg-&gt;pOtfaRegs, and/or pCryptoCfg are NULL CSL_EFAIL The function was called while the crypto engine is enabled CSL_EINVALID_PARAMS One or more parameters in the <a class="el" href="struct_c_s_l___fss_otfa_crypto_cfg.html">CSL_FssOtfaCryptoCfg</a> structure are illegal </dd></dl>

</div>
</div>
<a class="anchor" id="gacbcc45a979147b9354eafb280f26fcc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaCfgCryptoRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_otfa_crypto_region_cfg.html">CSL_FssOtfaCryptoRegionCfg</a> *&#160;</td>
          <td class="paramname"><em>pRegionCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a crypto memory region. </p>
<p>This function configures the specified memory region for crypto protection. Up to 4 protected memory regions can be configured.</p>
<p>An CSL_EFAIL error is returned if this function is called while OTFA transactions are active. Call the <a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga5420358e767ee7a44f129ac315b5a637">CSL_fssOtfaIsBusy</a> until it returns false before calling this function.</p>
<p>This function will automatically truncate the pRegionCfg-&gt;regionAddrStart and pRegionCfg-&gt;macSignaturesBaseAddr parameters to the required 4Kbyte aligned boundary.</p>
<p>This function will automatically round up the pRegionCfg-&gt;regionSizeBytes value to the required multiple of 4Kbytes size. Specifying a regionSizeBytes of 0 will disable the region from crypto protection.</p>
<p>An CSL_EINVALID_PARAMS error is returned under the following conditions: a) if the truncated regionAddrStart + rounded-up regionSizeBytes is </p><blockquote class="doxtable">
<p>4Gbytes, as wrap-around addressing is not supported. </p>
</blockquote>
<p>b) If the truncated macSignaturesBaseAddr + ((rounded-up regionSizeBytes)/8) </p><blockquote class="doxtable">
<p>4Gbytes, as wrap-around addressing is not supported. </p>
</blockquote>
<p>c) If the specified pRegionCfg-&gt;macMode and pRegionCfg-&gt;encMode result in an invalid combination per the table below: </p><pre class="fragment">                 +------------------------------+
                 |           encMode            |
                 +----------+---------+---------+
                 | DISABLED | AES_CTR | AES_ECB |
</pre><p> +------&mdash;+-------&mdash;+-------&mdash;+------&mdash;+------&mdash;+ | | DISABLED | OK | OK | OK | | +-------&mdash;+-------&mdash;+------&mdash;+------&mdash;+ | macMode | GMAC | OK | OK | INVALID | | +-------&mdash;+-------&mdash;+------&mdash;+------&mdash;+ | | CBC-MAC | INVALID | OK | INVALID | +------&mdash;+-------&mdash;+-------&mdash;+------&mdash;+------&mdash;+</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">regionNum</td><td>[IN] Region number (0..(CSL_FSS_OTFA_MAX_PROTECTED_MEMORY_REGIONS-1)) </td></tr>
    <tr><td class="paramname">pRegionCfg</td><td>[IN] Pointer to a <a class="el" href="struct_c_s_l___fss_otfa_crypto_region_cfg.html">CSL_FssOtfaCryptoRegionCfg</a> structure containing configuration parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg, pFssCfg-&gt;pOtfaRegs, and/or pRegionCfg are NULL CSL_EFAIL The function was called before <a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga2cae9ce04bd2be076d4ea1a3a93c2d69">CSL_fssOtfaCfgCrypto</a> or while the crypto engine was busy CSL_EINVALID_PARAMS One or more parameters in the <a class="el" href="struct_c_s_l___fss_otfa_crypto_region_cfg.html">CSL_FssOtfaCryptoRegionCfg</a> structure are illegal CSL_EOUT_OF_RANGE The regionNum argument is out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="gabe21de3d6ee3a4d90eba2ba709eb782d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaGetIrqInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_otfa_irq_info.html">CSL_FssOtfaIrqInfo</a> *&#160;</td>
          <td class="paramname"><em>pIrqInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get additional OTFA IRQ information. </p>
<p>This function returns additional OTFA IRQ information following an IRQ event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">pIrqInfo</td><td>[OUT] Pointer to a <a class="el" href="struct_c_s_l___fss_otfa_irq_info.html">CSL_FssOtfaIrqInfo</a> structure where the IRQ information is returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg and/or pIrqInfo are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaffeb1c6c7c67af1a9f176ce5170bbb92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaGetPipeStallEventCnts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRdStallEventCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pWrStallEventCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read pipe stall event counters. </p>
<p>This function returns and clears the current pipe stall event counters. These counters can be used to fine tune the AES core allocation to the read and write pipes per the <a class="el" href="group___c_s_l___f_s_s___f_u_n_c_t_i_o_n.html#ga2cae9ce04bd2be076d4ea1a3a93c2d69">CSL_fssOtfaCfgCrypto</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">pRdStallEventCnt</td><td>[OUT] Pointer to uint32_t where the read pipe stall event counter is returned </td></tr>
    <tr><td class="paramname">pWrStallEventCnt</td><td>[OUT] Pointer to uint32_t where the write pipe stall event counter is returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg, pFssCfg-&gt;pOtfaRegs, pRdStallEventCnt and/or wrStallEventCnt are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga4050f9bed925f81e4e68df07d49c93b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaGetRevision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return revision of the FSS OTFA module. </p>
<p>This function returns the contents of the FSS OTFA revision register. Consult the OTFA module documentation for a description of the contents of the revision register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">pRev</td><td>[OUT] Pointer to uint32_t where revision is returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg and/or pRev are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga19f38d37a719b01263edf5ec89441280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaGetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_otfa_stats.html">CSL_FssOtfaStats</a> *&#160;</td>
          <td class="paramname"><em>pStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get OTFA statistics. </p>
<p>This function returns OTFA statistic counts. The hardware statistic counters are automatically cleared by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">pStats</td><td>[OUT] Pointer to a <a class="el" href="struct_c_s_l___fss_otfa_stats.html">CSL_FssOtfaStats</a> structure where the statistic counters are returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg and/or pStats are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga5420358e767ee7a44f129ac315b5a637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaIsBusy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the OTFA is busy. </p>
<p>This function returns a status indicating if the OTFA is busy (one or more crypto or non-crypto transactions are active) or not busy (no crypto or non-crypto transactions are active).</p>
<p>Software needs to read 2 consecutive falses with at least 100ns delay between samples to insure the pipe is fully empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 the OTFA is not busy 1 the OTFA is busy CSL_EBADARGS pFssCfg is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b89001626477e809b9b1d3ae96666c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaIsCryptoAvailable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the encryption/authentication function is enabled. </p>
<p>This function returns a boolean true or false indicating if the encryption/authentication function is hardware enabled (via EFUSE) for the interface to OSPI0 or HYPERBUS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 the encryption/authentication function is hardware disabled 1 the encryption/authentication function is hardware enabled CSL_EBADARGS pFssCfg is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga99f18239003cb268ea681799c889267b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaIsCryptoBusy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the OTFA crypto engine is busy. </p>
<p>This function returns a status indicating if the OTFA crypto engine is busy (one or more crypto transactions are active) or not busy (no crypto transactions are active).</p>
<p>Software needs to read 2 consecutive falses with at least 100ns delay between samples to insure the pipe is fully empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 the OTFA crypto engine is not busy 1 the OTFA crypto engine is busy CSL_EBADARGS pFssCfg is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a602956721605ecf0f41241184d9fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaIsCryptoEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the OTFA crypto functionality is enabled. </p>
<p>This function returns a status indicating if the OTFA crypto functionality is enabled or disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 the OTFA crypto functionality is disabled (bypass mode is active) 1 the OTFA crypto functionality is enabled CSL_EBADARGS pFssCfg is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a8cba62de0dfb98e69d9ccd511cae33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaIsIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified OTFA masked interrupt is pending. </p>
<p>This function returns the pending masked interrupt status of the specified OTFA region's interrupt. Note that this indication takes into account both the raw interrupt status and the interrupt enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">regionSelect</td><td>[IN] Region selector (0..(CSL_FSS_OTFA_MAX_PROTECTED_MEMORY_REGIONS-1)) </td></tr>
    <tr><td class="paramname">intrSelect</td><td>[IN] Interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#gabd3cc60c8583002d8ec2672b7c1d1307">CSL_FssOtfaInterruptSourceSelect</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Masked interrupt is not pending 1 Masked interrupt is pending CSL_EBADARGS pFssCfg and/or pFssCfg-&gt;pOtfaRegs are NULL CSL_EOUT_OF_RANGE The regionSelect and/or intrSelect arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="gaecb103fe3a8d83325f2ed4a959010644"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaIsRawIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the specified OTFA raw interrupt is pending. </p>
<p>This function returns the pending raw interrupt status of the specified OTFA region's interrupt. Note that this indication takes into account only the raw interrupt status and not the interrupt enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">regionSelect</td><td>[IN] Region selector (0..(CSL_FSS_OTFA_MAX_PROTECTED_MEMORY_REGIONS-1)) </td></tr>
    <tr><td class="paramname">intrSelect</td><td>[IN] Interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#gabd3cc60c8583002d8ec2672b7c1d1307">CSL_FssOtfaInterruptSourceSelect</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Raw interrupt is not pending 1 Raw interrupt is pending CSL_EBADARGS pFssCfg and/or pFssCfg-&gt;pOtfaRegs are NULL CSL_EOUT_OF_RANGE The regionSelect and/or intrSelect arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="ga14cecd93fccac9a1041efb68d25c17a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaSetCryptoEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the OTFA crypto functionality. </p>
<p>This function enables or disables the OTFA crypto functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, the OTFA crypto functionslity is enabled, otherwise it is disabled (bypassed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga8591ec759fec1c4b823d10ee49c853d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaSetCryptoPause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause or resume the OTFA crypto functionality. </p>
<p>This function pauses or resumes the OTFA crypto functionality. The crypto functionality must be paused before software can safely change the OTFA configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">bPause</td><td>[IN] If true, the OTFA crypto functionality is paused, otherwise it is resumed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gada8f2481b02beda05fb8907113aca92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaSetIntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the specified OTFA interrupt. </p>
<p>This function enables or disables generation of the specified OTFA region's interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">regionSelect</td><td>[IN] Region selector (0..(CSL_FSS_OTFA_MAX_PROTECTED_MEMORY_REGIONS-1)) </td></tr>
    <tr><td class="paramname">intrSelect</td><td>[IN] Interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#gabd3cc60c8583002d8ec2672b7c1d1307">CSL_FssOtfaInterruptSourceSelect</a>) </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, the interrupt generation is enabled, otherwise it is disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg and/or pFssCfg-&gt;pOtfaRegs are NULL CSL_EOUT_OF_RANGE The regionSelect and/or intrSelect arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3d9b9024a956a5218932da7496e3c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssOtfaSetIntrPendingStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or clear the specified OTFA interrupt pending status. </p>
<p>This function is used to set or clear the pending status of the specified OTFA region's interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">regionSelect</td><td>[IN] Region selector (0..(CSL_FSS_OTFA_MAX_PROTECTED_MEMORY_REGIONS-1)) </td></tr>
    <tr><td class="paramname">intrSelect</td><td>[IN] Interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#gabd3cc60c8583002d8ec2672b7c1d1307">CSL_FssOtfaInterruptSourceSelect</a>) </td></tr>
    <tr><td class="paramname">bPend</td><td>[IN] If true, the interrupt pending status is set, otherwise it is cleared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg and/or pFssCfg-&gt;pOtfaRegs are NULL CSL_EOUT_OF_RANGE The regionSelect and/or intrSelect arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="gaf771f03c4e1257a2bd2c10f78eaef908"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssSelectInterfacePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pathSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the path (OSPI0 or HYPERBUS) for the interface to OSPI0 or HYPERBUS. </p>
<p>This function selects to path (OSPI0 or HYPERBUS) for the interface conntected to OSPI0 or HYPERBUS.</p>
<p>The path will not be switched until traffic through the interface is idle. It is the responsibility of software to insure interface traffic is stopped before calling this function to select a different path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">pathSelect</td><td>[IN] Path selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssFsasInterfacePathSelect">CSL_FssFsasInterfacePathSelect</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL CSL_EOUT_OF_RANGE The pathSelect argument is out-of-range. See <a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssFsasInterfacePathSelect">CSL_FssFsasInterfacePathSelect</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf35c3983fb77f3d0f495521c83253a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssSetIntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the specified interrupt. </p>
<p>This function enables or disables generation of the specified interface's interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">intrSelect</td><td>[IN] Interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterruptSourceSelect">CSL_FssInterruptSourceSelect</a>) </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, the interrupt generation is enabled, otherwise it is disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL CSL_EOUT_OF_RANGE The ifSelect and/or intrSelect arguments are out-of-range </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c7280a33a1eca9fda9c603a150e7eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_fssSetIntrPendingStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> *&#160;</td>
          <td class="paramname"><em>pFssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or clear the specified interrupt pending status. </p>
<p>This function is used to set or clear the pending status of the specified interface's interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFssCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___fss_cfg.html">CSL_FssCfg</a> configuration structure </td></tr>
    <tr><td class="paramname">ifSelect</td><td>[IN] Interface selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterfaceSelect">CSL_FssInterfaceSelect</a>) </td></tr>
    <tr><td class="paramname">intrSelect</td><td>[IN] Interrupt selector (<a class="el" href="group___c_s_l___f_s_s___e_n_u_m.html#CSL_FssInterruptSourceSelect">CSL_FssInterruptSourceSelect</a>) </td></tr>
    <tr><td class="paramname">bPend</td><td>[IN] If true, the interrupt pending status is set, otherwise it is cleared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_PASS The function completed successfully CSL_EBADARGS pFssCfg is NULL CSL_EOUT_OF_RANGE The ifSelect and/or intrSelect arguments are out-of-range </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
