<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PSILCFG Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PSILCFG Functions<div class="ingroups"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___a_p_i.html">Packet Streaming Interface Link (PSI-L) configuration CSL-FL API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7d646a6f80ce28cff578b2708ea11281"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga7d646a6f80ce28cff578b2708ea11281">CSL_psilcfgGetRevision</a> (const CSL_psilcfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga7d646a6f80ce28cff578b2708ea11281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return revision of the PSILCFG module.  <a href="#ga7d646a6f80ce28cff578b2708ea11281">More...</a><br /></td></tr>
<tr class="separator:ga7d646a6f80ce28cff578b2708ea11281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267fca7159f11f18c31f2d0e374abbe8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga267fca7159f11f18c31f2d0e374abbe8">CSL_psilcfgWrite</a> (const CSL_psilcfgRegs *pRegs, uint32_t threadId, uint32_t regId, uint32_t <a class="el" href="csl__udmap__tr_8h.html#ae4abda5e3cab325153762e904fd3f1e8">data</a>)</td></tr>
<tr class="memdesc:ga267fca7159f11f18c31f2d0e374abbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a PSI-L periperal using the PSI-L configuration proxy.  <a href="#ga267fca7159f11f18c31f2d0e374abbe8">More...</a><br /></td></tr>
<tr class="separator:ga267fca7159f11f18c31f2d0e374abbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2e40f14db1e8f7e2fc7ec05d5a7767"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gadd2e40f14db1e8f7e2fc7ec05d5a7767">CSL_psilcfgRead</a> (const CSL_psilcfgRegs *pRegs, uint32_t threadId, uint32_t regId, uint32_t *pData)</td></tr>
<tr class="memdesc:gadd2e40f14db1e8f7e2fc7ec05d5a7767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a PSI-L periperal using the PSI-L configuration proxy.  <a href="#gadd2e40f14db1e8f7e2fc7ec05d5a7767">More...</a><br /></td></tr>
<tr class="separator:gadd2e40f14db1e8f7e2fc7ec05d5a7767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef5e9871692471233a939d9b03751be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gadef5e9871692471233a939d9b03751be">CSL_psilcfgSetThreadEnable</a> (const CSL_psilcfgRegs *pRegs, uint32_t threadId, bool bEnable)</td></tr>
<tr class="memdesc:gadef5e9871692471233a939d9b03751be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a thread.  <a href="#gadef5e9871692471233a939d9b03751be">More...</a><br /></td></tr>
<tr class="separator:gadef5e9871692471233a939d9b03751be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd4ede29979e7d55c77d7e0c7a57ede"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gaccd4ede29979e7d55c77d7e0c7a57ede">CSL_psilcfgSetThreadRealtimeEnable</a> (const CSL_psilcfgRegs *pRegs, uint32_t threadId, bool bEnable)</td></tr>
<tr class="memdesc:gaccd4ede29979e7d55c77d7e0c7a57ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a thread via the realtime register.  <a href="#gaccd4ede29979e7d55c77d7e0c7a57ede">More...</a><br /></td></tr>
<tr class="separator:gaccd4ede29979e7d55c77d7e0c7a57ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6f2dbd3add0674b5e0f0e29b446d77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga0e6f2dbd3add0674b5e0f0e29b446d77">CSL_psilcfgTeardownThread</a> (const CSL_psilcfgRegs *pRegs, uint32_t threadId)</td></tr>
<tr class="memdesc:ga0e6f2dbd3add0674b5e0f0e29b446d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Teardown a thread.  <a href="#ga0e6f2dbd3add0674b5e0f0e29b446d77">More...</a><br /></td></tr>
<tr class="separator:ga0e6f2dbd3add0674b5e0f0e29b446d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c485c27a5bfff280ee2b09a9c721ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gad0c485c27a5bfff280ee2b09a9c721ef">CSL_psilcfgClrTeardown</a> (const CSL_psilcfgRegs *pRegs, uint32_t threadId)</td></tr>
<tr class="memdesc:gad0c485c27a5bfff280ee2b09a9c721ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a thread's teardown and flush bits.  <a href="#gad0c485c27a5bfff280ee2b09a9c721ef">More...</a><br /></td></tr>
<tr class="separator:gad0c485c27a5bfff280ee2b09a9c721ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd31272a47f13544256c991e16f2329"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gaccd31272a47f13544256c991e16f2329">CSL_psilcfgFlushThread</a> (const CSL_psilcfgRegs *pRegs, uint32_t threadId)</td></tr>
<tr class="memdesc:gaccd31272a47f13544256c991e16f2329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush data from a destination thread.  <a href="#gaccd31272a47f13544256c991e16f2329">More...</a><br /></td></tr>
<tr class="separator:gaccd31272a47f13544256c991e16f2329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0591ce71f4c47185712c897ab461e253"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga0591ce71f4c47185712c897ab461e253">CSL_psilcfgSetThreadPause</a> (const CSL_psilcfgRegs *pRegs, uint32_t threadId, bool bPause)</td></tr>
<tr class="memdesc:ga0591ce71f4c47185712c897ab461e253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause or un-pause a thread.  <a href="#ga0591ce71f4c47185712c897ab461e253">More...</a><br /></td></tr>
<tr class="separator:ga0591ce71f4c47185712c897ab461e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbff24abfd7ac29982b7cd7848f9adaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gacbff24abfd7ac29982b7cd7848f9adaa">CSL_psilcfgCreateRoute</a> (const CSL_psilcfgRegs *pRegs, uint32_t srcThreadId, uint32_t dstThreadId)</td></tr>
<tr class="memdesc:gacbff24abfd7ac29982b7cd7848f9adaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a route through the PSI-L switch.  <a href="#gacbff24abfd7ac29982b7cd7848f9adaa">More...</a><br /></td></tr>
<tr class="separator:gacbff24abfd7ac29982b7cd7848f9adaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a85d7d8f63a5994966092154dd0338"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga12a85d7d8f63a5994966092154dd0338">CSL_psilcfgCreateLink</a> (const CSL_psilcfgRegs *pRegs, uint32_t srcThreadId, uint32_t dstThreadId)</td></tr>
<tr class="memdesc:ga12a85d7d8f63a5994966092154dd0338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a link through the PSI-L switch.  <a href="#ga12a85d7d8f63a5994966092154dd0338">More...</a><br /></td></tr>
<tr class="separator:ga12a85d7d8f63a5994966092154dd0338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7922afe6f52521671550fd13616b23"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga3e7922afe6f52521671550fd13616b23">CSL_pvuGetRevision</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg)</td></tr>
<tr class="memdesc:ga3e7922afe6f52521671550fd13616b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return revision of the PVU module.  <a href="#ga3e7922afe6f52521671550fd13616b23">More...</a><br /></td></tr>
<tr class="separator:ga3e7922afe6f52521671550fd13616b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc7a66301a79b9d228e3d808201e8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga7dc7a66301a79b9d228e3d808201e8a7">CSL_pvuGetCfg</a> (<a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t *pNumTlbs, uint32_t *pNumEntriesPerTlb)</td></tr>
<tr class="memdesc:ga7dc7a66301a79b9d228e3d808201e8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PVU configuration.  <a href="#ga7dc7a66301a79b9d228e3d808201e8a7">More...</a><br /></td></tr>
<tr class="separator:ga7dc7a66301a79b9d228e3d808201e8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe08ef563f5cbf3a1b469e0383937c7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gaefe08ef563f5cbf3a1b469e0383937c7">CSL_pvuSetMaxVirtId</a> (<a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t numVirtIds)</td></tr>
<tr class="memdesc:gaefe08ef563f5cbf3a1b469e0383937c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of virtid values.  <a href="#gaefe08ef563f5cbf3a1b469e0383937c7">More...</a><br /></td></tr>
<tr class="separator:gaefe08ef563f5cbf3a1b469e0383937c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2ba19a1a325d2a22bbdb103f77ed37"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gacd2ba19a1a325d2a22bbdb103f77ed37">CSL_pvuCfgDmaClassSupport</a> (<a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t numDmaVirtIds, uint32_t mapSubClass0, uint32_t mapSubClass1, uint32_t mapSubClass2, uint32_t mapSubClass3)</td></tr>
<tr class="memdesc:gacd2ba19a1a325d2a22bbdb103f77ed37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DMA class support.  <a href="#gacd2ba19a1a325d2a22bbdb103f77ed37">More...</a><br /></td></tr>
<tr class="separator:gacd2ba19a1a325d2a22bbdb103f77ed37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga281ac383a2c3055b30aafe0019cebe57"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga281ac383a2c3055b30aafe0019cebe57">CSL_pvuGetTlbNum</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t virtId, uint32_t dmaSubClass)</td></tr>
<tr class="memdesc:ga281ac383a2c3055b30aafe0019cebe57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the TLB number associated with the specified virtId.  <a href="#ga281ac383a2c3055b30aafe0019cebe57">More...</a><br /></td></tr>
<tr class="separator:ga281ac383a2c3055b30aafe0019cebe57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6262d88c079c58877e00f0000cc929"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga3f6262d88c079c58877e00f0000cc929">CSL_pvuCfgTlb</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t tlbNum, uint32_t entryNum, const <a class="el" href="struct_c_s_l___pvu_tlb_cfg.html">CSL_PvuTlbCfg</a> *pTlbCfg)</td></tr>
<tr class="memdesc:ga3f6262d88c079c58877e00f0000cc929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a TLB entry.  <a href="#ga3f6262d88c079c58877e00f0000cc929">More...</a><br /></td></tr>
<tr class="separator:ga3f6262d88c079c58877e00f0000cc929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b389f82b371823bcbacca85c2a2987d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga9b389f82b371823bcbacca85c2a2987d">CSL_pvuSetTlbEnable</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t tlbNum, bool bEnable)</td></tr>
<tr class="memdesc:ga9b389f82b371823bcbacca85c2a2987d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a TLB.  <a href="#ga9b389f82b371823bcbacca85c2a2987d">More...</a><br /></td></tr>
<tr class="separator:ga9b389f82b371823bcbacca85c2a2987d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e18afed036b3efe5bced1e091c0a2d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga91e18afed036b3efe5bced1e091c0a2d">CSL_pvuChainToTlb</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t tlbNum, uint32_t chainToTlbNum)</td></tr>
<tr class="memdesc:ga91e18afed036b3efe5bced1e091c0a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain to another TLB.  <a href="#ga91e18afed036b3efe5bced1e091c0a2d">More...</a><br /></td></tr>
<tr class="separator:ga91e18afed036b3efe5bced1e091c0a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5feff739478be31210bc775b53e6fee1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga5feff739478be31210bc775b53e6fee1">CSL_pvuSetTlbFaultLogging</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t tlbNum, bool bEnable)</td></tr>
<tr class="memdesc:ga5feff739478be31210bc775b53e6fee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable fault logging for a TLB.  <a href="#ga5feff739478be31210bc775b53e6fee1">More...</a><br /></td></tr>
<tr class="separator:ga5feff739478be31210bc775b53e6fee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa944e262572ce210eac6d784e01717fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gaa944e262572ce210eac6d784e01717fd">CSL_pvuSetExceptionTypeLoggingEnable</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t exceptionTypes, bool bEnable)</td></tr>
<tr class="memdesc:gaa944e262572ce210eac6d784e01717fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable logging of the specified exception types.  <a href="#gaa944e262572ce210eac6d784e01717fd">More...</a><br /></td></tr>
<tr class="separator:gaa944e262572ce210eac6d784e01717fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab70a6ab53474e72e4e793efca140865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gaab70a6ab53474e72e4e793efca140865">CSL_pvuSetErrMsgDestId</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t destId)</td></tr>
<tr class="memdesc:gaab70a6ab53474e72e4e793efca140865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the destination ID value for error messages.  <a href="#gaab70a6ab53474e72e4e793efca140865">More...</a><br /></td></tr>
<tr class="separator:gaab70a6ab53474e72e4e793efca140865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00987d45ef7b195e1fe1293a59fdde10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga00987d45ef7b195e1fe1293a59fdde10">CSL_pvuSetExceptionLoggingEnable</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, bool bEnable)</td></tr>
<tr class="memdesc:ga00987d45ef7b195e1fe1293a59fdde10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable exception error logging.  <a href="#ga00987d45ef7b195e1fe1293a59fdde10">More...</a><br /></td></tr>
<tr class="separator:ga00987d45ef7b195e1fe1293a59fdde10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fcf9ed3d42c84893cb4bd2d76e677d5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga8fcf9ed3d42c84893cb4bd2d76e677d5">CSL_pvuSetEnable</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, bool bEnable)</td></tr>
<tr class="memdesc:ga8fcf9ed3d42c84893cb4bd2d76e677d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the PVU.  <a href="#ga8fcf9ed3d42c84893cb4bd2d76e677d5">More...</a><br /></td></tr>
<tr class="separator:ga8fcf9ed3d42c84893cb4bd2d76e677d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652a692894289fab2df7abd9566562ec"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga652a692894289fab2df7abd9566562ec">CSL_pvuIsTlbFaultSet</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t tlbNum)</td></tr>
<tr class="memdesc:ga652a692894289fab2df7abd9566562ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has a TLB fault been detected that could not be logged?  <a href="#ga652a692894289fab2df7abd9566562ec">More...</a><br /></td></tr>
<tr class="separator:ga652a692894289fab2df7abd9566562ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bc5be2811f1140af96b84a65a61938"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gad2bc5be2811f1140af96b84a65a61938">CSL_pvuClrTlbFault</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, uint32_t tlbNum)</td></tr>
<tr class="memdesc:gad2bc5be2811f1140af96b84a65a61938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear TLB fault.  <a href="#gad2bc5be2811f1140af96b84a65a61938">More...</a><br /></td></tr>
<tr class="separator:gad2bc5be2811f1140af96b84a65a61938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41bab04933f52d650c533497265ae234"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga41bab04933f52d650c533497265ae234">CSL_pvuIsExceptionIntrPending</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg)</td></tr>
<tr class="memdesc:ga41bab04933f52d650c533497265ae234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the exception interrupt pending?  <a href="#ga41bab04933f52d650c533497265ae234">More...</a><br /></td></tr>
<tr class="separator:ga41bab04933f52d650c533497265ae234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20036fd325b6bed336d5a3a522636e1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga20036fd325b6bed336d5a3a522636e1d">CSL_pvuSetExceptionIntrPendingSet</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, bool bSet)</td></tr>
<tr class="memdesc:ga20036fd325b6bed336d5a3a522636e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or clear a pending exception interrupt.  <a href="#ga20036fd325b6bed336d5a3a522636e1d">More...</a><br /></td></tr>
<tr class="separator:ga20036fd325b6bed336d5a3a522636e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e951a9aaad355f8e80d8b7545f5278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga17e951a9aaad355f8e80d8b7545f5278">CSL_pvuAckExceptionIntr</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg)</td></tr>
<tr class="memdesc:ga17e951a9aaad355f8e80d8b7545f5278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge exception interrupt.  <a href="#ga17e951a9aaad355f8e80d8b7545f5278">More...</a><br /></td></tr>
<tr class="separator:ga17e951a9aaad355f8e80d8b7545f5278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bd7923b792ecd5ba870747bdc05fbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gad2bd7923b792ecd5ba870747bdc05fbf">CSL_pvuSetExceptionIntrEnable</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, bool bEnable)</td></tr>
<tr class="memdesc:gad2bd7923b792ecd5ba870747bdc05fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the assertion of the exception interrupt signal.  <a href="#gad2bd7923b792ecd5ba870747bdc05fbf">More...</a><br /></td></tr>
<tr class="separator:gad2bd7923b792ecd5ba870747bdc05fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c3315cb1d60c9e2080963aeaa85fe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga33c3315cb1d60c9e2080963aeaa85fe3">CSL_pvuGetExceptionInfo</a> (const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *pPvuCfg, <a class="el" href="struct_c_s_l___pvu_exception_info.html">CSL_PvuExceptionInfo</a> *pExceptionInfo)</td></tr>
<tr class="memdesc:ga33c3315cb1d60c9e2080963aeaa85fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get exception information.  <a href="#ga33c3315cb1d60c9e2080963aeaa85fe3">More...</a><br /></td></tr>
<tr class="separator:ga33c3315cb1d60c9e2080963aeaa85fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad0c485c27a5bfff280ee2b09a9c721ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgClrTeardown </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a thread's teardown and flush bits. </p>
<p>This function clears the teardown and flush bits in the specified thread's PSIL realtime enable register.</p>
<p>Software can call this function following a thread teardown via the <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga0e6f2dbd3add0674b5e0f0e29b446d77" title="Teardown a thread. ">CSL_psilcfgTeardownThread</a> function to clear the thread's teardown and flush bits prior to re-enabling this thread again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">threadId</td><td>[IN] Thread identifying the PSI-L peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = the command was successfully executed false = the command was not submitted because a prior command was still busy </dd></dl>

</div>
</div>
<a class="anchor" id="ga12a85d7d8f63a5994966092154dd0338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgCreateLink </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstThreadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a link through the PSI-L switch. </p>
<p>This function creates a link through the PSI-L switch between the specified source and destination thread ID's. It reads the thread width and credit count from the destination thread and sets the source thread to use these values. It then enables the credit passing functionality for both threads.</p>
<p>Unlike the <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#gacbff24abfd7ac29982b7cd7848f9adaa" title="Create a route through the PSI-L switch. ">CSL_psilcfgCreateRoute()</a> function, this function does not enable either thread via their real-time enable configuration register. Software must use the udmap CSL-FL <a class="el" href="group___c_s_l___u_d_m_a_p___f_u_n_c_t_i_o_n.html#ga6e75a5810f1ac7345dfbcf298b4b223a" title="Enable a directional data flow for a paired link. ">CSL_udmapEnableLink()</a> function to accomplish this.</p>
<p>srcThreadId must not have bit 15 set to 1. If it does, this function does nothing and false is returned.</p>
<p>This function forces bit 15 of dstThreadId to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">srcThreadId</td><td>[IN] Thread identifying the source PSI-L peripheral </td></tr>
    <tr><td class="paramname">dstThreadId</td><td>[IN] Thread identifying the destination PSI-L peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if 1) bit 15 is set in srcThreadId, or 2) a transaction timeout occurs </dd></dl>

</div>
</div>
<a class="anchor" id="gacbff24abfd7ac29982b7cd7848f9adaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgCreateRoute </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstThreadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a route through the PSI-L switch. </p>
<p>This function creates a route through the PSI-L switch between the specified source and destination thread ID's. It reads the thread width and credit count from the destination thread and sets the source thread to use these values. It then enables the credit passing functionality for both threads.</p>
<p>In addition, this function also enables both threads via their psil real-time enable configuration register.</p>
<p>srcThreadId must not have bit 15 set to 1. If it does, this function does nothing and false is returned.</p>
<p>This function forces bit 15 of dstThreadId to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">srcThreadId</td><td>[IN] Thread identifying the source PSI-L peripheral </td></tr>
    <tr><td class="paramname">dstThreadId</td><td>[IN] Thread identifying the destination PSI-L peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if 1) bit 15 is set in srcThreadId, or 2) a transaction timeout occurs </dd></dl>

</div>
</div>
<a class="anchor" id="gaccd31272a47f13544256c991e16f2329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgFlushThread </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush data from a destination thread. </p>
<p>This function flushes data in the specified destination thread.</p>
<p>This function only operates with destination threads. The flush command causes all destination thread data to be discarded instead of being written to the peripheral.</p>
<p>The flush command should be called only when a thread fails to complete its teardown procedure normally, because a peripheral is no longer functioning or because some other factor is causing a deadlock beyond the PSI-L interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">threadId</td><td>[IN] Thread identifying the PSI-L peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = the command was successfully executed false = the command was not submitted because a prior command was still busy, or the specified thread is not a destinaition thread </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d646a6f80ce28cff578b2708ea11281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_psilcfgGetRevision </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return revision of the PSILCFG module. </p>
<p>This function returns the contents of the PSILCFG revision register. Consult the PSILCFG module documentation for a description of the contents of the revision register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit revision register is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd2e40f14db1e8f7e2fc7ec05d5a7767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgRead </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a PSI-L periperal using the PSI-L configuration proxy. </p>
<p>This function submits a read command to the PSI-L periperal specified by the thread 'threadId' at address specified by 'regId', waits for the read command to complete, then reads and returns the data value in pData.</p>
<p>Note: This command will return false if the PSI-L peripheral specified by the thread 'threadId' is invalid, the regId is invalid, or the peripheral is powered down or is in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">threadId</td><td>[IN] Thread identifying the PSI-L peripheral to write to </td></tr>
    <tr><td class="paramname">regId</td><td>[IN] Register of the PSI-L peripheral to read from. See <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___e_n_u_m.html#CSL_PsilCfgReg">CSL_PsilCfgReg</a>. </td></tr>
    <tr><td class="paramname">pData</td><td>[OUT] A pointer where to store the 32-bit data value read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = The read command completed successfully false = The read command timed out. Check the threadId and regId parameters to make sure they are valid and that the targeted PSI-L peripheral is powered up and unreset. </dd></dl>

</div>
</div>
<a class="anchor" id="gadef5e9871692471233a939d9b03751be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgSetThreadEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable a thread. </p>
<p>This function enables or disables the specified thread.</p>
<p>Software should only disable a thread if the thread is to be reset before being re-enabled. Otherwise, a teardown command <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga0e6f2dbd3add0674b5e0f0e29b446d77" title="Teardown a thread. ">CSL_psilcfgTeardownThread</a> should be used to gracefully disable a thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">threadId</td><td>[IN] Thread identifying the PSI-L peripheral </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] 0 = thread is disabled, 1 = thread is enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = the command was successfully executed false = the command was not submitted because a prior command was still busy </dd></dl>

</div>
</div>
<a class="anchor" id="ga0591ce71f4c47185712c897ab461e253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgSetThreadPause </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause or un-pause a thread. </p>
<p>This function pauses or un-pauses the specified thread.</p>
<p>While paused, data transfers will no longer occur but other application specific actions may still occur (DMA event increments, etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">threadId</td><td>[IN] Thread identifying the PSI-L peripheral </td></tr>
    <tr><td class="paramname">bPause</td><td>[IN] 0 = thread is un-paused, 1 = thread is paused</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = the command was successfully executed false = the command was not submitted because a prior command was still busy </dd></dl>

</div>
</div>
<a class="anchor" id="gaccd4ede29979e7d55c77d7e0c7a57ede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgSetThreadRealtimeEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable a thread via the realtime register. </p>
<p>This function enables or disables the specified thread via the realtime register.</p>
<p>Software should only disable a thread if the thread is to be reset before being re-enabled. Otherwise, a teardown command <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga0e6f2dbd3add0674b5e0f0e29b446d77" title="Teardown a thread. ">CSL_psilcfgTeardownThread</a> should be used to gracefully disable a thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">threadId</td><td>[IN] Thread identifying the PSI-L peripheral </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] 0 = thread is disabled, 1 = thread is enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = the command was successfully executed false = the command was not submitted because a prior command was still busy </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e6f2dbd3add0674b5e0f0e29b446d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgTeardownThread </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Teardown a thread. </p>
<p>This function tears down the specified thread.</p>
<p>For a source thread: </p><pre class="fragment">A teardown command will stop transferring data on a boundary which is
appropriate for the type of attached peripheral and clear and mask any
peripheral specific functionality (DMA event counters, etc.).

After stopping data transfer, the source thread sends a 'NULL data'
teardown message to the destination thread.

Once the thread teardown is complete and ready to be reused, the enable
bit is cleared.
</pre><p>For a destination thread: </p><pre class="fragment">To perform a destination thread teardown, it is recommended that the
teardown command be set in the source thread and it will automatically
propagate to destination thread with the normal flow of peripheral data
via the tdown bit.

As a result, if a destination thread is specified in this function, then
nothing is done and false is returned.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">threadId</td><td>[IN] Thread identifying the PSI-L peripheral</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = the command was successfully executed false = the command was not submitted because a prior command was still busy, or a destination thread was specified </dd></dl>

</div>
</div>
<a class="anchor" id="ga267fca7159f11f18c31f2d0e374abbe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_psilcfgWrite </td>
          <td>(</td>
          <td class="paramtype">const CSL_psilcfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a PSI-L periperal using the PSI-L configuration proxy. </p>
<p>This function submits a write command to the PSI-L periperal specified by the thread 'threadId' at address specified by 'regId'. It then waits for the write command to complete before returning.</p>
<p>Note: This command will return false if the PSI-L peripheral specified by the thread 'threadId' is invalid, the regId is invalid, or the peripheral is powered down or is in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] Pointer to the CSL_psilcfgRegs register structure </td></tr>
    <tr><td class="paramname">threadId</td><td>[IN] Thread identifying the PSI-L peripheral to write to </td></tr>
    <tr><td class="paramname">regId</td><td>[IN] Register of the PSI-L peripheral to write to. See <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___e_n_u_m.html#CSL_PsilCfgReg">CSL_PsilCfgReg</a>. </td></tr>
    <tr><td class="paramname">data</td><td>[IN] Data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = The write command completed successfully false = The write command timed out. Check the threadId and regId parameters to make sure they are valid and that the targeted PSI-L peripheral is powered up and unreset. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17e951a9aaad355f8e80d8b7545f5278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_pvuAckExceptionIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge exception interrupt. </p>
<p>This function is used to acknowledge the exception interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gacd2ba19a1a325d2a22bbdb103f77ed37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuCfgDmaClassSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDmaVirtIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSubClass0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSubClass1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSubClass2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSubClass3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure DMA class support. </p>
<p>This function configures the DMA class support in the PVU.</p>
<p>The numDmaVirtIds specifies the maximum number of virtid values (0..numDmaVirtIds-1) used for DMA purposes. This value must be &lt;= the # of TLB's supported by the PVU (see the pNumTlbs value in <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga7dc7a66301a79b9d228e3d808201e8a7" title="Get PVU configuration. ">CSL_pvuGetCfg</a>).</p>
<p>The mapSubClass0 .. mapSubClass3 arguments specify the TLB select offset (0..3) for the given DMA virtid/TLB. For example, if the DMA virtid is 6, and mapSubClass2 is 2, then the corresponding TLB for this DMA subclass is 26 ((6*4)+2).</p>
<p>Note: This function needs to be called only when DMA class support is desired in the PVU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">numDmaVirtIds</td><td>[IN] Max DMA virtid value </td></tr>
    <tr><td class="paramname">mapSubClass0</td><td>[IN] TLB select offset for DMA sub-class 0 </td></tr>
    <tr><td class="paramname">mapSubClass1</td><td>[IN] TLB select offset for DMA sub-class 1 </td></tr>
    <tr><td class="paramname">mapSubClass2</td><td>[IN] TLB select offset for DMA sub-class 2 </td></tr>
    <tr><td class="paramname">mapSubClass3</td><td>[IN] TLB select offset for DMA sub-class 3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = success -1 = numDmaVirtIds is invalid -2 = one or more mapSubClass arguments are invalid (must be 0..3) </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f6262d88c079c58877e00f0000cc929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuCfgTlb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tlbNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>entryNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_tlb_cfg.html">CSL_PvuTlbCfg</a> *&#160;</td>
          <td class="paramname"><em>pTlbCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a TLB entry. </p>
<p>This function is used to configure the specified TLB entry.</p>
<p>Note that the TLB must be disabled before it can be configured.</p>
<p>Call the <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga281ac383a2c3055b30aafe0019cebe57" title="Return the TLB number associated with the specified virtId. ">CSL_pvuGetTlbNum</a> function to get the TLB number associated with a given virtId and dmaSubClass (if virtId belongs to a DMA class).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">tlbNum</td><td>[IN] TLB number </td></tr>
    <tr><td class="paramname">entryNum</td><td>[IN] TLB entry number </td></tr>
    <tr><td class="paramname">pTlbCfg</td><td>[IN] Pointer to TLB configuration structure (see <a class="el" href="struct_c_s_l___pvu_tlb_cfg.html" title="TLB configuration structure passed to the CSL_pvuCfgTlb() function. ">CSL_PvuTlbCfg</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = success -1 = tlbNum or entryNum arguments are invalid -2 = TLB is currently enabled (disable it first) </dd></dl>

</div>
</div>
<a class="anchor" id="ga91e18afed036b3efe5bced1e091c0a2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuChainToTlb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tlbNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chainToTlbNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain to another TLB. </p>
<p>This function is used chain a TLB to another TLB.</p>
<p>Call the <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga281ac383a2c3055b30aafe0019cebe57" title="Return the TLB number associated with the specified virtId. ">CSL_pvuGetTlbNum</a> function to get the TLB number associated with a given virtId and dmaSubClass (if virtId belongs to a DMA class).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">tlbNum</td><td>[IN] The TLB number to chain </td></tr>
    <tr><td class="paramname">chainToTlbNum</td><td>[IN] The TLB number to chain to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = success -1 = tlbNum or chainToTlbNum arguments are invalid </dd></dl>

</div>
</div>
<a class="anchor" id="gad2bc5be2811f1140af96b84a65a61938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuClrTlbFault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tlbNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear TLB fault. </p>
<p>This function is used to clear a TLB fault.</p>
<p>Call the <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga281ac383a2c3055b30aafe0019cebe57" title="Return the TLB number associated with the specified virtId. ">CSL_pvuGetTlbNum</a> function to get the TLB number associated with a given virtId and dmaSubClass (if virtId belongs to a DMA class).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">tlbNum</td><td>[IN] TLB number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = success -1 = tlbNum argument is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga7dc7a66301a79b9d228e3d808201e8a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_pvuGetCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pNumTlbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pNumEntriesPerTlb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get PVU configuration. </p>
<p>This function returns the PVU hardware configuration, specifically the number of TLBs supported in the PVU and the number of entries available per TLB.</p>
<p>These values can be queried by the caller to determine the TLB resources available in the PVU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">pNumTlbs</td><td>[OUT] Number of TLBs supported is returned </td></tr>
    <tr><td class="paramname">pNumEntriesPerTlb</td><td>[OUT] Number of entries per TLB is returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga33c3315cb1d60c9e2080963aeaa85fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_pvuGetExceptionInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___pvu_exception_info.html">CSL_PvuExceptionInfo</a> *&#160;</td>
          <td class="paramname"><em>pExceptionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get exception information. </p>
<p>This function is used to get detailed exception information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">pExceptionInfo</td><td>[IN] Pointer to a <a class="el" href="struct_c_s_l___pvu_exception_info.html" title="Exception information returned by the CSL_pvuGetExceptionInfo() function. ">CSL_PvuExceptionInfo</a> structure where the exception information is written to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e7922afe6f52521671550fd13616b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_pvuGetRevision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return revision of the PVU module. </p>
<p>This function returns the contents of the PVU revision register. Consult the PVU module documentation for a description of the contents of the revision register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit revision register is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga281ac383a2c3055b30aafe0019cebe57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuGetTlbNum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>virtId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dmaSubClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the TLB number associated with the specified virtId. </p>
<p>This function returns the TLB number associated with the specified virtId. It uses the following formula:</p>
<p>if( virtId &lt; numDmaVirtIds ) { tlbNum = (virtId * 4) + dmaSubClass; } else { tlbNum = (numDmaVirtIds * 4) + (virtId - numDmaVirtIds). }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">virtId</td><td>[IN] virtid </td></tr>
    <tr><td class="paramname">dmaSubClass</td><td>[IN] dma sub-class (valid only if virtId belongs to a DMA class)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 = success (the TLB number is returned) -1 = virtId is invalid -2 = dmaSubClass is invalid (must be 0..3) </dd></dl>

</div>
</div>
<a class="anchor" id="ga41bab04933f52d650c533497265ae234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_pvuIsExceptionIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the exception interrupt pending? </p>
<p>This function is used to determine if the exception interrupt is pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true = The exception interrupt is pending false = The exception interrupt is not pending </dd></dl>

</div>
</div>
<a class="anchor" id="ga652a692894289fab2df7abd9566562ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuIsTlbFaultSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tlbNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has a TLB fault been detected that could not be logged? </p>
<p>This function is used to determine if a fault has been detected that could not be logged for the specified TLB.</p>
<p>Call the <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga281ac383a2c3055b30aafe0019cebe57" title="Return the TLB number associated with the specified virtId. ">CSL_pvuGetTlbNum</a> function to get the TLB number associated with a given virtId and dmaSubClass (if virtId belongs to a DMA class).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">tlbNum</td><td>[IN] TLB number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 = true (fault detected) 0 = false (fault not detected) -1 = tlbNum argument is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fcf9ed3d42c84893cb4bd2d76e677d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuSetEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the PVU. </p>
<p>This function is used to enable or disable the PVU.</p>
<p>Prior to enabling the PVU, the following functions must/may be called to configure the PVU:</p>
<p>a) CSL_pvuSetMaxVirtId (required) b) CSL_pvuCfgDmaClassSupport (optional) c) CSL_pvuCfgTlb (required) d) CSL_pvuSetTlbEnable (required) e) CSL_pvuChainToTlb (optional) f) CSL_pvuSetTlbFaultLogging (optional) g) CSL_pvuSetExceptionTypeLoggingEnable (optional) h) CSL_pvuSetErrMsgDestId (optional) i) CSL_pvuSetExceptionLoggingEnable (optional)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, the PVU is enabled. If false, it is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = success -1 = Required configuration functions have not been called </dd></dl>

</div>
</div>
<a class="anchor" id="gaab70a6ab53474e72e4e793efca140865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_pvuSetErrMsgDestId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the destination ID value for error messages. </p>
<p>This function is used to set the destination ID for error messages produced by the PVU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">destId</td><td>[IN] Destination ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gad2bd7923b792ecd5ba870747bdc05fbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_pvuSetExceptionIntrEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the assertion of the exception interrupt signal. </p>
<p>This function is used to enable or disable assertion of the exception interrupt signal.</p>
<p>If enabled, this function also calls <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga00987d45ef7b195e1fe1293a59fdde10">CSL_pvuSetExceptionLoggingEnable</a> to enable exception logging as there is no valid reason to enable the exception interrupt source and not log the exception information and assert the module's exception interrupt signal.</p>
<p>If disabled, the module's exception interrupt signal is prevented from being asserted. Note that software can still call <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga41bab04933f52d650c533497265ae234">CSL_pvuIsExceptionIntrPending</a> to poll for an exception event and call <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga33c3315cb1d60c9e2080963aeaa85fe3">CSL_pvuGetExceptionInfo</a> to read exception event information if exception logging is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, assertion of the exception interrupt signal is enabled. If false, it is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga20036fd325b6bed336d5a3a522636e1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_pvuSetExceptionIntrPendingSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or clear a pending exception interrupt. </p>
<p>This function is used to forcibly set or clear the exception interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">bSet</td><td>[IN] If true, the exception interrupt is forcibly set. If false, the exception interrupt is cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga00987d45ef7b195e1fe1293a59fdde10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_pvuSetExceptionLoggingEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable exception error logging. </p>
<p>This function is used to enable or disable exception error logging.</p>
<p>When enabled, information is logged when an exception occurs and can be read by calling <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga33c3315cb1d60c9e2080963aeaa85fe3">CSL_pvuGetExceptionInfo</a>. Also, the module's exception interrupt signal is asserted if the exception interrupt source is enabled.</p>
<p>When disabled, no information is logged when an exception occurs. Also, the module's exception interrupt signal generation is disabled, regardless of whether the exception interrupt source is enabled or disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, exception error logging is enabled. If false, it is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa944e262572ce210eac6d784e01717fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_pvuSetExceptionTypeLoggingEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>exceptionTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable logging of the specified exception types. </p>
<p>This function is used to enable or disable logging of the specified exception types.</p>
<p>The exceptionTypes argument is a logical OR of the exception types to enable or disable. See <a class="el" href="group___c_s_l___p_v_u___e_n_u_m.html#CSL_PvuExceptionType">CSL_PvuExceptionType</a> for a list of valid exception types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">exceptionTypes</td><td>[IN] Logical OR of exception types </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, logging of the specified exception types is enabled. If false, they are disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaefe08ef563f5cbf3a1b469e0383937c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuSetMaxVirtId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVirtIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of virtid values. </p>
<p>This function allows the caller to set the maximum number of virtid values (0..numVirtIds-1) considered valid by the PVU. This value must be &lt;= the # of TLB's supported by the PVU (see the pNumTlbs value in <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga7dc7a66301a79b9d228e3d808201e8a7" title="Get PVU configuration. ">CSL_pvuGetCfg</a>).</p>
<p>Note: The caller must call this function prior to enabling the PVU via <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga8fcf9ed3d42c84893cb4bd2d76e677d5" title="Enable or disable the PVU. ">CSL_pvuSetEnable</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">numVirtIds</td><td>[IN] Maximum number of virtid's</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = success -1 = numVirtIds is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b389f82b371823bcbacca85c2a2987d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuSetTlbEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tlbNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable a TLB. </p>
<p>This function is used to enable or disable the specified TLB.</p>
<p>Call the <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga281ac383a2c3055b30aafe0019cebe57" title="Return the TLB number associated with the specified virtId. ">CSL_pvuGetTlbNum</a> function to get the TLB number associated with a given virtId and dmaSubClass (if virtId belongs to a DMA class).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">tlbNum</td><td>[IN] TLB number </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, the TLB is enabled. If false, it is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = success -1 = tlbNum argument is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ga5feff739478be31210bc775b53e6fee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_pvuSetTlbFaultLogging </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___pvu_cfg.html">CSL_PvuCfg</a> *&#160;</td>
          <td class="paramname"><em>pPvuCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tlbNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable fault logging for a TLB. </p>
<p>This function is used to enable or disable fault logging for the specified TLB.</p>
<p>Call the <a class="el" href="group___c_s_l___p_s_i_l_c_f_g___f_u_n_c_t_i_o_n.html#ga281ac383a2c3055b30aafe0019cebe57" title="Return the TLB number associated with the specified virtId. ">CSL_pvuGetTlbNum</a> function to get the TLB number associated with a given virtId and dmaSubClass (if virtId belongs to a DMA class).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPvuCfg</td><td>[IN] Pointer to the <a class="el" href="struct_c_s_l___pvu_cfg.html" title="PVU configuration structure passed to all API functions. ">CSL_PvuCfg</a> config structure </td></tr>
    <tr><td class="paramname">tlbNum</td><td>[IN] TLB number </td></tr>
    <tr><td class="paramname">bEnable</td><td>[IN] If true, fault logging for the TLB is enabled. If false, it is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = success -1 = tlbNum argument is invalid </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
