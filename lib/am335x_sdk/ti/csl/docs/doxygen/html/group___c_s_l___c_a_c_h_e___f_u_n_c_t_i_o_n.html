<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CACHE Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CACHE Functions<div class="ingroups"><a class="el" href="group___c_s_l___c_a_c_h_e___a_p_i.html">CACHE</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga31b5f990dee1b011843dbe14b04b33fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga31b5f990dee1b011843dbe14b04b33fd">CACHE_setMemRegionWritethrough</a> (Uint8 mar, Bool arg)</td></tr>
<tr class="separator:ga31b5f990dee1b011843dbe14b04b33fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17427bfbebc6ecaf2edb1958dacab9db"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga17427bfbebc6ecaf2edb1958dacab9db">CACHE_getMemRegionWritethrough</a> (Uint8 mar, Uint8 *wte)</td></tr>
<tr class="separator:ga17427bfbebc6ecaf2edb1958dacab9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040dd5318ae5a484d2fb23aba8744c37"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga040dd5318ae5a484d2fb23aba8744c37">CACHE_enableCaching</a> (Uint8 mar)</td></tr>
<tr class="separator:ga040dd5318ae5a484d2fb23aba8744c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad5cfd0918f820a5f20aba7ac950054"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga3ad5cfd0918f820a5f20aba7ac950054">CACHE_disableCaching</a> (Uint8 mar)</td></tr>
<tr class="separator:ga3ad5cfd0918f820a5f20aba7ac950054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956373bed99338aefd1a5910d1b8a0a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga956373bed99338aefd1a5910d1b8a0a5">CACHE_getMemRegionInfo</a> (Uint8 mar, Uint8 *pcx, Uint8 *pfx)</td></tr>
<tr class="separator:ga956373bed99338aefd1a5910d1b8a0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1419f1618053ab2b7807ad93511434"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gacb1419f1618053ab2b7807ad93511434">CACHE_setMemRegionInfo</a> (Uint8 mar, Uint8 pcx, Uint8 pfx)</td></tr>
<tr class="separator:gacb1419f1618053ab2b7807ad93511434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ccabc2313b03cc3c3507d76f2b9675"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga99ccabc2313b03cc3c3507d76f2b9675">CACHE_setL1DSize</a> (CACHE_L1Size newSize)</td></tr>
<tr class="separator:ga99ccabc2313b03cc3c3507d76f2b9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacce718cb4196d285fb05708c11ecb01"><td class="memItemLeft" align="right" valign="top">static CACHE_L1Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaacce718cb4196d285fb05708c11ecb01">CACHE_getL1DSize</a> (void)</td></tr>
<tr class="separator:gaacce718cb4196d285fb05708c11ecb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344eb8fdc838e6e0a9da1d95c5335903"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga344eb8fdc838e6e0a9da1d95c5335903">CACHE_freezeL1D</a> (void)</td></tr>
<tr class="separator:ga344eb8fdc838e6e0a9da1d95c5335903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf83985fa67170ed621633107bdc7faad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaf83985fa67170ed621633107bdc7faad">CACHE_unfreezeL1D</a> (void)</td></tr>
<tr class="separator:gaf83985fa67170ed621633107bdc7faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407c2683b26241fe19c1b542dedf61f0"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga407c2683b26241fe19c1b542dedf61f0">CACHE_getPrevL1DMode</a> (void)</td></tr>
<tr class="separator:ga407c2683b26241fe19c1b542dedf61f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae678477b0b7b33dce7264b51523c083d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gae678477b0b7b33dce7264b51523c083d">CACHE_invAllL1dWait</a> (void)</td></tr>
<tr class="separator:gae678477b0b7b33dce7264b51523c083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fcd320ff71f527b60cb2ad262e386d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga45fcd320ff71f527b60cb2ad262e386d">CACHE_invAllL1d</a> (CACHE_Wait wait)</td></tr>
<tr class="separator:ga45fcd320ff71f527b60cb2ad262e386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d1ff409f143654cfc907a7276337a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gad6d1ff409f143654cfc907a7276337a6">CACHE_wbAllL1dWait</a> (void)</td></tr>
<tr class="separator:gad6d1ff409f143654cfc907a7276337a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6f37f721c45481d0423f5c36dd192d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gafa6f37f721c45481d0423f5c36dd192d">CACHE_wbAllL1d</a> (CACHE_Wait wait)</td></tr>
<tr class="separator:gafa6f37f721c45481d0423f5c36dd192d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6b1c408916d4187322bc3778add7fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga3a6b1c408916d4187322bc3778add7fd">CACHE_wbInvAllL1dWait</a> (void)</td></tr>
<tr class="separator:ga3a6b1c408916d4187322bc3778add7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a3ad16dcd6f8c4dca01c2fe15d0c90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga70a3ad16dcd6f8c4dca01c2fe15d0c90">CACHE_wbInvAllL1d</a> (CACHE_Wait wait)</td></tr>
<tr class="separator:ga70a3ad16dcd6f8c4dca01c2fe15d0c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19c7f4be2e13004bdc35b0d64d637bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gac19c7f4be2e13004bdc35b0d64d637bc">CACHE_invL1dWait</a> (void)</td></tr>
<tr class="separator:gac19c7f4be2e13004bdc35b0d64d637bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387c6bdc855f2881628f6e5c8f7aceb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga387c6bdc855f2881628f6e5c8f7aceb5">CACHE_invL1d</a> (const void *blockPtr, Uint32 byteCnt, CACHE_Wait wait)</td></tr>
<tr class="separator:ga387c6bdc855f2881628f6e5c8f7aceb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9901f3be27202d94786f23bd0038669"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gac9901f3be27202d94786f23bd0038669">CACHE_wbL1dWait</a> (void)</td></tr>
<tr class="separator:gac9901f3be27202d94786f23bd0038669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf742ead062792780c2e7d46c28fab7b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaf742ead062792780c2e7d46c28fab7b0">CACHE_wbL1d</a> (const void *blockPtr, Uint32 byteCnt, CACHE_Wait wait)</td></tr>
<tr class="separator:gaf742ead062792780c2e7d46c28fab7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f81589b5271c97ae562a32a0d16a55"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gab7f81589b5271c97ae562a32a0d16a55">CACHE_wbInvL1dWait</a> (void)</td></tr>
<tr class="separator:gab7f81589b5271c97ae562a32a0d16a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0957912e23cffd6b2ae994d99dfca78c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga0957912e23cffd6b2ae994d99dfca78c">CACHE_wbInvL1d</a> (const void *blockPtr, Uint32 byteCnt, CACHE_Wait wait)</td></tr>
<tr class="separator:ga0957912e23cffd6b2ae994d99dfca78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga263d7e6e29cd77121c4f08f4d7371049"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga263d7e6e29cd77121c4f08f4d7371049">CACHE_setL1PSize</a> (CACHE_L1Size newSize)</td></tr>
<tr class="separator:ga263d7e6e29cd77121c4f08f4d7371049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2e0d10b748964eef15dc1946be9422"><td class="memItemLeft" align="right" valign="top">static CACHE_L1Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaaa2e0d10b748964eef15dc1946be9422">CACHE_getL1PSize</a> (void)</td></tr>
<tr class="separator:gaaa2e0d10b748964eef15dc1946be9422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ffc9ac6c5dd8ad3895b2e6f26b0ed7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaa1ffc9ac6c5dd8ad3895b2e6f26b0ed7">CACHE_freezeL1P</a> (void)</td></tr>
<tr class="separator:gaa1ffc9ac6c5dd8ad3895b2e6f26b0ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafedcfd5ac35d4d4914d76aa8fc49f3e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gafedcfd5ac35d4d4914d76aa8fc49f3e2">CACHE_unfreezeL1P</a> (void)</td></tr>
<tr class="separator:gafedcfd5ac35d4d4914d76aa8fc49f3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47eda8ef824a8cdc20d4e84664077b0"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gab47eda8ef824a8cdc20d4e84664077b0">CACHE_getPrevL1PMode</a> (void)</td></tr>
<tr class="separator:gab47eda8ef824a8cdc20d4e84664077b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddfe9e1b3300e504d8d019fa422095c8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaddfe9e1b3300e504d8d019fa422095c8">CACHE_invL1pWait</a> (void)</td></tr>
<tr class="separator:gaddfe9e1b3300e504d8d019fa422095c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8e1cdfd053917c52bebcd0ca509a51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gadc8e1cdfd053917c52bebcd0ca509a51">CACHE_invL1p</a> (const void *blockPtr, Uint32 byteCnt, CACHE_Wait wait)</td></tr>
<tr class="separator:gadc8e1cdfd053917c52bebcd0ca509a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d2a1e5d850b43c7933fc72536bf070"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gac5d2a1e5d850b43c7933fc72536bf070">CACHE_invAllL1pWait</a> (void)</td></tr>
<tr class="separator:gac5d2a1e5d850b43c7933fc72536bf070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa989b972867e7055fc031b25cb29c174"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaa989b972867e7055fc031b25cb29c174">CACHE_invAllL1p</a> (CACHE_Wait wait)</td></tr>
<tr class="separator:gaa989b972867e7055fc031b25cb29c174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ce521384f9b28258c74b9d9fbeebf7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga42ce521384f9b28258c74b9d9fbeebf7">CACHE_setL2Size</a> (CACHE_L2Size newSize)</td></tr>
<tr class="separator:ga42ce521384f9b28258c74b9d9fbeebf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8f5eabbdeb0e311c09de55fa6504889"><td class="memItemLeft" align="right" valign="top">static CACHE_L2Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gae8f5eabbdeb0e311c09de55fa6504889">CACHE_getL2Size</a> (void)</td></tr>
<tr class="separator:gae8f5eabbdeb0e311c09de55fa6504889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga796dab761f48c00000e8d97b3da3f9bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga796dab761f48c00000e8d97b3da3f9bc">CACHE_freezeL2</a> (void)</td></tr>
<tr class="separator:ga796dab761f48c00000e8d97b3da3f9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c89d51165218478551003a3cc0d7485"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga5c89d51165218478551003a3cc0d7485">CACHE_unfreezeL2</a> (void)</td></tr>
<tr class="separator:ga5c89d51165218478551003a3cc0d7485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a84edd80d4e266567e11779113496f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga91a84edd80d4e266567e11779113496f">CACHE_wbL2Wait</a> (void)</td></tr>
<tr class="separator:ga91a84edd80d4e266567e11779113496f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0206cf236d306fa5ca1005d9c96954"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaef0206cf236d306fa5ca1005d9c96954">CACHE_wbL2</a> (const void *blockPtr, Uint32 byteCnt, CACHE_Wait wait)</td></tr>
<tr class="separator:gaef0206cf236d306fa5ca1005d9c96954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a2f1ddd79d30b446afaeb470d2d8e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga68a2f1ddd79d30b446afaeb470d2d8e6">CACHE_invL2Wait</a> (void)</td></tr>
<tr class="separator:ga68a2f1ddd79d30b446afaeb470d2d8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88141557d0be3fa037ce8e51e7accd09"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga88141557d0be3fa037ce8e51e7accd09">CACHE_invL2</a> (const void *blockPtr, Uint32 byteCnt, CACHE_Wait wait)</td></tr>
<tr class="separator:ga88141557d0be3fa037ce8e51e7accd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7559c57aa86296cfd09bfdca2f8901"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga0c7559c57aa86296cfd09bfdca2f8901">CACHE_wbInvL2Wait</a> (void)</td></tr>
<tr class="separator:ga0c7559c57aa86296cfd09bfdca2f8901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54aa28abf1e8cb611e48dedbc951a87b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga54aa28abf1e8cb611e48dedbc951a87b">CACHE_wbInvL2</a> (const void *blockPtr, Uint32 byteCnt, CACHE_Wait wait)</td></tr>
<tr class="separator:ga54aa28abf1e8cb611e48dedbc951a87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e37b60041dae738ed20aa38e53e1c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaa2e37b60041dae738ed20aa38e53e1c6">CACHE_wbAllL2Wait</a> (void)</td></tr>
<tr class="separator:gaa2e37b60041dae738ed20aa38e53e1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c0a8aade7dae57e215bf1e7c18f78cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga6c0a8aade7dae57e215bf1e7c18f78cd">CACHE_wbAllL2</a> (CACHE_Wait wait)</td></tr>
<tr class="separator:ga6c0a8aade7dae57e215bf1e7c18f78cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa377d104d9bda1309ce76244a082e816"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#gaa377d104d9bda1309ce76244a082e816">CACHE_invAllL2Wait</a> (void)</td></tr>
<tr class="separator:gaa377d104d9bda1309ce76244a082e816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ff0354b346117bfac7af0d080e0861"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga86ff0354b346117bfac7af0d080e0861">CACHE_invAllL2</a> (CACHE_Wait wait)</td></tr>
<tr class="separator:ga86ff0354b346117bfac7af0d080e0861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0574d7dcabbb755047df5b34acf693b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga0574d7dcabbb755047df5b34acf693b6">CACHE_wbInvAllL2Wait</a> (void)</td></tr>
<tr class="separator:ga0574d7dcabbb755047df5b34acf693b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d86530ef35a5e877c8760db629facd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_a_c_h_e___f_u_n_c_t_i_o_n.html#ga1d86530ef35a5e877c8760db629facd9">CACHE_wbInvAllL2</a> (CACHE_Wait wait)</td></tr>
<tr class="separator:ga1d86530ef35a5e877c8760db629facd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3ad5cfd0918f820a5f20aba7ac950054"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_disableCaching </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>mar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_disableCaching</b> </p>
<p><b>Description</b> <br />
 This function disables caching for a specific memory region.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mar      Memory region for which cache is to be disabled.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Memory region is now <em>not</em> cacheable.</p>
<p><b>Writes</b> <br />
 CGEM_MAR0_PC=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_disableCaching (20);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga040dd5318ae5a484d2fb23aba8744c37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_enableCaching </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>mar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_enableCaching</b> </p>
<p><b>Description</b> <br />
 This function enables caching for a specific memory region.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mar      Memory region for which cache is to be enabled.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Memory region is now cacheable.</p>
<p><b>Writes</b> <br />
 CGEM_MAR0_PC=1</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_enableCaching (20);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga344eb8fdc838e6e0a9da1d95c5335903"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_freezeL1D </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_freezeL1D</b> </p>
<p><b>Description</b> <br />
 This function is used to freeze the L1D cache.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CGEM_L1DCC_OPER=1</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_freezeL1D();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa1ffc9ac6c5dd8ad3895b2e6f26b0ed7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_freezeL1P </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_freezeL1P</b> </p>
<p><b>Description</b> <br />
 This function is used to freeze the L1P cache.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CGEM_L1PCC_OPER=1</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_freezeL1P();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga796dab761f48c00000e8d97b3da3f9bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_freezeL2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_freezeL2</b> </p>
<p><b>Description</b> <br />
 This function is used to freeze the L2 Cache</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The L2 Cache is frozen.</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_freezeL2();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaacce718cb4196d285fb05708c11ecb01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CACHE_L1Size CACHE_getL1DSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_getL1DSize</b> </p>
<p><b>Description</b> <br />
 This function is used to get the L1 Data Cache Size.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CGEM_L1DCFG_L1DMODE</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_L1Size cacheSize;

     cacheSize = CACHE_getL1DSize();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaa2e0d10b748964eef15dc1946be9422"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CACHE_L1Size CACHE_getL1PSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_getL1PSize</b> </p>
<p><b>Description</b> <br />
 This function is used to get the L1P Cache Size.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CGEM_L1PCFG_L1PMODE</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_L1Size cacheSize;

     cacheSize = CACHE_getL1PSize();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae8f5eabbdeb0e311c09de55fa6504889"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CACHE_L2Size CACHE_getL2Size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_getL2Size</b> </p>
<p><b>Description</b> <br />
 This function is used to get the L2 cache size.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 CACHE_L2Size</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CGEM_L2CFG_L2MODE</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_L2Size size;

     size = CACHE_getL2Size();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga956373bed99338aefd1a5910d1b8a0a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_getMemRegionInfo </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>mar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pcx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pfx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_getMemRegionInfo</b> </p>
<p><b>Description</b> <br />
 This function is used to get memory region information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mar      Memory region for which the information is required.
       pcx      Is address cacheable in external cache (MSMC)
       pfx      Is address prefetchable</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CGEM_MAR0_PCX, CGEM_MAR0_PFX</p>
<p><b>Example</b> </p><pre class="fragment">     Uint8 pcx;
     Uint8 pfx;

     // Get the memory region information for 20
     CACHE_getMemRegionInfo (20, &amp;pcx, &amp;pfx);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga17427bfbebc6ecaf2edb1958dacab9db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_getMemRegionWritethrough </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>mar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>wte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_getMemRegionWritethrough</b> </p>
<p><b>Description</b> <br />
 This function gets write through mode for a specific memory region.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mar      Memory region for which WTE bit information to be read.
       wte      Address of WTE value</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 WTE bit value reflecting the write through mode is returned.</p>
<p><b>Writes</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">    CACHE_getMemRegionWritethrough (20, &amp;wte);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga407c2683b26241fe19c1b542dedf61f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CACHE_getPrevL1DMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_getPrevL1DMode</b> </p>
<p><b>Description</b> <br />
 This function is used get the previous operating state of the L1D cache</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CGEM_L1DCC_POPER</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 prev;

     prev = CACHE_getPrevL1DMode();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab47eda8ef824a8cdc20d4e84664077b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CACHE_getPrevL1PMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_getPrevL1PMode</b> </p>
<p><b>Description</b> <br />
 This function is used get the previous operating state of the L1P cache</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CGEM_L1PCC_POPER</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32  prev;

     prev = CACHE_getPrevL1PMode();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga45fcd320ff71f527b60cb2ad262e386d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invAllL1d </td>
          <td>(</td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invAllL1d</b> </p>
<p><b>Description</b> <br />
 This function is used to globally invalidate the L1D cache.</p>
<p><b>Arguments</b> </p><pre class="fragment">       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The L1D Cache is being invalidated.</p>
<p><b>Writes</b> <br />
 CGEM_L1DINV_I=1</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_invAllL1d(CACHE_WAIT); // Invalidate the L1D cache</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae678477b0b7b33dce7264b51523c083d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invAllL1dWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invAllL1dWait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L1D global invalidate operation to complete. This API should be used only if the CACHE_invAllL1d was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_invAllL1d</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CGEM_L1DINV_I=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_invAllL1d(CACHE_NOWAIT); // Invalidate the L1D cache
     ...
     CACHE_invAllL1dWait();        // Wait for the invalidate operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa989b972867e7055fc031b25cb29c174"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invAllL1p </td>
          <td>(</td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invAllL1p</b> </p>
<p><b>Description</b> <br />
 This function is used to invalidate the entire L1P Cache</p>
<p><b>Arguments</b> </p><pre class="fragment">       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The entire L1P cache is being invalidated.</p>
<p><b>Writes</b> <br />
 CGEM_L1PINV_I=1</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_invAllL1p(CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac5d2a1e5d850b43c7933fc72536bf070"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invAllL1pWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invAllL1pWait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L1P invalidate operation to complete. This API should be used only if the CACHE_invAllL1p was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_invAllL1p</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The L1P Cache is invalidated.</p>
<p><b>Reads</b> <br />
 CGEM_L1PINV_I=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_invAllL1p(CACHE_NOWAIT);
     ...
     CACHE_invAllL1pWait();        // Wait for the Invalidate operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga86ff0354b346117bfac7af0d080e0861"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invAllL2 </td>
          <td>(</td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invAllL2</b> </p>
<p><b>Description</b> <br />
 This function is used to invalidate all the contents of the L2 Cache.</p>
<p><b>Arguments</b> </p><pre class="fragment">       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the L2 Cache are being invalidated.</p>
<p><b>Writes</b> <br />
 CGEM_L2INV_I=1</p>
<p><b>Example</b> </p><pre class="fragment">     // Invalidate the contents of the L2 Cache.
     CACHE_invAllL2(CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa377d104d9bda1309ce76244a082e816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invAllL2Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invAllL2Wait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L2 Invalidate operation to complete. This API should be used only if the CACHE_invAllL2 was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_invAllL2</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The contents of the L2 Cache have been invalidated</p>
<p><b>Reads</b> <br />
 CGEM_L2INV_I=0</p>
<p><b>Example</b> </p><pre class="fragment">     // Invalidate the contents of the L2 Cache.
     CACHE_invAllL2(CACHE_NOWAIT);

     // Wait for the operation to complete.
     CACHE_invAllL2Wait();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga387c6bdc855f2881628f6e5c8f7aceb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invL1d </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invL1d</b> </p>
<p><b>Description</b> <br />
 This function is used to invalidate a block in the L1D Cache. Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       blockPtr      Address of the block which is to be invalidated
       byteCnt       Size of the block to be invalidated.
       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the blockPtr are being invalidated</p>
<p><b>Writes</b> <br />
 CGEM_L1DIBAR_ADDR,CGEM_L1DIWC_WC</p>
<p><b>Example</b> </p><pre class="fragment">     Uint8* ptr_buffer;

     // Invalidate 128 bytes of the buffer.
     CACHE_invL1d((void *)ptr_buffer, 128, CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac19c7f4be2e13004bdc35b0d64d637bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invL1dWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invL1dWait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L1D invalidate block operation to complete. This API should be used only if the CACHE_invL1d was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_invL1d</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The L1D Block Cache is invalidated.</p>
<p><b>Reads</b> <br />
 CGEM_L1DIWC_WC=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_invL1d((void *)ptr_buffer, 128, CACHE_NOWAIT);
     ...
     CACHE_invL1dWait();        // Wait for the Invalidate/Writeback operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadc8e1cdfd053917c52bebcd0ca509a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invL1p </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invL1p</b> </p>
<p><b>Description</b> <br />
 This function is used to invalidate the L1P Cache pointed by the block address. Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       blockPtr      Address of the block which is to be invalidated
       byteCnt       Size of the block to be invalidated.
       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the blockPtr are being invalidated</p>
<p><b>Writes</b> <br />
 CGEM_L1PIBAR_ADDR,CGEM_L1PIWC_WC</p>
<p><b>Example</b> </p><pre class="fragment">     // Invalidate the 128 bytes of the function 'foo'
     CACHE_invL1p((void *)&amp;foo, 128, CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaddfe9e1b3300e504d8d019fa422095c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invL1pWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invL1pWait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L1D invalidate block operation to complete. This API should be used only if the CACHE_invL1p was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_invL1p</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The L1D Block Cache is invalidated.</p>
<p><b>Reads</b> <br />
 CGEM_L1PIWC_WC=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_invL1p((void *)&amp;foo, 128, CACHE_NOWAIT);
     ...
     CACHE_invL1pWait();        // Wait for the Invalidate operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga88141557d0be3fa037ce8e51e7accd09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invL2 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invL2</b> </p>
<p><b>Description</b> <br />
 This function is used to invalidate the contents of the L2 Cache. Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       blockPtr      Address of the block which is to be invalidated
       byteCnt       Size of the block to be invalidated.
       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the L2 Cache are being invalidated.</p>
<p><b>Writes</b> <br />
 CGEM_L2IBAR_ADDR,CGEM_L2IWC_WC</p>
<p><b>Example</b> </p><pre class="fragment">     Uint8* ptr_buffer;

     // Invalidate the contents of the buffer.
     CACHE_invL2(ptr_buffer, 100, CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga68a2f1ddd79d30b446afaeb470d2d8e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_invL2Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_invL2Wait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L2 invalidate block operation to complete. This API should be used only if the CACHE_invL2 was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_invL2</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 Invalidate the contents of the L2 Cache.</p>
<p><b>Reads</b> <br />
 CGEM_L2IWC_WC=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_invL2((void *)ptr_buffer, 128, CACHE_NOWAIT);
     ...
     CACHE_invL2Wait();        // Wait for the Invalidate operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga99ccabc2313b03cc3c3507d76f2b9675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_setL1DSize </td>
          <td>(</td>
          <td class="paramtype">CACHE_L1Size&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_setL1DSize</b> </p>
<p><b>Description</b> <br />
 This function is used to set the L1 Data Cache Size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       newSize      Cache Size to be configured.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CGEM_L1DCFG_L1DMODE</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_setL1DSize(1); // Configure 4K Cache Size</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga263d7e6e29cd77121c4f08f4d7371049"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_setL1PSize </td>
          <td>(</td>
          <td class="paramtype">CACHE_L1Size&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_setL1PSize</b> </p>
<p><b>Description</b> <br />
 This function is used to set the L1P Cache Size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       newSize      Cache Size to be configured.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CGEM_L1PCFG_L1PMODE</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_setL1PSize(1); // Configure 4K Cache Size</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga42ce521384f9b28258c74b9d9fbeebf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_setL2Size </td>
          <td>(</td>
          <td class="paramtype">CACHE_L2Size&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_setL2Size</b> </p>
<p><b>Description</b> <br />
 This function is used to set the new size of the L2 Cache.</p>
<p><b>Arguments</b> </p><pre class="fragment">       newSize   New Size of the L2 Cache to be set.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The L2 Cache is configured to use the new size.</p>
<p><b>Writes</b> <br />
 CGEM_L2CFG_L2MODE</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_setL2Size(CACHE_32KCACHE); // Use 32K L2 Cache.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacb1419f1618053ab2b7807ad93511434"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_setMemRegionInfo </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>mar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>pcx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>pfx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_setMemRegionInfo</b> </p>
<p><b>Description</b> <br />
 This function is used to set memory region information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mar      Memory region for which the information is required.
       pcx      Is address cacheable in external cache (MSMC)
       pfx      Is address prefetchable</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CGEM_MAR0_PCX, CGEM_MAR0_PFX</p>
<p><b>Example</b> </p><pre class="fragment">     Uint8 pcx;
     Uint8 pfx;

     // Get the memory region information for 20
     CACHE_getMemRegionInfo (20, &amp;pcx, &amp;pfx);
     ...
     // Ensure Memory Region 20 is not prefetchable.
     CACHE_setMemRegionInfo(20, pcx, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga31b5f990dee1b011843dbe14b04b33fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_setMemRegionWritethrough </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>mar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_setMemRegionWritethrough</b> </p>
<p><b>Description</b> <br />
 This function sets write through mode for a specific memory region.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mar      Memory region for which cache is to be set to writethrough mode.
       arg      TRUE to set to write through mode, otherwise to wribeback mode.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Memory region is now set to writethrough mode.</p>
<p><b>Writes</b> <br />
 CGEM_MAR0_WTE=1, when arg == TRUE, zero otherwise</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_setMemRegionWritethrough (20, TRUE);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf83985fa67170ed621633107bdc7faad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_unfreezeL1D </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_unfreezeL1D</b> </p>
<p><b>Description</b> <br />
 This function is used to unfreeze the L1D cache.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CGEM_L1DCC_OPER=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_unfreezeL1D();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafedcfd5ac35d4d4914d76aa8fc49f3e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_unfreezeL1P </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_unfreezeL1P</b> </p>
<p><b>Description</b> <br />
 This function is used to unfreeze the L1D cache.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CGEM_L1PCC_OPER=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_unfreezeL1D();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5c89d51165218478551003a3cc0d7485"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_unfreezeL2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_unfreezeL2</b> </p>
<p><b>Description</b> <br />
 This function is used to unfreeze the L2 Cache</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The L2 Cache is unfrozen</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_unfreezeL2();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafa6f37f721c45481d0423f5c36dd192d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbAllL1d </td>
          <td>(</td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbAllL1d</b> </p>
<p><b>Description</b> <br />
 This function is used to writeback the dirty lines of the L1D Cache</p>
<p><b>Arguments</b> </p><pre class="fragment">       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The dirty lines of the L1D Cache are being written back</p>
<p><b>Writes</b> <br />
 CGEM_L1DWB_C=1</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_wbAllL1d(CACHE_WAIT); // Writeback the Dirty Lines of the L1D cache</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad6d1ff409f143654cfc907a7276337a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbAllL1dWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbAllL1dWait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L1D writeback operation to complete. This API should be used only if the CACHE_wbAllL1d was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_wbAllL1d</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The L1D Dirty lines are written back</p>
<p><b>Reads</b> <br />
 CGEM_L1DWB_C=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_wbAllL1d(CACHE_NOWAIT); // Writeback the L1D cache
     ...
     CACHE_wbAllL1dWait();        // Wait for the writeback operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6c0a8aade7dae57e215bf1e7c18f78cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbAllL2 </td>
          <td>(</td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbAllL2</b> </p>
<p><b>Description</b> <br />
 This function is used to write back all the contents of the L2 Cache.</p>
<p><b>Arguments</b> </p><pre class="fragment">       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the L2 Cache are being written back.</p>
<p><b>Writes</b> <br />
 CGEM_L2WB_C=1</p>
<p><b>Example</b> </p><pre class="fragment">     // Writeback the contents of the L2 Cache.
     CACHE_wbAllL2(CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa2e37b60041dae738ed20aa38e53e1c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbAllL2Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbAllL2Wait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L2 Writeback &amp; invalidate operation to complete. This API should be used only if the CACHE_wbAllL2 was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_wbAllL2</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The contents of the L2 Cache have been written back</p>
<p><b>Reads</b> <br />
 CGEM_L2WB_C=0</p>
<p><b>Example</b> </p><pre class="fragment">     // Writeback the contents of the L2 Cache.
     CACHE_wbAllL2(CACHE_NOWAIT);

     // Wait for the operation to complete.
     CACHE_wbAllL2Wait();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga70a3ad16dcd6f8c4dca01c2fe15d0c90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbInvAllL1d </td>
          <td>(</td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbInvAllL1d</b> </p>
<p><b>Description</b> <br />
 This function is used to invalidate and writeback the dirty lines of the L1D Cache</p>
<p><b>Arguments</b> </p><pre class="fragment">       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Invalidates and Writebacks the dirty lines of the L1D Cache</p>
<p><b>Writes</b> <br />
 CGEM_L1DWBINV_C=1</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_wbInvAllL1d(CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3a6b1c408916d4187322bc3778add7fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbInvAllL1dWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbInvAllL1dWait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L1D writeback invalidate operation to complete. This API should be used only if the CACHE_wbInvAllL1d was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_wbInvAllL1d</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The L1D Dirty lines are written back</p>
<p><b>Reads</b> <br />
 CGEM_L1DWBINV_C=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_wbInvAllL1d(CACHE_NOWAIT); // Invalidate/Writeback the L1D cache
     ...
     CACHE_wbInvAllL1dWait();        // Wait for the Invalidate/Writeback operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1d86530ef35a5e877c8760db629facd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbInvAllL2 </td>
          <td>(</td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbInvAllL2</b> </p>
<p><b>Description</b> <br />
 This function is used to writeback and invalidate all the contents of the L2 Cache.</p>
<p><b>Arguments</b> </p><pre class="fragment">       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the L2 Cache are being written back &amp; invalidated.</p>
<p><b>Writes</b> <br />
 CGEM_L2WBINV_C=1</p>
<p><b>Example</b> </p><pre class="fragment">     // Invalidate the contents of the L2 Cache.
     CACHE_wbInvAllL2(CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0574d7dcabbb755047df5b34acf693b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbInvAllL2Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbInvAllL2Wait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L2 Writeback and Invalidate operation to complete. This API should be used only if the CACHE_wbInvAllL2 was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_wbInvAllL2</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The contents of the L2 Cache have been invalidated and written back</p>
<p><b>Reads</b> <br />
 CGEM_L2WBINV_C=0</p>
<p><b>Example</b> </p><pre class="fragment">     // Writeback &amp; Invalidate the contents of the L2 Cache.
     CACHE_wbInvAllL2(CACHE_NOWAIT);

     // Wait for the operation to complete.
     CACHE_wbInvAllL2Wait();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0957912e23cffd6b2ae994d99dfca78c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbInvL1d </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbInvL1d</b> </p>
<p><b>Description</b> <br />
 This function is used to invalidate and writeback the dirty lines of the block address. Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       blockPtr      Address of the block which is to be invalidated/written back
       byteCnt       Size of the block to be invalidated/written back.
       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the blockPtr are being invalidated and the dirty lines are written back</p>
<p><b>Writes</b> <br />
 CGEM_L1DWIBAR_ADDR,CGEM_L1DWIWC_WC</p>
<p><b>Example</b> </p><pre class="fragment">     Uint8* ptr_buffer;

     // Writeback/Invalidate 128 bytes of the buffer.
     CACHE_wbInvL1d((void *)ptr_buffer, 128, CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab7f81589b5271c97ae562a32a0d16a55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbInvL1dWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbInvL1dWait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L1D invalidate/writeback block operation to complete. This API should be used only if the CACHE_wbInvL1d was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_wbInvL1d</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The dirty lines of the L1D Block Cache have been written back and the cache contents pointed to by the block address are also invalidated.</p>
<p><b>Reads</b> <br />
 CGEM_L1DWIWC_WC=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_wbInvL1d((void *)ptr_buffer, 128, CACHE_NOWAIT);
     ...
     CACHE_wbInvL1dWait();        // Wait for the operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga54aa28abf1e8cb611e48dedbc951a87b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbInvL2 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbInvL2</b> </p>
<p><b>Description</b> <br />
 This function is used to write back and invalidate the contents of the L2 Cache. Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       blockPtr      Address of the block which is to be written back &amp; invalidated
       byteCnt       Size of the block to be written back &amp; invalidated.
       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the L2 Cache are being written back &amp; invalidated.</p>
<p><b>Writes</b> <br />
 CGEM_L2WIBAR_ADDR,CGEM_L2WIWC_WC</p>
<p><b>Example</b> </p><pre class="fragment">     Uint8* ptr_buffer;

     // Invalidate the contents of the buffer.
     CACHE_wbInvL2(ptr_buffer, 100, CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0c7559c57aa86296cfd09bfdca2f8901"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbInvL2Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbInvL2Wait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L2 Writeback &amp; invalidate block operation to complete. This API should be used only if the CACHE_wbInvL2 was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_wbInvL2</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 Invalidate the contents of the L2 Cache.</p>
<p><b>Reads</b> <br />
 CGEM_L2WIWC_WC=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_wbInvL2((void *)ptr_buffer, 128, CACHE_NOWAIT);
     ...
     CACHE_wbInvL2Wait();  // Wait for the Writeback-Invalidate operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf742ead062792780c2e7d46c28fab7b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbL1d </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbL1d</b> </p>
<p><b>Description</b> <br />
 This function is used to writeback the dirty lines of the block address. Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       blockPtr      Address of the block which is to be written back
       byteCnt       Size of the block to be written back.
       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The contents of the blockPtr are being written back</p>
<p><b>Writes</b> <br />
 CGEM_L1DWBAR_ADDR,CGEM_L1DWWC_WC</p>
<p><b>Example</b> </p><pre class="fragment">     Uint8* ptr_buffer;

     // Writeback 128 bytes of the buffer.
     CACHE_wbL1d((void *)ptr_buffer, 128, CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac9901f3be27202d94786f23bd0038669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbL1dWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbL1dWait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L1D writeback block operation to complete. This API should be used only if the CACHE_wbL1d was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_wbL1d</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The dirty lines of the L1D Block Cache have been written back.</p>
<p><b>Reads</b> <br />
 CGEM_L1DWWC_WC=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_wbL1d((void *)ptr_buffer, 128, CACHE_NOWAIT);
     ...
     CACHE_wbL1dWait();        // Wait for the writeback operation to complete.</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaef0206cf236d306fa5ca1005d9c96954"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbL2 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blockPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CACHE_Wait&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbL2</b> </p>
<p><b>Description</b> <br />
 This function is used to writeback the contents of the L2 Cache. Although the block size can be specified in the number of bytes, the cache controller operates on whole cache lines. To prevent unintended behavior "blockPtr" should be aligned on the cache line size and "byteCnt" should be a multiple of the cache line size.</p>
<p><b>Arguments</b> </p><pre class="fragment">       blockPtr      Address of the block which is to be written back
       byteCnt       Size of the block to be written block.
       wait          Indicates if the call should block or not.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The dirty lines of the L2 Cache are being written back.</p>
<p><b>Writes</b> <br />
 CGEM_L2WBAR_ADDR,CGEM_L2WWC_WC</p>
<p><b>Example</b> </p><pre class="fragment">     Uint8* ptr_buffer;

     // Writeback the contents of the buffer.
     CACHE_wbL2(ptr_buffer, 100, CACHE_WAIT);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga91a84edd80d4e266567e11779113496f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CACHE_wbL2Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CACHE_wbL2Wait</b> </p>
<p><b>Description</b> <br />
 This function is used to wait for the L2 writeback block operation to complete. This API should be used only if the CACHE_wbL2 was called with the CACHE_NOWAIT argument.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 <em>CACHE_wbL2</em>(wait=CACHE_NOWAIT) must be called.</p>
<p><b> Post Condition </b> <br />
 The dirty lines of the L1D Block Cache have been written back.</p>
<p><b>Reads</b> <br />
 CGEM_L2WWC_WC=0</p>
<p><b>Example</b> </p><pre class="fragment">     CACHE_wbL2((void *)ptr_buffer, 128, CACHE_NOWAIT);
     ...
     CACHE_wbL2Wait();        // Wait for the writeback operation to complete.</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
