<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CPSW_3GF Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CPSW_3GF Functions<div class="ingroups"><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v4.html">Ethernet switch submodule (CPSW - V4)</a> &raquo; <a class="el" href="group___c_s_l___c_p_s_w__3_g_f___a_p_i.html">Ethernet switch submodule (CPSW_3GF)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v4.html">Ethernet switch submodule (CPSW - V4)</a> &raquo; <a class="el" href="group___c_s_l___c_p_s_w__3_g_f___a_p_i.html">Ethernet switch submodule (CPSW_3GF)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w__3_g_f___d_a_t_a_s_t_r_u_c_t.html">CPSW_3GF Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac684bb425637bb1a84d99f86cd8cae75"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gac684bb425637bb1a84d99f86cd8cae75">CSL_CPSW_nGF_getCpswVersionInfo</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___v_e_r_s_i_o_n.html">CSL_CPSW_3GF_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:gac684bb425637bb1a84d99f86cd8cae75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f11cbd345f77b2eaa3296173d63719"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga99f11cbd345f77b2eaa3296173d63719">CSL_CPSW_nGF_isFIFOLoopbackEnabled</a> (void)</td></tr>
<tr class="separator:ga99f11cbd345f77b2eaa3296173d63719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1504d92274c46f26dc0ffd1b4ef7115f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga1504d92274c46f26dc0ffd1b4ef7115f">CSL_CPSW_nGF_enableFIFOLoopback</a> (void)</td></tr>
<tr class="separator:ga1504d92274c46f26dc0ffd1b4ef7115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3692ec076de402c204574094441f59"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaee3692ec076de402c204574094441f59">CSL_CPSW_nGF_disableFIFOLoopback</a> (void)</td></tr>
<tr class="separator:gaee3692ec076de402c204574094441f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d3fac4e15319a7729dc75a606b1211"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga06d3fac4e15319a7729dc75a606b1211">CSL_CPSW_nGF_isVlanAwareEnabled</a> (void)</td></tr>
<tr class="separator:ga06d3fac4e15319a7729dc75a606b1211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48814fee30d621d1573cf3f9243244dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga48814fee30d621d1573cf3f9243244dc">CSL_CPSW_nGF_enableVlanAware</a> (void)</td></tr>
<tr class="separator:ga48814fee30d621d1573cf3f9243244dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac863878c5de414341eebb6ce7feedf48"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gac863878c5de414341eebb6ce7feedf48">CSL_CPSW_nGF_disableVlanAware</a> (void)</td></tr>
<tr class="separator:gac863878c5de414341eebb6ce7feedf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e3bc20295b66b73ba99fefc2f9d5846"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga5e3bc20295b66b73ba99fefc2f9d5846">CSL_CPSW_nGF_isPort0Enabled</a> (void)</td></tr>
<tr class="separator:ga5e3bc20295b66b73ba99fefc2f9d5846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462f4858825e94dd81926b37e06d5e16"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga462f4858825e94dd81926b37e06d5e16">CSL_CPSW_nGF_enablePort0</a> (void)</td></tr>
<tr class="separator:ga462f4858825e94dd81926b37e06d5e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22c4025b624a37c4090d0c9d28ebabe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab22c4025b624a37c4090d0c9d28ebabe">CSL_CPSW_nGF_disablePort0</a> (void)</td></tr>
<tr class="separator:gab22c4025b624a37c4090d0c9d28ebabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba9d022b4a64e407fbbcae006dc5337"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga4ba9d022b4a64e407fbbcae006dc5337">CSL_CPSW_nGF_isPort0PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga4ba9d022b4a64e407fbbcae006dc5337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f210570bff960321d112639310b21dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga0f210570bff960321d112639310b21dc">CSL_CPSW_nGF_enablePort0PassPriTag</a> (void)</td></tr>
<tr class="separator:ga0f210570bff960321d112639310b21dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff26dd36cb4f429e23bb4e45b48497e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gafff26dd36cb4f429e23bb4e45b48497e">CSL_CPSW_nGF_disablePort0PassPriTag</a> (void)</td></tr>
<tr class="separator:gafff26dd36cb4f429e23bb4e45b48497e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cb47b0913ad65ccef8a1de3e93344d4"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga4cb47b0913ad65ccef8a1de3e93344d4">CSL_CPSW_nGF_isPort1PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga4cb47b0913ad65ccef8a1de3e93344d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266433bde9484f5e1e3c74c4c490f442"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga266433bde9484f5e1e3c74c4c490f442">CSL_CPSW_nGF_enablePort1PassPriTag</a> (void)</td></tr>
<tr class="separator:ga266433bde9484f5e1e3c74c4c490f442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae820486ff249522a3da6ce6e4a7f39a1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gae820486ff249522a3da6ce6e4a7f39a1">CSL_CPSW_nGF_disablePort1PassPriTag</a> (void)</td></tr>
<tr class="separator:gae820486ff249522a3da6ce6e4a7f39a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee77b52b000f824746d964e79885932"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga3ee77b52b000f824746d964e79885932">CSL_CPSW_nGF_isPort2PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga3ee77b52b000f824746d964e79885932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a68068d612cd74049dda6dbcb3e7d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga88a68068d612cd74049dda6dbcb3e7d2">CSL_CPSW_nGF_enablePort2PassPriTag</a> (void)</td></tr>
<tr class="separator:ga88a68068d612cd74049dda6dbcb3e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f92d8dda11f6da86d77c074b438e81"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga18f92d8dda11f6da86d77c074b438e81">CSL_CPSW_nGF_disablePort2PassPriTag</a> (void)</td></tr>
<tr class="separator:ga18f92d8dda11f6da86d77c074b438e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8057d4b41528352cdb2d4b6a50132f66"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga8057d4b41528352cdb2d4b6a50132f66">CSL_CPSW_nGF_getCpswControlReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___c_o_n_t_r_o_l.html">CSL_CPSW_3GF_CONTROL</a> *pControlRegInfo)</td></tr>
<tr class="separator:ga8057d4b41528352cdb2d4b6a50132f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac49222fc0f134cbecc0695786190d63b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gac49222fc0f134cbecc0695786190d63b">CSL_CPSW_nGF_setCpswControlReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___c_o_n_t_r_o_l.html">CSL_CPSW_3GF_CONTROL</a> *pControlRegInfo)</td></tr>
<tr class="separator:gac49222fc0f134cbecc0695786190d63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8aa0b63c612b6c51bcb8230c9fb60bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaa8aa0b63c612b6c51bcb8230c9fb60bc">CSL_CPSW_nGF_getEmulationControlReg</a> (Uint32 *pFree, Uint32 *pSoft)</td></tr>
<tr class="separator:gaa8aa0b63c612b6c51bcb8230c9fb60bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b837c4070c7fbf57adecc26a7c81e3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gae6b837c4070c7fbf57adecc26a7c81e3">CSL_CPSW_nGF_setEmulationControlReg</a> (Uint32 free, Uint32 soft)</td></tr>
<tr class="separator:gae6b837c4070c7fbf57adecc26a7c81e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61dbf24cd06c4e23040f2548e89132f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga61dbf24cd06c4e23040f2548e89132f8">CSL_CPSW_nGF_getPortStatsEnableReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___p_o_r_t_s_t_a_t.html">CSL_CPSW_3GF_PORTSTAT</a> *pPortStatsCfg)</td></tr>
<tr class="separator:ga61dbf24cd06c4e23040f2548e89132f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65317608a8fbf31c5134eef569c32ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab65317608a8fbf31c5134eef569c32ec">CSL_CPSW_nGF_setPortStatsEnableReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___p_o_r_t_s_t_a_t.html">CSL_CPSW_3GF_PORTSTAT</a> *pPortStatsCfg)</td></tr>
<tr class="separator:gab65317608a8fbf31c5134eef569c32ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga271e7d197a40ebfb6e91064138d4e16b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga271e7d197a40ebfb6e91064138d4e16b">CSL_CPSW_nGF_getPrioTypeReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___p_t_y_p_e.html">CSL_CPSW_3GF_PTYPE</a> *pTypeCfg)</td></tr>
<tr class="separator:ga271e7d197a40ebfb6e91064138d4e16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a4e5175790f814be4882d11311b2e3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab9a4e5175790f814be4882d11311b2e3">CSL_CPSW_nGF_setPrioTypeReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___p_t_y_p_e.html">CSL_CPSW_3GF_PTYPE</a> *pTypeCfg)</td></tr>
<tr class="separator:gab9a4e5175790f814be4882d11311b2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3a33bf6891e6ffc86fdaeb702b3553"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga4e3a33bf6891e6ffc86fdaeb702b3553">CSL_CPSW_nGF_getShortGapThreshold</a> (void)</td></tr>
<tr class="separator:ga4e3a33bf6891e6ffc86fdaeb702b3553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e2834a6becb4c2f5f0be82ca1816fb0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga2e2834a6becb4c2f5f0be82ca1816fb0">CSL_CPSW_nGF_setShortGapThreshold</a> (Uint32 gapThreshVal)</td></tr>
<tr class="separator:ga2e2834a6becb4c2f5f0be82ca1816fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fbcc27f8427142c909cbd4f69cc9b58"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga5fbcc27f8427142c909cbd4f69cc9b58">CSL_CPSW_nGF_getTxStartWordsReg</a> (void)</td></tr>
<tr class="separator:ga5fbcc27f8427142c909cbd4f69cc9b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1807bee7b2657d2ae64b338108fefe2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga1807bee7b2657d2ae64b338108fefe2d">CSL_CPSW_nGF_setTxStartWordsReg</a> (Uint32 startWordsVal)</td></tr>
<tr class="separator:ga1807bee7b2657d2ae64b338108fefe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425bd0274392efcb4cd51a2306897f5f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga425bd0274392efcb4cd51a2306897f5f">CSL_CPSW_nGF_getFlowControlReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___f_l_o_w_c_n_t_l.html">CSL_CPSW_3GF_FLOWCNTL</a> *pFlowControlCfg)</td></tr>
<tr class="separator:ga425bd0274392efcb4cd51a2306897f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69bc75a889ffaeb8a5eaeb025122e833"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga69bc75a889ffaeb8a5eaeb025122e833">CSL_CPSW_nGF_setFlowControlReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___f_l_o_w_c_n_t_l.html">CSL_CPSW_3GF_FLOWCNTL</a> *pFlowControlCfg)</td></tr>
<tr class="separator:ga69bc75a889ffaeb8a5eaeb025122e833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa069ea9e0533a16bec5d5d1d2cae9b8d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaa069ea9e0533a16bec5d5d1d2cae9b8d">CSL_CPSW_nGF_getCppiSourceIdReg</a> (Uint32 *pTxASrcId, Uint32 *pTxBSrcId)</td></tr>
<tr class="separator:gaa069ea9e0533a16bec5d5d1d2cae9b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad592f12b004195efb03740b2f9ede6bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gad592f12b004195efb03740b2f9ede6bd">CSL_CPSW_nGF_setCppiSourceIdReg</a> (Uint32 txASrcId, Uint32 txBSrcId)</td></tr>
<tr class="separator:gad592f12b004195efb03740b2f9ede6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11592d4843e4e53ae81ff57ddf149bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab11592d4843e4e53ae81ff57ddf149bd">CSL_CPSW_nGF_getPort0VlanReg</a> (Uint32 *pPortVID, Uint32 *pPortCFI, Uint32 *pPortPRI)</td></tr>
<tr class="separator:gab11592d4843e4e53ae81ff57ddf149bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85a0c35c6570082e4c85388b27bd95d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaa85a0c35c6570082e4c85388b27bd95d">CSL_CPSW_nGF_setPort0VlanReg</a> (Uint32 portVID, Uint32 portCFI, Uint32 portPRI)</td></tr>
<tr class="separator:gaa85a0c35c6570082e4c85388b27bd95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99c8c800b562d0b99cd8932efded194"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab99c8c800b562d0b99cd8932efded194">CSL_CPSW_nGF_getPort0RxPriMapReg</a> (Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:gab99c8c800b562d0b99cd8932efded194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c27e0710363f941927e1425dc5537e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga0c27e0710363f941927e1425dc5537e6">CSL_CPSW_nGF_setPort0RxPriMapReg</a> (Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:ga0c27e0710363f941927e1425dc5537e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3800bf2b724f83627fea70af4f15aaf7"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga3800bf2b724f83627fea70af4f15aaf7">CSL_CPSW_nGF_getPort0RxMaxLen</a> (void)</td></tr>
<tr class="separator:ga3800bf2b724f83627fea70af4f15aaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf588feb52603f246e9a20f30cfadc8b1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaf588feb52603f246e9a20f30cfadc8b1">CSL_CPSW_nGF_setPort0RxMaxLen</a> (Uint32 rxMaxLen)</td></tr>
<tr class="separator:gaf588feb52603f246e9a20f30cfadc8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff3094f05868b8de6a730c0fdac9600"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga3ff3094f05868b8de6a730c0fdac9600">CSL_CPSW_nGF_getPortMaxBlocksReg</a> (Uint32 portNum, Uint32 *pRxMaxBlks, Uint32 *pTxMaxBlks)</td></tr>
<tr class="separator:ga3ff3094f05868b8de6a730c0fdac9600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fbac51ff633f41f6911f8b47472a2dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga0fbac51ff633f41f6911f8b47472a2dc">CSL_CPSW_nGF_setPortMaxBlocksReg</a> (Uint32 portNum, Uint32 rxMaxBlks, Uint32 txMaxBlks)</td></tr>
<tr class="separator:ga0fbac51ff633f41f6911f8b47472a2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8732447f5a1bad3a7e1b1fc36d364f83"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga8732447f5a1bad3a7e1b1fc36d364f83">CSL_CPSW_nGF_getPortBlockCountReg</a> (Uint32 portNum, Uint32 *pRxBlkCnt, Uint32 *pTxBlkCnt)</td></tr>
<tr class="separator:ga8732447f5a1bad3a7e1b1fc36d364f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8744df18a0df73376949a8d7a12dc74a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga8744df18a0df73376949a8d7a12dc74a">CSL_CPSW_nGF_getPortVlanReg</a> (Uint32 portNum, Uint32 *pPortVID, Uint32 *pPortCFI, Uint32 *pPortPRI)</td></tr>
<tr class="separator:ga8744df18a0df73376949a8d7a12dc74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa080d5436e8487bdb82006152a3ea7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga5fa080d5436e8487bdb82006152a3ea7">CSL_CPSW_nGF_setPortVlanReg</a> (Uint32 portNum, Uint32 portVID, Uint32 portCFI, Uint32 portPRI)</td></tr>
<tr class="separator:ga5fa080d5436e8487bdb82006152a3ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946261bef9e67bafb70543a127c315a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga946261bef9e67bafb70543a127c315a4">CSL_CPSW_nGF_getPortTxPriMapReg</a> (Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:ga946261bef9e67bafb70543a127c315a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8d4a1e32a6b8527561810cf5a87c96"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga3f8d4a1e32a6b8527561810cf5a87c96">CSL_CPSW_nGF_setPortTxPriMapReg</a> (Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:ga3f8d4a1e32a6b8527561810cf5a87c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8e4fd704500fba61cc096a94fd730cf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaa8e4fd704500fba61cc096a94fd730cf">CSL_CPSW_nGF_getPortMACAddress</a> (Uint32 portNum, Uint8 *pMacAddress)</td></tr>
<tr class="separator:gaa8e4fd704500fba61cc096a94fd730cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b25c97701878540efb1747b7fdf91b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga84b25c97701878540efb1747b7fdf91b">CSL_CPSW_nGF_setPortMACAddress</a> (Uint32 portNum, Uint8 *pMacAddress)</td></tr>
<tr class="separator:ga84b25c97701878540efb1747b7fdf91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5ea1377d9190a4ad478cba37c6a985"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga8a5ea1377d9190a4ad478cba37c6a985">CSL_CPSW_nGF_getPortTimeSyncCntlReg</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___t_s_c_n_t_l.html">CSL_CPSW_3GF_TSCNTL</a> *pTimeSyncCntlCfg)</td></tr>
<tr class="separator:ga8a5ea1377d9190a4ad478cba37c6a985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fcf90e2dcdf3e59d6708d55faf8cae7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga0fcf90e2dcdf3e59d6708d55faf8cae7">CSL_CPSW_nGF_setPortTimeSyncCntlReg</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___t_s_c_n_t_l.html">CSL_CPSW_3GF_TSCNTL</a> *pTimeSyncCntlCfg)</td></tr>
<tr class="separator:ga0fcf90e2dcdf3e59d6708d55faf8cae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb880b0a03537f4d9526c1ef84b1b2a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gafb880b0a03537f4d9526c1ef84b1b2a5">CSL_CPSW_nGF_getPortTimeSyncSeqIdReg</a> (Uint32 portNum, Uint32 *pTsLtype, Uint32 *pTsSeqIdOffset)</td></tr>
<tr class="separator:gafb880b0a03537f4d9526c1ef84b1b2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gababdd83dacf5f9a736a92c454e33117b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gababdd83dacf5f9a736a92c454e33117b">CSL_CPSW_nGF_setPortTimeSyncSeqIdReg</a> (Uint32 portNum, Uint32 tsLtype, Uint32 tsSeqIdOffset)</td></tr>
<tr class="separator:gababdd83dacf5f9a736a92c454e33117b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62da595c6b0a2a3058d6f7e5cc934945"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga62da595c6b0a2a3058d6f7e5cc934945">CSL_CPSW_nGF_getPortTimeSyncVlanLTypeReg</a> (Uint32 portNum, Uint32 *pTsVlanLtype1, Uint32 *pTsVlanLtype2)</td></tr>
<tr class="separator:ga62da595c6b0a2a3058d6f7e5cc934945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4ad0e2589561aa1ad954fc48b3e1ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gacd4ad0e2589561aa1ad954fc48b3e1ec">CSL_CPSW_nGF_setPortTimeSyncVlanLTypeReg</a> (Uint32 portNum, Uint32 tsVlanLtype1, Uint32 tsVlanLtype2)</td></tr>
<tr class="separator:gacd4ad0e2589561aa1ad954fc48b3e1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac907d51b0add04a788c8ecc359e13492"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gac907d51b0add04a788c8ecc359e13492">CSL_CPSW_nGF_getStats</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___s_t_a_t_s.html">CSL_CPSW_3GF_STATS</a> *pCpswStats)</td></tr>
<tr class="separator:gac907d51b0add04a788c8ecc359e13492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b8c46e48068fbc688246023d0825a50"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga2b8c46e48068fbc688246023d0825a50">CSL_CPSW_nGF_getAleVersionInfo</a> (<a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_e_r_s_i_o_n.html">CSL_CPSW_3GF_ALE_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:ga2b8c46e48068fbc688246023d0825a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67010ed3cf68c53653ba3745d14a30de"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga67010ed3cf68c53653ba3745d14a30de">CSL_CPSW_nGF_isAleRateLimitEnabled</a> (void)</td></tr>
<tr class="separator:ga67010ed3cf68c53653ba3745d14a30de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac760810f6ef46373dfd04d1f01696a41"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gac760810f6ef46373dfd04d1f01696a41">CSL_CPSW_nGF_enableAleRateLimit</a> (void)</td></tr>
<tr class="separator:gac760810f6ef46373dfd04d1f01696a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8b703866e17f94e33826853fb5639d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaf8b703866e17f94e33826853fb5639d9">CSL_CPSW_nGF_disableAleRateLimit</a> (void)</td></tr>
<tr class="separator:gaf8b703866e17f94e33826853fb5639d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3359532458a65f4b8ae82cf558515b3"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaa3359532458a65f4b8ae82cf558515b3">CSL_CPSW_nGF_isAleMacAuthModeEnabled</a> (void)</td></tr>
<tr class="separator:gaa3359532458a65f4b8ae82cf558515b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc81a9c41db35aabee63a88db76234e3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gafc81a9c41db35aabee63a88db76234e3">CSL_CPSW_nGF_enableAleMacAuthMode</a> (void)</td></tr>
<tr class="separator:gafc81a9c41db35aabee63a88db76234e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5361cb6344ae34ffddef098dd0772ec2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga5361cb6344ae34ffddef098dd0772ec2">CSL_CPSW_nGF_disableAleMacAuthMode</a> (void)</td></tr>
<tr class="separator:ga5361cb6344ae34ffddef098dd0772ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0cf904131749b6d45f9c8bfa4871ffb"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gad0cf904131749b6d45f9c8bfa4871ffb">CSL_CPSW_nGF_isAleVlanAwareEnabled</a> (void)</td></tr>
<tr class="separator:gad0cf904131749b6d45f9c8bfa4871ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga626526309539b41defa4fdb0b7e1ed2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga626526309539b41defa4fdb0b7e1ed2b">CSL_CPSW_nGF_enableAleVlanAware</a> (void)</td></tr>
<tr class="separator:ga626526309539b41defa4fdb0b7e1ed2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3263c93ff95908b19c1863b7e206dea4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga3263c93ff95908b19c1863b7e206dea4">CSL_CPSW_nGF_disableAleVlanAware</a> (void)</td></tr>
<tr class="separator:ga3263c93ff95908b19c1863b7e206dea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5bf6034893cdf161624abd77b86d91d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gae5bf6034893cdf161624abd77b86d91d">CSL_CPSW_nGF_isAleTxRateLimitEnabled</a> (void)</td></tr>
<tr class="separator:gae5bf6034893cdf161624abd77b86d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b447154fa5b4bd846792efb0edc0cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga55b447154fa5b4bd846792efb0edc0cb">CSL_CPSW_nGF_enableAleTxRateLimit</a> (void)</td></tr>
<tr class="separator:ga55b447154fa5b4bd846792efb0edc0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga616be471b392175decc7234cb757dd07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga616be471b392175decc7234cb757dd07">CSL_CPSW_nGF_disableAleTxRateLimit</a> (void)</td></tr>
<tr class="separator:ga616be471b392175decc7234cb757dd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8bf3200fe173c4d9e08c7b2a19a72bf"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaf8bf3200fe173c4d9e08c7b2a19a72bf">CSL_CPSW_nGF_isAleBypassEnabled</a> (void)</td></tr>
<tr class="separator:gaf8bf3200fe173c4d9e08c7b2a19a72bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7877ad0427bd911f14c07a83e6fd5e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gadf7877ad0427bd911f14c07a83e6fd5e">CSL_CPSW_nGF_enableAleBypass</a> (void)</td></tr>
<tr class="separator:gadf7877ad0427bd911f14c07a83e6fd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb8e66bfbfb7f5345a42a5c0b464cc0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaaeb8e66bfbfb7f5345a42a5c0b464cc0">CSL_CPSW_nGF_disableAleBypass</a> (void)</td></tr>
<tr class="separator:gaaeb8e66bfbfb7f5345a42a5c0b464cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae457368aa6e09ecc4475f942a154f09a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gae457368aa6e09ecc4475f942a154f09a">CSL_CPSW_nGF_isAleOUIDenyModeEnabled</a> (void)</td></tr>
<tr class="separator:gae457368aa6e09ecc4475f942a154f09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b1f638947d5104ce14b056efe891adf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga2b1f638947d5104ce14b056efe891adf">CSL_CPSW_nGF_enableAleOUIDenyMode</a> (void)</td></tr>
<tr class="separator:ga2b1f638947d5104ce14b056efe891adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ecb81ff8c3621c28305f81e16abe038"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga7ecb81ff8c3621c28305f81e16abe038">CSL_CPSW_nGF_disableAleOUIDenyMode</a> (void)</td></tr>
<tr class="separator:ga7ecb81ff8c3621c28305f81e16abe038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ce4568d410713b8eba2ea4f65da5db"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gad5ce4568d410713b8eba2ea4f65da5db">CSL_CPSW_nGF_isAleVID0ModeEnabled</a> (void)</td></tr>
<tr class="separator:gad5ce4568d410713b8eba2ea4f65da5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab269d790a07ccabf17becf070ddf7d3f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab269d790a07ccabf17becf070ddf7d3f">CSL_CPSW_nGF_enableAleVID0Mode</a> (void)</td></tr>
<tr class="separator:gab269d790a07ccabf17becf070ddf7d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6aa5dddf6ab4926a79e9ec20da513f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gad6aa5dddf6ab4926a79e9ec20da513f3">CSL_CPSW_nGF_disableAleVID0Mode</a> (void)</td></tr>
<tr class="separator:gad6aa5dddf6ab4926a79e9ec20da513f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99caac59069289b4b3b7d4fffe28d412"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga99caac59069289b4b3b7d4fffe28d412">CSL_CPSW_nGF_isAleLearnNoVIDEnabled</a> (void)</td></tr>
<tr class="separator:ga99caac59069289b4b3b7d4fffe28d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae70941c9283371e8c0351161a6156a1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaae70941c9283371e8c0351161a6156a1">CSL_CPSW_nGF_enableAleLearnNoVID</a> (void)</td></tr>
<tr class="separator:gaae70941c9283371e8c0351161a6156a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2e0f3f53c8fe966f92f54409664952"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga4a2e0f3f53c8fe966f92f54409664952">CSL_CPSW_nGF_disableAleLearnNoVID</a> (void)</td></tr>
<tr class="separator:ga4a2e0f3f53c8fe966f92f54409664952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf77a6b2a6617a4f1a663ab8ae5349537"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaf77a6b2a6617a4f1a663ab8ae5349537">CSL_CPSW_nGF_startAleAgeOutNow</a> (void)</td></tr>
<tr class="separator:gaf77a6b2a6617a4f1a663ab8ae5349537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f71262fb7194854a6e4df8aa18c132"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga98f71262fb7194854a6e4df8aa18c132">CSL_CPSW_nGF_isAleAgeOutDone</a> (void)</td></tr>
<tr class="separator:ga98f71262fb7194854a6e4df8aa18c132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac93a6c951ce7be8a9199839d5ca72949"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gac93a6c951ce7be8a9199839d5ca72949">CSL_CPSW_nGF_clearAleTable</a> (void)</td></tr>
<tr class="separator:gac93a6c951ce7be8a9199839d5ca72949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b4c7f02f4af6452e9cb3bd2311ae7e"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaf9b4c7f02f4af6452e9cb3bd2311ae7e">CSL_CPSW_nGF_isAleEnabled</a> (void)</td></tr>
<tr class="separator:gaf9b4c7f02f4af6452e9cb3bd2311ae7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b962d35782b3dca8ff98ffef0a690c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga4b962d35782b3dca8ff98ffef0a690c5">CSL_CPSW_nGF_enableAle</a> (void)</td></tr>
<tr class="separator:ga4b962d35782b3dca8ff98ffef0a690c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953f2f02057311bedcaeb69dc0b67db3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga953f2f02057311bedcaeb69dc0b67db3">CSL_CPSW_nGF_disableAle</a> (void)</td></tr>
<tr class="separator:ga953f2f02057311bedcaeb69dc0b67db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044adeabccadc735c778d93661395034"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga044adeabccadc735c778d93661395034">CSL_CPSW_nGF_getAleControlReg</a> (void)</td></tr>
<tr class="separator:ga044adeabccadc735c778d93661395034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7656fb88e412a3887cacaf84cfc19ec6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga7656fb88e412a3887cacaf84cfc19ec6">CSL_CPSW_nGF_setAleControlReg</a> (Uint32 aleCtrlVal)</td></tr>
<tr class="separator:ga7656fb88e412a3887cacaf84cfc19ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1f08e32adec0042a40f7d7178ba819e"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab1f08e32adec0042a40f7d7178ba819e">CSL_CPSW_nGF_getAlePrescaleReg</a> (void)</td></tr>
<tr class="separator:gab1f08e32adec0042a40f7d7178ba819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a62f4df843a0a92ab4c7168f74e0bdc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga7a62f4df843a0a92ab4c7168f74e0bdc">CSL_CPSW_nGF_setAlePrescaleReg</a> (Uint32 alePrescaleVal)</td></tr>
<tr class="separator:ga7a62f4df843a0a92ab4c7168f74e0bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11f074e431910e45d0e56f42dfca57d6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga11f074e431910e45d0e56f42dfca57d6">CSL_CPSW_nGF_getAleUnkownVlanReg</a> (Uint32 *pUnVlanMemList, Uint32 *pUnMcastFloodMask, Uint32 *pUnRegMcastFloodMask, Uint32 *pUnForceUntagEgress)</td></tr>
<tr class="separator:ga11f074e431910e45d0e56f42dfca57d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d9db20150cd538fd041ea93f987624"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gad4d9db20150cd538fd041ea93f987624">CSL_CPSW_nGF_setAleUnkownVlanReg</a> (Uint32 unVlanMemList, Uint32 unMcastFloodMask, Uint32 unRegMcastFloodMask, Uint32 unForceUntagEgress)</td></tr>
<tr class="separator:gad4d9db20150cd538fd041ea93f987624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585fd783a762c30a5e7892ac1f4d98be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga585fd783a762c30a5e7892ac1f4d98be">CSL_CPSW_nGF_getAleTableEntry</a> (Uint32 index, Uint32 *pAleInfoWd0, Uint32 *pAleInfoWd1, Uint32 *pAleInfoWd2)</td></tr>
<tr class="separator:ga585fd783a762c30a5e7892ac1f4d98be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0660506478ce3fa65eea13cf4555b5e0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga0660506478ce3fa65eea13cf4555b5e0">CSL_CPSW_nGF_setAleTableEntry</a> (Uint32 index, Uint32 aleInfoWd0, Uint32 aleInfoWd1, Uint32 aleInfoWd2)</td></tr>
<tr class="separator:ga0660506478ce3fa65eea13cf4555b5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fad5821afdd1d5c0c224788160bb37"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga6ea23133eb6b1517c106ca3f1a8b7729">CSL_CPSW_3GF_ALE_ENTRYTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga88fad5821afdd1d5c0c224788160bb37">CSL_CPSW_nGF_getALEEntryType</a> (Uint32 index)</td></tr>
<tr class="separator:ga88fad5821afdd1d5c0c224788160bb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8800761f4328690a67131f8eaa4caa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#gac08366dceb5ccaea33ad2555f63471d5">CSL_CPSW_3GF_ALE_ADDRTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga4e8800761f4328690a67131f8eaa4caa">CSL_CPSW_nGF_getALEAddressType</a> (Uint32 index)</td></tr>
<tr class="separator:ga4e8800761f4328690a67131f8eaa4caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7431e9c179ade99c805572dc8f0a42e3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga7431e9c179ade99c805572dc8f0a42e3">CSL_CPSW_nGF_getAleMcastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY</a> *pMcastAddrCfg)</td></tr>
<tr class="separator:ga7431e9c179ade99c805572dc8f0a42e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64db227999c367609b721132da4673fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga64db227999c367609b721132da4673fc">CSL_CPSW_nGF_setAleMcastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY</a> *pMcastAddrCfg)</td></tr>
<tr class="separator:ga64db227999c367609b721132da4673fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69c7e46f82bd4ed800c27127e095681"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gac69c7e46f82bd4ed800c27127e095681">CSL_CPSW_nGF_getAleVlanMcastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY</a> *pVlanMcastAddrCfg)</td></tr>
<tr class="separator:gac69c7e46f82bd4ed800c27127e095681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf59c6486ad2ca7ec897d06c739640415"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gaf59c6486ad2ca7ec897d06c739640415">CSL_CPSW_nGF_setAleVlanMcastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY</a> *pVlanMcastAddrCfg)</td></tr>
<tr class="separator:gaf59c6486ad2ca7ec897d06c739640415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c04276aea05d61fd9ef20f0e65b5a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga81c04276aea05d61fd9ef20f0e65b5a4">CSL_CPSW_nGF_getAleUnicastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY</a> *pUcastAddrCfg)</td></tr>
<tr class="separator:ga81c04276aea05d61fd9ef20f0e65b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ebac3a15491336c53fc6ee33b80487"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga53ebac3a15491336c53fc6ee33b80487">CSL_CPSW_nGF_setAleUnicastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY</a> *pUcastAddrCfg)</td></tr>
<tr class="separator:ga53ebac3a15491336c53fc6ee33b80487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga376dfb786feccb3d8839de993e1a6b5d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga376dfb786feccb3d8839de993e1a6b5d">CSL_CPSW_nGF_getAleOUIAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_OUIADDR_ENTRY</a> *pOUIAddrCfg)</td></tr>
<tr class="separator:ga376dfb786feccb3d8839de993e1a6b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17c39c7d14f964b98096b79f4ed7e10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab17c39c7d14f964b98096b79f4ed7e10">CSL_CPSW_nGF_setAleOUIAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_OUIADDR_ENTRY</a> *pOUIAddrCfg)</td></tr>
<tr class="separator:gab17c39c7d14f964b98096b79f4ed7e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b56bc86ed55560cc057438fca2e4b8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga62b56bc86ed55560cc057438fca2e4b8">CSL_CPSW_nGF_getAleVlanUnicastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY</a> *pVlanUcastAddrCfg)</td></tr>
<tr class="separator:ga62b56bc86ed55560cc057438fca2e4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a8ac13ca1867897fb5dfd0cfb9afdc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga79a8ac13ca1867897fb5dfd0cfb9afdc">CSL_CPSW_nGF_setAleVlanUnicastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY</a> *pVlanUcastAddrCfg)</td></tr>
<tr class="separator:ga79a8ac13ca1867897fb5dfd0cfb9afdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ebde1dea83767796544b736fbdf79f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga3ebde1dea83767796544b736fbdf79f9">CSL_CPSW_nGF_getAleVlanEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLAN_ENTRY</a> *pVlanCfg)</td></tr>
<tr class="separator:ga3ebde1dea83767796544b736fbdf79f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69573437c1a37e884631b0b64a538074"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga69573437c1a37e884631b0b64a538074">CSL_CPSW_nGF_setAleVlanEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLAN_ENTRY</a> *pVlanCfg)</td></tr>
<tr class="separator:ga69573437c1a37e884631b0b64a538074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e619ba157de242cac1e11638976daa4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga0e619ba157de242cac1e11638976daa4">CSL_CPSW_nGF_clearAleEntry</a> (Uint32 index)</td></tr>
<tr class="separator:ga0e619ba157de242cac1e11638976daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f51b67f4115de4a862d0e426093a744"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#ga7f51b67f4115de4a862d0e426093a744">CSL_CPSW_nGF_getAlePortControlReg</a> (Uint32 portNo, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_3GF_ALE_PORTCONTROL</a> *pPortControlInfo)</td></tr>
<tr class="separator:ga7f51b67f4115de4a862d0e426093a744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3160490c752cfeede4e3aac8e04563a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w__3_g_f___f_u_n_c_t_i_o_n.html#gab3160490c752cfeede4e3aac8e04563a">CSL_CPSW_nGF_setAlePortControlReg</a> (Uint32 portNo, <a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_3GF_ALE_PORTCONTROL</a> *pPortControlInfo)</td></tr>
<tr class="separator:gab3160490c752cfeede4e3aac8e04563a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0e619ba157de242cac1e11638976daa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_clearAleEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_clearAleEntry</b> </p>
<p><b>Description</b> <br />
 This function clears the ALE entry corresponding to the index specified</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_3GF_ALE_TABLE_WORD0=0, CPSW_3GF_ALE_TABLE_WORD1=0, CPSW_3GF_ALE_TABLE_WORD2=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;

       index   =   0;

       CSL_CPSW_3GF_clearAleEntry (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac93a6c951ce7be8a9199839d5ca72949"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_clearAleTable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_clearAleTable</b> </p>
<p><b>Description</b> <br />
 This function initiates a full ALE table cleanup. The ALE hardware clears all table entries.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_CLEAR_TABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_clearAleTable ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga953f2f02057311bedcaeb69dc0b67db3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAle</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable ALE processing.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_ALE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaeb8e66bfbfb7f5345a42a5c0b464cc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAleBypass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAleBypass</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ALE_BYPASS=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAleBypass ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4a2e0f3f53c8fe966f92f54409664952"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAleLearnNoVID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAleLearnNoVID</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN Id learning.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_LEARN_NO_VID=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAleLearnNoVID ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5361cb6344ae34ffddef098dd0772ec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAleMacAuthMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAleMacAuthMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable MAC authorization mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAleMacAuthMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7ecb81ff8c3621c28305f81e16abe038"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAleOUIDenyMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAleOUIDenyMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_OUI_DENY=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAleOUIDenyMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf8b703866e17f94e33826853fb5639d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAleRateLimit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAleRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable multicast, broadcast rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAleRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga616be471b392175decc7234cb757dd07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAleTxRateLimit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAleTxRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable Tx rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_RATE_LIMIT_TX=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAleTxRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad6aa5dddf6ab4926a79e9ec20da513f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAleVID0Mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAleVID0Mode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable VID0 mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_EN_VID0_MODE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAleVID0Mode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3263c93ff95908b19c1863b7e206dea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableAleVlanAware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableAleVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ALE_VLAN_AWARE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableAleVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaee3692ec076de402c204574094441f59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableFIFOLoopback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableFIFOLoopback</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable FIFO loopback mode</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableFIFOLoopback ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab22c4025b624a37c4090d0c9d28ebabe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disablePort0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disablePort0</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disablePort0 ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafff26dd36cb4f429e23bb4e45b48497e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disablePort0PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disablePort0PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disablePort0PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae820486ff249522a3da6ce6e4a7f39a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disablePort1PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disablePort1PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disablePort1PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga18f92d8dda11f6da86d77c074b438e81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disablePort2PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disablePort2PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 2.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disablePort2PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac863878c5de414341eebb6ce7feedf48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_disableVlanAware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_disableVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_disableVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4b962d35782b3dca8ff98ffef0a690c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAle</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable ALE processing.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_ALE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadf7877ad0427bd911f14c07a83e6fd5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAleBypass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAleBypass</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ALE_BYPASS=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAleBypass ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaae70941c9283371e8c0351161a6156a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAleLearnNoVID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAleLearnNoVID</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN Id No Learn, i.e., disable VLAN Id learning.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_LEARN_NO_VID=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAleLearnNoVID ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafc81a9c41db35aabee63a88db76234e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAleMacAuthMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAleMacAuthMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable MAC authorization mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAleMacAuthMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2b1f638947d5104ce14b056efe891adf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAleOUIDenyMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAleOUIDenyMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_OUI_DENY=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAleOUIDenyMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac760810f6ef46373dfd04d1f01696a41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAleRateLimit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAleRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable multicast, broadcast rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAleRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga55b447154fa5b4bd846792efb0edc0cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAleTxRateLimit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAleTxRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable Tx rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_RATE_LIMIT_TX=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAleTxRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab269d790a07ccabf17becf070ddf7d3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAleVID0Mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAleVID0Mode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VID0 mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_EN_VID0_MODE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAleVID0Mode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga626526309539b41defa4fdb0b7e1ed2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableAleVlanAware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableAleVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ALE_VLAN_AWARE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableAleVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1504d92274c46f26dc0ffd1b4ef7115f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableFIFOLoopback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableFIFOLoopback</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable FIFO loopback mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableFIFOLoopback ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga462f4858825e94dd81926b37e06d5e16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enablePort0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enablePort0</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enablePort0 ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0f210570bff960321d112639310b21dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enablePort0PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enablePort0PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enablePort0PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga266433bde9484f5e1e3c74c4c490f442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enablePort1PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enablePort1PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enablePort1PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga88a68068d612cd74049dda6dbcb3e7d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enablePort2PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enablePort2PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 2.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enablePort2PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga48814fee30d621d1573cf3f9243244dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_enableVlanAware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_enableVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_enableVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4e8800761f4328690a67131f8eaa4caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#gac08366dceb5ccaea33ad2555f63471d5">CSL_CPSW_3GF_ALE_ADDRTYPE</a> CSL_CPSW_nGF_getALEAddressType </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getALEAddressType</b> </p>
<p><b>Description</b> <br />
 This function returns the address type of an ALE entry.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
*        </pre><p><b> Return Value </b> CSL_CPSW_3GF_ALE_ADDRTYPE <br />
 ALE_ADDRTYPE_UCAST Address at this entry is unicast <br />
 ALE_ADDRTYPE_MCAST Address at this entry is multicast <br />
 ALE_ADDRTYPE_OUI Address at this entry is OUI address</p>
<p><b> Pre Condition </b> <br />
 This function must be called only for an ALE address entry, i.e., if <em>CSL_CPSW_3GF_getALEEntryType</em> () returns ALE_ENTRYTYPE_ADDRESS or ALE_ENTRYTYPE_VLANADDRESS only.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0_REG, CPSW_3GF_ALE_TABLE_WORD1_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_CPSW_nGF_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_nGF_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Unicast address
           }
       }
       else
       {
           // Do nothing
       }

       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga044adeabccadc735c778d93661395034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_getAleControlReg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 ALE control register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      aleCtrlVal;

     aleCtrlVal  =   CSL_CPSW_3GF_getAleControlReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga88fad5821afdd1d5c0c224788160bb37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga6ea23133eb6b1517c106ca3f1a8b7729">CSL_CPSW_3GF_ALE_ENTRYTYPE</a> CSL_CPSW_nGF_getALEEntryType </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getALEEntryType</b> </p>
<p><b>Description</b> <br />
 This function returns the ALE entry type for any given ALE table entry index.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
*        </pre><p><b> Return Value </b> CSL_CPSW_3GF_ALE_ENTRYTYPE <br />
 ALE_ENTRYTYPE_FREE ALE entry is free. <br />
 ALE_ENTRYTYPE_ADDRESS ALE entry contains a unicast/multicast address. <br />
 ALE_ENTRYTYPE_VLAN VLAN ALE entry. <br />
 ALE_ENTRYTYPE_VLANADDRESS VLAN Address Entry.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD1_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;
       if (CSL_CPSW_3GF_getALEEntryType () == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry free
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7431e9c179ade99c805572dc8f0a42e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Multicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pMcastAddrCfg           ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;
       CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_nGF_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_nGF_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
           {
               // Read Multicast address config from hardware
               CSL_CPSW_nGF_getAleMcastAddrEntry (index, &amp;mcastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga376dfb786feccb3d8839de993e1a6b5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleOUIAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_OUIADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOUIAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleOUIAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with OUI address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pOUIAddrCfg             ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_OUIADDR_ENTRY          ouiAddrCfg;

       index   =   0;

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read Unicast address config from hardware
               CSL_CPSW_3GF_getAleOUIAddrEntry (index, &amp;ouiAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7f51b67f4115de4a862d0e426093a744"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAlePortControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_3GF_ALE_PORTCONTROL</a> *&#160;</td>
          <td class="paramname"><em>pPortControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAlePortControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of ALE Port control register corresponding to the port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNo                  Port number for which the ALE port control register
                               must be read.
       pPortControlInfo        CSL_CPSW_3GF_ALE_PORTCONTROL structure that needs to be 
                               filled with Port control register info read from
                               the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_PORT_CONTROL_REG_PORT_STATE, CPSW_3GF_ALE_PORT_CONTROL_REG_DROP_UNTAGGED, CPSW_3GF_ALE_PORT_CONTROL_REG_VID_INGRESS_CHECK, CPSW_3GF_ALE_PORT_CONTROL_REG_NO_LEARN, CPSW_3GF_ALE_PORT_CONTROL_REG_MCAST_LIMIT, CPSW_3GF_ALE_PORT_CONTROL_REG_BCAST_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                          index;
       CSL_CPSW_3GF_ALE_PORTCONTROL    portControlInfo;

       index   =   0;

       CSL_CPSW_3GF_getAlePortControlReg (index, &amp;portControlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab1f08e32adec0042a40f7d7178ba819e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_getAlePrescaleReg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAlePrescaleReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Prescale register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 ALE prescale register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_PRESCALE_REG_ALE_PRESCALE</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      alePrescaleVal;

     alePrescaleVal  =   CSL_CPSW_3GF_getAlePrescaleReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga585fd783a762c30a5e7892ac1f4d98be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleTableEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleTableEntry</b> </p>
<p><b>Description</b> <br />
 This function retrieves an ALE table entry corresponding to the ALE entry index specified in 'index' input parameter. The ALE entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and ALE_TBLW2 registers are returned in 'pAleInfoWd0', 'pAleInfoWd1', 'pAleInfoWd2' output parameters.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pAleInfoWd0             Contents of ALE Table Word 0 Register (ALE_TBLW0).
       pAleInfoWd1             Contents of ALE Table Word 1 Register (ALE_TBLW1).
       pAleInfoWd2             Contents of ALE Table Word 2 Register (ALE_TBLW2).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0_REG_ENTRY_31_0, CPSW_3GF_ALE_TABLE_WORD1_REG_ENTRY_63_32, CPSW_3GF_ALE_TABLE_WORD2_REG_ENTRY_71_64</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      index, info0, info1, info2;

       index   =   0;

       CSL_CPSW_3GF_getAleUnkownVlanReg (index, 
                                         &amp;info0,
                                         &amp;info1,
                                         &amp;info2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga81c04276aea05d61fd9ef20f0e65b5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Unicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pUcastAddrCfg           ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

       index   =   0;

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read Unicast address config from hardware
               CSL_CPSW_3GF_getAleUnicastAddrEntry (index, &amp;ucastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga11f074e431910e45d0e56f42dfca57d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleUnkownVlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnVlanMemList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnRegMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnForceUntagEgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleUnkownVlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Unknown VLAN register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pUnVlanMemList          Unknown VLAN member list.
       pUnMcastFloodMask       Unknown VLAN Multicast flood mask.
       pUnRegMcastFloodMask    Unknown VLAN Registered Multicast Flood mask.
       pUnForceUntagEgress     Unknown VLAN Force Untagged Egress.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_VLAN_MEMBER_LIST, CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_MCAST_FLOOD_MASK, CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_REG_MCAST_FLOOD_MASK, CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_FORCE_UNTAGGED_EGRESS</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

       CSL_CPSW_3GF_getAleUnkownVlanReg (&amp;unVlanMemList, 
                                         &amp;unMcastFloodMask,
                                         &amp;unRegMcastFloodMask,
                                         &amp;unForceUntagEgress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2b8c46e48068fbc688246023d0825a50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleVersionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_e_r_s_i_o_n.html">CSL_CPSW_3GF_ALE_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the ALE submodule identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVersionInfo        CSL_CPSW_3GF_ALE_VERSION structure that needs to be populated
                           with the ALE version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_ID_REG_ALE_MINOR_VER, CPSW_3GF_ALE_ID_REG_ALE_MAJOR_VER, CPSW_3GF_ALE_ID_REG_ALE_IDENT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_3GF_ALE_VERSION    versionInfo;

       CSL_CPSW_3GF_getAleVersionInfo (&amp;versionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3ebde1dea83767796544b736fbdf79f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleVlanEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanCfg                ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_VLAN_ENTRY             vlanCfg;

       index   =   0;

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_VLAN)
       {
           // ALE entry has a VLAN configuration
           CSL_CPSW_3GF_getAleVlanEntry (index, &amp;vlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac69c7e46f82bd4ed800c27127e095681"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleVlanMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleVlanMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN Multicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanMcastAddrCfg       ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
       {
           // ALE entry has a VLAN address

           if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
           {
               // Read VLAN Multicast address config from hardware
               CSL_CPSW_3GF_getAleVlanMcastAddrEntry (index, &amp;vlanMcastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga62b56bc86ed55560cc057438fca2e4b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getAleVlanUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getAleVlanUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN Unicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanUcastAddrCfg       ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
       {
           // ALE entry has a VLAN address

           if (CSL_CPSW_3GF_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read VLAN Unicast address config from hardware
               CSL_CPSW_3GF_getAleVlanUnicastAddrEntry (index, &amp;ucvlanUcastAddrCfgastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa069ea9e0533a16bec5d5d1d2cae9b8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getCppiSourceIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxASrcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxBSrcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getCppiSourceIdReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPPI Source Identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTxASrcId           CPPI Info Word0 Source Id Value on TxA.
       pTxBSrcId           CPPI Info Word0 Source Id Value on TxB.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P0_CPPI_SRC_ID_REG_TXA_SRC_ID, CPSW_3GF_P0_CPPI_SRC_ID_REG_TXB_SRC_ID</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      txASrcId, txBSrcId;

       CSL_CPSW_3GF_getCppiSourceIdReg (&amp;txASrcId, &amp;txBSrcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8057d4b41528352cdb2d4b6a50132f66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getCpswControlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___c_o_n_t_r_o_l.html">CSL_CPSW_3GF_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlRegInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getCpswControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pControlRegInfo     CSL_CPSW_CONTROL structure that needs to be populated
                           with the control register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK, CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE, CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE, CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED, CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED, CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_3GF_CONTROL    controlRegInfo;

       CSL_CPSW_3GF_getCpswControlReg (&amp;controlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac684bb425637bb1a84d99f86cd8cae75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getCpswVersionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___v_e_r_s_i_o_n.html">CSL_CPSW_3GF_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getCpswVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the CPSW identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVersionInfo        CSL_CPSW_3GF_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_CPSW_ID_VER_REG_CPSW_3GF_MINOR_VER, CPSW_3GF_CPSW_ID_VER_REG_CPSW_3GF_MAJ_VER, CPSW_3GF_CPSW_ID_VER_REG_CPSW_3GF_RTL_VER, CPSW_3GF_CPSW_ID_VER_REG_CPSW_3GF_IDENT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_3GF_VERSION    versionInfo;

       CSL_CPSW_3GF_getCpswVersionInfo (&amp;versionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa8aa0b63c612b6c51bcb8230c9fb60bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getEmulationControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pFree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pSoft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getEmulationControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Emulation Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFree                   Emulation free bit read from the hardware.
       pSoft                   Emulation soft bit read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_EM_CONTROL_REG_FREE, CPSW_3GF_EM_CONTROL_REG_SOFT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  free, soft;

       CSL_CPSW_3GF_getEmulationControlReg (&amp;free, &amp;soft);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga425bd0274392efcb4cd51a2306897f5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getFlowControlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___f_l_o_w_c_n_t_l.html">CSL_CPSW_3GF_FLOWCNTL</a> *&#160;</td>
          <td class="paramname"><em>pFlowControlCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getFlowControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Flow control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFlowControlCfg     CSL_CPSW_3GF_FLOWCNTL structure that needs to be populated
                           with contents of Flow control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_FLOW_CONTROL_REG_P0_FLOW_EN, CPSW_3GF_FLOW_CONTROL_REG_P1_FLOW_EN, CPSW_3GF_FLOW_CONTROL_REG_P2_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_3GF_FLOWCNTL       flowControlCfg;

       CSL_CPSW_3GF_getFlowControlReg (&amp;flowControlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3800bf2b724f83627fea70af4f15aaf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_getPort0RxMaxLen </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPort0RxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Receive Maximum Length Register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxLen;

       rxMaxLen    =   CSL_CPSW_3GF_getPort0RxMaxLen ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab99c8c800b562d0b99cd8932efded194"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPort0RxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPort0RxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortRxPriMap           Array of Port 0 Rx priority map priority values 
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortRxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P0_RX_PRI_MAP_REG_PRI0, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI1, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI2, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI3, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI4, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI5, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI6, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      port0RxPriMap [8];

       CSL_CPSW_3GF_getPort0RxPriMapReg (port0RxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab11592d4843e4e53ae81ff57ddf149bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPort0VlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPort0VlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 VLAN Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortVID                Port VLAN Id
       pPortCFI                Port CFI bit
       pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P0_PORT_VLAN_REG_PORT_VID, CPSW_3GF_P0_PORT_VLAN_REG_PORT_CFI, CPSW_3GF_P0_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI;

       CSL_CPSW_3GF_getPort0VlanReg (&amp;portVID, &amp;portCFI, &amp;portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8732447f5a1bad3a7e1b1fc36d364f83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortBlockCountReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxBlkCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxBlkCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortBlockCountReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Block Count register corresponding to the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the block count
                               must be retrieved.
       pRxBlkCnt               Receive block count usage read for this port.                                
       pTxBlkCnt               Transmit block count usage read for this port.                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P_BLK_CNT_REG_RX_BLK_CNT, CPSW_3GF_P_BLK_CNT_REG_TX_BLK_CNT</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxBlkCnt, txBlkCnt, portNum;

       portNum =   1;            

       CSL_CPSW_3GF_getPortBlockCountReg (portNum, &amp;rxBlkCnt, &amp;txBlkCnt);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa8e4fd704500fba61cc096a94fd730cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortMACAddress </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortMACAddress</b> </p>
<p><b>Description</b> <br />
 This function retreives the source MAC address corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the source MAC address
                               must be read and returned.
       pMacAddress             6 byte Source MAC address read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacAddres' must be large enough the 6 byte MAC address returned by this API.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_SL_SA_LO_REG_MACSRCADDR_7_0, CPSW_3GF_SL_SA_LO_REG_MACSRCADDR_15_8, CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_23_16, CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_31_24, CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_39_32, CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_47_40</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint8   macAddress [6], portNum;

       portNum =   1;

       CSL_CPSW_3GF_getPortMACAddress (portNum, macAddress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3ff3094f05868b8de6a730c0fdac9600"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortMaxBlocksReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortMaxBlocksReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Max Blocks Register corresponding to the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the max block numbers
                               must be retrieved.
       pRxMaxBlks              Receive FIFO Maximum blocks read for this port.                                
       pTxMaxBlks              Transmit FIFO Maximum blocks read for this port.                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P_MAX_BLKS_REG_RX_MAX_BLKS, CPSW_3GF_P_MAX_BLKS_REG_TX_MAX_BLKS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum =   1;            

       CSL_CPSW_3GF_getPortMaxBlocksReg (portNum, &amp;rxMaxBlks, &amp;txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga61dbf24cd06c4e23040f2548e89132f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortStatsEnableReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___p_o_r_t_s_t_a_t.html">CSL_CPSW_3GF_PORTSTAT</a> *&#160;</td>
          <td class="paramname"><em>pPortStatsCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortStatsEnableReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Port Statistics Enable register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortStatsCfg       CSL_CPSW_3GF_PORTSTAT structure that needs to be populated
                           with the port statistics enable register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_STAT_PORT_EN_REG_P0A_STAT_EN, CPSW_3GF_STAT_PORT_EN_REG_P0B_STAT_EN, CPSW_3GF_STAT_PORT_EN_REG_P1_STAT_EN, CPSW_3GF_STAT_PORT_EN_REG_P2_STAT_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_3GF_PORTSTAT       portStatsCfg;

       CSL_CPSW_3GF_getPortStatsEnableReg (&amp;portStatsCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8a5ea1377d9190a4ad478cba37c6a985"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortTimeSyncCntlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___t_s_c_n_t_l.html">CSL_CPSW_3GF_TSCNTL</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncCntlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortTimeSyncCntlReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time sync control register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be read.
       pTimeSyncCntlCfg        CSL_CPSW_3GF_TSCNTL that needs to be populated with 
                               contents of time sync control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P_TS_CTL_REG_TS_RX_EN, CPSW_3GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, CPSW_3GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, CPSW_3GF_P_TS_CTL_REG_TS_TX_EN, CPSW_3GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, CPSW_3GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, CPSW_3GF_P_TS_CTL_REG_TX_MSG_TYPE_EN_15_0</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_3GF_TSCNTL     tsCtlCfg;

       portNum =   1;

       CSL_CPSW_3GF_getPortTimeSyncCntlReg (portNum, &amp;tsCtlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafb880b0a03537f4d9526c1ef84b1b2a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortTimeSyncSeqIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsLtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsSeqIdOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortTimeSyncSeqIdReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time Sync Sequence Id and LTYPE register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be read.
       pTsLtype                Time sync LTYPE read.
       pTsSeqIdOffset          Time sync sequence Id offset read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P_TS_SEQ_LTYPE_REG_TS_LTYPE, CPSW_3GF_P_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype, tsSeqIdOffset;

       portNum =   1;

       CSL_CPSW_3GF_getPortTimeSyncSeqIdReg (portNum, &amp;tsLtype, &amp;tsSeqIdOffset);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga62da595c6b0a2a3058d6f7e5cc934945"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortTimeSyncVlanLTypeReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsVlanLtype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsVlanLtype2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortTimeSyncVlanLTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time Sync VLAN LTYPE register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be read.
       pTsVlanLtype1           Time sync VLAN LTYPE1 value read.
       pTsVlanLtype2           Time sync VLAN LTYPE2 value read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, CPSW_3GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype1, tsLtype2;

       portNum =   1;

       CSL_CPSW_3GF_getPortTimeSyncVlanLTypeReg (portNum, &amp;tsLtype1, &amp;tsLtype2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga946261bef9e67bafb70543a127c315a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortTxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortTxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Transmit Header Priority to Switch Priority Mapping Register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register contents
                               must be read and returned.
       pPortTxPriMap           Array of Port Tx priority map priority values 
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortTxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P_TX_PRI_MAP_REG_PRI0, CPSW_3GF_P_TX_PRI_MAP_REG_PRI1, CPSW_3GF_P_TX_PRI_MAP_REG_PRI2, CPSW_3GF_P_TX_PRI_MAP_REG_PRI3, CPSW_3GF_P_TX_PRI_MAP_REG_PRI4, CPSW_3GF_P_TX_PRI_MAP_REG_PRI5, CPSW_3GF_P_TX_PRI_MAP_REG_PRI6, CPSW_3GF_P_TX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portTxPriMap [8], portNum;

       portNum =   1;

       CSL_CPSW_3GF_getPortTxPriMapReg (portNum, portTxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8744df18a0df73376949a8d7a12dc74a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPortVlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPortVlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the VLAN Register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the VLAN register 
                               contents must be read
       pPortVID                Port VLAN Id
       pPortCFI                Port CFI bit
       pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_P_PORT_VLAN_REG_PORT_VID, CPSW_3GF_P_PORT_VLAN_REG_PORT_CFI, CPSW_3GF_P_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI, portNum;

       portNum =   2;

       CSL_CPSW_3GF_getPortVlanReg (portNum, &amp;portVID, &amp;portCFI, &amp;portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga271e7d197a40ebfb6e91064138d4e16b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getPrioTypeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___p_t_y_p_e.html">CSL_CPSW_3GF_PTYPE</a> *&#160;</td>
          <td class="paramname"><em>pTypeCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getPrioTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Priority Type register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTypeCfg            CSL_CPSW_3GF_PTYPE structure that needs to be populated
                           with the priority type register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_PTYPE_REG_ESC_PRI_LD_VAL, CPSW_3GF_PTYPE_REG_P0_PTYPE_ESC, CPSW_3GF_PTYPE_REG_P1_PTYPE_ESC, CPSW_3GF_PTYPE_REG_P2_PTYPE_ESC</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_3GF_PTYPE       pTypeCfg;

       CSL_CPSW_3GF_getPrioTypeReg (&amp;pTypeCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4e3a33bf6891e6ffc86fdaeb702b3553"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_getShortGapThreshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getShortGapThreshold</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW MAC Short Gap Threshold register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 MAC short gap threshold value read from the hardware.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_GAP_THRESH_CPGMAC_SL_REG_GAP_THRESH</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          gapThreshVal;

       gapThreshVal    =   CSL_CPSW_3GF_getShortGapThreshold ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac907d51b0add04a788c8ecc359e13492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_getStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___s_t_a_t_s.html">CSL_CPSW_3GF_STATS</a> *&#160;</td>
          <td class="paramname"><em>pCpswStats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getStats</b> </p>
<p><b>Description</b> <br />
 The CPSW stats are divided into 2 blocks, i.e., Stats for Host port (switch Port 0) and Stats for MAC ports (Port 1 and Port2). This function retreives hardware statistics for both the stat blocks.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCpswStats              Array of CSL_CPSW_3GF_STATS structure that needs to be filled
                               with the stats read from the hardware. This function expects
                               that the array passed to it is big enough to hold the stats
                               for both stat blocks, i.e., size of array passed to this 
                               function must be 2.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_RXGOODFRAMES, CPSW_RXBROADCASTFRAMES, CPSW_RXMULTICASTFRAMES, CPSW_RXPAUSEFRAMES, CPSW_RXCRCERRORS, CPSW_RXALIGNCODEERRORS, CPSW_RXOVERSIZEDFRAMES, CPSW_RXJABBERFRAMES, CPSW_RXUNDERSIZEDFRAMES, CPSW_RXFRAGMENTS, CPSW_RXOCTETS, CPSW_TXGOODFRAMES, CPSW_TXBROADCASTFRAMES, CPSW_TXMULTICASTFRAMES, CPSW_TXPAUSEFRAMES, CPSW_TXDEFERREDFRAMES, CPSW_TXCOLLISIONFRAMES, CPSW_TXSINGLECOLLFRAMES, CPSW_TXMULTCOLLFRAMES, CPSW_TXEXCESSIVECOLLISIONS, CPSW_TXLATECOLLISIONS, CPSW_TXUNDERRUN, CPSW_TXCARRIERSENSEERRORS, CPSW_TXOCTETS, CPSW_OCTETFRAMES64, CPSW_OCTETFRAMES65T127, CPSW_OCTETFRAMES128T255, CPSW_OCTETFRAMES256T511, CPSW_OCTETFRAMES512T1023, CPSW_OCTETFRAMES1024TUP, CPSW_NETOCTETS, CPSW_RXSOFOVERRUNS, CPSW_RXMOFOVERRUNS, CPSW_RXDMAOVERRUNS</p>
<p><b>Affects</b> <br />
 CPSW_RXGOODFRAMES=0, CPSW_RXBROADCASTFRAMES=0, CPSW_RXMULTICASTFRAMES=0, CPSW_RXPAUSEFRAMES=0, CPSW_RXCRCERRORS=0, CPSW_RXALIGNCODEERRORS=0, CPSW_RXOVERSIZEDFRAMES=0, CPSW_RXJABBERFRAMES=0, CPSW_RXUNDERSIZEDFRAMES=0, CPSW_RXFRAGMENTS=0, CPSW_RXOCTETS=0, CPSW_TXGOODFRAMES=0, CPSW_TXBROADCASTFRAMES=0, CPSW_TXMULTICASTFRAMES=0, CPSW_TXPAUSEFRAMES=0, CPSW_TXDEFERREDFRAMES=0, CPSW_TXCOLLISIONFRAMES=0, CPSW_TXSINGLECOLLFRAMES=0, CPSW_TXMULTCOLLFRAMES=0, CPSW_TXEXCESSIVECOLLISIONS=0, CPSW_TXLATECOLLISIONS=0, CPSW_TXUNDERRUN=0, CPSW_TXCARRIERSENSEERRORS=0, CPSW_TXOCTETS=0, CPSW_OCTETFRAMES64=0, CPSW_OCTETFRAMES65T127=0, CPSW_OCTETFRAMES128T255=0, CPSW_OCTETFRAMES256T511=0, CPSW_OCTETFRAMES512T1023=0, CPSW_OCTETFRAMES1024TUP=0, CPSW_NETOCTETS=0, CPSW_RXSOFOVERRUNS=0, CPSW_RXMOFOVERRUNS=0, CPSW_RXDMAOVERRUNS=0</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_3GF_STATS     stats [2];

       CSL_CPSW_3GF_getStats (stats);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5fbcc27f8427142c909cbd4f69cc9b58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_getTxStartWordsReg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_getTxStartWordsReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Transmit FIFO start words register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_TX_START_WDS_REG_TX_START_WDS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          startWordsVal;

       startWordsVal   =   CSL_CPSW_3GF_getTxStartWordsReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga98f71262fb7194854a6e4df8aa18c132"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleAgeOutDone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleAgeOutDone</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE control register's AGE_OUT_NOW bit to check if the ALE ageable entry cleanup process is done.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE age out process done. <br />
 FALSE ALE age out process not yet completed.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_AGE_OUT_NOW</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleAgeOutDone ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf8bf3200fe173c4d9e08c7b2a19a72bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleBypassEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleBypassEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Bypass mode enabled. <br />
 FALSE ALE Bypass mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ALE_BYPASS</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleBypassEnabled () == TRUE)
     {
         // ALE Bypass mode on
     }
     else
     {
         // ALE Bypass mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf9b4c7f02f4af6452e9cb3bd2311ae7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE processing is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE enabled. ALE packet processing will be done. <br />
 FALSE ALE disabled. All packets are dropped by ALE.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_ALE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleEnabled () == TRUE)
     {
         // ALE enabled
     }
     else
     {
         // ALE disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga99caac59069289b4b3b7d4fffe28d412"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleLearnNoVIDEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleLearnNoVIDEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to not learn VLAN Ids.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Learn no VID enabled. VLAN Id is not learned with source address (source address is not tied to VID) <br />
 FALSE ALE VID learning mode enabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_LEARN_NO_VID</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleLearnNoVIDEnabled () == TRUE)
     {
         // ALE VID learning disabled
     }
     else
     {
         // ALE VID learning enabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa3359532458a65f4b8ae82cf558515b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleMacAuthModeEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleMacAuthModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE MAC Authorization mode is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE is in MAC authorization mode. <br />
 FALSE ALE not in MAC authorization mode.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleMacAuthModeEnabled () == TRUE)
     {
         // ALE  is in MAC authorization mode
     }
     else
     {
         // ALE not in MAC authorization mode
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae457368aa6e09ecc4475f942a154f09a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleOUIDenyModeEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleOUIDenyModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE OUI deny mode enabled. <br />
 FALSE ALE OUI deny mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_OUI_DENY</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleOUIDenyModeEnabled () == TRUE)
     {
         // ALE OUI deny mode on
     }
     else
     {
         // ALE OUI deny mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga67010ed3cf68c53653ba3745d14a30de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleRateLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleRateLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE Broadcast and Multicast Rate Limit is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Broadcast and multicast rate limit enabled. Broadcast/multicast packet reception limited to port control register rate limit fields. <br />
 FALSE ALE Broadcast and multicast rate limit disabled. Broadcast/multicast rates not limited.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleRateLimitEnabled () == TRUE)
     {
         // ALE Broadcast/Multicast rate limit enabled
     }
     else
     {
         // ALE Broadcast/Multicast rate limit disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae5bf6034893cdf161624abd77b86d91d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleTxRateLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleTxRateLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be Tx rate limited.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Tx rate limit enabled. Broadcast, multicast rate limit counters are transmit port based. <br />
 FALSE ALE Tx rate limit disabled. Broadcast, multicast rate limit counters are receive port based.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_RATE_LIMIT_TX</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleTxRateLimitEnabled () == TRUE)
     {
         // ALE Tx rate limit on
     }
     else
     {
         // ALE Tx rate limit off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad5ce4568d410713b8eba2ea4f65da5db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleVID0ModeEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleVID0ModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in VID0 (VLAN ID=0) mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE VID0 mode enabled. Process the packet with VLAN Id = 0 <br />
 FALSE ALE VID0 mode disabled. Process the packet with VLAN Id =PORT_VLAN[11-0]</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_EN_VID0_MODE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleVID0ModeEnabled () == TRUE)
     {
         // ALE VID0 mode on
     }
     else
     {
         // ALE VID0 mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad0cf904131749b6d45f9c8bfa4871ffb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isAleVlanAwareEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isAleVlanAwareEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be VLAN aware.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE VLAN aware. ALE drops packets if VLAN not found. <br />
 FALSE ALE not VLAN aware. Floods if VLAN not found.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_ALE_VLAN_AWARE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isAleVlanAwareEnabled () == TRUE)
     {
         // ALE VLAN aware
     }
     else
     {
         // ALE not VLAN aware
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga99f11cbd345f77b2eaa3296173d63719"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isFIFOLoopbackEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isFIFOLoopbackEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if FIFO loopback mode is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE FIFO loopback mode enabled. Each packet received is turned around and sent out on the same port's transmit path. <br />
 FALSE FIFO loopback mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isFIFOLoopbackEnabled (portNum) == TRUE)
     {
         // FIFO loopback mode enabled
     }
     else
     {
         // FIFO loopback mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5e3bc20295b66b73ba99fefc2f9d5846"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isPort0Enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isPort0Enabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if CPPI Port (Port 0) is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 0 enabled. <br />
 FALSE Port 0 disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isPort0Enabled (portNum) == TRUE)
     {
         // Port 0 enabled
     }
     else
     {
         // Port 0 disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4ba9d022b4a64e407fbbcae006dc5337"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isPort0PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isPort0PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 0 ingress priority tagging enabled. <br />
 FALSE Port 0 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isPort0PassPriTagEnabled (portNum) == TRUE)
     {
         // Port 0 pass priority tagging enabled
     }
     else
     {
         // Port 0 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4cb47b0913ad65ccef8a1de3e93344d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isPort1PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isPort1PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 1 ingress priority tagging enabled. <br />
 FALSE Port 1 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isPort1PassPriTagEnabled (portNum) == TRUE)
     {
         // Port 1 pass priority tagging enabled
     }
     else
     {
         // Port 1 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3ee77b52b000f824746d964e79885932"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isPort2PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isPort2PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 2.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 2 ingress priority tagging enabled. <br />
 FALSE Port 2 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isPort2PassPriTagEnabled (portNum) == TRUE)
     {
         // Port 2 pass priority tagging enabled
     }
     else
     {
         // Port 2 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga06d3fac4e15319a7729dc75a606b1211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_nGF_isVlanAwareEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_isVlanAwareEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if VLAN aware mode is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE VLAN aware mode enabled. <br />
 FALSE VLAN aware mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_3GF_isVlanAwareEnabled (portNum) == TRUE)
     {
         // VLAN aware mode enabled
     }
     else
     {
         // VLAN aware mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7656fb88e412a3887cacaf84cfc19ec6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleCtrlVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       aleCtrlVal          Value to be configured to the ALE control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          aleCtrlVal = 0;

       aleCtrlVal      =   CSL_CPSW_3GF_getAleControlReg ();
       aleCtrlVal      |=  CSL_CPSW_3GF_ALECONTROL_CLRTABLE_EN;

       CSL_CPSW_3GF_setAleControlReg (&amp;aleCtrlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga64db227999c367609b721132da4673fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Multicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pMcastAddrCfg           ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;
       CSL_CPSW_3GF_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

       index   =   0;
       mcastAddrCfg.macAddress [0] = 0x00;
       mcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Multicast address entry
           CSL_CPSW_3GF_setAleMcastAddrEntry (index, &amp;mcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab17c39c7d14f964b98096b79f4ed7e10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleOUIAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_OUIADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOUIAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleOUIAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with OUI address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pOUIAddrCfg             ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_OUIADDR_ENTRY          ouiAddrCfg;

       index   =   0;
       ouiAddrCfg.ouiAddress [0] = 0x00;
       ouiAddrCfg.ouiAddress [1] = 0x01;
       ...

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add OUI address entry
           CSL_CPSW_3GF_setAleOUIAddrEntry (index, &amp;ouiAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab3160490c752cfeede4e3aac8e04563a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAlePortControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_3GF_ALE_PORTCONTROL</a> *&#160;</td>
          <td class="paramname"><em>pPortControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAlePortControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of ALE Port control register corresponding to the port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNo                  Port number for which the ALE port control register
                               must be configured.
       pPortControlInfo        CSL_CPSW_3GF_ALE_PORTCONTROL structure that contains 
                               port control register settings to be written.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_PORT_CONTROL_REG_PORT_STATE, CPSW_3GF_ALE_PORT_CONTROL_REG_DROP_UNTAGGED, CPSW_3GF_ALE_PORT_CONTROL_REG_VID_INGRESS_CHECK, CPSW_3GF_ALE_PORT_CONTROL_REG_NO_LEARN, CPSW_3GF_ALE_PORT_CONTROL_REG_MCAST_LIMIT, CPSW_3GF_ALE_PORT_CONTROL_REG_BCAST_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                          index;
       CSL_CPSW_3GF_ALE_PORTCONTROL    portControlInfo;

       index   =   0;
       portControlInfo.portState   =   ALE_PORTSTATE_FORWARD |
                                       ALE_PORTSTATE_LEARN;

       CSL_CPSW_3GF_setAlePortControlReg (index, &amp;portControlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7a62f4df843a0a92ab4c7168f74e0bdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAlePrescaleReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>alePrescaleVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAlePrescaleReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE prescale register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       alePrescaleVal      Value to be configured to the ALE Prescale register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_PRESCALE_REG_ALE_PRESCALE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          alePrescaleVal = 0;

       alePrescaleVal  =   10;

       CSL_CPSW_3GF_setAlePrescaleReg (&amp;aleCtrlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0660506478ce3fa65eea13cf4555b5e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleTableEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleTableEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up an ALE table entry corresponding to the ALE entry index specified in 'index' input parameter. The ALE entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and ALE_TBLW2 registers msut be specified in 'aleInfoWd0', 'aleInfoWd1', 'aleInfoWd2' input parameters.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be written.
       aleInfoWd0              Value to write to ALE Table Word 0 Register (ALE_TBLW0).
       aleInfoWd1              Value to write to Table Word 1 Register (ALE_TBLW1).
       aleInfoWd2              Value to write to ALE Table Word 2 Register (ALE_TBLW2).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_WORD0_REG_ENTRY_31_0, CPSW_3GF_ALE_TABLE_WORD1_REG_ENTRY_63_32, CPSW_3GF_ALE_TABLE_WORD2_REG_ENTRY_71_64, CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       Uint32      index, info0, info1, info2;

       index   =   0;
       info0   =   ...;
       info1   =   ...;
       info2   =   ...;

       CSL_CPSW_3GF_setAleTableEntry (index, 
                                         info0,
                                         info1,
                                         info2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga53ebac3a15491336c53fc6ee33b80487"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with unicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pUcastAddrCfg           ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

       index   =   0;
       ucastAddrCfg.macAddress [0] = 0x00;
       ucastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Unicast address entry
           CSL_CPSW_3GF_setAleUnicastAddrEntry (index, &amp;ucastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad4d9db20150cd538fd041ea93f987624"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleUnkownVlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unVlanMemList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unRegMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unForceUntagEgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleUnkownVlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE Unknown VLAN register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       unVlanMemList           Unknown VLAN member list.
       unMcastFloodMask        Unknown VLAN Multicast flood mask.
       unRegMcastFloodMask     Unknown VLAN Registered Multicast Flood mask.
       unForceUntagEgress      Unknown VLAN Force Untagged Egress.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_VLAN_MEMBER_LIST, CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_MCAST_FLOOD_MASK, CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_REG_MCAST_FLOOD_MASK, CPSW_3GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_FORCE_UNTAGGED_EGRESS</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

       unVlanMemList           =   0;
       unMcastFloodMask        =   3;
       unRegMcastFloodMask     =   0;
       unForceUntagEgress      =   0;

       CSL_CPSW_3GF_setAleUnkownVlanReg (unVlanMemList, 
                                         unMcastFloodMask,
                                         unRegMcastFloodMask,
                                         unForceUntagEgress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga69573437c1a37e884631b0b64a538074"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleVlanEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanCfg                ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_VLAN_ENTRY             vlanCfg;

       index   =   0;
       vlanCfg.vlanId  = 0x10;
       ...

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN entry
           CSL_CPSW_3GF_setAleVlanEntry (index, &amp;vlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf59c6486ad2ca7ec897d06c739640415"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleVlanMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleVlanMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN Multicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanMcastAddrCfg       ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

       index   =   0;
       vlanMcastAddrCfg.macAddress [0] = 0x00;
       vlanMcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN Multicast address entry
           CSL_CPSW_3GF_setAleVlanMcastAddrEntry (index, &amp;vlanMcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga79a8ac13ca1867897fb5dfd0cfb9afdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setAleVlanUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setAleVlanUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN unicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanUcastAddrCfg       ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_3GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_3GF_ALE_TABLE_WORD0, CPSW_3GF_ALE_TABLE_WORD1, CPSW_3GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_3GF_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

       index   =   0;
       vlanUcastAddrCfg.macAddress [0] = 0x00;
       vlanUcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_3GF_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN Unicast address entry
           CSL_CPSW_3GF_setAleVlanUnicastAddrEntry (index, &amp;vlanUcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad592f12b004195efb03740b2f9ede6bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setCppiSourceIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txASrcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txBSrcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setCppiSourceIdReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPPI Source Identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       txASrcId            CPPI Source Id to configure for TxA.
       txBSrcId            CPPI Source Id to configure for TxB.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P0_CPPI_SRC_ID_REG_TXA_SRC_ID, CPSW_3GF_P0_CPPI_SRC_ID_REG_TXB_SRC_ID</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      txASrcId, txBSrcId;

       txASrcId    =   1;
       txBSrcId    =   2;

       CSL_CPSW_3GF_setCppiSourceIdReg (txASrcId, txBSrcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac49222fc0f134cbecc0695786190d63b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setCpswControlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___c_o_n_t_r_o_l.html">CSL_CPSW_3GF_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlRegInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setCpswControlReg</b> </p>
<p><b>Description</b> <br />
 This function populates the contents of the CPSW Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pControlRegInfo     CSL_CPSW_CONTROL structure that holds the values 
                           that need to be configured to the CPSW control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CPSW control register modified with values provided.</p>
<p><b>Writes</b> <br />
 CPSW_3GF_CPSW_CONTROL_REG_FIFO_LOOPBACK, CPSW_3GF_CPSW_CONTROL_REG_VLAN_AWARE, CPSW_3GF_CPSW_CONTROL_REG_P0_ENABLE, CPSW_3GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED, CPSW_3GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED, CPSW_3GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_3GF_CONTROL    controlRegInfo;

       controlRegInfo.fifoLb       =   1;
       controlRegInfo.vlanAware    =   0;
       ...

       CSL_CPSW_3GF_setCpswControlReg (&amp;controlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae6b837c4070c7fbf57adecc26a7c81e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setEmulationControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>soft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setEmulationControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Emulation Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       free                   Emulation free bit configuration
       soft                   Emulation soft bit configuration
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_EM_CONTROL_REG_FREE, CPSW_3GF_EM_CONTROL_REG_SOFT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 free, soft;

       free   =   0;
       soft   =   1;

       CSL_CPSW_3GF_setEmulationControlReg (free, soft);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga69bc75a889ffaeb8a5eaeb025122e833"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setFlowControlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___f_l_o_w_c_n_t_l.html">CSL_CPSW_3GF_FLOWCNTL</a> *&#160;</td>
          <td class="paramname"><em>pFlowControlCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setFlowControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Flow control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFlowControlCfg     CSL_CPSW_3GF_FLOWCNTL structure that contains the values
                           that need to be configured to Flow control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_FLOW_CONTROL_REG_P0_FLOW_EN, CPSW_3GF_FLOW_CONTROL_REG_P1_FLOW_EN, CPSW_3GF_FLOW_CONTROL_REG_P2_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_3GF_FLOWCNTL       flowControlCfg;

       flowControlCfg.p0FlowEnable =   1;
       flowControlCfg.p1FlowEnable =   1;:
       flowControlCfg.p2FlowEnable =   1;

       CSL_CPSW_3GF_setFlowControlReg (&amp;flowControlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf588feb52603f246e9a20f30cfadc8b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPort0RxMaxLen </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxLen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPort0RxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function sets up the Port0 Receive Maximum length register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       rxMaxLen            Maximum receive frame length to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxLen;

       rxMaxLen    =   1518;            

       CSL_CPSW_3GF_setPort0RxMaxLen (rxMaxLen);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0c27e0710363f941927e1425dc5537e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPort0RxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPort0RxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port 0 Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortRxPriMap           Array of Port 0 Rx priority map priority values 
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P0_RX_PRI_MAP_REG_PRI0, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI1, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI2, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI3, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI4, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI5, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI6, CPSW_3GF_P0_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      i, port0RxPriMap [8];

       for (i = 0; i &lt; 8; i ++)
           port0RxPriMap [i] = i;

       CSL_CPSW_3GF_setPort0RxPriMapReg (port0RxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa85a0c35c6570082e4c85388b27bd95d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPort0VlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPort0VlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port 0 VLAN Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portVID                 Port VLAN Id to be configured
       portCFI                 Port CFI bit to be configured
       portPRI                 Port VLAN priority to be configured
                               (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P0_PORT_VLAN_REG_PORT_VID, CPSW_3GF_P0_PORT_VLAN_REG_PORT_CFI, CPSW_3GF_P0_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI;

       portVID     =   1;
       portCFI     =   0;
       portPRI     =   7;

       CSL_CPSW_3GF_setPort0VlanReg (portVID, portCFI, portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga84b25c97701878540efb1747b7fdf91b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPortMACAddress </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPortMACAddress</b> </p>
<p><b>Description</b> <br />
 This function sets up the source MAC address corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the source MAC address
                               must be setup.
       pMacAddress             6 byte Source MAC address to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacAddres' is expected to be 6 bytes long.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_SL_SA_LO_REG_MACSRCADDR_7_0, CPSW_3GF_SL_SA_LO_REG_MACSRCADDR_15_8, CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_23_16, CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_31_24, CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_39_32, CPSW_3GF_SL_SA_HI_REG_MACSRCADDR_47_40</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint8   macAddress [6], portNum;

       portNum         =   1;
       macAddress [0]  =   0x01;
       macAddress [1]  =   0x02;
       macAddress [2]  =   0x03;
       macAddress [3]  =   0x04;
       macAddress [4]  =   0x05;
       macAddress [5]  =   0x06;

       CSL_CPSW_3GF_setPortMACAddress (portNum, macAddress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0fbac51ff633f41f6911f8b47472a2dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPortMaxBlocksReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPortMaxBlocksReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Max Blocks Register corresponding to the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the max block numbers
                               must be configured.
       rxMaxBlks               Maximum number of 4K memory blocks that must be allocated
                               for the port's FIFO logical receive priority queues.
       txMaxBlks               Maximum number of 4K memory blocks that must be allocated
                               for the port's FIFO logical transmit priority queues.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P_MAX_BLKS_REG_RX_MAX_BLKS, CPSW_3GF_P_MAX_BLKS_REG_TX_MAX_BLKS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum     =   1;            
       rxMaxBlks   =   3;
       txMaxBlks   =   17;

       CSL_CPSW_3GF_getPortMaxBlocksReg (portNum, rxMaxBlks, txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab65317608a8fbf31c5134eef569c32ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPortStatsEnableReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___p_o_r_t_s_t_a_t.html">CSL_CPSW_3GF_PORTSTAT</a> *&#160;</td>
          <td class="paramname"><em>pPortStatsCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPortStatsEnableReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Port Statistics Enable register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortStatsCfg       CSL_CPSW_3GF_PORTSTAT structure that contains the values
                           to be used to setup port statistics enable register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_STAT_PORT_EN_REG_P0A_STAT_EN, CPSW_3GF_STAT_PORT_EN_REG_P0B_STAT_EN, CPSW_3GF_STAT_PORT_EN_REG_P1_STAT_EN, CPSW_3GF_STAT_PORT_EN_REG_P2_STAT_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_3GF_PORTSTAT       portStatsCfg;

       portStatsCfg.p0AStatEnable  =   1;
       portStatsCfg.p0BStatEnable  =   1;
       portStatsCfg.p1StatEnable   =   1;
       portStatsCfg.p2StatEnable   =   1;

       CSL_CPSW_3GF_setPortStatsEnableReg (&amp;portStatsCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0fcf90e2dcdf3e59d6708d55faf8cae7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPortTimeSyncCntlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___t_s_c_n_t_l.html">CSL_CPSW_3GF_TSCNTL</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncCntlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPortTimeSyncCntlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time sync control register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be 
                               configured.
       pTimeSyncCntlCfg        CSL_CPSW_3GF_TSCNTL containing settings for time
                               sync control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P_TS_CTL_REG_TS_RX_EN, CPSW_3GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, CPSW_3GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, CPSW_3GF_P_TS_CTL_REG_TS_TX_EN, CPSW_3GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, CPSW_3GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, CPSW_3GF_P_TS_CTL_REG_TX_MSG_TYPE_EN_15_0</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_3GF_TSCNTL     tsCtlCfg;

       portNum =   1;

       tsCtlCfg.tsRxEnable             =   1;
       tsCtlCfg.tsRxVlanLType1Enable   =   0;
       tsCtlCfg.tsRxVlanLType2Enable   =   0;
       ...

       CSL_CPSW_3GF_setPortTimeSyncCntlReg (portNum, &amp;tsCtlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gababdd83dacf5f9a736a92c454e33117b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPortTimeSyncSeqIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsLtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsSeqIdOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPortTimeSyncSeqIdReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time Sync Sequence Id and LTYPE register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be 
                               configured.
       tsLtype                 Time sync LTYPE to be configured.
       tsSeqIdOffset           Time sync sequence Id offset to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P_TS_SEQ_LTYPE_REG_TS_LTYPE, CPSW_3GF_P_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype, tsSeqIdOffset;

       portNum         =   1;
       tsLtype         =   0;
       tsSeqIdOffset   =   30;

       CSL_CPSW_3GF_getPortTimeSyncSeqIdReg (portNum, tsLtype, tsSeqIdOffset);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacd4ad0e2589561aa1ad954fc48b3e1ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPortTimeSyncVlanLTypeReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsVlanLtype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsVlanLtype2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPortTimeSyncVlanLTypeReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time Sync VLAN LTYPE register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be read.
       tsVlanLtype1            Time sync VLAN LTYPE1 value to be configured.
       tsVlanLtype2            Time sync VLAN LTYPE2 value to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, CPSW_3GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype1, tsLtype2;

       portNum     =   1;
       tsLtype1    =   0x8100;
       tsLtype2    =   0x8100;

       CSL_CPSW_3GF_setPortTimeSyncVlanLTypeReg (portNum, &amp;tsLtype1, &amp;tsLtype2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3f8d4a1e32a6b8527561810cf5a87c96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPortTxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPortTxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Transmit Header Priority to Switch Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register contents
                               must be configured.
       pPortTxPriMap           Array of Port Tx priority map priority values 
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P_TX_PRI_MAP_REG_PRI0, CPSW_3GF_P_TX_PRI_MAP_REG_PRI1, CPSW_3GF_P_TX_PRI_MAP_REG_PRI2, CPSW_3GF_P_TX_PRI_MAP_REG_PRI3, CPSW_3GF_P_TX_PRI_MAP_REG_PRI4, CPSW_3GF_P_TX_PRI_MAP_REG_PRI5, CPSW_3GF_P_TX_PRI_MAP_REG_PRI6, CPSW_3GF_P_TX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      i, portTxPriMap [8], portNum;

       for (i = 0; i &lt; 8; i ++)
           portTxPriMap [i] = i;

       portNum =   1;            

       CSL_CPSW_3GF_setPortTxPriMapReg (portNum, portTxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5fa080d5436e8487bdb82006152a3ea7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPortVlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPortVlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the VLAN Register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the VLAN register 
                               must be configured.
       portVID                 Port VLAN Id to be configured
       portCFI                 Port CFI bit to be configured
       portPRI                 Port VLAN priority to be configured
                               (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_P_PORT_VLAN_REG_PORT_VID, CPSW_3GF_P_PORT_VLAN_REG_PORT_CFI, CPSW_3GF_P_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI, portNum;
   
       portNum     =   2;
       portVID     =   1;
       portCFI     =   0;
       portPRI     =   7;

       CSL_CPSW_3GF_setPortVlanReg (portNum, portVID, portCFI, portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab9a4e5175790f814be4882d11311b2e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setPrioTypeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w__3_g_f___p_t_y_p_e.html">CSL_CPSW_3GF_PTYPE</a> *&#160;</td>
          <td class="paramname"><em>pTypeCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setPrioTypeReg</b> </p>
<p><b>Description</b> <br />
 This function modifies the contents of the CPSW Priority Type register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTypeCfg            CSL_CPSW_3GF_PTYPE structure that contains the values that
                           need to be populated to Priority type register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_PTYPE_REG_ESC_PRI_LD_VAL, CPSW_3GF_PTYPE_REG_P0_PTYPE_ESC, CPSW_3GF_PTYPE_REG_P1_PTYPE_ESC, CPSW_3GF_PTYPE_REG_P2_PTYPE_ESC</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_3GF_PTYPE       pTypeCfg;

       pTypeCfg.escPriLdVal    =   1;
       pTypeCfg.p0PtypeEsc     =   1;
       ...

       CSL_CPSW_3GF_setPrioTypeReg (&amp;pTypeCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2e2834a6becb4c2f5f0be82ca1816fb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setShortGapThreshold </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>gapThreshVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setShortGapThreshold</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW MAC Short Gap Threshold register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       gapThreshVal        Gap threshold value to use to configure the MAC Short
                           gap threshold value.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_GAP_THRESH_CPGMAC_SL_REG_GAP_THRESH</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          gapThreshVal;
*
*      gapThreshVal    =   11;

       CSL_CPSW_3GF_setShortGapThreshold (gapThreshVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1807bee7b2657d2ae64b338108fefe2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_setTxStartWordsReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>startWordsVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_setTxStartWordsReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Transmit FIFO start words register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pStartWordsVal      Start words value to be set to the Transmit FIFO start
                           words register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_TX_START_WDS_REG_TX_START_WDS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          startWordsVal;
*
*      startWordsVal   =   32;

       CSL_CPSW_3GF_setTxStartWordsReg (startWordsVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf77a6b2a6617a4f1a663ab8ae5349537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_nGF_startAleAgeOutNow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_3GF_startAleAgeOutNow</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to initiate an ALE ageable entry cleanup. This enables the ALE hardware to remove any ageable table entry that does not have a set touch bit.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3GF_ALE_CONTROL_REG_AGE_OUT_NOW=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_3GF_startAleAgeOutNow ();</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
