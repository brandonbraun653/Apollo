<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EDMA3 Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EDMA3 Functions<div class="ingroups"><a class="el" href="group___c_s_l___e_d_m_a3___a_p_i.html">EDMA3</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae61cc100cdf1d62f35787426ca2b342d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gae61cc100cdf1d62f35787426ca2b342d">CSL_edma3GetInfo</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga57808bce667ae4dd7e46a849b68f83ac">CSL_Edma3QueryInfo</a> *response)</td></tr>
<tr class="separator:gae61cc100cdf1d62f35787426ca2b342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e8100aa3db1c61e789d74fb992e4a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga57e8100aa3db1c61e789d74fb992e4a5">CSL_edma3MapDMAChannelToParamBlock</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Uint16 paramId)</td></tr>
<tr class="separator:ga57e8100aa3db1c61e789d74fb992e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44779b99a16d35cc4b88944cec22514e"><td class="memItemLeft" align="right" valign="top">static Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga44779b99a16d35cc4b88944cec22514e">CSL_edma3GetDMAChannelToParamBlockMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga44779b99a16d35cc4b88944cec22514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e25de939e1bcb1f714be5378058d9a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0e25de939e1bcb1f714be5378058d9a7">CSL_edma3MapQDMAChannelToParamBlock</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Uint16 paramId)</td></tr>
<tr class="separator:ga0e25de939e1bcb1f714be5378058d9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea0f5fb5768df2b80b10eaf8ea287d59"><td class="memItemLeft" align="right" valign="top">static Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaea0f5fb5768df2b80b10eaf8ea287d59">CSL_edma3GetQDMAChannelToParamBlockMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel)</td></tr>
<tr class="separator:gaea0f5fb5768df2b80b10eaf8ea287d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7627ac0aea91aa666b330d01c51e1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga6f7627ac0aea91aa666b330d01c51e1e">CSL_edma3SetQDMATriggerWord</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Uint8 trword)</td></tr>
<tr class="separator:ga6f7627ac0aea91aa666b330d01c51e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e8af206fafb44fe5b4233eb30bb205"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gab3e8af206fafb44fe5b4233eb30bb205">CSL_edma3GetQDMATriggerWord</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Uint8 *trword)</td></tr>
<tr class="separator:gab3e8af206fafb44fe5b4233eb30bb205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d5fa3b6f36d2e9dc63c4dc3412f0f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gac9d5fa3b6f36d2e9dc63c4dc3412f0f8">CSL_edma3MapDMAChannelToEventQueue</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Uint8 eventQueue)</td></tr>
<tr class="separator:gac9d5fa3b6f36d2e9dc63c4dc3412f0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de736c33c9bec94590ef201ebf2ead6"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8de736c33c9bec94590ef201ebf2ead6">CSL_edma3GetDMAChannelToEventQueueMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga8de736c33c9bec94590ef201ebf2ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6e2fe8687852b8d640cfbf72e34d07a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaa6e2fe8687852b8d640cfbf72e34d07a">CSL_edma3MapQDMAChannelToEventQueue</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Uint8 eventQueue)</td></tr>
<tr class="separator:gaa6e2fe8687852b8d640cfbf72e34d07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec01050a67942a6fcdd1ce8b3aed2d1"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga5ec01050a67942a6fcdd1ce8b3aed2d1">CSL_edma3GetQDMAChannelToEventQueueMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel)</td></tr>
<tr class="separator:ga5ec01050a67942a6fcdd1ce8b3aed2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d1b866c3c23f1c1f7970f9b5fbc5e6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga6d1b866c3c23f1c1f7970f9b5fbc5e6f">CSL_edma3MapEventQueueToTC</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 tcNum)</td></tr>
<tr class="separator:ga6d1b866c3c23f1c1f7970f9b5fbc5e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eaed8e6d7f20dac45eedcb71ebd6804"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9eaed8e6d7f20dac45eedcb71ebd6804">CSL_edma3GetEventQueueToTCMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue)</td></tr>
<tr class="separator:ga9eaed8e6d7f20dac45eedcb71ebd6804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad8668228a1584b1201fa63e94d2498"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga5ad8668228a1584b1201fa63e94d2498">CSL_edma3SetEventQueuePriority</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 priority)</td></tr>
<tr class="separator:ga5ad8668228a1584b1201fa63e94d2498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404bacac2a4ea2fbef703034d003800e"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga404bacac2a4ea2fbef703034d003800e">CSL_edma3GetEventQueuePriority</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue)</td></tr>
<tr class="separator:ga404bacac2a4ea2fbef703034d003800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83e94b0bab125d21048a68935123e2f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gae83e94b0bab125d21048a68935123e2f">CSL_edma3GetEventMissed</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, CSL_BitMask32 *missedLo, CSL_BitMask32 *missedHi, CSL_BitMask32 *missedQdma)</td></tr>
<tr class="separator:gae83e94b0bab125d21048a68935123e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc0bc1999aa69769ca9e33215d7c614"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaffc0bc1999aa69769ca9e33215d7c614">CSL_edma3IsDMAChannelMissedEventSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Bool *response)</td></tr>
<tr class="separator:gaffc0bc1999aa69769ca9e33215d7c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c32de61c3988315043e6476ed3a3a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga64c32de61c3988315043e6476ed3a3a8">CSL_edma3IsQDMAChannelMissedEventSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Bool *response)</td></tr>
<tr class="separator:ga64c32de61c3988315043e6476ed3a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bd948c76d68bde4433984ef84eedb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gae6bd948c76d68bde4433984ef84eedb5">CSL_edma3EventsMissedClear</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, CSL_BitMask32 missedLo, CSL_BitMask32 missedHi, CSL_BitMask32 missedQdma)</td></tr>
<tr class="separator:gae6bd948c76d68bde4433984ef84eedb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4772e6598f65bac04d0c59ca7a1b3612"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga4772e6598f65bac04d0c59ca7a1b3612">CSL_edma3ClearDMAMissedEvent</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga4772e6598f65bac04d0c59ca7a1b3612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6219a158b58e7defea51a7f3f53f5855"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga6219a158b58e7defea51a7f3f53f5855">CSL_edma3ClearQDMAMissedEvent</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel)</td></tr>
<tr class="separator:ga6219a158b58e7defea51a7f3f53f5855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff82735cb56a5e4f20f4e0a89fbf2e3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaff82735cb56a5e4f20f4e0a89fbf2e3e">CSL_edma3GetControllerError</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga76304c2b9e36a2959a1bcaf63d84502b">CSL_Edma3CtrlErrStat</a> *ccStat)</td></tr>
<tr class="separator:gaff82735cb56a5e4f20f4e0a89fbf2e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5458556421487c2da32cbf1dc9bdb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gafb5458556421487c2da32cbf1dc9bdb2">CSL_edma3ClearControllerError</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, const <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga76304c2b9e36a2959a1bcaf63d84502b">CSL_Edma3CtrlErrStat</a> *ccStat)</td></tr>
<tr class="separator:gafb5458556421487c2da32cbf1dc9bdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4110e49f4500afc5314104bb3c4d5673"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga4110e49f4500afc5314104bb3c4d5673">CSL_edma3ErrorEval</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule)</td></tr>
<tr class="separator:ga4110e49f4500afc5314104bb3c4d5673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fcbc17db5594f430851db0bdd785e03"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0fcbc17db5594f430851db0bdd785e03">CSL_edma3DmaRegionAccessEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int edmaRegion, CSL_BitMask32 drae, CSL_BitMask32 draeh)</td></tr>
<tr class="separator:ga0fcbc17db5594f430851db0bdd785e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070e9c2a86bd18ce0850dfc45e7d5551"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga070e9c2a86bd18ce0850dfc45e7d5551">CSL_edma3DmaRegionAccessDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int edmaRegion, CSL_BitMask32 drae, CSL_BitMask32 draeh)</td></tr>
<tr class="separator:ga070e9c2a86bd18ce0850dfc45e7d5551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c8815957d655fd903f7ff29719bfee5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga1c8815957d655fd903f7ff29719bfee5">CSL_edma3QdmaRegionAccessEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int edmaRegion, CSL_BitMask32 qrae)</td></tr>
<tr class="separator:ga1c8815957d655fd903f7ff29719bfee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1253d6e8d81dd6370fdbea203f62718c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga1253d6e8d81dd6370fdbea203f62718c">CSL_edma3QdmaRegionAccessDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int edmaRegion, CSL_BitMask32 qrae)</td></tr>
<tr class="separator:ga1253d6e8d81dd6370fdbea203f62718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dd2dfe416cd94e4ca3d9d0a1a6176a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga83dd2dfe416cd94e4ca3d9d0a1a6176a">CSL_edma3GetWaterMark</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 *waterMark)</td></tr>
<tr class="separator:ga83dd2dfe416cd94e4ca3d9d0a1a6176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc05b1eb70228c60531fbbb1c3921c3c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gadc05b1eb70228c60531fbbb1c3921c3c">CSL_edma3GetNumberValidEntries</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 *numValidEntries)</td></tr>
<tr class="separator:gadc05b1eb70228c60531fbbb1c3921c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3d8851f43a731dbbc084f5a9b2db8d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga7f3d8851f43a731dbbc084f5a9b2db8d">CSL_edma3GetStartPointer</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 *startPtr)</td></tr>
<tr class="separator:ga7f3d8851f43a731dbbc084f5a9b2db8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3284c3d8aa6cf1228c8b834581e9f7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaa3284c3d8aa6cf1228c8b834581e9f7a">CSL_edma3GetThresholdExceeded</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Bool *thresholdExceeded)</td></tr>
<tr class="separator:gaa3284c3d8aa6cf1228c8b834581e9f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8f408030d583005808e473ffbffecc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gada8f408030d583005808e473ffbffecc">CSL_edma3EventQueueThresholdSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 threshold)</td></tr>
<tr class="separator:gada8f408030d583005808e473ffbffecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d54fbe4ac3a8808b4085b0785519a9a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga4d54fbe4ac3a8808b4085b0785519a9a">CSL_edma3GetActivityStatus</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga2ae058d6cba90191fa7e3ec7a319a52f">CSL_Edma3ActivityStat</a> *activityStat)</td></tr>
<tr class="separator:ga4d54fbe4ac3a8808b4085b0785519a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00186ec229dde02888eaf6a9ac4b2e95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga00186ec229dde02888eaf6a9ac4b2e95">CSL_edma3GetMemoryFaultError</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gac83cf570375046eeab358c62f4d34699">CSL_Edma3MemFaultStat</a> *memFault)</td></tr>
<tr class="separator:ga00186ec229dde02888eaf6a9ac4b2e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c24483db8373f8e4b8eae0a9ad295ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8c24483db8373f8e4b8eae0a9ad295ca">CSL_edma3MemFaultClear</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule)</td></tr>
<tr class="separator:ga8c24483db8373f8e4b8eae0a9ad295ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5194b8227d01a15dfdc53354e41b755"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gac5194b8227d01a15dfdc53354e41b755">CSL_edma3GetMemoryProtectionAttrib</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 *mppa)</td></tr>
<tr class="separator:gac5194b8227d01a15dfdc53354e41b755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c5d18de6e596e42437199c3601b881"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59c5d18de6e596e42437199c3601b881">CSL_edma3SetMemoryProtectionAttrib</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 mppa)</td></tr>
<tr class="separator:ga59c5d18de6e596e42437199c3601b881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866c9adb7b8e44f8cd62df238122c46d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga866c9adb7b8e44f8cd62df238122c46d">CSL_edma3IsDMAChannelEventPending</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Bool *response)</td></tr>
<tr class="separator:ga866c9adb7b8e44f8cd62df238122c46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015fd64ae0f97abb699b3a0950cce12e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga015fd64ae0f97abb699b3a0950cce12e">CSL_edma3ClearDMAChannelEvent</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga015fd64ae0f97abb699b3a0950cce12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b71a3e6c8bb5938e759d7abb1c071c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gab6b71a3e6c8bb5938e759d7abb1c071c">CSL_edma3SetDMAChannelEvent</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 dmaChannel)</td></tr>
<tr class="separator:gab6b71a3e6c8bb5938e759d7abb1c071c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b74b51ed885b086a933b1f971aecd7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga98b74b51ed885b086a933b1f971aecd7">CSL_edma3DMAChannelDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga98b74b51ed885b086a933b1f971aecd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa54eff8bdd357d4cc1827b15bce2d317"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaa54eff8bdd357d4cc1827b15bce2d317">CSL_edma3DMAChannelEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 dmaChannel)</td></tr>
<tr class="separator:gaa54eff8bdd357d4cc1827b15bce2d317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c6f7086fcc2f1f60d1ffa744d26b9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gac4c6f7086fcc2f1f60d1ffa744d26b9e">CSL_edma3GetDMASecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, CSL_BitMask32 *secEventLo, CSL_BitMask32 *secEventHi)</td></tr>
<tr class="separator:gac4c6f7086fcc2f1f60d1ffa744d26b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d6bf46947c559ac464a2856209cd65"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gad5d6bf46947c559ac464a2856209cd65">CSL_edma3IsDMAChannelSecondaryEventSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Bool *response)</td></tr>
<tr class="separator:gad5d6bf46947c559ac464a2856209cd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7980f171ac5f5cb2f7cd168944a9b88d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga7980f171ac5f5cb2f7cd168944a9b88d">CSL_edma3ClearDMASecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, CSL_BitMask32 secEventLo, CSL_BitMask32 secEventHi)</td></tr>
<tr class="separator:ga7980f171ac5f5cb2f7cd168944a9b88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b02edfc6f108291b61b89c448a699f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga22b02edfc6f108291b61b89c448a699f">CSL_edma3ClearDMAChannelSecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga22b02edfc6f108291b61b89c448a699f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cca9a54be594bf9b3d9642e9538797e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8cca9a54be594bf9b3d9642e9538797e">CSL_edma3InterruptLoDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrLo)</td></tr>
<tr class="separator:ga8cca9a54be594bf9b3d9642e9538797e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9b854d4799036131f82237bc877ca5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaec9b854d4799036131f82237bc877ca5">CSL_edma3InterruptHiDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrHi)</td></tr>
<tr class="separator:gaec9b854d4799036131f82237bc877ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d222265626a331066b9ec9aaa38d25e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga2d222265626a331066b9ec9aaa38d25e">CSL_edma3InterruptLoEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrLo)</td></tr>
<tr class="separator:ga2d222265626a331066b9ec9aaa38d25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd501db6edf23e9201e11cf63acd7bd6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gadd501db6edf23e9201e11cf63acd7bd6">CSL_edma3InterruptHiEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrHi)</td></tr>
<tr class="separator:gadd501db6edf23e9201e11cf63acd7bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743ae95c1373dc77ef523f848fb8f40d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga743ae95c1373dc77ef523f848fb8f40d">CSL_edma3GetLoPendingInterrupts</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 *intrLo)</td></tr>
<tr class="separator:ga743ae95c1373dc77ef523f848fb8f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99bde63badafa04c8ec1c9024ceb9179"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga99bde63badafa04c8ec1c9024ceb9179">CSL_edma3GetHiPendingInterrupts</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 *intrHi)</td></tr>
<tr class="separator:ga99bde63badafa04c8ec1c9024ceb9179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8649dce41be1f3eb9ab730f0b2f6dad9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8649dce41be1f3eb9ab730f0b2f6dad9">CSL_edma3ClearLoPendingInterrupts</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrLo)</td></tr>
<tr class="separator:ga8649dce41be1f3eb9ab730f0b2f6dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffcdd5be47e621d5dec4581e1f7166d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaffcdd5be47e621d5dec4581e1f7166d4">CSL_edma3ClearHiPendingInterrupts</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrHi)</td></tr>
<tr class="separator:gaffcdd5be47e621d5dec4581e1f7166d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c5e5d18e400c1706deafbe5ea5aed2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga61c5e5d18e400c1706deafbe5ea5aed2">CSL_edma3InterruptEval</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region)</td></tr>
<tr class="separator:ga61c5e5d18e400c1706deafbe5ea5aed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5bd1589917a92b8de77a997811706a1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaa5bd1589917a92b8de77a997811706a1">CSL_edma3IsQDMAChannelEventPending</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Bool *response)</td></tr>
<tr class="separator:gaa5bd1589917a92b8de77a997811706a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18cbdd27ffd1b507768f64a22758323c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga18cbdd27ffd1b507768f64a22758323c">CSL_edma3QDMAChannelEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 qdmaChannel)</td></tr>
<tr class="separator:ga18cbdd27ffd1b507768f64a22758323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace982cddeda1d0afd516524cc4906756"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gace982cddeda1d0afd516524cc4906756">CSL_edma3QDMAChannelDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 qdmaChannel)</td></tr>
<tr class="separator:gace982cddeda1d0afd516524cc4906756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae746e4d3ff996ac285846189be3eae51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gae746e4d3ff996ac285846189be3eae51">CSL_edma3GetQDMASecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint32 *qdmaSecEvent)</td></tr>
<tr class="separator:gae746e4d3ff996ac285846189be3eae51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d26ed086c003ea5942764bc83639326"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0d26ed086c003ea5942764bc83639326">CSL_edma3IsQDMAChannelSecondaryEventSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Bool *response)</td></tr>
<tr class="separator:ga0d26ed086c003ea5942764bc83639326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8890ca36df2fd1b2d296ee380812d1ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8890ca36df2fd1b2d296ee380812d1ab">CSL_edma3ClearQDMASecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint32 qdmaSecEvent)</td></tr>
<tr class="separator:ga8890ca36df2fd1b2d296ee380812d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315b2794bb181cc094ce5b01006c3dfd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga315b2794bb181cc094ce5b01006c3dfd">CSL_edma3ClearQDMAChannelSecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel)</td></tr>
<tr class="separator:ga315b2794bb181cc094ce5b01006c3dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafb5458556421487c2da32cbf1dc9bdb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearControllerError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga76304c2b9e36a2959a1bcaf63d84502b">CSL_Edma3CtrlErrStat</a> *&#160;</td>
          <td class="paramname"><em>ccStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearControllerError</b> </p>
<p><b>Description</b> <br />
 Channel Controller Error Fault.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle        
     ccStat            Error Status which is to be cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_CCERRCLR_QTHRXD0;TPCC_TPCC_CCERRCLR_QTHRXD1;TPCC_TPCC_CCERRCLR_QTHRXD2; TPCC_TPCC_CCERRCLR_QTHRXD3;TPCC_TPCC_CCERRCLR_QTHRXD4;TPCC_TPCC_CCERRCLR_QTHRXD5; TPCC_TPCC_CCERRCLR_QTHRXD6;TPCC_TPCC_CCERRCLR_QTHRXD7, TPCC_TPCC_CCERR_TCCERR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3CtrlErrStat    ccError;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get Controller Error
         status = CSL_edma3GetControllerError(hModule,&amp;ccError);
         ...
         // Clear the error. 
         CSL_edma3ClearControllerError(hModule,&amp;ccError);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga015fd64ae0f97abb699b3a0950cce12e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearDMAChannelEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearDMAChannelEvent</b> </p>
<p><b>Description</b> <br />
 This API clears the event for the specific DMA channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadow or Global)
     dmaChannel      DMA Channel for which the event is cleared. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_ECR_E0=1;TPCC_TPCC_ECR_E1=1;TPCC_TPCC_ECR_E2=1;TPCC_TPCC_ECR_E3=1; TPCC_TPCC_ECR_E4=1;TPCC_TPCC_ECR_E5=1;TPCC_TPCC_ECR_E6=1;TPCC_TPCC_ECR_E7=1; TPCC_TPCC_ECR_E8=1;TPCC_TPCC_ECR_E9=1;TPCC_TPCC_ECR_E10=1;TPCC_TPCC_ECR_E11=1; TPCC_TPCC_ECR_E12=1;TPCC_TPCC_ECR_E13=1;TPCC_TPCC_ECR_E14=1;TPCC_TPCC_ECR_E15=1; TPCC_TPCC_ECR_E16=1;TPCC_TPCC_ECR_E17=1;TPCC_TPCC_ECR_E18=1;TPCC_TPCC_ECR_E19=1; TPCC_TPCC_ECR_E20=1;TPCC_TPCC_ECR_E21=1;TPCC_TPCC_ECR_E22=1;TPCC_TPCC_ECR_E23=1; TPCC_TPCC_ECR_E24=1;TPCC_TPCC_ECR_E25=1;TPCC_TPCC_ECR_E26=1;TPCC_TPCC_ECR_E27=1; TPCC_TPCC_ECR_E28=1;TPCC_TPCC_ECR_E29=1;TPCC_TPCC_ECR_E30=1;TPCC_TPCC_ECR_E31=1; <br />
 TPCC_TPCC_ECRH_E32=1;TPCC_TPCC_ECRH_E33=1;TPCC_TPCC_ECRH_E34=1;TPCC_TPCC_ECRH_E35=1; TPCC_TPCC_ECRH_E36=1;TPCC_TPCC_ECRH_E37=1;TPCC_TPCC_ECRH_E38=1;TPCC_TPCC_ECRH_E39=1; TPCC_TPCC_ECRH_E40=1;TPCC_TPCC_ECRH_E41=1;TPCC_TPCC_ECRH_E42=1;TPCC_TPCC_ECRH_E43=1; TPCC_TPCC_ECRH_E44=1;TPCC_TPCC_ECRH_E45=1;TPCC_TPCC_ECRH_E46=1;TPCC_TPCC_ECRH_E47=1; TPCC_TPCC_ECRH_E48=1;TPCC_TPCC_ECRH_E49=1;TPCC_TPCC_ECRH_E50=1;TPCC_TPCC_ECRH_E51=1; TPCC_TPCC_ECRH_E52=1;TPCC_TPCC_ECRH_E53=1;TPCC_TPCC_ECRH_E54=1;TPCC_TPCC_ECRH_E55=1; TPCC_TPCC_ECRH_E56=1;TPCC_TPCC_ECRH_E57=1;TPCC_TPCC_ECRH_E58=1;TPCC_TPCC_ECRH_E59=1; TPCC_TPCC_ECRH_E60=1;TPCC_TPCC_ECRH_E61=1;TPCC_TPCC_ECRH_E62=1;TPCC_TPCC_ECRH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    dmaStatus;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get DMA Channel 0 Status 
         CSL_edma3GetDMAChannelEvent(hModule, 0, &amp;dmaStatus);
         if (dmaStatus == TRUE)
         {
             // DMA Channel 0 is active... 
             ...
             // Clear DMA Channel 0.
             CSL_edma3ClearDMAChannelEvent (hModule, CSL_EDMA3_REGION_GLOBAL, 0);
         }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga22b02edfc6f108291b61b89c448a699f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearDMAChannelSecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearDMAChannelSecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API clears the DMA Secondary Event for a specific DMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     DMA Channel for which the secondary event is to be cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_SECR_SECR0=1;TPCC_TPCC_SECR_SECR1=1;TPCC_TPCC_SECR_SECR2=1; TPCC_TPCC_SECR_SECR3=1;TPCC_TPCC_SECR_SECR4=1;TPCC_TPCC_SECR_SECR5=1; TPCC_TPCC_SECR_SECR6=1;TPCC_TPCC_SECR_SECR7=1;TPCC_TPCC_SECR_SECR8=1; TPCC_TPCC_SECR_SECR9=1;TPCC_TPCC_SECR_SECR10=1;TPCC_TPCC_SECR_SECR11=1; TPCC_TPCC_SECR_SECR12=1;TPCC_TPCC_SECR_SECR13=1;TPCC_TPCC_SECR_SECR14=1; TPCC_TPCC_SECR_SECR15=1;TPCC_TPCC_SECR_SECR16=1;TPCC_TPCC_SECR_SECR17=1; TPCC_TPCC_SECR_SECR18=1;TPCC_TPCC_SECR_SECR19=1;TPCC_TPCC_SECR_SECR20=1; TPCC_TPCC_SECR_SECR21=1;TPCC_TPCC_SECR_SECR22=1;TPCC_TPCC_SECR_SECR23=1; TPCC_TPCC_SECR_SECR24=1;TPCC_TPCC_SECR_SECR25=1;TPCC_TPCC_SECR_SECR26=1; TPCC_TPCC_SECR_SECR27=1;TPCC_TPCC_SECR_SECR28=1;TPCC_TPCC_SECR_SECR29=1; TPCC_TPCC_SECR_SECR30=1;TPCC_TPCC_SECR_SECR31=1; <br />
 TPCC_TPCC_SECRH_SECR32=1;TPCC_TPCC_SECRH_SECR33=1;TPCC_TPCC_SECRH_SECR34=1; TPCC_TPCC_SECRH_SECR35=1;TPCC_TPCC_SECRH_SECR36=1;TPCC_TPCC_SECRH_SECR37=1; TPCC_TPCC_SECRH_SECR38=1;TPCC_TPCC_SECRH_SECR39=1;TPCC_TPCC_SECRH_SECR40=1; TPCC_TPCC_SECRH_SECR41=1;TPCC_TPCC_SECRH_SECR42=1;TPCC_TPCC_SECRH_SECR43=1; TPCC_TPCC_SECRH_SECR44=1;TPCC_TPCC_SECRH_SECR45=1;TPCC_TPCC_SECRH_SECR46=1; TPCC_TPCC_SECRH_SECR47=1;TPCC_TPCC_SECRH_SECR48=1;TPCC_TPCC_SECRH_SECR49=1; TPCC_TPCC_SECRH_SECR50=1;TPCC_TPCC_SECRH_SECR51=1;TPCC_TPCC_SECRH_SECR52=1; TPCC_TPCC_SECRH_SECR53=1;TPCC_TPCC_SECRH_SECR54=1;TPCC_TPCC_SECRH_SECR55=1; TPCC_TPCC_SECRH_SECR56=1;TPCC_TPCC_SECRH_SECR57=1;TPCC_TPCC_SECRH_SECR58=1; TPCC_TPCC_SECRH_SECR59=1;TPCC_TPCC_SECRH_SECR60=1;TPCC_TPCC_SECRH_SECR61=1; TPCC_TPCC_SECRH_SECR62=1;TPCC_TPCC_SECRH_SECR63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         Uint32                  qdmaSecEvent;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Clear the DMA Secondary Event for DMA channel 1
         CSL_edma3ClearDMAChannelSecondaryEvents(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4772e6598f65bac04d0c59ca7a1b3612"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearDMAMissedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearDMAMissedEvent</b> </p>
<p><b>Description</b> <br />
 The API clears the missed event for the specific DMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     dmaChannel      DMA Channel for which the event is cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 Clears all the missed events</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EMCR_EMCR0;TPCC_TPCC_EMCR_EMCR1;TPCC_TPCC_EMCR_EMCR2; TPCC_TPCC_EMCR_EMCR3;TPCC_TPCC_EMCR_EMCR4;TPCC_TPCC_EMCR_EMCR5; TPCC_TPCC_EMCR_EMCR6;TPCC_TPCC_EMCR_EMCR7;TPCC_TPCC_EMCR_EMCR8; TPCC_TPCC_EMCR_EMCR9;TPCC_TPCC_EMCR_EMCR10;TPCC_TPCC_EMCR_EMCR11; TPCC_TPCC_EMCR_EMCR12;TPCC_TPCC_EMCR_EMCR13;TPCC_TPCC_EMCR_EMCR14; TPCC_TPCC_EMCR_EMCR15;TPCC_TPCC_EMCR_EMCR16;TPCC_TPCC_EMCR_EMCR17; TPCC_TPCC_EMCR_EMCR18;TPCC_TPCC_EMCR_EMCR19;TPCC_TPCC_EMCR_EMCR20; TPCC_TPCC_EMCR_EMCR21;TPCC_TPCC_EMCR_EMCR22;TPCC_TPCC_EMCR_EMCR23; TPCC_TPCC_EMCR_EMCR24;TPCC_TPCC_EMCR_EMCR25;TPCC_TPCC_EMCR_EMCR26; TPCC_TPCC_EMCR_EMCR27;TPCC_TPCC_EMCR_EMCR28;TPCC_TPCC_EMCR_EMCR29; TPCC_TPCC_EMCR_EMCR30;TPCC_TPCC_EMCR_EMCR31; TPCC_TPCC_EMCRH_EMCR32;TPCC_TPCC_EMCRH_EMCR33;TPCC_TPCC_EMCRH_EMCR34 TPCC_TPCC_EMCRH_EMCR35;TPCC_TPCC_EMCRH_EMCR36;TPCC_TPCC_EMCRH_EMCR37 TPCC_TPCC_EMCRH_EMCR38;TPCC_TPCC_EMCRH_EMCR39;TPCC_TPCC_EMCRH_EMCR40 TPCC_TPCC_EMCRH_EMCR41;TPCC_TPCC_EMCRH_EMCR42;TPCC_TPCC_EMCRH_EMCR43 TPCC_TPCC_EMCRH_EMCR44;TPCC_TPCC_EMCRH_EMCR45;TPCC_TPCC_EMCRH_EMCR46 TPCC_TPCC_EMCRH_EMCR47;TPCC_TPCC_EMCRH_EMCR48;TPCC_TPCC_EMCRH_EMCR49 TPCC_TPCC_EMCRH_EMCR50;TPCC_TPCC_EMCRH_EMCR51;TPCC_TPCC_EMCRH_EMCR52 TPCC_TPCC_EMCRH_EMCR53;TPCC_TPCC_EMCRH_EMCR54;TPCC_TPCC_EMCRH_EMCR55 TPCC_TPCC_EMCRH_EMCR56;TPCC_TPCC_EMCRH_EMCR57;TPCC_TPCC_EMCRH_EMCR58 TPCC_TPCC_EMCRH_EMCR59;TPCC_TPCC_EMCRH_EMCR60;TPCC_TPCC_EMCRH_EMCR61 TPCC_TPCC_EMCRH_EMCR62;TPCC_TPCC_EMCRH_EMCR63;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           missedLo, missedHi, missedQdma;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...            
         // Clear missed DMA 1 channel event.
         CSL_edma3ClearDMAMissedEvent(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7980f171ac5f5cb2f7cd168944a9b88d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearDMASecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>secEventLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>secEventHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearDMASecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API clears the DMA secondary events</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     secEventLo      Lower order 32 bits of secondary events to be cleared
     secEventHi      Higher order 32 bits of secondary events to be cleared</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_SECR,TPCC_TPCC_SECRH</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           secEventLo;
         CSL_BitMask32           secEventHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Get the DMA Secondary Events.
         CSL_edma3GetDMASecondaryEvents(hModule, &amp;secEventLo, &amp;secEventHi);            
         ...
         // Clear the DMA Secondary Events
         CSL_edma3ClearDMASecondaryEvents(hModule, secEventLo, secEventHi);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaffcdd5be47e621d5dec4581e1f7166d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearHiPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearHiPendingInterrupts</b> </p>
<p><b>Description</b> <br />
 This API clears the High pending interrupts using the interrupt bitmasks provided</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)
     intrHi            Interrupt 32-63 (BitMask32) to be cleared</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_ICRH</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get all the pending interrupts for the global region. 
         CSL_edma3GetHiPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, &amp;edmaIntrHi);
         ...
         // Clear the pending interrupts for the global region.
         CSL_edma3ClearHiPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, edmaIntrHi);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8649dce41be1f3eb9ab730f0b2f6dad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearLoPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearLoPendingInterrupts</b> </p>
<p><b>Description</b> <br />
 This API clears the low pending interrupts using the interrupt bitmasks provided</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)
     intrLo            Interrupt 0-31 (BitMask32) to be cleared        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_ICR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrLo;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get all the pending interrupts for the global region. 
         CSL_edma3GetLoPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, &amp;edmaIntrLo);
         ...
         // Clear the pending interrupts for the global region.
         CSL_edma3ClearLoPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, edmaIntrLo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga315b2794bb181cc094ce5b01006c3dfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearQDMAChannelSecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearQDMAChannelSecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API clears the QDMA Secondary Event for a specific QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel for which the secondary event is to be cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QSECR_QSECR0=1;TPCC_TPCC_QSECR_QSECR1=1;TPCC_TPCC_QSECR_QSECR2=1; TPCC_TPCC_QSECR_QSECR3=1;TPCC_TPCC_QSECR_QSECR4=1;TPCC_TPCC_QSECR_QSECR5=1; TPCC_TPCC_QSECR_QSECR6=1;TPCC_TPCC_QSECR_QSECR7=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         Uint32                  qdmaSecEvent;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Clear the QDMA Secondary Event for QDMA channel 1
         CSL_edma3ClearQDMAChannelSecondaryEvents(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6219a158b58e7defea51a7f3f53f5855"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearQDMAMissedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearQDMAMissedEvent</b> </p>
<p><b>Description</b> <br />
 The API clears the missed event for the specific QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel for which the event is cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 Clears all the missed events</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QEMCR_QEMCR0;TPCC_TPCC_QEMCR_QEMCR1;TPCC_TPCC_QEMCR_QEMCR2; TPCC_TPCC_QEMCR_QEMCR3;TPCC_TPCC_QEMCR_QEMCR4;TPCC_TPCC_QEMCR_QEMCR5; TPCC_TPCC_QEMCR_QEMCR6;TPCC_TPCC_QEMCR_QEMCR7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           missedLo, missedHi, missedQdma;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...            
         // Clear missed QDMA Channel 1 event.
         CSL_edma3ClearQDMAMissedEvent(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8890ca36df2fd1b2d296ee380812d1ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearQDMASecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>qdmaSecEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearQDMASecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API clears the QDMA Secondary Event.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaSecEvent    QDMA Secondary Event to be cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QSECR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         Uint32                  qdmaSecEvent;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get the QDMA Secondary Event
         CSL_edma3GetQDMASecondaryEvents(hModule, &amp;qdmaSecEvent);
         ...            
         // Clear the QDMA Secondary Event
         CSL_edma3ClearQDMASecondaryEvents(hModule, qdmaSecEvent);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga98b74b51ed885b086a933b1f971aecd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3DMAChannelDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3DMAChannelDisable</b> </p>
<p><b>Description</b> <br />
 This API disables the specified DMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadow or Global)
     dmaChannel      DMA Channel to be disabled. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EECR_E0=1;TPCC_TPCC_EECR_E1=1;TPCC_TPCC_EECR_E2=1; TPCC_TPCC_EECR_E3=1;TPCC_TPCC_EECR_E4=1;TPCC_TPCC_EECR_E5=1; TPCC_TPCC_EECR_E6=1;TPCC_TPCC_EECR_E7=1;TPCC_TPCC_EECR_E8=1; TPCC_TPCC_EECR_E9=1;TPCC_TPCC_EECR_E10=1;TPCC_TPCC_EECR_E11=1; TPCC_TPCC_EECR_E12=1;TPCC_TPCC_EECR_E13=1;TPCC_TPCC_EECR_E14=1; TPCC_TPCC_EECR_E15=1;TPCC_TPCC_EECR_E16=1;TPCC_TPCC_EECR_E17=1; TPCC_TPCC_EECR_E18=1;TPCC_TPCC_EECR_E19=1;TPCC_TPCC_EECR_E20=1; TPCC_TPCC_EECR_E21=1;TPCC_TPCC_EECR_E22=1;TPCC_TPCC_EECR_E23=1; TPCC_TPCC_EECR_E24=1;TPCC_TPCC_EECR_E25=1;TPCC_TPCC_EECR_E26=1; TPCC_TPCC_EECR_E27=1;TPCC_TPCC_EECR_E28=1;TPCC_TPCC_EECR_E29=1; TPCC_TPCC_EECR_E30=1;TPCC_TPCC_EECR_E31=1; <br />
 TPCC_TPCC_EECRH_E32=1;TPCC_TPCC_EECRH_E33=1;TPCC_TPCC_EECRH_E34=1; TPCC_TPCC_EECRH_E35=1;TPCC_TPCC_EECRH_E36=1;TPCC_TPCC_EECRH_E37=1; TPCC_TPCC_EECRH_E38=1;TPCC_TPCC_EECRH_E39=1;TPCC_TPCC_EECRH_E40=1; TPCC_TPCC_EECRH_E41=1;TPCC_TPCC_EECRH_E42=1;TPCC_TPCC_EECRH_E43=1; TPCC_TPCC_EECRH_E44=1;TPCC_TPCC_EECRH_E45=1;TPCC_TPCC_EECRH_E46=1; TPCC_TPCC_EECRH_E47=1;TPCC_TPCC_EECRH_E48=1;TPCC_TPCC_EECRH_E49=1; TPCC_TPCC_EECRH_E50=1;TPCC_TPCC_EECRH_E51=1;TPCC_TPCC_EECRH_E52=1; TPCC_TPCC_EECRH_E53=1;TPCC_TPCC_EECRH_E54=1;TPCC_TPCC_EECRH_E55=1; TPCC_TPCC_EECRH_E56=1;TPCC_TPCC_EECRH_E57=1;TPCC_TPCC_EECRH_E58=1; TPCC_TPCC_EECRH_E59=1;TPCC_TPCC_EECRH_E60=1;TPCC_TPCC_EECRH_E61=1; TPCC_TPCC_EECRH_E62=1;TPCC_TPCC_EECRH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
       
         // Disables DMA Channel 0
         CSL_edma3DMAChannelDisable(hModule, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa54eff8bdd357d4cc1827b15bce2d317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3DMAChannelEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3DMAChannelEnable</b> </p>
<p><b>Description</b> <br />
 This API enables the specified DMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadow or Global)
     dmaChannel      DMA Channel to be enabled. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EESR_E0=1;TPCC_TPCC_EESR_E1=1;TPCC_TPCC_EESR_E2=1; TPCC_TPCC_EESR_E3=1;TPCC_TPCC_EESR_E4=1;TPCC_TPCC_EESR_E5=1; TPCC_TPCC_EESR_E6=1;TPCC_TPCC_EESR_E7=1;TPCC_TPCC_EESR_E8=1; TPCC_TPCC_EESR_E9=1;TPCC_TPCC_EESR_E10=1;TPCC_TPCC_EESR_E11=1; TPCC_TPCC_EESR_E12=1;TPCC_TPCC_EESR_E13=1;TPCC_TPCC_EESR_E14=1; TPCC_TPCC_EESR_E15=1;TPCC_TPCC_EESR_E16=1;TPCC_TPCC_EESR_E17=1; TPCC_TPCC_EESR_E18=1;TPCC_TPCC_EESR_E19=1;TPCC_TPCC_EESR_E20=1; TPCC_TPCC_EESR_E21=1;TPCC_TPCC_EESR_E22=1;TPCC_TPCC_EESR_E23=1; TPCC_TPCC_EESR_E24=1;TPCC_TPCC_EESR_E25=1;TPCC_TPCC_EESR_E26=1; TPCC_TPCC_EESR_E27=1;TPCC_TPCC_EESR_E28=1;TPCC_TPCC_EESR_E29=1; TPCC_TPCC_EESR_E30=1;TPCC_TPCC_EESR_E31=1; <br />
 TPCC_TPCC_EESRH_E32=1;TPCC_TPCC_EESRH_E33=1;TPCC_TPCC_EESRH_E34=1; TPCC_TPCC_EESRH_E35=1;TPCC_TPCC_EESRH_E36=1;TPCC_TPCC_EESRH_E37=1; TPCC_TPCC_EESRH_E38=1;TPCC_TPCC_EESRH_E39=1;TPCC_TPCC_EESRH_E40=1; TPCC_TPCC_EESRH_E41=1;TPCC_TPCC_EESRH_E42=1;TPCC_TPCC_EESRH_E43=1; TPCC_TPCC_EESRH_E44=1;TPCC_TPCC_EESRH_E45=1;TPCC_TPCC_EESRH_E46=1; TPCC_TPCC_EESRH_E47=1;TPCC_TPCC_EESRH_E48=1;TPCC_TPCC_EESRH_E49=1; TPCC_TPCC_EESRH_E50=1;TPCC_TPCC_EESRH_E51=1;TPCC_TPCC_EESRH_E52=1; TPCC_TPCC_EESRH_E53=1;TPCC_TPCC_EESRH_E54=1;TPCC_TPCC_EESRH_E55=1; TPCC_TPCC_EESRH_E56=1;TPCC_TPCC_EESRH_E57=1;TPCC_TPCC_EESRH_E58=1; TPCC_TPCC_EESRH_E59=1;TPCC_TPCC_EESRH_E60=1;TPCC_TPCC_EESRH_E61=1; TPCC_TPCC_EESRH_E62=1;TPCC_TPCC_EESRH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
       
         // Enables DMA Channel 0 for the global region.
         CSL_edma3DMAChannelEnable(hModule, CSL_EDMA3_REGION_GLOBAL, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga070e9c2a86bd18ce0850dfc45e7d5551"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3DmaRegionAccessDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>edmaRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>drae</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>draeh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3DmaRegionAccessDisable</b> </p>
<p><b>Description</b> <br />
 This API disables read/write access to the shadow regions for the specific DMA channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     edmaRegion        Shadow Region 
     access            Region bits to be programmed
     drae              Bitmask to be disabled in DRAE
     draeh             Bitmask to be disabled in DRAEH</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DRA_DRAE_E0=0;TPCC_TPCC_DRA_DRAE_E1=0;TPCC_TPCC_DRA_DRAE_E2=0; TPCC_TPCC_DRA_DRAE_E3=0;TPCC_TPCC_DRA_DRAE_E4=0;TPCC_TPCC_DRA_DRAE_E5=0; TPCC_TPCC_DRA_DRAE_E6=0;TPCC_TPCC_DRA_DRAE_E7=0;TPCC_TPCC_DRA_DRAE_E8=0; TPCC_TPCC_DRA_DRAE_E9=0;TPCC_TPCC_DRA_DRAE_E10=0;TPCC_TPCC_DRA_DRAE_E11=0; TPCC_TPCC_DRA_DRAE_E12=0;TPCC_TPCC_DRA_DRAE_E13=0;TPCC_TPCC_DRA_DRAE_E14=0; TPCC_TPCC_DRA_DRAE_E15=0;TPCC_TPCC_DRA_DRAE_E16=0;TPCC_TPCC_DRA_DRAE_E17=0; TPCC_TPCC_DRA_DRAE_E18=0;TPCC_TPCC_DRA_DRAE_E19=0;TPCC_TPCC_DRA_DRAE_E20=0; TPCC_TPCC_DRA_DRAE_E21=0;TPCC_TPCC_DRA_DRAE_E22=0;TPCC_TPCC_DRA_DRAE_E23=0; TPCC_TPCC_DRA_DRAE_E24=0;TPCC_TPCC_DRA_DRAE_E25=0;TPCC_TPCC_DRA_DRAE_E26=0; TPCC_TPCC_DRA_DRAE_E27=0;TPCC_TPCC_DRA_DRAE_E28=0;TPCC_TPCC_DRA_DRAE_E29=0; TPCC_TPCC_DRA_DRAE_E30=0;TPCC_TPCC_DRA_DRAE_E31=0; <br />
 TPCC_TPCC_DRA_DRAEH_E32=0;TPCC_TPCC_DRA_DRAEH_E33=0;TPCC_TPCC_DRA_DRAEH_E34=0; TPCC_TPCC_DRA_DRAEH_E35=0;TPCC_TPCC_DRA_DRAEH_E36=0;TPCC_TPCC_DRA_DRAEH_E37=0; TPCC_TPCC_DRA_DRAEH_E38=0;TPCC_TPCC_DRA_DRAEH_E39=0;TPCC_TPCC_DRA_DRAEH_E40=0; TPCC_TPCC_DRA_DRAEH_E41=0;TPCC_TPCC_DRA_DRAEH_E42=0;TPCC_TPCC_DRA_DRAEH_E43=0; TPCC_TPCC_DRA_DRAEH_E44=0;TPCC_TPCC_DRA_DRAEH_E45=0;TPCC_TPCC_DRA_DRAEH_E46=0; TPCC_TPCC_DRA_DRAEH_E47=0;TPCC_TPCC_DRA_DRAEH_E48=0;TPCC_TPCC_DRA_DRAEH_E49=0; TPCC_TPCC_DRA_DRAEH_E50=0;TPCC_TPCC_DRA_DRAEH_E51=0;TPCC_TPCC_DRA_DRAEH_E52=0; TPCC_TPCC_DRA_DRAEH_E53=0;TPCC_TPCC_DRA_DRAEH_E54=0;TPCC_TPCC_DRA_DRAEH_E55=0; TPCC_TPCC_DRA_DRAEH_E56=0;TPCC_TPCC_DRA_DRAEH_E57=0;TPCC_TPCC_DRA_DRAEH_E58=0; TPCC_TPCC_DRA_DRAEH_E59=0;TPCC_TPCC_DRA_DRAEH_E60=0;TPCC_TPCC_DRA_DRAEH_E61=0; TPCC_TPCC_DRA_DRAEH_E62=0;TPCC_TPCC_DRA_DRAEH_E63=0;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Disable read/write access in Region 0 for DMA Channel 0 to 7
         CSL_edma3DmaRegionAccessDisable(hModule, 0, 0x000000FF, 0x0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0fcbc17db5594f430851db0bdd785e03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3DmaRegionAccessEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>edmaRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>drae</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>draeh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3DmaRegionAccessEnable</b> </p>
<p><b>Description</b> <br />
 This API enables read/write access to the shadow regions for the specific DMA channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     edmaRegion        Shadow Region 
     access            Region bits to be programmed
     drae              Bitmask to be enabled in DRAE
     draeh             Bitmask to be enabled in DRAEH</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DRA_DRAE_E0=1;TPCC_TPCC_DRA_DRAE_E1=1;TPCC_TPCC_DRA_DRAE_E2=1; TPCC_TPCC_DRA_DRAE_E3=1;TPCC_TPCC_DRA_DRAE_E4=1;TPCC_TPCC_DRA_DRAE_E5=1; TPCC_TPCC_DRA_DRAE_E6=1;TPCC_TPCC_DRA_DRAE_E7=1;TPCC_TPCC_DRA_DRAE_E8=1; TPCC_TPCC_DRA_DRAE_E9=1;TPCC_TPCC_DRA_DRAE_E10=1;TPCC_TPCC_DRA_DRAE_E11=1; TPCC_TPCC_DRA_DRAE_E12=1;TPCC_TPCC_DRA_DRAE_E13=1;TPCC_TPCC_DRA_DRAE_E14=1; TPCC_TPCC_DRA_DRAE_E15=1;TPCC_TPCC_DRA_DRAE_E16=1;TPCC_TPCC_DRA_DRAE_E17=1; TPCC_TPCC_DRA_DRAE_E18=1;TPCC_TPCC_DRA_DRAE_E19=1;TPCC_TPCC_DRA_DRAE_E20=1; TPCC_TPCC_DRA_DRAE_E21=1;TPCC_TPCC_DRA_DRAE_E22=1;TPCC_TPCC_DRA_DRAE_E23=1; TPCC_TPCC_DRA_DRAE_E24=1;TPCC_TPCC_DRA_DRAE_E25=1;TPCC_TPCC_DRA_DRAE_E26=1; TPCC_TPCC_DRA_DRAE_E27=1;TPCC_TPCC_DRA_DRAE_E28=1;TPCC_TPCC_DRA_DRAE_E29=1; TPCC_TPCC_DRA_DRAE_E30=1;TPCC_TPCC_DRA_DRAE_E31=1; <br />
 TPCC_TPCC_DRA_DRAEH_E32=1;TPCC_TPCC_DRA_DRAEH_E33=1;TPCC_TPCC_DRA_DRAEH_E34=1; TPCC_TPCC_DRA_DRAEH_E35=1;TPCC_TPCC_DRA_DRAEH_E36=1;TPCC_TPCC_DRA_DRAEH_E37=1; TPCC_TPCC_DRA_DRAEH_E38=1;TPCC_TPCC_DRA_DRAEH_E39=1;TPCC_TPCC_DRA_DRAEH_E40=1; TPCC_TPCC_DRA_DRAEH_E41=1;TPCC_TPCC_DRA_DRAEH_E42=1;TPCC_TPCC_DRA_DRAEH_E43=1; TPCC_TPCC_DRA_DRAEH_E44=1;TPCC_TPCC_DRA_DRAEH_E45=1;TPCC_TPCC_DRA_DRAEH_E46=1; TPCC_TPCC_DRA_DRAEH_E47=1;TPCC_TPCC_DRA_DRAEH_E48=1;TPCC_TPCC_DRA_DRAEH_E49=1; TPCC_TPCC_DRA_DRAEH_E50=1;TPCC_TPCC_DRA_DRAEH_E51=1;TPCC_TPCC_DRA_DRAEH_E52=1; TPCC_TPCC_DRA_DRAEH_E53=1;TPCC_TPCC_DRA_DRAEH_E54=1;TPCC_TPCC_DRA_DRAEH_E55=1; TPCC_TPCC_DRA_DRAEH_E56=1;TPCC_TPCC_DRA_DRAEH_E57=1;TPCC_TPCC_DRA_DRAEH_E58=1; TPCC_TPCC_DRA_DRAEH_E59=1;TPCC_TPCC_DRA_DRAEH_E60=1;TPCC_TPCC_DRA_DRAEH_E61=1; TPCC_TPCC_DRA_DRAEH_E62=1;TPCC_TPCC_DRA_DRAEH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Enable read/write access in Region 0 for DMA Channel 0 to 7
         CSL_edma3DmaRegionAccessEnable(hModule, 0, 0x000000FF, 0x0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4110e49f4500afc5314104bb3c4d5673"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ErrorEval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ErrorEval</b> </p>
<p><b>Description</b> <br />
 This API enables enables evaluation of errros for the specified view/shadow region.Sets EVAL bit of the EEVAL register in the Global register space</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EEVAL_EVAL=1</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Set the Error Interrupt Evaluation 
         CSL_edma3ErrorEval(hModule);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gada8f408030d583005808e473ffbffecc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3EventQueueThresholdSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3EventQueueThresholdSet</b> </p>
<p><b>Description</b> <br />
 The function configures the queue threshold.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue for which the threshold is configured                          
     threshold         Target threshold value.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QWMTHRA_Q0;TPCC_TPCC_QWMTHRA_Q1;TPCC_TPCC_QWMTHRA_Q2; TPCC_TPCC_QWMTHRA_Q3; <br />
 TPCC_TPCC_QWMTHRB_Q4;TPCC_TPCC_QWMTHRB_Q1;TPCC_TPCC_QWMTHRB_Q2; TPCC_TPCC_QWMTHRB_Q3</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Set the Queue threshold for Event Queue 0 to be 9
         CSL_edma3EventQueueThresholdSet(hModule, 0, 9);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae6bd948c76d68bde4433984ef84eedb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3EventsMissedClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>missedLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>missedHi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>missedQdma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3EventMissedClear</b> </p>
<p><b>Description</b> <br />
 Clear the Event missed errors</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     missedLo          Lower 32 of of the Event Missed register needing to 
                       be cleared (This is the same value as EMR)
     missedHi          Upper 32 of of the Event Missed register needing to 
                       be cleared (This is the same value as EMRH)
     missedQdma        Bit mask of Qdma events missed needing to be cleared</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 Clears all the missed events</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EMCR,TPCC_TPCC_EMCRH,TPCC_TPCC_QEMCR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           missedLo, missedHi, missedQdma;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...            
         // Get the missed events 
         CSL_edma3GetEventMissed(hModule, &amp;missedEdma, &amp;missedEdmaHi, &amp;missedQdma);
         ...
         // Clear the error 
         CSL_edma3EventMissedClear(hModule,missedLo, missedHi,qdmamissed);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4d54fbe4ac3a8808b4085b0785519a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetActivityStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga2ae058d6cba90191fa7e3ec7a319a52f">CSL_Edma3ActivityStat</a> *&#160;</td>
          <td class="paramname"><em>activityStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetActivityStatus</b> </p>
<p><b>Description</b> <br />
 Obtains the Channel Controller Activity Status</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     activityStat      Activity Status populated by this API.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_CCSTAT_EVTACTV,TPCC_TPCC_CCSTAT_QEVTACTV,TPCC_TPCC_CCSTAT_TRACTV, TPCC_TPCC_CCSTAT_ACTV,TPCC_TPCC_CCSTAT_COMP_ACTV</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3ActivityStat   activityStat;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get the CC activity status.
         CSL_edma3GetActivityStatus(hModule,&amp;activityStat);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaff82735cb56a5e4f20f4e0a89fbf2e3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetControllerError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga76304c2b9e36a2959a1bcaf63d84502b">CSL_Edma3CtrlErrStat</a> *&#160;</td>
          <td class="paramname"><em>ccStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetControllerError</b> </p>
<p><b>Description</b> <br />
 The function gets the status of the controller error.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     ccStat      Controller Error populated by this API </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_CCERR_QTHRXD0;TPCC_TPCC_CCERR_QTHRXD1;TPCC_TPCC_CCERR_QTHRXD2; TPCC_TPCC_CCERR_QTHRXD3;TPCC_TPCC_CCERR_QTHRXD4;TPCC_TPCC_CCERR_QTHRXD5; TPCC_TPCC_CCERR_QTHRXD6;TPCC_TPCC_CCERR_QTHRXD7, TPCC_TPCC_CCERR_TCCERR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3CtrlErrStat    ccError;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get Controller Error
         status = CSL_edma3GetControllerError(hModule,&amp;ccError);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8de736c33c9bec94590ef201ebf2ead6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_edma3GetDMAChannelToEventQueueMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetDMAChannelToEventQueueMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the mapping of the DMA Channel to the Event Queue</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     dmaChannel  DMA Channel for which the mapping is to be retreived.</pre><p><b> Return Value </b> <br />
 Event Queue to which the DMA channel is mapped to</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_DMAQNUM_E0;TPCC_TPCC_DMAQNUM_E1;TPCC_TPCC_DMAQNUM_E2; TPCC_TPCC_DMAQNUM_E3;TPCC_TPCC_DMAQNUM_E4;TPCC_TPCC_DMAQNUM_E5; TPCC_TPCC_DMAQNUM_E6;TPCC_TPCC_DMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   eventQueue;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the Event Queue mapping of DMA Channel 1
         eventQueue = CSL_edma3GetDMAChannelToEventQueueMapping(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga44779b99a16d35cc4b88944cec22514e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint16 CSL_edma3GetDMAChannelToParamBlockMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetDMAChannelToParamBlockMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the PARAM Entry ID to which a specific DMA Channel is mapped.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     dmaChannel  DMA Channel Number whose mapping is to be found.</pre><p><b> Return Value </b> <br />
 Paramater ID to which the specific DMA Channel is mapped to.</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_DCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint16                  paramId;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the mapping information for DMA channel 1.
         paramId = CSL_edma3GetDMAChannelToParamBlockMapping(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac4c6f7086fcc2f1f60d1ffa744d26b9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetDMASecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>secEventLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>secEventHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetDMASecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API gets the DMA secondary events</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     secEventLo      Lower order 32 bits of secondary events populated by the API
     secEventHi      Higher order 32 bits of secondary events populated by the API</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_SER,TPCC_TPCC_SERH</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           secEventLo;
         CSL_BitMask32           secEventHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Get the DMA Secondary Events.
         CSL_edma3GetDMASecondaryEvents(hModule, &amp;secEventLo, &amp;secEventHi);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae83e94b0bab125d21048a68935123e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetEventMissed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>missedLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>missedHi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>missedQdma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetEventMissed</b> </p>
<p><b>Description</b> <br />
 Queries all the events missed.Since there may be upto 64 EDMA channels + upto 8 QDMA channels,this points to an array of 3, 32 bit elements.Gets the status of the missed events.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     missedLo          missed [0] - holds status from EMR
     missedHi          missed [1] - holds status from EMRH
     missedQdma        missed [2] - holds status from QEMR</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_EMR,TPCC_TPCC_EMRH,TPCC_TPCC_QEMR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           missedLo, missedHi, missedQdma;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get the missed events 
         CSL_edma3GetEventMissed(hModule, &amp;missedEdma, &amp;missedEdmaHi, &amp;missedQdma);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga404bacac2a4ea2fbef703034d003800e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_edma3GetEventQueuePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetEventQueuePriority</b> </p>
<p><b>Description</b> <br />
 The function gets the priority of the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle        
     eventQueue  Event Queue whose priority is to be retrieved.</pre><p><b> Return Value </b> <br />
 Priority to which the Event Queue is mapped to.</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 Event Queue is configured to the specific priority.</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QUEPRI_PRIQ0;TPCC_TPCC_QUEPRI_PRIQ1;TPCC_TPCC_QUEPRI_PRIQ2; TPCC_TPCC_QUEPRI_PRIQ3;TPCC_TPCC_QUEPRI_PRIQ4;TPCC_TPCC_QUEPRI_PRIQ5; TPCC_TPCC_QUEPRI_PRIQ6;TPCC_TPCC_QUEPRI_PRIQ7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   priority;         

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the priority of Event Queue 2.
         priority = CSL_edma3GetEventQueuePriority(hModule, 2);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9eaed8e6d7f20dac45eedcb71ebd6804"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_edma3GetEventQueueToTCMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetEventQueueToTCMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the TC mapping for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle        
     eventQueue  Event Queue which for which the mapping is needed.</pre><p><b> Return Value </b> <br />
 TC Number to which the event queue is mapped to</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 Event Queue is mapped to the specific TC</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QUETCMAP_TCNUMQ0;TPCC_TPCC_QUETCMAP_TCNUMQ1;TPCC_TPCC_QUETCMAP_TCNUMQ2; TPCC_TPCC_QUETCMAP_TCNUMQ3;TPCC_TPCC_QUETCMAP_TCNUMQ4;TPCC_TPCC_QUETCMAP_TCNUMQ5; TPCC_TPCC_QUETCMAP_TCNUMQ6;TPCC_TPCC_QUETCMAP_TCNUMQ7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   tcNum;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the TC mapping for Event Queue 1 
         tcNum = CSL_edma3GetEventQueueToTCMapping(hModule, 1, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga99bde63badafa04c8ec1c9024ceb9179"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetHiPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>intrHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetHiPendingInterrupts</b> </p>
<p><b>Description</b> <br />
 The API gets a bitmask of all high pending interrupts.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)
     intrHi            Status 32-63 of the interrupts       </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_IPRH</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get all the high pending interrupts for the global region.
         CSL_edma3GetHiPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, &amp;edmaIntrHi);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae61cc100cdf1d62f35787426ca2b342d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga57808bce667ae4dd7e46a849b68f83ac">CSL_Edma3QueryInfo</a> *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetInfo</b> </p>
<p><b>Description</b> <br />
 The function gets the EDMA Channel Controller Configuration Information which includes reading the peripheral revision register and configuration register.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     response    Output parameter populated with the configuration information.      </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_CFG,TPCC_TPCC_PID</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3QueryInfo      info;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get Module Info
         CSL_edma3GetInfo(hModule,&amp;info);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga743ae95c1373dc77ef523f848fb8f40d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetLoPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>intrLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetLoPendingInterrupts</b> </p>
<p><b>Description</b> <br />
 The API gets a bitmask of all low pending interrupts.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)
     intrLo            Status 0-31 of the interrupts</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_IPR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrLo;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get all low pending interrupts for the global region.
         CSL_edma3GetLoPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, &amp;edmaIntrLo);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga00186ec229dde02888eaf6a9ac4b2e95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetMemoryFaultError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gac83cf570375046eeab358c62f4d34699">CSL_Edma3MemFaultStat</a> *&#160;</td>
          <td class="paramname"><em>memFault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetMemoryFaultError</b> </p>
<p><b>Description</b> <br />
 The function gets the Controllers memory fault error and the error attributes.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     memFault          The structure is populated by this API.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_MPFAR_FADDR,TPCC_TPCC_MPFSR_FID, TPCC_TPCC_MPFSR_UXE,TPCC_TPCC_MPFSR_UWE,TPCC_TPCC_MPFSR_URE, TPCC_TPCC_MPFSR_SXE,TPCC_TPCC_MPFSR_SWE,TPCC_TPCC_MPFSR_SRE, TPCC_TPCC_MPFSR_SECE</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3MemFaultStat   memFault;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get memory protection fault 
         CSL_edma3GetMemoryFaultError(hModule, &amp;memFault);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac5194b8227d01a15dfdc53354e41b755"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetMemoryProtectionAttrib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>mppa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetMemoryProtectionAttrib</b> </p>
<p><b>Description</b> <br />
 The function gets the memory access/protection attributes of the specific region.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region being queried.
     mppa              Memory Access/Protection Attributes populated by this API</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_MPPAG;TPCC_TPCC_MPPA</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           mppa;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get memory protection attributes for the Global Region.
         CSL_edma3GetMemoryProtectionAttrib(hModule, -1, &amp;mppa);
         ...
         // Get memory protection attributes for region 2 
         CSL_edma3GetMemoryProtectionAttrib(hModule, 2, &amp;mppa);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadc05b1eb70228c60531fbbb1c3921c3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetNumberValidEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>numValidEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetNumberValidEntries</b> </p>
<p><b>Description</b> <br />
 The function gets the Number of valid entries for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue number for which the watermark is retreived.
     numValidEntries   This is populated by the API to the number of valid entries</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSTAT_NUMVAL</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   numVal;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Get the Number of valid entries in event queue 0.
         CSL_edma3GetNumberValidEntries(hModule, 0, &amp;numVal);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5ec01050a67942a6fcdd1ce8b3aed2d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_edma3GetQDMAChannelToEventQueueMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetQDMAChannelToEventQueueMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the mapping of the QDMA Channel to the Event Queue</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel for which the mapping is to be retreived.</pre><p><b> Return Value </b> <br />
 Event Queue to which the QDMA channel is mapped to</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QDMAQNUM_E0;TPCC_TPCC_QDMAQNUM_E1;TPCC_TPCC_QDMAQNUM_E2; TPCC_TPCC_QDMAQNUM_E3;TPCC_TPCC_QDMAQNUM_E4;TPCC_TPCC_QDMAQNUM_E5; TPCC_TPCC_QDMAQNUM_E6;TPCC_TPCC_QDMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   eventQueue;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the Event Queue mapping of QDMA Channel 1
         eventQueue = CSL_edma3GetQDMAChannelToEventQueueMapping(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaea0f5fb5768df2b80b10eaf8ea287d59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint16 CSL_edma3GetQDMAChannelToParamBlockMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetQDMAChannelToParamBlockMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the PARAM Entry ID to which a specific QDMA Channel is mapped.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel Number whose mapping is to be found.</pre><p><b> Return Value </b> <br />
 Paramater ID to which the specific QDMA Channel is mapped to.</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the mapping information for QDMA channel 1.
         paramId = CSL_edma3GetQDMAChannelMap(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae746e4d3ff996ac285846189be3eae51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetQDMASecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>qdmaSecEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetQDMASecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API reads the QDMA Secondary Event.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaSecEvent    QDMA Secondary Event which is populated by this API</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSER</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         Uint32                  qdmaSecEvent;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get the QDMA Secondary Event
         CSL_edma3GetQDMASecondaryEvents(hModule, &amp;qdmaSecEvent);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab3e8af206fafb44fe5b4233eb30bb205"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetQDMATriggerWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>trword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetQDMATriggerWord</b> </p>
<p><b>Description</b> <br />
 The function gets the trigger word of the PaRAM Entry block.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel Number which is to be configured.
     trword      Trigger Word to be retreived populated by this API.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 QDMA Channel is mapped to the specified PARAM Block.</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QCHMAP_TRWORD</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   trWord;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the QDMA Channel 1 Trigger Word
         trWord = CSL_edma3SetQDMATriggerWord(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7f3d8851f43a731dbbc084f5a9b2db8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetStartPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>startPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetStartPointer</b> </p>
<p><b>Description</b> <br />
 The function gets the Number of valid entries for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue number for which the watermark is retreived.
     startPtr          This is populated by the API to the start pointer</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSTAT_STRPTR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   startPtr;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Get the Number of valid entries in event queue 0.
         CSL_edma3GetStartPointer(hModule, 0, &amp;startPtr);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa3284c3d8aa6cf1228c8b834581e9f7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetThresholdExceeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>thresholdExceeded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetThresholdExceeded</b> </p>
<p><b>Description</b> <br />
 The function gets the threshold exceeded flag for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue number for which the watermark is retreived.
     thresholdExceeded This is populated by the API to the threshold exceeded flag
                       for the specific event queue.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSTAT_THRXCD</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   thresholdExceeded;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Determine if the threshold has been exceeded or not for Queue 1
         CSL_edma3GetThresholdExceeded(hModule, 1, &amp;thresholdExceeded);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga83dd2dfe416cd94e4ca3d9d0a1a6176a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetWaterMark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>waterMark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetWaterMark</b> </p>
<p><b>Description</b> <br />
 The function gets the Queue Watermark for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue number for which the watermark is retreived.
     waterMark         This is populated by the API to the configured water mark </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSTAT_WM</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   waterMark;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Get the Water Mark Queue for event queue 0
         CSL_edma3GetWaterMark(hModule, 0, &amp;waterMark);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga61c5e5d18e400c1706deafbe5ea5aed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptEval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptEval</b> </p>
<p><b>Description</b> <br />
 The API is used to set the EVAL bit which will cause an interrupt to be generated if any enabled interrupts are still pending.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IEVAL_EVAL=1</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrLo;
         CSL_BitMask32           edmaIntrHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...        
         // Interrupt Evaluate for Global Region.
         status = CSL_edma3InterruptEval(hModule, CSL_EDMA3_REGION_GLOBAL);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaec9b854d4799036131f82237bc877ca5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptHiDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptHiDisable</b> </p>
<p><b>Description</b> <br />
 The API disables the specified high interrupt Number.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadow or Global)
     intrHi            Interrupt 32-63 (BitMask32) to be disabled</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IECRH_IECR32=1;TPCC_TPCC_IECRH_IECR33=1;TPCC_TPCC_IECRH_IECR34=1; TPCC_TPCC_IECRH_IECR35=1;TPCC_TPCC_IECRH_IECR36=1;TPCC_TPCC_IECRH_IECR37=1; TPCC_TPCC_IECRH_IECR38=1;TPCC_TPCC_IECRH_IECR39=1;TPCC_TPCC_IECRH_IECR40=1; TPCC_TPCC_IECRH_IECR41=1;TPCC_TPCC_IECRH_IECR42=1;TPCC_TPCC_IECRH_IECR43=1; TPCC_TPCC_IECRH_IECR44=1;TPCC_TPCC_IECRH_IECR45=1;TPCC_TPCC_IECRH_IECR46=1; TPCC_TPCC_IECRH_IECR47=1;TPCC_TPCC_IECRH_IECR48=1;TPCC_TPCC_IECRH_IECR49=1; TPCC_TPCC_IECRH_IECR50=1;TPCC_TPCC_IECRH_IECR51=1;TPCC_TPCC_IECRH_IECR52=1; TPCC_TPCC_IECRH_IECR53=1;TPCC_TPCC_IECRH_IECR54=1;TPCC_TPCC_IECRH_IECR55=1; TPCC_TPCC_IECRH_IECR56=1;TPCC_TPCC_IECRH_IECR57=1;TPCC_TPCC_IECRH_IECR58=1; TPCC_TPCC_IECRH_IECR59=1;TPCC_TPCC_IECRH_IECR60=1;TPCC_TPCC_IECRH_IECR61=1; TPCC_TPCC_IECRH_IECR62=1;TPCC_TPCC_IECRH_IECR63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
     
         // Interrupts 32 disabled for Global Region.
         CSL_edma3InterruptHiDisable(hModule, CSL_EDMA3_REGION_GLOBAL, 0x1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadd501db6edf23e9201e11cf63acd7bd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptHiEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptHiEnable</b> </p>
<p><b>Description</b> <br />
 The API enables the specific High interrupt.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule          Module Handle
     region           Region (Shadow or Global) 
     intrHi           Interrupt 32-63 (BitMask32) to be enabled</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IESRH_IESR32=1;TPCC_TPCC_IESRH_IESR33=1;TPCC_TPCC_IESRH_IESR34=1; TPCC_TPCC_IESRH_IESR35=1;TPCC_TPCC_IESRH_IESR36=1;TPCC_TPCC_IESRH_IESR37=1; TPCC_TPCC_IESRH_IESR38=1;TPCC_TPCC_IESRH_IESR39=1;TPCC_TPCC_IESRH_IESR40=1; TPCC_TPCC_IESRH_IESR41=1;TPCC_TPCC_IESRH_IESR42=1;TPCC_TPCC_IESRH_IESR43=1; TPCC_TPCC_IESRH_IESR44=1;TPCC_TPCC_IESRH_IESR45=1;TPCC_TPCC_IESRH_IESR46=1; TPCC_TPCC_IESRH_IESR47=1;TPCC_TPCC_IESRH_IESR48=1;TPCC_TPCC_IESRH_IESR49=1; TPCC_TPCC_IESRH_IESR50=1;TPCC_TPCC_IESRH_IESR51=1;TPCC_TPCC_IESRH_IESR52=1; TPCC_TPCC_IESRH_IESR53=1;TPCC_TPCC_IESRH_IESR54=1;TPCC_TPCC_IESRH_IESR55=1; TPCC_TPCC_IESRH_IESR56=1;TPCC_TPCC_IESRH_IESR57=1;TPCC_TPCC_IESRH_IESR58=1; TPCC_TPCC_IESRH_IESR59=1;TPCC_TPCC_IESRH_IESR60=1;TPCC_TPCC_IESRH_IESR61=1; TPCC_TPCC_IESRH_IESR62=1;TPCC_TPCC_IESRH_IESR63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
     
         // Interrupts 32 enabled for the global region.
         CSL_edma3InterruptHiEnable(hModule,CSL_EDMA3_REGION_GLOBAL, 0x1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8cca9a54be594bf9b3d9642e9538797e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptLoDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptLoDisable</b> </p>
<p><b>Description</b> <br />
 The API disables the specified low interrupt Number.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadow or Global)
     intrLo            Interrupt 0-31 (BitMask32) to be disabled</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IECR_IECR0=1;TPCC_TPCC_IECR_IECR1=1;TPCC_TPCC_IECR_IECR2=1; TPCC_TPCC_IECR_IECR3=1;TPCC_TPCC_IECR_IECR4=1;TPCC_TPCC_IECR_IECR5=1; TPCC_TPCC_IECR_IECR6=1;TPCC_TPCC_IECR_IECR7=1;TPCC_TPCC_IECR_IECR8=1; TPCC_TPCC_IECR_IECR9=1;TPCC_TPCC_IECR_IECR10=1;TPCC_TPCC_IECR_IECR11=1; TPCC_TPCC_IECR_IECR12=1;TPCC_TPCC_IECR_IECR13=1;TPCC_TPCC_IECR_IECR14=1; TPCC_TPCC_IECR_IECR15=1;TPCC_TPCC_IECR_IECR16=1;TPCC_TPCC_IECR_IECR17=1; TPCC_TPCC_IECR_IECR18=1;TPCC_TPCC_IECR_IECR19=1;TPCC_TPCC_IECR_IECR20=1; TPCC_TPCC_IECR_IECR21=1;TPCC_TPCC_IECR_IECR22=1;TPCC_TPCC_IECR_IECR23=1; TPCC_TPCC_IECR_IECR24=1;TPCC_TPCC_IECR_IECR25=1;TPCC_TPCC_IECR_IECR26=1; TPCC_TPCC_IECR_IECR27=1;TPCC_TPCC_IECR_IECR28=1;TPCC_TPCC_IECR_IECR29=1; TPCC_TPCC_IECR_IECR30=1;TPCC_TPCC_IECR_IECR31=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
     
         // Interrupts 5-7 disabled for Global Region.
         CSL_edma3InterruptLoDisable(hModule, CSL_EDMA3_REGION_GLOBAL, 0x000000E0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2d222265626a331066b9ec9aaa38d25e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptLoEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptLoEnable</b> </p>
<p><b>Description</b> <br />
 The API enables the specific lower interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule          Module Handle
     region           Region (Shadow or Global) 
     intrLo           Interrupt 0-31 (BitMask32) to be enabled</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IESR_IESR0=1;TPCC_TPCC_IESR_IESR1=1;TPCC_TPCC_IESR_IESR2=1; TPCC_TPCC_IESR_IESR3=1;TPCC_TPCC_IESR_IESR4=1;TPCC_TPCC_IESR_IESR5=1; TPCC_TPCC_IESR_IESR6=1;TPCC_TPCC_IESR_IESR7=1;TPCC_TPCC_IESR_IESR8=1; TPCC_TPCC_IESR_IESR9=1;TPCC_TPCC_IESR_IESR10=1;TPCC_TPCC_IESR_IESR11=1; TPCC_TPCC_IESR_IESR12=1;TPCC_TPCC_IESR_IESR13=1;TPCC_TPCC_IESR_IESR14=1; TPCC_TPCC_IESR_IESR15=1;TPCC_TPCC_IESR_IESR16=1;TPCC_TPCC_IESR_IESR17=1; TPCC_TPCC_IESR_IESR18=1;TPCC_TPCC_IESR_IESR19=1;TPCC_TPCC_IESR_IESR20=1; TPCC_TPCC_IESR_IESR21=1;TPCC_TPCC_IESR_IESR22=1;TPCC_TPCC_IESR_IESR23=1; TPCC_TPCC_IESR_IESR24=1;TPCC_TPCC_IESR_IESR25=1;TPCC_TPCC_IESR_IESR26=1; TPCC_TPCC_IESR_IESR27=1;TPCC_TPCC_IESR_IESR28=1;TPCC_TPCC_IESR_IESR29=1; TPCC_TPCC_IESR_IESR30=1;TPCC_TPCC_IESR_IESR31=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
     
         // Interrupts 5-7 enabled for the global region.
         CSL_edma3InterruptLoEnable(hModule,CSL_EDMA3_REGION_GLOBAL, 0x000000E0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga866c9adb7b8e44f8cd62df238122c46d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsDMAChannelEventPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsDMAChannelEventPending</b> </p>
<p><b>Description</b> <br />
 The function gets the status of the specified DMA channel i.e. if there is a pending event on the specific channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     dmaChannel      DMA Channel for which status is being inquired.
     response        Place holder for whether an event is set(TRUE) or not (FALSE)</pre><p><b> Return Value </b> <br />
 None.</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_ER_E0;TPCC_TPCC_ER_E1;TPCC_TPCC_ER_E2;TPCC_TPCC_ER_E3; TPCC_TPCC_ER_E4;TPCC_TPCC_ER_E5;TPCC_TPCC_ER_E6;TPCC_TPCC_ER_E7; TPCC_TPCC_ER_E8;TPCC_TPCC_ER_E9;TPCC_TPCC_ER_E10;TPCC_TPCC_ER_E11; TPCC_TPCC_ER_E12;TPCC_TPCC_ER_E13;TPCC_TPCC_ER_E14;TPCC_TPCC_ER_E15; TPCC_TPCC_ER_E16;TPCC_TPCC_ER_E17;TPCC_TPCC_ER_E18;TPCC_TPCC_ER_E19; TPCC_TPCC_ER_E20;TPCC_TPCC_ER_E21;TPCC_TPCC_ER_E22;TPCC_TPCC_ER_E23; TPCC_TPCC_ER_E24;TPCC_TPCC_ER_E25;TPCC_TPCC_ER_E26;TPCC_TPCC_ER_E27; TPCC_TPCC_ER_E28;TPCC_TPCC_ER_E29;TPCC_TPCC_ER_E30;TPCC_TPCC_ER_E31; <br />
 TPCC_TPCC_ERH_E32;TPCC_TPCC_ERH_E33;TPCC_TPCC_ERH_E34;TPCC_TPCC_ERH_E35; TPCC_TPCC_ERH_E36;TPCC_TPCC_ERH_E37;TPCC_TPCC_ERH_E38;TPCC_TPCC_ERH_E39; TPCC_TPCC_ERH_E40;TPCC_TPCC_ERH_E41;TPCC_TPCC_ERH_E42;TPCC_TPCC_ERH_E43; TPCC_TPCC_ERH_E44;TPCC_TPCC_ERH_E45;TPCC_TPCC_ERH_E46;TPCC_TPCC_ERH_E47; TPCC_TPCC_ERH_E48;TPCC_TPCC_ERH_E49;TPCC_TPCC_ERH_E50;TPCC_TPCC_ERH_E51; TPCC_TPCC_ERH_E52;TPCC_TPCC_ERH_E53;TPCC_TPCC_ERH_E54;TPCC_TPCC_ERH_E55; TPCC_TPCC_ERH_E56;TPCC_TPCC_ERH_E57;TPCC_TPCC_ERH_E58;TPCC_TPCC_ERH_E59; TPCC_TPCC_ERH_E60;TPCC_TPCC_ERH_E61;TPCC_TPCC_ERH_E62;TPCC_TPCC_ERH_E63;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    dmaStatus;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Determine if there is an event pending on DMA Channel 0.
         CSL_edma3IsDMAChannelEventPending(hModule, 0, &amp;dmaStatus);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaffc0bc1999aa69769ca9e33215d7c614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsDMAChannelMissedEventSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsDMAChannelMissedEventSet</b> </p>
<p><b>Description</b> <br />
 The API checks determines if there is a missed Event for a specific DMA channel</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     dmaChannel      DMA Channel to be checked
     response        This is populated by the API and returns TRUE if the
                     event was missed else it returns FALSE.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_EMR_EMR0;TPCC_TPCC_EMR_EMR1;TPCC_TPCC_EMR_EMR2; TPCC_TPCC_EMR_EMR3;TPCC_TPCC_EMR_EMR4;TPCC_TPCC_EMR_EMR5; TPCC_TPCC_EMR_EMR6;TPCC_TPCC_EMR_EMR7;TPCC_TPCC_EMR_EMR8; TPCC_TPCC_EMR_EMR9;TPCC_TPCC_EMR_EMR10;TPCC_TPCC_EMR_EMR11; TPCC_TPCC_EMR_EMR12;TPCC_TPCC_EMR_EMR13;TPCC_TPCC_EMR_EMR14; TPCC_TPCC_EMR_EMR15;TPCC_TPCC_EMR_EMR16;TPCC_TPCC_EMR_EMR17; TPCC_TPCC_EMR_EMR18;TPCC_TPCC_EMR_EMR19;TPCC_TPCC_EMR_EMR20; TPCC_TPCC_EMR_EMR21;TPCC_TPCC_EMR_EMR22;TPCC_TPCC_EMR_EMR23; TPCC_TPCC_EMR_EMR24;TPCC_TPCC_EMR_EMR25;TPCC_TPCC_EMR_EMR26; TPCC_TPCC_EMR_EMR27;TPCC_TPCC_EMR_EMR28;TPCC_TPCC_EMR_EMR29; TPCC_TPCC_EMR_EMR30;TPCC_TPCC_EMR_EMR31; TPCC_TPCC_EMRH_EMR32;TPCC_TPCC_EMRH_EMR33;TPCC_TPCC_EMRH_EMR34; TPCC_TPCC_EMRH_EMR35;TPCC_TPCC_EMRH_EMR36;TPCC_TPCC_EMRH_EMR37; TPCC_TPCC_EMRH_EMR38;TPCC_TPCC_EMRH_EMR39;TPCC_TPCC_EMRH_EMR40; TPCC_TPCC_EMRH_EMR41;TPCC_TPCC_EMRH_EMR42;TPCC_TPCC_EMRH_EMR43; TPCC_TPCC_EMRH_EMR44;TPCC_TPCC_EMRH_EMR45;TPCC_TPCC_EMRH_EMR46; TPCC_TPCC_EMRH_EMR47;TPCC_TPCC_EMRH_EMR48;TPCC_TPCC_EMRH_EMR49; TPCC_TPCC_EMRH_EMR50;TPCC_TPCC_EMRH_EMR51;TPCC_TPCC_EMRH_EMR52; TPCC_TPCC_EMRH_EMR53;TPCC_TPCC_EMRH_EMR54;TPCC_TPCC_EMRH_EMR55; TPCC_TPCC_EMRH_EMR56;TPCC_TPCC_EMRH_EMR57;TPCC_TPCC_EMRH_EMR58; TPCC_TPCC_EMRH_EMR59;TPCC_TPCC_EMRH_EMR60;TPCC_TPCC_EMRH_EMR61; TPCC_TPCC_EMRH_EMR62;TPCC_TPCC_EMRH_EMR63;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    missed;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Check if DMA Channel 1 has an event missed.
         CSL_edma3IsDMAChannelMissedEventSet(hModule, 1, &amp;missed);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad5d6bf46947c559ac464a2856209cd65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsDMAChannelSecondaryEventSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsDMAChannelSecondaryEventSet</b> </p>
<p><b>Description</b> <br />
 This API is used to determine if the secondary Event for a specific DMA channel is set or not?</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     dmaChannel      DMA Channel for which secondary Events are being checked
     response        Status of the check populated by the API (TRUE if event
                     is missed else FALSE)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_SER_SER0;TPCC_TPCC_SER_SER1;TPCC_TPCC_SER_SER2; TPCC_TPCC_SER_SER3;TPCC_TPCC_SER_SER4;TPCC_TPCC_SER_SER5; TPCC_TPCC_SER_SER6;TPCC_TPCC_SER_SER7;TPCC_TPCC_SER_SER8; TPCC_TPCC_SER_SER9;TPCC_TPCC_SER_SER10;TPCC_TPCC_SER_SER11; TPCC_TPCC_SER_SER12;TPCC_TPCC_SER_SER13;TPCC_TPCC_SER_SER14; TPCC_TPCC_SER_SER15;TPCC_TPCC_SER_SER16;TPCC_TPCC_SER_SER17; TPCC_TPCC_SER_SER18;TPCC_TPCC_SER_SER19;TPCC_TPCC_SER_SER20; TPCC_TPCC_SER_SER21;TPCC_TPCC_SER_SER22;TPCC_TPCC_SER_SER23; TPCC_TPCC_SER_SER24;TPCC_TPCC_SER_SER25;TPCC_TPCC_SER_SER26; TPCC_TPCC_SER_SER27;TPCC_TPCC_SER_SER28;TPCC_TPCC_SER_SER29; TPCC_TPCC_SER_SER30;TPCC_TPCC_SER_SER31; <br />
 TPCC_TPCC_SERH_SER32;TPCC_TPCC_SERH_SER33;TPCC_TPCC_SERH_SER34; TPCC_TPCC_SERH_SER35;TPCC_TPCC_SERH_SER36;TPCC_TPCC_SERH_SER37; TPCC_TPCC_SERH_SER38;TPCC_TPCC_SERH_SER39;TPCC_TPCC_SERH_SER40; TPCC_TPCC_SERH_SER41;TPCC_TPCC_SERH_SER42;TPCC_TPCC_SERH_SER43; TPCC_TPCC_SERH_SER44;TPCC_TPCC_SERH_SER45;TPCC_TPCC_SERH_SER46; TPCC_TPCC_SERH_SER47;TPCC_TPCC_SERH_SER48;TPCC_TPCC_SERH_SER49; TPCC_TPCC_SERH_SER50;TPCC_TPCC_SERH_SER51;TPCC_TPCC_SERH_SER52; TPCC_TPCC_SERH_SER53;TPCC_TPCC_SERH_SER54;TPCC_TPCC_SERH_SER55; TPCC_TPCC_SERH_SER56;TPCC_TPCC_SERH_SER57;TPCC_TPCC_SERH_SER58; TPCC_TPCC_SERH_SER59;TPCC_TPCC_SERH_SER60;TPCC_TPCC_SERH_SER61; TPCC_TPCC_SERH_SER62;TPCC_TPCC_SERH_SER63;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    response;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Check if the DMA Channel 1 Secondary Event is set or not? 
         CSL_edma3IsDMAChannelSecondaryEventSet(hModule, 1, &amp;response);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa5bd1589917a92b8de77a997811706a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsQDMAChannelEventPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsQDMAChannelEventPending</b> </p>
<p><b>Description</b> <br />
 The function gets the status of the specified QDMA channel i.e. if there is a pending event on the specific channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel for which status is being inquired.
     response        Place holder for whether an event is set(TRUE) or not (FALSE)</pre><p><b> Return Value </b> <br />
 None.</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QER_QER0;TPCC_TPCC_QER_QER1;TPCC_TPCC_QER_QER2;TPCC_TPCC_QER_QER3; TPCC_TPCC_QER_QER4;TPCC_TPCC_QER_QER5;TPCC_TPCC_QER_QER6;TPCC_TPCC_QER_QER7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    qdmaStatus;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Is QDMA Channel 1 event pending.
         CSL_edma3IsQDMAChannelEventPending(hModule, 1, &amp;qdmaStatus);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga64c32de61c3988315043e6476ed3a3a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsQDMAChannelMissedEventSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsQDMAChannelMissedEventSet</b> </p>
<p><b>Description</b> <br />
 The API checks determines if there is a missed Event for a specific DMA channel</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel to be checked
     response        This is populated by the API and returns TRUE if the
                     event was missed else it returns FALSE.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QEMR_QEMR0;TPCC_TPCC_QEMR_QEMR1;TPCC_TPCC_QEMR_QEMR2; TPCC_TPCC_QEMR_QEMR3;TPCC_TPCC_QEMR_QEMR4;TPCC_TPCC_QEMR_QEMR5; TPCC_TPCC_QEMR_QEMR6;TPCC_TPCC_QEMR_QEMR7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    missed;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Check if DMA Channel 0 has an event missed.
         CSL_edma3IsQDMAChannelMissedEventSet(hModule, 0, &amp;missed);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0d26ed086c003ea5942764bc83639326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsQDMAChannelSecondaryEventSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsDMAChannelSecondaryEventSet</b> </p>
<p><b>Description</b> <br />
 This API is used to determine if the secondary Event for a specific DMA channel is set or not?</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel for which secondary Events are being checked
     response        Status of the check populated by the API (TRUE if event
                     is missed else FALSE)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSER_QSER0;TPCC_TPCC_QSER_QSER1;TPCC_TPCC_QSER_QSER2; TPCC_TPCC_QSER_QSER3;TPCC_TPCC_QSER_QSER4;TPCC_TPCC_QSER_QSER5; TPCC_TPCC_QSER_QSER6;TPCC_TPCC_QSER_QSER7;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    response;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Check if the QDMA Channel 1 Secondary Event is set or not? 
         CSL_edma3IsQDMAChannelSecondaryEventSet(hModule, 1, &amp;response);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac9d5fa3b6f36d2e9dc63c4dc3412f0f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapDMAChannelToEventQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapDMAChannelToEventQueue</b> </p>
<p><b>Description</b> <br />
 The function maps the event ID to the specific DMA Queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     dmaChannel  DMA Channel to which the event is mapped.
     eventQueue  Event Queue which is to be mapped.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 DMA Channel is mapped to the specified Event Queue.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DMAQNUM_E0;TPCC_TPCC_DMAQNUM_E1;TPCC_TPCC_DMAQNUM_E2; TPCC_TPCC_DMAQNUM_E3;TPCC_TPCC_DMAQNUM_E4;TPCC_TPCC_DMAQNUM_E5; TPCC_TPCC_DMAQNUM_E6;TPCC_TPCC_DMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps DMA Channel 1 to Event Queue 2
         CSL_edma3MapDMAChannelToEventQueue(hModule, 1, 2);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga57e8100aa3db1c61e789d74fb992e4a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapDMAChannelToParamBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>paramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapDMAChannelToParamBlock</b> </p>
<p><b>Description</b> <br />
 The function maps the DMA Channel to the specified PARAM Entry Block.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     dmaChannel  DMA Channel Number which is to be mapped.
     paramId     Parameter Identifier to be mapped to.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 DMA Channel is mapped to the specified PARAM Block.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps DMA Channel 1 to Param ID Block 5.
         CSL_edma3MapDMAChannelToParamBlock(hModule, 1, 5);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6d1b866c3c23f1c1f7970f9b5fbc5e6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapEventQueueToTC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>tcNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapEventQueueToTC</b> </p>
<p><b>Description</b> <br />
 The function maps the event queue to a specific TC</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle        
     eventQueue  Event Queue which is to be mapped.
     tcNum       TC to which the queue is to be mapped to.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 Event Queue is mapped to the specific TC</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QUETCMAP_TCNUMQ0;TPCC_TPCC_QUETCMAP_TCNUMQ1;TPCC_TPCC_QUETCMAP_TCNUMQ2; TPCC_TPCC_QUETCMAP_TCNUMQ3;TPCC_TPCC_QUETCMAP_TCNUMQ4;TPCC_TPCC_QUETCMAP_TCNUMQ5; TPCC_TPCC_QUETCMAP_TCNUMQ6;TPCC_TPCC_QUETCMAP_TCNUMQ7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps Event Queue 1 to TC0
         CSL_edma3MapEventQueueToTC(hModule, 1, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa6e2fe8687852b8d640cfbf72e34d07a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapQDMAChannelToEventQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapQDMAChannelToEventQueue</b> </p>
<p><b>Description</b> <br />
 The function maps the event ID to the specific DMA Queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel to which the event is mapped.
     eventQueue  Event Queue which is to be mapped.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 DMA Channel is mapped to the specified Event Queue.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QDMAQNUM_E0;TPCC_TPCC_QDMAQNUM_E1;TPCC_TPCC_QDMAQNUM_E2; TPCC_TPCC_QDMAQNUM_E3;TPCC_TPCC_QDMAQNUM_E4;TPCC_TPCC_QDMAQNUM_E5; TPCC_TPCC_QDMAQNUM_E6;TPCC_TPCC_QDMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps QDMA Channel 1 to Event Queue 2
         CSL_edma3MapQDMAChannelToEventQueue(hModule, 1, 2);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0e25de939e1bcb1f714be5378058d9a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapQDMAChannelToParamBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>paramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapQDMAChannelToParamBlock</b> </p>
<p><b>Description</b> <br />
 The function maps the QDMA Channel to the specified PARAM Entry Block.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel Number which is to be mapped.
     paramId     Parameter Identifier to be mapped to.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 QDMA Channel is mapped to the specified PARAM Block.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps QDMA Channel 1 to Param ID Block 5.
         CSL_edma3MapQDMAChannelToParamBlock(hModule, 1, 5);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8c24483db8373f8e4b8eae0a9ad295ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MemFaultClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MemFaultClear</b> </p>
<p><b>Description</b> <br />
 The function clears the memory fault.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_MPFCR_MPFCLR=1</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Clear the memory protection fault 
         CSL_edma3MemFaultClear(hModule);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gace982cddeda1d0afd516524cc4906756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3QDMAChannelDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3QDMAChannelDisable</b> </p>
<p><b>Description</b> <br />
 This API disables the specified QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadown Region or Global)
     qdmaChannel     QDMA Channel to be disabled. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QEECR_QEECR0=1;TPCC_TPCC_QEECR_QEECR1=1;TPCC_TPCC_QEECR_QEECR2=1; TPCC_TPCC_QEECR_QEECR3=1;TPCC_TPCC_QEECR_QEECR4=1;TPCC_TPCC_QEECR_QEECR5=1; TPCC_TPCC_QEECR_QEECR6=1;TPCC_TPCC_QEECR_QEECR7=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
       
         // Disables QDMA Channel 0
         CSL_edma3QDMAChannelDisable(hModule, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga18cbdd27ffd1b507768f64a22758323c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3QDMAChannelEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3QDMAChannelEnable</b> </p>
<p><b>Description</b> <br />
 This API enables the specified QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadown Region or Global)
     qdmaChannel     QDMA Channel to be enabled. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QEESR_QEESR0=1;TPCC_TPCC_QEESR_QEESR1=1;TPCC_TPCC_QEESR_QEESR2=1; TPCC_TPCC_QEESR_QEESR3=1;TPCC_TPCC_QEESR_QEESR4=1;TPCC_TPCC_QEESR_QEESR5=1; TPCC_TPCC_QEESR_QEESR6=1;TPCC_TPCC_QEESR_QEESR7=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
       
         // Enables QDMA Channel 1 for Global Region.
         CSL_edma3QDMAChannelEnable(hModule, CSL_EDMA3_REGION_GLOBAL, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1253d6e8d81dd6370fdbea203f62718c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3QdmaRegionAccessDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>edmaRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>qrae</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3QdmaRegionAccessDisable</b> </p>
<p><b>Description</b> <br />
 This API disables read/write access to the shadow regions for the specific QDMA channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle        
     edmaRegion        Shadow Region.                          
     qrae              Bitmask to be enabled in QRAE</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QRAE_E0=0;TPCC_TPCC_QRAE_E1=0;TPCC_TPCC_QRAE_E2=0; TPCC_TPCC_QRAE_E3=0;TPCC_TPCC_QRAE_E4=0;TPCC_TPCC_QRAE_E5=0; TPCC_TPCC_QRAE_E6=0;TPCC_TPCC_QRAE_E7=0</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Disable read/write access in Region 0 for QDMA 0 to 3
         CSL_edma3QdmaRegionAccessDisable(hModule, 0, 0x0000000F);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1c8815957d655fd903f7ff29719bfee5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3QdmaRegionAccessEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>edmaRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>qrae</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3QdmaRegionAccessEnable</b> </p>
<p><b>Description</b> <br />
 This API enables read/write access to the shadow regions for the specific QDMA channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     edmaRegion        Shadow Region
     qrae              Bitmask to be enabled in QRAE</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QRAE_E0=1;TPCC_TPCC_QRAE_E1=1;TPCC_TPCC_QRAE_E2=1; TPCC_TPCC_QRAE_E3=1;TPCC_TPCC_QRAE_E4=1;TPCC_TPCC_QRAE_E5=1; TPCC_TPCC_QRAE_E6=1;TPCC_TPCC_QRAE_E7=1</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Enable read/write access in Region 0 for QDMA 0 to 3
         CSL_edma3QdmaRegionAccessEnable(hModule, 0, 0x0000000F);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab6b71a3e6c8bb5938e759d7abb1c071c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3SetDMAChannelEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3SetDMAChannelEvent</b> </p>
<p><b>Description</b> <br />
 This API sets the event for the specific DMA channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadow or Global)
     dmaChannel      DMA Channel for which the event is to be set</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_ESR_E0=1;TPCC_TPCC_ESR_E1=1;TPCC_TPCC_ESR_E2=1;TPCC_TPCC_ESR_E3=1; TPCC_TPCC_ESR_E4=1;TPCC_TPCC_ESR_E5=1;TPCC_TPCC_ESR_E6=1;TPCC_TPCC_ESR_E7=1; TPCC_TPCC_ESR_E8=1;TPCC_TPCC_ESR_E9=1;TPCC_TPCC_ESR_E10=1;TPCC_TPCC_ESR_E11=1; TPCC_TPCC_ESR_E12=1;TPCC_TPCC_ESR_E13=1;TPCC_TPCC_ESR_E14=1;TPCC_TPCC_ESR_E15=1; TPCC_TPCC_ESR_E16=1;TPCC_TPCC_ESR_E17=1;TPCC_TPCC_ESR_E18=1;TPCC_TPCC_ESR_E19=1; TPCC_TPCC_ESR_E20=1;TPCC_TPCC_ESR_E21=1;TPCC_TPCC_ESR_E22=1;TPCC_TPCC_ESR_E23=1; TPCC_TPCC_ESR_E24=1;TPCC_TPCC_ESR_E25=1;TPCC_TPCC_ESR_E26=1;TPCC_TPCC_ESR_E27=1; TPCC_TPCC_ESR_E28=1;TPCC_TPCC_ESR_E29=1;TPCC_TPCC_ESR_E30=1;TPCC_TPCC_ESR_E31=1; <br />
 TPCC_TPCC_ESRH_E32=1;TPCC_TPCC_ESRH_E33=1;TPCC_TPCC_ESRH_E34=1;TPCC_TPCC_ESRH_E35=1; TPCC_TPCC_ESRH_E36=1;TPCC_TPCC_ESRH_E37=1;TPCC_TPCC_ESRH_E38=1;TPCC_TPCC_ESRH_E39=1; TPCC_TPCC_ESRH_E40=1;TPCC_TPCC_ESRH_E41=1;TPCC_TPCC_ESRH_E42=1;TPCC_TPCC_ESRH_E43=1; TPCC_TPCC_ESRH_E44=1;TPCC_TPCC_ESRH_E45=1;TPCC_TPCC_ESRH_E46=1;TPCC_TPCC_ESRH_E47=1; TPCC_TPCC_ESRH_E48=1;TPCC_TPCC_ESRH_E49=1;TPCC_TPCC_ESRH_E50=1;TPCC_TPCC_ESRH_E51=1; TPCC_TPCC_ESRH_E52=1;TPCC_TPCC_ESRH_E53=1;TPCC_TPCC_ESRH_E54=1;TPCC_TPCC_ESRH_E55=1; TPCC_TPCC_ESRH_E56=1;TPCC_TPCC_ESRH_E57=1;TPCC_TPCC_ESRH_E58=1;TPCC_TPCC_ESRH_E59=1; TPCC_TPCC_ESRH_E60=1;TPCC_TPCC_ESRH_E61=1;TPCC_TPCC_ESRH_E62=1;TPCC_TPCC_ESRH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Set the DMA Channel 0 Event for the Global Region. 
         CSL_edma3SetDMAChannelEvent(hModule, CSL_EDMA3_REGION_GLOBAL, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5ad8668228a1584b1201fa63e94d2498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3SetEventQueuePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3SetEventQueuePriority</b> </p>
<p><b>Description</b> <br />
 The function sets the priority of the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle        
     eventQueue  Event Queue whose priority is to be configured.
     priority    Priority to be configured.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 Event Queue is configured to the specific priority.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QUEPRI_PRIQ0;TPCC_TPCC_QUEPRI_PRIQ1;TPCC_TPCC_QUEPRI_PRIQ2; TPCC_TPCC_QUEPRI_PRIQ3;TPCC_TPCC_QUEPRI_PRIQ4;TPCC_TPCC_QUEPRI_PRIQ5; TPCC_TPCC_QUEPRI_PRIQ6;TPCC_TPCC_QUEPRI_PRIQ7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;            

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps Event Queue 2 to Priority 4 
         CSL_edma3SetEventQueuePriority(hModule, 2, 4);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga59c5d18de6e596e42437199c3601b881"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3SetMemoryProtectionAttrib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>mppa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3SetMemoryProtectionAttrib</b> </p>
<p><b>Description</b> <br />
 This API sets the memory protection attributes for the specified region.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region being configured.                          
     mpa             Value to be programmed into the MPPAG/MPPA[0/1/2/../n]
                     This is a Bitmask of the protection attributes.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_MPPAG;TPCC_TPCC_MPPA</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Set the memory protection attributes of region 0. 
         CSL_edma3SetMemoryProtectionAttrib (hModule, 0, CSL_EDMA3_MEMACCESS_UX |
                                                         CSL_EDMA3_MEMACCESS_UW |
                                                         CSL_EDMA3_MEMACCESS_UR |
                                                         CSL_EDMA3_MEMACCESS_AID2));
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6f7627ac0aea91aa666b330d01c51e1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3SetQDMATriggerWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>trword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3SetQDMATriggerWord</b> </p>
<p><b>Description</b> <br />
 The function sets the trigger word of the PaRAM Entry block.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel Number which is to be configured.
     trword      Trigger Word to be configured.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em>CSL_edma3Init()</em> and <em>CSL_edma3Open()</em> must be called.</p>
<p><b> Post Condition </b> <br />
 QDMA Channel is mapped to the specified PARAM Block.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QCHMAP_TRWORD</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Configure QDMA Channel 1 Trigger Word as 0
         CSL_edma3SetQDMATriggerWord(hModule, 1, 0);
         ...</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
