<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Tesoc</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tesoc<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:tesoc_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tesoc_8h.html">tesoc.h</a></td></tr>
<tr class="memdesc:tesoc_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains the prototypes of the APIs present in the device abstraction layer file of TESOC. This also contains some related macros. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtesoc_test_cfg.html">tesocTestCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Structure defines the configuration for running TESOC test. These parameters are used for configuring domainType and slice configuration.  <a href="structtesoc_test_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtesoc_diagnostic_slice_cfg.html">tesocDiagnosticSliceCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Structure is used for diagnostic slice configuration info for each domain in current revision of SoC.  <a href="structtesoc_diagnostic_slice_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtesoc_advance_result.html">tesocAdvanceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Structure is used for storing results of TESOC test. These parameters are used as place holder for storing result.  <a href="structtesoc_advance_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9c40ce13af7431e7eb48ec37fca01108"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga9c40ce13af7431e7eb48ec37fca01108">TESOC_IRQSTATUS_RAW_ALL</a>&#160;&#160;&#160;(TESOC_INTR_STATUS_RAW_TEST_COMPLETION_SET_MASK)</td></tr>
<tr class="memdesc:ga9c40ce13af7431e7eb48ec37fca01108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro containing mask of all the interrupts. This macro can be passed to interrupt control API's to enable or disable all the main interrupts at a time.  <a href="#ga9c40ce13af7431e7eb48ec37fca01108">More...</a><br /></td></tr>
<tr class="separator:ga9c40ce13af7431e7eb48ec37fca01108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4054d1e0e76c4c40c782469236953ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4054d1e0e76c4c40c782469236953ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#gaf4054d1e0e76c4c40c782469236953ae">TESOC_TIMEOUT_TEST_START</a>&#160;&#160;&#160;(0xFFFFU)</td></tr>
<tr class="memdesc:gaf4054d1e0e76c4c40c782469236953ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout value for TESOC start after test configuration is done. <br /></td></tr>
<tr class="separator:gaf4054d1e0e76c4c40c782469236953ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256da992d68a6b5686178b5a7a5a5914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga256da992d68a6b5686178b5a7a5a5914"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga256da992d68a6b5686178b5a7a5a5914">TESOC_TIMEOUT_TEST_END</a>&#160;&#160;&#160;(0xFFFFU)</td></tr>
<tr class="memdesc:ga256da992d68a6b5686178b5a7a5a5914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout value for TESOC test completion after test is started. This is maximum of test times of all domains. <br /></td></tr>
<tr class="separator:ga256da992d68a6b5686178b5a7a5a5914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e40f1cd007d865402ec765fbbbdc18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01e40f1cd007d865402ec765fbbbdc18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga01e40f1cd007d865402ec765fbbbdc18">TESOC_TIMEOUT_INFINITE</a>&#160;&#160;&#160;(0xFFFFFFFFU)</td></tr>
<tr class="memdesc:ga01e40f1cd007d865402ec765fbbbdc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinite timeout for TESOC test. Use this if you want to wait infinitely for test start or test completion. <br /></td></tr>
<tr class="separator:ga01e40f1cd007d865402ec765fbbbdc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae754ec51b7f21b0eb70278020385f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ae754ec51b7f21b0eb70278020385f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga1ae754ec51b7f21b0eb70278020385f3">TESOC_TEST_RUNNING</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga1ae754ec51b7f21b0eb70278020385f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">TESOC test running status: TESOC is running test. <br /></td></tr>
<tr class="separator:ga1ae754ec51b7f21b0eb70278020385f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabca78e87a1ce6451d43fd263fa08806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabca78e87a1ce6451d43fd263fa08806"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#gaabca78e87a1ce6451d43fd263fa08806">TESOC_TEST_COMPLETED</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gaabca78e87a1ce6451d43fd263fa08806"><td class="mdescLeft">&#160;</td><td class="mdescRight">TESOC test running status: TESOC has completed test. <br /></td></tr>
<tr class="separator:gaabca78e87a1ce6451d43fd263fa08806"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga497159ca45c8e5da93936e08e0fcb1c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga497159ca45c8e5da93936e08e0fcb1c1"></a>
typedef enum <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga60453300f7b0c91558e56aee99c50312">tesocSliceSrc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga497159ca45c8e5da93936e08e0fcb1c1">tesocSliceSrc_t</a></td></tr>
<tr class="memdesc:ga497159ca45c8e5da93936e08e0fcb1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to select the slice source for TESOC Test. TESOC can run slices from ROM or RAM. <br /></td></tr>
<tr class="separator:ga497159ca45c8e5da93936e08e0fcb1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f5bdf65e8d13b5e8fc13010458ffbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55f5bdf65e8d13b5e8fc13010458ffbc"></a>
typedef enum <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga52af6160048d0a68252cbcf0a2e2d5da">tesocIntrFlag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga55f5bdf65e8d13b5e8fc13010458ffbc">tesocIntrFlag_t</a></td></tr>
<tr class="memdesc:ga55f5bdf65e8d13b5e8fc13010458ffbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">TESOC interrupt flags. <br /></td></tr>
<tr class="separator:ga55f5bdf65e8d13b5e8fc13010458ffbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6905adedc6b35b3feabe4cab236907d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6905adedc6b35b3feabe4cab236907d3"></a>
typedef struct <a class="el" href="structtesoc_test_cfg.html">tesocTestCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a></td></tr>
<tr class="memdesc:ga6905adedc6b35b3feabe4cab236907d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Structure defines the configuration for running TESOC test. These parameters are used for configuring domainType and slice configuration. <br /></td></tr>
<tr class="separator:ga6905adedc6b35b3feabe4cab236907d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9d2cf34a0dd9f90e9da43d892bd130"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b9d2cf34a0dd9f90e9da43d892bd130"></a>
typedef struct <a class="el" href="structtesoc_diagnostic_slice_cfg.html">tesocDiagnosticSliceCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6b9d2cf34a0dd9f90e9da43d892bd130">tesocDiagnosticSliceCfg_t</a></td></tr>
<tr class="memdesc:ga6b9d2cf34a0dd9f90e9da43d892bd130"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Structure is used for diagnostic slice configuration info for each domain in current revision of SoC. <br /></td></tr>
<tr class="separator:ga6b9d2cf34a0dd9f90e9da43d892bd130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e5a35afc7dc70f169d76d1e8bfac72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92e5a35afc7dc70f169d76d1e8bfac72"></a>
typedef struct <a class="el" href="structtesoc_advance_result.html">tesocAdvanceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga92e5a35afc7dc70f169d76d1e8bfac72">tesocAdvanceResult_t</a></td></tr>
<tr class="memdesc:ga92e5a35afc7dc70f169d76d1e8bfac72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Structure is used for storing results of TESOC test. These parameters are used as place holder for storing result. <br /></td></tr>
<tr class="separator:ga92e5a35afc7dc70f169d76d1e8bfac72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga60453300f7b0c91558e56aee99c50312"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga60453300f7b0c91558e56aee99c50312">tesocSliceSrc</a> { <a class="el" href="group___c_s_l___t_e_s_o_c.html#gga60453300f7b0c91558e56aee99c50312a8dbd3587826bc111f2eb733fc76d37e1">TESOC_SLICE_SRC_ROM</a> = TESOC_MISC_CONFIG_SOURCE_CONTROL_SLICE_SOURCE_ROM, 
<a class="el" href="group___c_s_l___t_e_s_o_c.html#gga60453300f7b0c91558e56aee99c50312ad80e68a0ec5234fc20cd50b2ead7ac67">TESOC_SLICE_SRC_RAM</a> = TESOC_MISC_CONFIG_SOURCE_CONTROL_SLICE_SOURCE_RAM
 }</td></tr>
<tr class="memdesc:ga60453300f7b0c91558e56aee99c50312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to select the slice source for TESOC Test. TESOC can run slices from ROM or RAM.  <a href="group___c_s_l___t_e_s_o_c.html#ga60453300f7b0c91558e56aee99c50312">More...</a><br /></td></tr>
<tr class="separator:ga60453300f7b0c91558e56aee99c50312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52af6160048d0a68252cbcf0a2e2d5da"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga52af6160048d0a68252cbcf0a2e2d5da">tesocIntrFlag</a> { <a class="el" href="group___c_s_l___t_e_s_o_c.html#gga52af6160048d0a68252cbcf0a2e2d5daa88cfe7a981f94a1444e4c872ed273aeb">TESOC_INTR_FLAG_TEST_COMPLETION</a>, 
<a class="el" href="group___c_s_l___t_e_s_o_c.html#gga52af6160048d0a68252cbcf0a2e2d5daab6238a21e570eaa8999f8c2887c0f9f7">TESOC_INTR_FLAG_ALL</a> = TESOC_IRQSTATUS_RAW_ALL
 }</td></tr>
<tr class="memdesc:ga52af6160048d0a68252cbcf0a2e2d5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">TESOC interrupt flags.  <a href="group___c_s_l___t_e_s_o_c.html#ga52af6160048d0a68252cbcf0a2e2d5da">More...</a><br /></td></tr>
<tr class="separator:ga52af6160048d0a68252cbcf0a2e2d5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1bc7224ed2bc6ea02a6cc4ce57b48dfa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga1bc7224ed2bc6ea02a6cc4ce57b48dfa">TESOCGetDefaultSliceInfo</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a> *testCfg)</td></tr>
<tr class="memdesc:ga1bc7224ed2bc6ea02a6cc4ce57b48dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets default slice configuration information for a particular domain.  <a href="#ga1bc7224ed2bc6ea02a6cc4ce57b48dfa">More...</a><br /></td></tr>
<tr class="separator:ga1bc7224ed2bc6ea02a6cc4ce57b48dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e9d97d3b11103a39a635afab25db268"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga5e9d97d3b11103a39a635afab25db268">TESOCClearPrevState</a> (uint32_t baseAddr, uint32_t domainLabel)</td></tr>
<tr class="memdesc:ga5e9d97d3b11103a39a635afab25db268"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears register state of previous TESOC test run(if any).  <a href="#ga5e9d97d3b11103a39a635afab25db268">More...</a><br /></td></tr>
<tr class="separator:ga5e9d97d3b11103a39a635afab25db268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2e93471a9e068038b420898c5916fb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga1f2e93471a9e068038b420898c5916fb">TESOCConfigAndStart</a> (uint32_t baseAddr, const <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a> *testCfg)</td></tr>
<tr class="memdesc:ga1f2e93471a9e068038b420898c5916fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures TESOC for test and starts test on selected domain.  <a href="#ga1f2e93471a9e068038b420898c5916fb">More...</a><br /></td></tr>
<tr class="separator:ga1f2e93471a9e068038b420898c5916fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979316f5ae3240fd12904602aca77e6c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga979316f5ae3240fd12904602aca77e6c">TESOCGetTestExecutionStatus</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga979316f5ae3240fd12904602aca77e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get execution state of TESOC(busy/completed).  <a href="#ga979316f5ae3240fd12904602aca77e6c">More...</a><br /></td></tr>
<tr class="separator:ga979316f5ae3240fd12904602aca77e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1becee1d3970c113ed04fcd1b247d030"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga1becee1d3970c113ed04fcd1b247d030">TESOCWaitUntilBusy</a> (uint32_t baseAddr, uint32_t timeOut)</td></tr>
<tr class="memdesc:ga1becee1d3970c113ed04fcd1b247d030"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to wait till TESOC starts test.  <a href="#ga1becee1d3970c113ed04fcd1b247d030">More...</a><br /></td></tr>
<tr class="separator:ga1becee1d3970c113ed04fcd1b247d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14c6c56c52a7b51aadcb7b3e4ef2a843"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga14c6c56c52a7b51aadcb7b3e4ef2a843">TESOCWaitUntilNotBusy</a> (uint32_t baseAddr, uint32_t timeOut)</td></tr>
<tr class="memdesc:ga14c6c56c52a7b51aadcb7b3e4ef2a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to wait till TESOC completes running test.  <a href="#ga14c6c56c52a7b51aadcb7b3e4ef2a843">More...</a><br /></td></tr>
<tr class="separator:ga14c6c56c52a7b51aadcb7b3e4ef2a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d53f382f1a036ca4b791aaa1f8b167"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga38d53f382f1a036ca4b791aaa1f8b167">TESOCCheckTestResult</a> (uint32_t baseAddr, const <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a> *testCfg)</td></tr>
<tr class="memdesc:ga38d53f382f1a036ca4b791aaa1f8b167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check result of TESOC test.  <a href="#ga38d53f382f1a036ca4b791aaa1f8b167">More...</a><br /></td></tr>
<tr class="separator:ga38d53f382f1a036ca4b791aaa1f8b167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf073bd93ee3d8519890e38d76cab3ebf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#gaf073bd93ee3d8519890e38d76cab3ebf">TESOCAbortTest</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaf073bd93ee3d8519890e38d76cab3ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API aborts ongoing TESOC test.  <a href="#gaf073bd93ee3d8519890e38d76cab3ebf">More...</a><br /></td></tr>
<tr class="separator:gaf073bd93ee3d8519890e38d76cab3ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404e49e2b72002e382985c1b04e76496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga404e49e2b72002e382985c1b04e76496">TESOCClearAbort</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga404e49e2b72002e382985c1b04e76496"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears TESOC abort register.  <a href="#ga404e49e2b72002e382985c1b04e76496">More...</a><br /></td></tr>
<tr class="separator:ga404e49e2b72002e382985c1b04e76496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bad97e9a91fe2ba17806ed55650e502"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga4bad97e9a91fe2ba17806ed55650e502">TESOCSetSliceSrc</a> (uint32_t baseAddr, uint32_t testSliceSrc)</td></tr>
<tr class="memdesc:ga4bad97e9a91fe2ba17806ed55650e502"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will set slice source for running TESOC test.  <a href="#ga4bad97e9a91fe2ba17806ed55650e502">More...</a><br /></td></tr>
<tr class="separator:ga4bad97e9a91fe2ba17806ed55650e502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf6b6c0ee6da09ca5ef69a90b70feff"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#gadbf6b6c0ee6da09ca5ef69a90b70feff">TESOCRunTesoCDiagnostic</a> (uint32_t baseAddr, uint32_t testId)</td></tr>
<tr class="memdesc:gadbf6b6c0ee6da09ca5ef69a90b70feff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will run TESOC diagnostic slice for domain passed.  <a href="#gadbf6b6c0ee6da09ca5ef69a90b70feff">More...</a><br /></td></tr>
<tr class="separator:gadbf6b6c0ee6da09ca5ef69a90b70feff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f7af6bfde10e64aba481d657208d1d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga82f7af6bfde10e64aba481d657208d1d">TESOCGetAdvanceResult</a> (uint32_t baseAddr, const <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a> *testCfg, <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga92e5a35afc7dc70f169d76d1e8bfac72">tesocAdvanceResult_t</a> *advanceResult)</td></tr>
<tr class="memdesc:ga82f7af6bfde10e64aba481d657208d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads detailed result of TESOC test. Result contains details like slices configured for test, slice status like completed/not run and result(pass/fail) of each of these slice.  <a href="#ga82f7af6bfde10e64aba481d657208d1d">More...</a><br /></td></tr>
<tr class="separator:ga82f7af6bfde10e64aba481d657208d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561bb2be14d2a7cd54b667d499e89ce8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga561bb2be14d2a7cd54b667d499e89ce8">TESOCReadDiagnosticLog</a> (uint32_t baseAddr, uint32_t *const *diagnosticLog)</td></tr>
<tr class="memdesc:ga561bb2be14d2a7cd54b667d499e89ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads error diagnostic log for TESOC test failure.  <a href="#ga561bb2be14d2a7cd54b667d499e89ce8">More...</a><br /></td></tr>
<tr class="separator:ga561bb2be14d2a7cd54b667d499e89ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba0fce60905c9db9c2b6e98bbaa72f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#gabfba0fce60905c9db9c2b6e98bbaa72f">TESOCIntrEnable</a> (uint32_t baseAddr, uint32_t intrMask)</td></tr>
<tr class="memdesc:gabfba0fce60905c9db9c2b6e98bbaa72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables specified TESOC interrupts.  <a href="#gabfba0fce60905c9db9c2b6e98bbaa72f">More...</a><br /></td></tr>
<tr class="separator:gabfba0fce60905c9db9c2b6e98bbaa72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400fd9e4cc9cf7d753471449f81d689f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga400fd9e4cc9cf7d753471449f81d689f">TESOCIntrDisable</a> (uint32_t baseAddr, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga400fd9e4cc9cf7d753471449f81d689f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables specified TESOC interrupts.  <a href="#ga400fd9e4cc9cf7d753471449f81d689f">More...</a><br /></td></tr>
<tr class="separator:ga400fd9e4cc9cf7d753471449f81d689f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc6204d9a1c560289d6bcd88d876004"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga2bc6204d9a1c560289d6bcd88d876004">TESOCGetIntrEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga2bc6204d9a1c560289d6bcd88d876004"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of enabled interrupts.  <a href="#ga2bc6204d9a1c560289d6bcd88d876004">More...</a><br /></td></tr>
<tr class="separator:ga2bc6204d9a1c560289d6bcd88d876004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed671112e438619bc09d6b931eed1e81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#gaed671112e438619bc09d6b931eed1e81">TESOCGetIntrStatus</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaed671112e438619bc09d6b931eed1e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the status of interrupts.  <a href="#gaed671112e438619bc09d6b931eed1e81">More...</a><br /></td></tr>
<tr class="separator:gaed671112e438619bc09d6b931eed1e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1719d06820934f0edc91f4a8145d2ceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga1719d06820934f0edc91f4a8145d2ceb">TESOCIntrClear</a> (uint32_t baseAddr, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga1719d06820934f0edc91f4a8145d2ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Function clears the status of specified interrupts.  <a href="#ga1719d06820934f0edc91f4a8145d2ceb">More...</a><br /></td></tr>
<tr class="separator:ga1719d06820934f0edc91f4a8145d2ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355b3c672d984e44eef771895af62a7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga355b3c672d984e44eef771895af62a7d">TESOCGetIntrRawStatus</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga355b3c672d984e44eef771895af62a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the raw status of interrupts. Returned value can be masked with the values in enum TESOCIntrFlag_t to check the required interrupt status.  <a href="#ga355b3c672d984e44eef771895af62a7d">More...</a><br /></td></tr>
<tr class="separator:ga355b3c672d984e44eef771895af62a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86bb681b55fdf3f90cd2ccc297c40fb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga86bb681b55fdf3f90cd2ccc297c40fb2">TESOCUnlockMMR</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga86bb681b55fdf3f90cd2ccc297c40fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock access to TESOC registers by writing unlock pattern to TESOC lock register.  <a href="#ga86bb681b55fdf3f90cd2ccc297c40fb2">More...</a><br /></td></tr>
<tr class="separator:ga86bb681b55fdf3f90cd2ccc297c40fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfda5c971128ae722c55b72e074f4f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga9cfda5c971128ae722c55b72e074f4f7">TESOCLockMMR</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga9cfda5c971128ae722c55b72e074f4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock access to TESOC registers by writing lock pattern to TESOC lock register.  <a href="#ga9cfda5c971128ae722c55b72e074f4f7">More...</a><br /></td></tr>
<tr class="separator:ga9cfda5c971128ae722c55b72e074f4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9c40ce13af7431e7eb48ec37fca01108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TESOC_IRQSTATUS_RAW_ALL&#160;&#160;&#160;(TESOC_INTR_STATUS_RAW_TEST_COMPLETION_SET_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro containing mask of all the interrupts. This macro can be passed to interrupt control API's to enable or disable all the main interrupts at a time. </p>
<p>TESOC module allows functional mode field testing of SoC. It enables SW initiated field testing during run-time. The field test can be initiated by any SoC master having access to TESOC registers. SoC is divided into multiple domains for field test. At any point of time field test can be enabled on one domain without corrupting/ stalling functionality of the rest of the SoC. The TESOC ROM image is the encoded version of the test vectors and is already divided into slices. For running field test through TESOC, select domain for which test be tun, slices to be run are configured through tesocTestCfg_t structure. Default slice configuration of each domain on SoC can be obtained through TESOCGetDefaultSliceInfo function.</p>
<p>TESOC programming sequence:</p>
<ol type="1">
<li>Configure TESOC external clock for required frequency.</li>
<li>Check if module for which TESOC test to be run is powered off.</li>
<li>Select configuration for running TESOC through tesocTestCfg_t structure.</li>
<li>Clear TESOC registers before test (use API <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga5e9d97d3b11103a39a635afab25db268" title="This API clears register state of previous TESOC test run(if any). ">TESOCClearPrevState()</a>).</li>
<li>Configure TESOC for test, select domain and slices to be run (use API <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga1f2e93471a9e068038b420898c5916fb" title="This API configures TESOC for test and starts test on selected domain. ">TESOCConfigAndStart()</a>).</li>
<li>Get TESOC test running status(use API TESOCGetTestStatus()).</li>
<li>Wait for TESOC test to complete(Interrupt or polling).</li>
<li>Check result of test. Use API <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga38d53f382f1a036ca4b791aaa1f8b167" title="Check result of TESOC test. ">TESOCCheckTestResult()</a> which returns fail or pass status of TESOC test. </li>
</ol>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga52af6160048d0a68252cbcf0a2e2d5da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga52af6160048d0a68252cbcf0a2e2d5da">tesocIntrFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TESOC interrupt flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga52af6160048d0a68252cbcf0a2e2d5daa88cfe7a981f94a1444e4c872ed273aeb"></a>TESOC_INTR_FLAG_TEST_COMPLETION&#160;</td><td class="fielddoc">
<p>TESOC test completion interrupt mask </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga52af6160048d0a68252cbcf0a2e2d5daab6238a21e570eaa8999f8c2887c0f9f7"></a>TESOC_INTR_FLAG_ALL&#160;</td><td class="fielddoc">
<p>Macro to control all the above interrupt status </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga60453300f7b0c91558e56aee99c50312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga60453300f7b0c91558e56aee99c50312">tesocSliceSrc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to select the slice source for TESOC Test. TESOC can run slices from ROM or RAM. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga60453300f7b0c91558e56aee99c50312a8dbd3587826bc111f2eb733fc76d37e1"></a>TESOC_SLICE_SRC_ROM&#160;</td><td class="fielddoc">
<p>Configure slice source as ROM </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga60453300f7b0c91558e56aee99c50312ad80e68a0ec5234fc20cd50b2ead7ac67"></a>TESOC_SLICE_SRC_RAM&#160;</td><td class="fielddoc">
<p>Configure slice source as RAM </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf073bd93ee3d8519890e38d76cab3ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCAbortTest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API aborts ongoing TESOC test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether test is aborted correctly. STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga38d53f382f1a036ca4b791aaa1f8b167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCCheckTestResult </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a> *&#160;</td>
          <td class="paramname"><em>testCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check result of TESOC test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">testCfg</td><td>Structure containing TESOC test configuration info like domain label and slices configured. Refer struct <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3" title="This Structure defines the configuration for running TESOC test. These parameters are used for config...">tesocTestCfg_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status TESOC test result. STW_SOK : Test Passed. STW_EFAIL : Test Failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga404e49e2b72002e382985c1b04e76496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TESOCClearAbort </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears TESOC abort register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e9d97d3b11103a39a635afab25db268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCClearPrevState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domainLabel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears register state of previous TESOC test run(if any). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">domainLabel</td><td>Domain configured for TESOC test. Registers associated with this domain will be cleared. Refer enum #tesocDomainLabel_t for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether TESOC previous run state is cleaned correctly. STW_SOK : Success. STW_EFAIL : Failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f2e93471a9e068038b420898c5916fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCConfigAndStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a> *&#160;</td>
          <td class="paramname"><em>testCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures TESOC for test and starts test on selected domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">testCfg</td><td>Structure for TESOC test configuration, contains details like domain label and slices to be run. Refer struct <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3" title="This Structure defines the configuration for running TESOC test. These parameters are used for config...">tesocTestCfg_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether TESOC configured and started test correctly. STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga82f7af6bfde10e64aba481d657208d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCGetAdvanceResult </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a> *&#160;</td>
          <td class="paramname"><em>testCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga92e5a35afc7dc70f169d76d1e8bfac72">tesocAdvanceResult_t</a> *&#160;</td>
          <td class="paramname"><em>advanceResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads detailed result of TESOC test. Result contains details like slices configured for test, slice status like completed/not run and result(pass/fail) of each of these slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">testCfg</td><td>Structure containing TESOC test configuration info like domain label and slices configured. Refer struct <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3" title="This Structure defines the configuration for running TESOC test. These parameters are used for config...">tesocTestCfg_t</a> for details. </td></tr>
    <tr><td class="paramname">advanceResult</td><td>Structure for holding detailed TESOC test result, contains information for slice configured, slice status and slice result after TESOC test. Refer struct <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga92e5a35afc7dc70f169d76d1e8bfac72" title="This Structure is used for storing results of TESOC test. These parameters are used as place holder f...">tesocAdvanceResult_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status TESOC test result. STW_SOK : Test Passed. STW_EFAIL : Test Failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bc7224ed2bc6ea02a6cc4ce57b48dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCGetDefaultSliceInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3">tesocTestCfg_t</a> *&#160;</td>
          <td class="paramname"><em>testCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets default slice configuration information for a particular domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC registers </td></tr>
    <tr><td class="paramname">testCfg</td><td>Structure for holding TESOC test default configuration. Contains information of default slices enabled for the domain in the current revision of SoC. Refer struct <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga6905adedc6b35b3feabe4cab236907d3" title="This Structure defines the configuration for running TESOC test. These parameters are used for config...">tesocTestCfg_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether slice info is fetched correctly. STW_SOK : Success. STW_EFAIL : Failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bc6204d9a1c560289d6bcd88d876004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TESOCGetIntrEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of enabled interrupts. </p>
<ul>
<li>It returns 32 bit integer with bits specifying whether an interrupt is enabled or disabled.</li>
<li>Returned value can be masked with the values in enum TESOCIntrFlag_t to check the required interrupt status.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status All the enabled interrupts. </dd></dl>

</div>
</div>
<a class="anchor" id="ga355b3c672d984e44eef771895af62a7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TESOCGetIntrRawStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the raw status of interrupts. Returned value can be masked with the values in enum TESOCIntrFlag_t to check the required interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status All the raw interrupt status. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed671112e438619bc09d6b931eed1e81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TESOCGetIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the status of interrupts. </p>
<ul>
<li>It specifies whether an interrupt is active or inactive.</li>
<li>After an interrupt is serviced, the software must set to 0 the corresponding flag in the interrupt status register.</li>
<li>Returned value can be masked with the values in enum TESOCIntrFlag_t to check the required interrupt status.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status All the active interrupt status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga979316f5ae3240fd12904602aca77e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TESOCGetTestExecutionStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get execution state of TESOC(busy/completed). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status TESOC running status TESOC_TEST_RUNNING : TESOC test Running TESOC_TEST_COMPLETED: TESOC test Completed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1719d06820934f0edc91f4a8145d2ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TESOCIntrClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This Function clears the status of specified interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC registers. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Mask value for the interrupts to be cleared given by enum - TESOCIntrFlag_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga400fd9e4cc9cf7d753471449f81d689f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TESOCIntrDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables specified TESOC interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC registers. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Mask value for the interrupts to be disabled. Supported values are given by enum TESOCIntrFlag_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gabfba0fce60905c9db9c2b6e98bbaa72f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TESOCIntrEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables specified TESOC interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC registers. </td></tr>
    <tr><td class="paramname">intrMask</td><td>Mask value for the interrupts to be enabled. Supported values are given by the enum TESOCIntrFlag_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga9cfda5c971128ae722c55b72e074f4f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TESOCLockMMR </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock access to TESOC registers by writing lock pattern to TESOC lock register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga561bb2be14d2a7cd54b667d499e89ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCReadDiagnosticLog </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const *&#160;</td>
          <td class="paramname"><em>diagnosticLog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads error diagnostic log for TESOC test failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">diagnosticLog</td><td>Pointer to 2D integer array size 16x4 to store TESOC test diagnostic log(as TESOC dumps 16 cycles of 128 bit data on test failure).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether TESOC diagnostic log read correctly. STW_SOK : Success STW_EFAIL : Failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gadbf6b6c0ee6da09ca5ef69a90b70feff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCRunTesoCDiagnostic </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>testId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will run TESOC diagnostic slice for domain passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">testId</td><td>Test Id for which TESOC diagnostic slice to be run. Refer enum #tesocTestId_t for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether TESOC diagnostic test on selected domain run correctly. STW_SOK : Success STW_EFAIL : Failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not all TESOC domains have diagnostic slice. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bad97e9a91fe2ba17806ed55650e502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCSetSliceSrc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>testSliceSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will set slice source for running TESOC test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">testSliceSrc</td><td>Source of slice for TESOC test. Refer enum <a class="el" href="group___c_s_l___t_e_s_o_c.html#ga497159ca45c8e5da93936e08e0fcb1c1" title="Enum to select the slice source for TESOC Test. TESOC can run slices from ROM or RAM. ">tesocSliceSrc_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status TESOC test result. STW_SOK : Test Passed. STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga86bb681b55fdf3f90cd2ccc297c40fb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TESOCUnlockMMR </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock access to TESOC registers by writing unlock pattern to TESOC lock register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga1becee1d3970c113ed04fcd1b247d030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCWaitUntilBusy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to wait till TESOC starts test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">timeOut</td><td>Wait time duration can be set to any uint32 or TESOC_TIMEOUT_TEST_START TESOC_TIMEOUT_INFINITE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether wait for TESOC busy succeeded. STW_SOK : Success STW_EFAIL : wait for busy failed(timeout). </dd></dl>

</div>
</div>
<a class="anchor" id="ga14c6c56c52a7b51aadcb7b3e4ef2a843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t TESOCWaitUntilNotBusy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to wait till TESOC completes running test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the TESOC Registers. </td></tr>
    <tr><td class="paramname">timeOut</td><td>Wait time duration can be set to any uint32 or TESOC_TIMEOUT_TEST_END TESOC_TIMEOUT_INFINITE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether wait for TESOC not busy succeeded. STW_SOK : Success STW_EFAIL : wait for not busy failed(timeout). </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
