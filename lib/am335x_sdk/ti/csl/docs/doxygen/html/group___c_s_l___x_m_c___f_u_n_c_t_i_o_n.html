<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XMC Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">XMC Functions<div class="ingroups"><a class="el" href="group___c_s_l___x_m_c___a_p_i.html">XMC</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga41c10207752c6eb70304ca964d875b8d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga41c10207752c6eb70304ca964d875b8d">CSL_XMC_setXMPAXH</a> (Uint32 index, const <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#gac9e943a6a5c55706f9ec00582d001fb7">CSL_XMC_XMPAXH</a> *mpaxh)</td></tr>
<tr class="separator:ga41c10207752c6eb70304ca964d875b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e987c506363ea81a1d6d90abc75e23e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga9e987c506363ea81a1d6d90abc75e23e">CSL_XMC_setXMPAXL</a> (Uint32 index, const <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga0122e529cd705a5825c46d9a800c0c57">CSL_XMC_XMPAXL</a> *mpaxl)</td></tr>
<tr class="separator:ga9e987c506363ea81a1d6d90abc75e23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87144e8f3321f29b8f4197ab06d9cf37"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga87144e8f3321f29b8f4197ab06d9cf37">CSL_XMC_getXMPAXH</a> (Uint32 index, <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#gac9e943a6a5c55706f9ec00582d001fb7">CSL_XMC_XMPAXH</a> *mpaxh)</td></tr>
<tr class="separator:ga87144e8f3321f29b8f4197ab06d9cf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07b174e0d92c6d30a40203190cc7457"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#gab07b174e0d92c6d30a40203190cc7457">CSL_XMC_getXMPAXL</a> (Uint32 index, <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga0122e529cd705a5825c46d9a800c0c57">CSL_XMC_XMPAXL</a> *mpaxl)</td></tr>
<tr class="separator:gab07b174e0d92c6d30a40203190cc7457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f4b5c5b74f4573371d7b6fd59716f24"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga9f4b5c5b74f4573371d7b6fd59716f24">CSL_XMC_getFaultAddress</a> (void)</td></tr>
<tr class="separator:ga9f4b5c5b74f4573371d7b6fd59716f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdf39f1637d7b4244463af5d7816493"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga7fdf39f1637d7b4244463af5d7816493">CSL_XMC_clearFault</a> (void)</td></tr>
<tr class="separator:ga7fdf39f1637d7b4244463af5d7816493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ce497d71607102228ecefcc50dc9c2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga04ce497d71607102228ecefcc50dc9c2">CSL_XMC_getFaultStatus</a> (<a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga22c0158c9cf5ccba84f54708d70c63eb">CSL_XMC_MPFSR</a> *xmpfsr)</td></tr>
<tr class="separator:ga04ce497d71607102228ecefcc50dc9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73384d6839c031c8c9bf8bf3f7effc16"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga73384d6839c031c8c9bf8bf3f7effc16">CSL_XMC_invalidatePrefetchBuffer</a> (void)</td></tr>
<tr class="separator:ga73384d6839c031c8c9bf8bf3f7effc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17d92e7045fb77bc9cf05787d383815"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#gaa17d92e7045fb77bc9cf05787d383815">CSL_XMC_loadAnalysisCounterEnable</a> (void)</td></tr>
<tr class="separator:gaa17d92e7045fb77bc9cf05787d383815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca63f94419ed1220865996f2abcac6b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga1ca63f94419ed1220865996f2abcac6b">CSL_XMC_setAnalysisCounterEnableMode</a> (<a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga36cc2a4f80ddbf2b54dc81233a57453e">CSL_XMC_ACEN_MODE</a> acenMode)</td></tr>
<tr class="separator:ga1ca63f94419ed1220865996f2abcac6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e484bf450f236a2e46d53be3cefd92"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga59e484bf450f236a2e46d53be3cefd92">CSL_XMC_resetAnalysisCounters</a> (void)</td></tr>
<tr class="separator:ga59e484bf450f236a2e46d53be3cefd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d55a62c6990b5f0f3d7672e26bbf53d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga1d55a62c6990b5f0f3d7672e26bbf53d">CSL_XMC_setPrefetchCommand</a> (Uint8 inv, Uint8 acEnLoad, <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga36cc2a4f80ddbf2b54dc81233a57453e">CSL_XMC_ACEN_MODE</a> acenMode, Uint8 acRst)</td></tr>
<tr class="separator:ga1d55a62c6990b5f0f3d7672e26bbf53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c9d2a895f306680f1b009083963f9b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga36cc2a4f80ddbf2b54dc81233a57453e">CSL_XMC_ACEN_MODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#gaf7c9d2a895f306680f1b009083963f9b">CSL_XMC_getAnalysisCounterEnableStatus</a> (void)</td></tr>
<tr class="separator:gaf7c9d2a895f306680f1b009083963f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e3aa21876321b04c37313a931a9dc7"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga61e3aa21876321b04c37313a931a9dc7">CSL_XMC_getNumPrefetchSent</a> (void)</td></tr>
<tr class="separator:ga61e3aa21876321b04c37313a931a9dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39baefbb537736bbdad12f8da908111a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga39baefbb537736bbdad12f8da908111a">CSL_XMC_getNumPrefetchCanceled</a> (void)</td></tr>
<tr class="separator:ga39baefbb537736bbdad12f8da908111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbafe73f1ffacde09842269a3d4e5d6e"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#gabbafe73f1ffacde09842269a3d4e5d6e">CSL_XMC_getNumPrefetchHits</a> (void)</td></tr>
<tr class="separator:gabbafe73f1ffacde09842269a3d4e5d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga200e93805657a30b08acf68ce641b9de"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga200e93805657a30b08acf68ce641b9de">CSL_XMC_getNumPrefetchMisses</a> (void)</td></tr>
<tr class="separator:ga200e93805657a30b08acf68ce641b9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602d831cfbabf1e1a8173d84bf202748"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga602d831cfbabf1e1a8173d84bf202748">CSL_XMC_getPrefetchAddress</a> (Uint32 index, <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga9532a06a9b35c157c1f235ce88b2443a">CSL_XMC_XPFADDR</a> *xpfaddr)</td></tr>
<tr class="separator:ga602d831cfbabf1e1a8173d84bf202748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa684b465caf19e8c4394af00e419c7f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#gaaa684b465caf19e8c4394af00e419c7f">CSL_XMC_setMDMAPriority</a> (Uint32 priority)</td></tr>
<tr class="separator:gaaa684b465caf19e8c4394af00e419c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c5621d21c60d0b518433bf721aafe8"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___x_m_c___f_u_n_c_t_i_o_n.html#ga76c5621d21c60d0b518433bf721aafe8">CSL_XMC_getMDMAPriority</a> (void)</td></tr>
<tr class="separator:ga76c5621d21c60d0b518433bf721aafe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7fdf39f1637d7b4244463af5d7816493"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_clearFault </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_clearFault</b> </p>
<p><b>Description</b> <br />
 This function clears the fault information.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 XMPFCR register configured with the value passed. Fault address and status registers are cleared.</p>
<p><b>Writes</b> <br />
 XMC_XMPFCR_MPFCLR=1</p>
<p><b>Affects</b> <br />
 XMC_XMPFAR_FADDR=0, XMC_XMPFSR_LOCAL=0, XMC_XMPFSR_SR=0, XMC_XMPFSR_SX=0, XMC_XMPFSR_UR=0, XMC_XMPFSR_UW=0, XMC_XMPFSR_UW=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_XMC_clearFault ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf7c9d2a895f306680f1b009083963f9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga36cc2a4f80ddbf2b54dc81233a57453e">CSL_XMC_ACEN_MODE</a> CSL_XMC_getAnalysisCounterEnableStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getAnalysisCounterEnableStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the Analysis counter enable mode by reading the contents of 'ACEN' bits from the XPFACS register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> CSL_XMC_ACEN_MODE - Event counting mode</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CSL_XMC_XPFACS_ACEN bits read and returned</p>
<p><b>Reads</b> <br />
 XMC_XPFACS_ACEN</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_XMC_ACEN_MODE   acenMode;

     // Read ACEN Mode Status
     acenMode = CSL_XMC_getAnalysisCounterEnableStatus ();
     if (acenMode == CSL_XMC_ACEN_MODE_COUNT_DISABLE)
     {
         ...
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9f4b5c5b74f4573371d7b6fd59716f24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_XMC_getFaultAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getFaultAddress</b> </p>
<p><b>Description</b> <br />
 This function gets the access address causing the fault.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XMPFAR_FADDR</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 faultAddr;

     faultAddr = CSL_XMC_getFaultAddress ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga04ce497d71607102228ecefcc50dc9c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_getFaultStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga22c0158c9cf5ccba84f54708d70c63eb">CSL_XMC_MPFSR</a> *&#160;</td>
          <td class="paramname"><em>xmpfsr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getFaultStatus</b> </p>
<p><b>Description</b> <br />
 This function gets the contents of Fault Status Register XMPFSR.</p>
<p><b>Arguments</b> </p><pre class="fragment">       xmpfsr    CSL_XMC_MPFSR structure that needs to be filled in from
                 XMPFSR register</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XMPFSR_LOCAL, XMC_XMPFSR_SR, XMC_XMPFSR_SX, XMC_XMPFSR_UR, XMC_XMPFSR_UW, XMC_XMPFSR_UW</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_XMC_MPFSR xmpfsr;

     CSL_XMC_getFaultStatus (&amp;xmpfsr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga76c5621d21c60d0b518433bf721aafe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_XMC_getMDMAPriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getMDMAPriority</b> </p>
<p><b>Description</b> <br />
 This function retrieves the priority of transaction submissions to Master DMA (MDMA).</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_MDMAARBX_PRI</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 priority;

     priority = CSL_XMC_getMDMAPriority ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga39baefbb537736bbdad12f8da908111a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_XMC_getNumPrefetchCanceled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getNumPrefetchCanceled</b> </p>
<p><b>Description</b> <br />
 This function returns the contents of XPFAC1 register, i.e., the number of prefetch requests canceled (prefetch requests that returned a non-zero rstatus or other error).</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XPFAC1_CANCELED</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      numPrefetchCanceled;

     // Read Prefetch request canceled
     numPrefetchCanceled = CSL_XMC_getNumPrefetchCanceled ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabbafe73f1ffacde09842269a3d4e5d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_XMC_getNumPrefetchHits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getNumPrefetchHits</b> </p>
<p><b>Description</b> <br />
 This function returns the contents of XPFAC2 register, i.e., the number of demand prefetch requests that resulted in a successful prefetch.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XPFAC2_HIT</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      numPrefetchHits;

     // Read Number of Prefetch request hits
     numPrefetchHits = CSL_XMC_getNumPrefetchHits ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga200e93805657a30b08acf68ce641b9de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_XMC_getNumPrefetchMisses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getNumPrefetchMisses</b> </p>
<p><b>Description</b> <br />
 This function returns the contents of XPFAC3 register, i.e., the number of prefetch requests that resulted in a miss and had to be submitted as a demand prefetch request into the system.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XPFAC3_MISS</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      numPrefetchMisses;

     // Read Number of Prefetch request misses
     numPrefetchMisses = CSL_XMC_getNumPrefetchMisses ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga61e3aa21876321b04c37313a931a9dc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_XMC_getNumPrefetchSent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getNumPrefetchSent</b> </p>
<p><b>Description</b> <br />
 This function returns the contents of XPFAC0 register, i.e., the number of prefetch requests sent into the system.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XPFAC0_SENT</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      numPrefetchSent;

     // Read Prefetch request sent count
     numPrefetchSent = CSL_XMC_getNumPrefetchSent ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga602d831cfbabf1e1a8173d84bf202748"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_getPrefetchAddress </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga9532a06a9b35c157c1f235ce88b2443a">CSL_XMC_XPFADDR</a> *&#160;</td>
          <td class="paramname"><em>xpfaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getPrefetchAddress</b> </p>
<p><b>Description</b> <br />
 This function gets the contents of XPFADDR register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index     Index into the set of 8 registers
       xpfaddr   CSL_XMC_XPFADDR structure that needs to be filled from
                 XPFADDR register</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XPFADDR_ADDR, XMC_XPFADDR_DIR, XMC_XPFADDR_DPH, XMC_XPFADDR_DVH, XMC_XPFADDR_AVH, XMC_XPFADDR_DPL, XMC_XPFADDR_DVL, XMC_XPFADDR_AVL</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 index = 0;
     CSL_XMC_XPFADDR xpfaddr;

     CSL_XMC_getPrefetchAddress (index, &amp;xpfaddr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga87144e8f3321f29b8f4197ab06d9cf37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_getXMPAXH </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#gac9e943a6a5c55706f9ec00582d001fb7">CSL_XMC_XMPAXH</a> *&#160;</td>
          <td class="paramname"><em>mpaxh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getXMPAXH</b> </p>
<p><b>Description</b> <br />
 This function gets the contents of XMPAXH register.</p>
<p>please see section 7.3 on MPAX unit <a href="http://www.ti.com/lit/sprugw0">http://www.ti.com/lit/sprugw0</a> for details on the sample arguments and example values to set XMPAXH register as provided under table 7-2</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       Index into the set of 16 XMPAXH registers
     mpaxh       CSL_XMC_XMPAXH structure that needs to be populated with
                 XMPAXH register contents.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XMPAXH_SEGSZ, XMC_XMPAXH_BADDR</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 index = 0;
     CSL_XMC_XMPAXH mpaxh;

     CSL_XMC_getXMPAXH (index, &amp;mpaxh);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab07b174e0d92c6d30a40203190cc7457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_getXMPAXL </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga0122e529cd705a5825c46d9a800c0c57">CSL_XMC_XMPAXL</a> *&#160;</td>
          <td class="paramname"><em>mpaxl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_getXMPAXL</b> </p>
<p><b>Description</b> <br />
 This function gets the contents of XMPAXL register.</p>
<p>please see section 7.3 on MPAX unit <a href="http://www.ti.com/lit/sprugw0">http://www.ti.com/lit/sprugw0</a> for details on the sample arguments and example values to set XMPAXL register as provided under table 7-2</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       Index into the set of 16 registers
     mpaxl       CSL_XMC_XMPAXL structure that needs to be populated with
                 XMPAXL register contents.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XMC_XMPAXL_RADDR, XMC_XMPAXL_UX, XMC_XMPAXL_UW, XMC_XMPAXL_UR, XMC_XMPAXL_SX, XMC_XMPAXL_SW, XMC_XMPAXL_SR</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 index = 0;
     CSL_XMC_XMPAXL mpaxl;

     CSL_XMC_getXMPAXL (index, &amp;mpaxl);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga73384d6839c031c8c9bf8bf3f7effc16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_invalidatePrefetchBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_invalidatePrefetchBuffer</b> </p>
<p><b>Description</b> <br />
 This function when called marks all slots in the data prefetch buffer and program prefetch buffer invalid by writing 1 in the XPFCMD register's INV bit.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CSL_XMC_XPFCMD_INV bit set to 1 and data and program prefetch buffers are invalidated.</p>
<p><b>Writes</b> <br />
 XMC_XPFCMD_INV=1</p>
<p><b>Affects</b> <br />
 XMC_XPFADDR_DVH=0, XMC_XPFADDR_DVL=0</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">* 
       CSL_XMC_invalidatePrefetchBuffer ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa17d92e7045fb77bc9cf05787d383815"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_loadAnalysisCounterEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_loadAnalysisCounterEnable</b> </p>
<p><b>Description</b> <br />
 This function when called sets the 'ACENL' bit of the XPFCMD register, thus triggering a copy/load of ACEN bits (Analysis counter enable mode) into ACEN bits of XPFACS register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CSL_XMC_XPFCMD_ACENL bit set to 1 and ACEN bits value is loaded into the ACEN bits of XPFACS register.</p>
<p><b>Writes</b> <br />
 XMC_XPFCMD_ACENL=1</p>
<p><b>Affects</b> <br />
 XMC_XPFACS_ACEN</p>
<p><b>Example</b> </p><pre class="fragment">* 
       CSL_XMC_loadAnalysisCounterEnable ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga59e484bf450f236a2e46d53be3cefd92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_resetAnalysisCounters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_resetAnalysisCounters</b> </p>
<p><b>Description</b> <br />
 This function when called sets the 'ACRST' bit of the XPFCMD register, thus triggering a clear/reset operation on the prefetch analysis counter registers.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CSL_XMC_XPFCMD_ACRST bit set to 1 and prefetch analysis counter registers are cleared.</p>
<p><b>Writes</b> <br />
 XMC_XPFCMD_ACRST=1</p>
<p><b>Affects</b> <br />
 XMC_XPFAC0_SENT=0, XMC_XPFAC1_CANCELED=0, XMC_XPFAC2_HIT=0, XMC_XPFAC3_MISS=0</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">* 
       CSL_XMC_resetAnalysisCounters ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1ca63f94419ed1220865996f2abcac6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_setAnalysisCounterEnableMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga36cc2a4f80ddbf2b54dc81233a57453e">CSL_XMC_ACEN_MODE</a>&#160;</td>
          <td class="paramname"><em>acenMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_setAnalysisCounterEnableMode</b> </p>
<p><b>Description</b> <br />
 This function when called sets up the Event counting mode by writing to the 'ACEN' bits of the XPFCMD register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       acenMode  Analyis counter mode.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CSL_XMC_XPFCMD_ACEN bits written with the Analysis counter mode specified.</p>
<p><b>Writes</b> <br />
 XMC_XPFCMD_ACEN</p>
<p><b>Example</b> </p><pre class="fragment">     // Enable both program and data events
     CSL_XMC_setAnalysisCounterEnableMode (CSL_XMC_ACEN_MODE_COUNT_ALL);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaa684b465caf19e8c4394af00e419c7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_setMDMAPriority </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_setMDMAPriority</b> </p>
<p><b>Description</b> <br />
 This function configures the priority of transaction submissions to Master DMA (MDMA).</p>
<p><b>Arguments</b> </p><pre class="fragment">     priority        Priority value to set for MDMA transactions.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XMC_MDMAARBX_PRI</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 priority = 4;

     CSL_XMC_setMDMAPriority (priority);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1d55a62c6990b5f0f3d7672e26bbf53d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_setPrefetchCommand </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>acEnLoad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga36cc2a4f80ddbf2b54dc81233a57453e">CSL_XMC_ACEN_MODE</a>&#160;</td>
          <td class="paramname"><em>acenMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>acRst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_setPrefetchCommand</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the XPFCMD register based on the inputs specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">     inv         Invalidate Prefetch Buffer command flag. When set to 1,
                 data and program prefetch buffers are invalidated.
     acEnLoad    Analysis Counter Enable Load flag. When set to 1, the
                 Analysis Counter Enable mode is loaded into the XPFACS status
                 register.
     acEnMode    Analyis counter enable mode. Specifies the event counting mode
                 for the prefetcher.
     acRst       Analysis counter Reset flag. When set to 1, resets all
                 the prefetch event counters.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CSL_XMC_XPFCMD written with the settings specified.</p>
<p><b>Writes</b> <br />
 XMC_XPFCMD_INV, XMC_XPFCMD_ACENL, XMC_XPFCMD_ACEN, XMC_XPFCMD_ACRST</p>
<p><b>Example</b> </p><pre class="fragment">     // Issue the following prefetch commands:
     //  - Dont invalidate prefetch buffers
     //  - Enable Analysis Counter Enable load
     //  - Enable both program and data event counting
     //  - Dont reset the prefetch counters
     CSL_XMC_setPrefetchCommand (0, 1, CSL_XMC_ACEN_MODE_COUNT_ALL, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga41c10207752c6eb70304ca964d875b8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_setXMPAXH </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#gac9e943a6a5c55706f9ec00582d001fb7">CSL_XMC_XMPAXH</a> *&#160;</td>
          <td class="paramname"><em>mpaxh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_setXMPAXH</b> </p>
<p><b>Description</b> <br />
 This function sets the contents of XMPAXH register indicated by the index here. please see section 7.3 on MPAX unit <a href="http://www.ti.com/lit/sprugw0">http://www.ti.com/lit/sprugw0</a> for details on the sample arguments and example values to set XMPAXH register as provided under table 7-2</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       Index into the set of 16 registers (0-15)
     mpaxh       CSL_XMC_XMPAXH structure that needs to be set into the
                 register</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Corresponding XMPAXH register configured with the value passed.</p>
<p><b>Writes</b> <br />
 XMC_XMPAXH_SEGSZ, XMC_XMPAXH_BADDR</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 index = 0;
     CSL_XMC_XMPAXH mpaxh;

     mpaxh.segSize = 4;
     mpaxh.baseAddress = 0x1000;

     CSL_XMC_setXMPAXH (index, &amp;mpaxh);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9e987c506363ea81a1d6d90abc75e23e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_XMC_setXMPAXL </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___x_m_c___d_a_t_a_s_t_r_u_c_t.html#ga0122e529cd705a5825c46d9a800c0c57">CSL_XMC_XMPAXL</a> *&#160;</td>
          <td class="paramname"><em>mpaxl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_XMC_setXMPAXL</b> </p>
<p><b>Description</b> <br />
 This function sets the contents of XMPAXL register corresponding to the index specified. please see section 7.3 on MPAX unit <a href="http://www.ti.com/lit/sprugw0">http://www.ti.com/lit/sprugw0</a> for details on the sample arguments and example values to set XMPAXL register as provided under table 7-2</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       Index into the set of 16 registers (0-15)
     mpaxl       CSL_XMC_XMPAXL structure that needs to be set into the
                 register</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Corresponding XMPAXL register configured with the value passed.</p>
<p><b>Writes</b> <br />
 XMC_XMPAXL_RADDR, XMC_XMPAXL_UX, XMC_XMPAXL_UW, XMC_XMPAXL_UR, XMC_XMPAXL_SX, XMC_XMPAXL_SW, XMC_XMPAXL_SR</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 index = 0;
     CSL_XMC_XMPAXL mpaxl;

     mpaxl.ux = 1;
     mpaxl.uw = 1;
     mpaxl.ur = 1;
     mpaxl.sx = 1;
     mpaxl.sw = 1;
     mpaxl.sr = 1;
     mpaxl.rAddr = 0x4000 ;

     CSL_XMC_setXMPAXL (index, &amp;mpaxl);</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
