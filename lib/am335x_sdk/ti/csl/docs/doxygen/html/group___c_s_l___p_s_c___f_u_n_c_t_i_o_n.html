<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PSC Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PSC Functions<div class="ingroups"><a class="el" href="group___c_s_l___p_s_c___a_p_i.html">PSC</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga17d9b8ff5c1b8b53c254bbbfb02b769f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga17d9b8ff5c1b8b53c254bbbfb02b769f">CSL_PSC_getVersionInfo</a> (void)</td></tr>
<tr class="separator:ga17d9b8ff5c1b8b53c254bbbfb02b769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7846a2786f477dae3eede9951295f0"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga2d7846a2786f477dae3eede9951295f0">CSL_PSC_getVoltageControl</a> (void)</td></tr>
<tr class="separator:ga2d7846a2786f477dae3eede9951295f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf4dbb847086a45ab16d3c9d8a1d4a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga6bf4dbb847086a45ab16d3c9d8a1d4a9">CSL_PSC_setModuleNextState</a> (Uint32 moduleNum, <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> state)</td></tr>
<tr class="separator:ga6bf4dbb847086a45ab16d3c9d8a1d4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb18baae028405ec60204951a51c4ca3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gafb18baae028405ec60204951a51c4ca3">CSL_PSC_getModuleNextState</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gafb18baae028405ec60204951a51c4ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bbed752504c9b9055a98d6f6272bd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gad6bbed752504c9b9055a98d6f6272bd9">CSL_PSC_setModuleLocalReset</a> (Uint32 moduleNum, <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> resetState)</td></tr>
<tr class="separator:gad6bbed752504c9b9055a98d6f6272bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab40f49bd4d18287ed764942935c17361"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gab40f49bd4d18287ed764942935c17361">CSL_PSC_getModuleLocalReset</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gab40f49bd4d18287ed764942935c17361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7d97147f83f067d182132532ff06f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga7a7d97147f83f067d182132532ff06f1">CSL_PSC_enableModuleResetIsolation</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga7a7d97147f83f067d182132532ff06f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9714f642ae9eeba76dea943598365a24"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga9714f642ae9eeba76dea943598365a24">CSL_PSC_disableModuleResetIsolation</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga9714f642ae9eeba76dea943598365a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga324b12d773941edd62391b439ae539a3"><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga324b12d773941edd62391b439ae539a3">CSL_PSC_isModuleResetIsolationEnabled</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga324b12d773941edd62391b439ae539a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac801999b12f3847bc0c79d2fd3d9b7c9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gac801999b12f3847bc0c79d2fd3d9b7c9">CSL_PSC_getModuleState</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gac801999b12f3847bc0c79d2fd3d9b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11cc663d2770ec472e2487587494431"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gaa11cc663d2770ec472e2487587494431">CSL_PSC_getModuleLocalResetStatus</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gaa11cc663d2770ec472e2487587494431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9511a9d7f23e2f40c3304c95a96a4620"><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga9511a9d7f23e2f40c3304c95a96a4620">CSL_PSC_isModuleLocalResetDone</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga9511a9d7f23e2f40c3304c95a96a4620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddfe8f0bfea7f2f39d038893e607c120"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga978a43aff53dc4b6345aada91a7adda5">CSL_PSC_MDRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gaddfe8f0bfea7f2f39d038893e607c120">CSL_PSC_getModuleResetStatus</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gaddfe8f0bfea7f2f39d038893e607c120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d3d0d7e54f80a17289f72cff84b499"><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gab8d3d0d7e54f80a17289f72cff84b499">CSL_PSC_isModuleResetDone</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gab8d3d0d7e54f80a17289f72cff84b499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9df2b36d97da0fa0022ca1e141e0dd"><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga1a9df2b36d97da0fa0022ca1e141e0dd">CSL_PSC_isModuleClockOn</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga1a9df2b36d97da0fa0022ca1e141e0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71658f7648aa20cf4e955831586d27de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga71658f7648aa20cf4e955831586d27de">CSL_PSC_enablePowerDomain</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:ga71658f7648aa20cf4e955831586d27de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb48ff1ba86e4d0b7a1c0bf5f80011c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga8fb48ff1ba86e4d0b7a1c0bf5f80011c">CSL_PSC_disablePowerDomain</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:ga8fb48ff1ba86e4d0b7a1c0bf5f80011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a0b036fa507c380a62d68957e2291b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga370db44ee943415db4d3237456b90887">CSL_PSC_PDSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga42a0b036fa507c380a62d68957e2291b">CSL_PSC_getPowerDomainState</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:ga42a0b036fa507c380a62d68957e2291b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8773ed44366cd6a55d451440a44c885c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga8773ed44366cd6a55d451440a44c885c">CSL_PSC_startStateTransition</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:ga8773ed44366cd6a55d451440a44c885c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b22f9fb21b400cffcf128b3999de50"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gac2b22f9fb21b400cffcf128b3999de50">CSL_PSC_isStateTransitionDone</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:gac2b22f9fb21b400cffcf128b3999de50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga828d1edabdb004d8243d53ec3085391a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga828d1edabdb004d8243d53ec3085391a">CSL_PSC_getVersionInfo2</a> (void)</td></tr>
<tr class="separator:ga828d1edabdb004d8243d53ec3085391a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea1011218ad01af4de7e8b00caf06fd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga5ea1011218ad01af4de7e8b00caf06fd">CSL_PSC_isInvalidModuleNumber</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga5ea1011218ad01af4de7e8b00caf06fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32022704c894b3eef58abf446a0b53d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gac32022704c894b3eef58abf446a0b53d">CSL_PSC_setModuleNextState2</a> (Uint32 moduleNum, <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> state)</td></tr>
<tr class="separator:gac32022704c894b3eef58abf446a0b53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10a34101f6af856089e55d44f8c7f88"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gae10a34101f6af856089e55d44f8c7f88">CSL_PSC_getModuleNextState2</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gae10a34101f6af856089e55d44f8c7f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42accc6013d0100bd1a14e2019c6d090"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga42accc6013d0100bd1a14e2019c6d090">CSL_PSC_setModuleLocalReset2</a> (Uint32 moduleNum, <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> resetState)</td></tr>
<tr class="separator:ga42accc6013d0100bd1a14e2019c6d090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b697ca78aeb78eccf296b3cb38d33fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga7b697ca78aeb78eccf296b3cb38d33fa">CSL_PSC_getModuleLocalReset2</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga7b697ca78aeb78eccf296b3cb38d33fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c1d98aa6ef22e36c27bfa301c25aa6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga27c1d98aa6ef22e36c27bfa301c25aa6">CSL_PSC_getModuleState2</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga27c1d98aa6ef22e36c27bfa301c25aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f7d56818b564166150f77a79148d69"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gac2f7d56818b564166150f77a79148d69">CSL_PSC_getModuleLocalResetStatus2</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gac2f7d56818b564166150f77a79148d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958f54e8092ccae3cd31313854a6b2a4"><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga958f54e8092ccae3cd31313854a6b2a4">CSL_PSC_isModuleLocalResetDone2</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga958f54e8092ccae3cd31313854a6b2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6727811e2103541a4fa061510f18754"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga978a43aff53dc4b6345aada91a7adda5">CSL_PSC_MDRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gae6727811e2103541a4fa061510f18754">CSL_PSC_getModuleResetStatus2</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:gae6727811e2103541a4fa061510f18754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2193d6e391ab70aebda80429b1b1fe"><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga4b2193d6e391ab70aebda80429b1b1fe">CSL_PSC_isModuleResetDone2</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga4b2193d6e391ab70aebda80429b1b1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90598d93edbf0003efc14bd3216e7de6"><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga90598d93edbf0003efc14bd3216e7de6">CSL_PSC_isModuleClockOn2</a> (Uint32 moduleNum)</td></tr>
<tr class="separator:ga90598d93edbf0003efc14bd3216e7de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac987fa8807374f788b3ee7e7949bf8b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gac987fa8807374f788b3ee7e7949bf8b0">CSL_PSC_enablePowerDomain2</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:gac987fa8807374f788b3ee7e7949bf8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a4ea1d5f4869a54d53350214a63c8f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gaf0a4ea1d5f4869a54d53350214a63c8f">CSL_PSC_disablePowerDomain2</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:gaf0a4ea1d5f4869a54d53350214a63c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8caca2e79d60377f0aa3abbb13a8c059"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga370db44ee943415db4d3237456b90887">CSL_PSC_PDSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga8caca2e79d60377f0aa3abbb13a8c059">CSL_PSC_getPowerDomainState2</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:ga8caca2e79d60377f0aa3abbb13a8c059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccbebb2b2889287916d2da4991da0455"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gaccbebb2b2889287916d2da4991da0455">CSL_PSC_startStateTransition2</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:gaccbebb2b2889287916d2da4991da0455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e98ca1ec25018bc2aa257750586ae8"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga14e98ca1ec25018bc2aa257750586ae8">CSL_PSC_isStateTransitionDone2</a> (Uint32 pwrDmnNum)</td></tr>
<tr class="separator:ga14e98ca1ec25018bc2aa257750586ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3935f4a6b051b0d94cd345f6ff0c4b0b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga3935f4a6b051b0d94cd345f6ff0c4b0b">CSL_PSC_getVersionInfo</a> (const CSL_PscRegs *pPscRegs)</td></tr>
<tr class="separator:ga3935f4a6b051b0d94cd345f6ff0c4b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0846fb05bc513217322444abc04789e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gae0846fb05bc513217322444abc04789e">CSL_PSC_getVoltageControl</a> (const CSL_PscRegs *pPscRegs)</td></tr>
<tr class="separator:gae0846fb05bc513217322444abc04789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd432de657125fedce3e18855bb03e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga4cd432de657125fedce3e18855bb03e1">CSL_PSC_setModuleNextState</a> (CSL_PscRegs *pPscRegs, uint32_t moduleNum, <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> state)</td></tr>
<tr class="separator:ga4cd432de657125fedce3e18855bb03e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863f6aa60294e461091770a9e93d85bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga863f6aa60294e461091770a9e93d85bd">CSL_PSC_getModuleNextState</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:ga863f6aa60294e461091770a9e93d85bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc603f663c4532471b995fd3b593b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga2fc603f663c4532471b995fd3b593b36">CSL_PSC_setModuleLocalReset</a> (CSL_PscRegs *pPscRegs, uint32_t moduleNum, <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> resetState)</td></tr>
<tr class="separator:ga2fc603f663c4532471b995fd3b593b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cbf8cf247c53831425698d04789c636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga3cbf8cf247c53831425698d04789c636">CSL_PSC_getModuleLocalReset</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:ga3cbf8cf247c53831425698d04789c636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7031d2a6491cb8377c6bd0463325cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga6d7031d2a6491cb8377c6bd0463325cd">CSL_PSC_enableModuleResetIsolation</a> (CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:ga6d7031d2a6491cb8377c6bd0463325cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52e3ceba48493891db948e34c999bcf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga52e3ceba48493891db948e34c999bcf4">CSL_PSC_disableModuleResetIsolation</a> (CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:ga52e3ceba48493891db948e34c999bcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553245c388fb42e50db1c1fa13909b04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga553245c388fb42e50db1c1fa13909b04">CSL_PSC_isModuleResetIsolationEnabled</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:ga553245c388fb42e50db1c1fa13909b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ebb2c97382ea7af5b6dc8815c6dd30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga1ebb2c97382ea7af5b6dc8815c6dd30d">CSL_PSC_getModuleState</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:ga1ebb2c97382ea7af5b6dc8815c6dd30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a40e802cf6d71dadad19e0efcbd46de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga2a40e802cf6d71dadad19e0efcbd46de">CSL_PSC_getModuleLocalResetStatus</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:ga2a40e802cf6d71dadad19e0efcbd46de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0c19995d157fa6790fec05486ae4f83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gac0c19995d157fa6790fec05486ae4f83">CSL_PSC_isModuleLocalResetDone</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:gac0c19995d157fa6790fec05486ae4f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b159765024a8184ae06627edc20da0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga978a43aff53dc4b6345aada91a7adda5">CSL_PSC_MDRST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gac4b159765024a8184ae06627edc20da0">CSL_PSC_getModuleResetStatus</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:gac4b159765024a8184ae06627edc20da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6964a793ae13eb11fbc116378d39e15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gaf6964a793ae13eb11fbc116378d39e15">CSL_PSC_isModuleResetDone</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:gaf6964a793ae13eb11fbc116378d39e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7ef9b921121309a2b52b6dc5f6052e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga6c7ef9b921121309a2b52b6dc5f6052e">CSL_PSC_isModuleClockOn</a> (const CSL_PscRegs *pPscRegs, uint32_t moduleNum)</td></tr>
<tr class="separator:ga6c7ef9b921121309a2b52b6dc5f6052e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2240dd296b3fbf0d575f542da277ea11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga2240dd296b3fbf0d575f542da277ea11">CSL_PSC_enablePowerDomain</a> (CSL_PscRegs *pPscRegs, uint32_t pwrDmnNum)</td></tr>
<tr class="separator:ga2240dd296b3fbf0d575f542da277ea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef619298e93f2ca8cc3da7e2a4ed4af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga2ef619298e93f2ca8cc3da7e2a4ed4af">CSL_PSC_disablePowerDomain</a> (CSL_PscRegs *pPscRegs, uint32_t pwrDmnNum)</td></tr>
<tr class="separator:ga2ef619298e93f2ca8cc3da7e2a4ed4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa212b7399bb421ab87c06d240211b6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga370db44ee943415db4d3237456b90887">CSL_PSC_PDSTATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gaa212b7399bb421ab87c06d240211b6fd">CSL_PSC_getPowerDomainState</a> (const CSL_PscRegs *pPscRegs, uint32_t pwrDmnNum)</td></tr>
<tr class="separator:gaa212b7399bb421ab87c06d240211b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f914012241e366d54506f91cc224e99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#ga9f914012241e366d54506f91cc224e99">CSL_PSC_startStateTransition</a> (CSL_PscRegs *pPscRegs, uint32_t pwrDmnNum)</td></tr>
<tr class="separator:ga9f914012241e366d54506f91cc224e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51b8ff490b4dac56f319053a1425648"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___p_s_c___f_u_n_c_t_i_o_n.html#gaa51b8ff490b4dac56f319053a1425648">CSL_PSC_isStateTransitionDone</a> (const CSL_PscRegs *pPscRegs, uint32_t pwrDmnNum)</td></tr>
<tr class="separator:gaa51b8ff490b4dac56f319053a1425648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9714f642ae9eeba76dea943598365a24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_disableModuleResetIsolation </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_disableModuleResetIsolation</b> </p>
<p><b>Description</b> <br />
 This function disables the Module reset isolation control.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the configuration must be done.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_RSTISO=0</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Disable Module 2's reset isolation
     CSL_PSC_disableModuleResetIsolation (2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga52e3ceba48493891db948e34c999bcf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_PSC_disableModuleResetIsolation </td>
          <td>(</td>
          <td class="paramtype">CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_disableModuleResetIsolation</b> </p>
<p><b>Description</b> <br />
 This function disables the Module reset isolation control.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the configuration must be done.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_RSTISO=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_PscRegs *pPscRegs = (CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Disable Module 2's reset isolation
     CSL_PSC_disableModuleResetIsolation (pPscRegs, 2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8fb48ff1ba86e4d0b7a1c0bf5f80011c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_disablePowerDomain </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_disablePowerDomain</b> </p>
<p><b>Description</b> <br />
 This function turns off the specified power domain.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number that needs to be disabled.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain is disabled.</p>
<p><b>Writes</b> <br />
 PSC_PDCTL_NEXT=0</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Off the power domain 2
     CSL_PSC_disablePowerDomain (2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2ef619298e93f2ca8cc3da7e2a4ed4af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_PSC_disablePowerDomain </td>
          <td>(</td>
          <td class="paramtype">CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_disablePowerDomain</b> </p>
<p><b>Description</b> <br />
 This function turns off the specified power domain.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     pwrDmnNum       Power domain number that needs to be disabled.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain is disabled.</p>
<p><b>Writes</b> <br />
 PSC_PDCTL_NEXT=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_PscRegs *pPscRegs = (CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Off the power domain 2
     CSL_PSC_disablePowerDomain (pPscRegs, 2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf0a4ea1d5f4869a54d53350214a63c8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_disablePowerDomain2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_disablePowerDomain2</b> </p>
<p><b>Description</b> <br />
 This function turns off the specified power domain in the LPSC instance 1.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number that needs to be disabled in LPSC instance 1.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain is disabled.</p>
<p><b>Writes</b> <br />
 PSC_PDCTL_NEXT=0</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Off the power domain 1
     CSL_PSC_disablePowerDomain2 (1);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7a7d97147f83f067d182132532ff06f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_enableModuleResetIsolation </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_enableModuleResetIsolation</b> </p>
<p><b>Description</b> <br />
 This function enables the Module reset isolation control.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the configuration must be done.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_RSTISO=1</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Enable Module 2's reset isolation
     CSL_PSC_enableModuleResetIsolation (2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6d7031d2a6491cb8377c6bd0463325cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_PSC_enableModuleResetIsolation </td>
          <td>(</td>
          <td class="paramtype">CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_enableModuleResetIsolation</b> </p>
<p><b>Description</b> <br />
 This function enables the Module reset isolation control.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the configuration must be done.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_RSTISO=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_PscRegs *pPscRegs = (CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Enable Module 2's reset isolation
     CSL_PSC_enableModuleResetIsolation (pPscRegs, 2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga71658f7648aa20cf4e955831586d27de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_enablePowerDomain </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_enablePowerDomain</b> </p>
<p><b>Description</b> <br />
 This function enables the specified power domain.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number that needs to be enabled.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain is enabled.</p>
<p><b>Writes</b> <br />
 PSC_PDCTL_NEXT=1</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // On the power domain 2
     CSL_PSC_enablePowerDomain (2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2240dd296b3fbf0d575f542da277ea11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_PSC_enablePowerDomain </td>
          <td>(</td>
          <td class="paramtype">CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_enablePowerDomain</b> </p>
<p><b>Description</b> <br />
 This function enables the specified power domain.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     pwrDmnNum       Power domain number that needs to be enabled.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain is enabled.</p>
<p><b>Writes</b> <br />
 PSC_PDCTL_NEXT=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_PscRegs *pPscRegs = (CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // On the power domain 2
     CSL_PSC_enablePowerDomain (pPscRegs, 2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac987fa8807374f788b3ee7e7949bf8b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_enablePowerDomain2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_enablePowerDomain2</b> </p>
<p><b>Description</b> <br />
 This function enables the specified power domain in LPSC instance 1.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number that needs to be enabled in LPSC instance 1.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain is enabled.</p>
<p><b>Writes</b> <br />
 PSC_PDCTL_NEXT=1</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // On the power domain 1 in instance 1
     CSL_PSC_enablePowerDomain2 (1);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab40f49bd4d18287ed764942935c17361"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> CSL_PSC_getModuleLocalReset </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleLocalReset</b> </p>
<p><b>Description</b> <br />
 This function reads the Module local reset control configured.</p>
<p><b>Arguments</b> </p><pre class="fragment">       moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDLRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDCTL_LRST</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  resetState;

       ...
       // Check Module 2's local reset bit
       resetState = CSL_PSC_getModuleLocalReset (2);
       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3cbf8cf247c53831425698d04789c636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> CSL_PSC_getModuleLocalReset </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleLocalReset</b> </p>
<p><b>Description</b> <br />
 This function reads the Module local reset control configured.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPscRegs        Pointer to PSC register structure.
       moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDLRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDCTL_LRST</p>
<p><b>Example</b> </p><pre class="fragment">*      uint32_t  resetState;
       const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;

       ...
       // Check Module 2's local reset bit
       resetState = CSL_PSC_getModuleLocalReset (pPscRegs, 2);
       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7b697ca78aeb78eccf296b3cb38d33fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> CSL_PSC_getModuleLocalReset2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleLocalReset2</b> </p>
<p><b>Description</b> <br />
 This function reads the Module local reset control configured.</p>
<p><b>Arguments</b> </p><pre class="fragment">       moduleNum       Module number of instnace 1 for which the status 
        must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDLRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDCTL_LRST</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  resetState;

       ...
       // Check Module 21's local reset bit
       resetState = CSL_PSC_getModuleLocalReset2 (CSL_PSC_EMAC);
       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa11cc663d2770ec472e2487587494431"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> CSL_PSC_getModuleLocalResetStatus </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleLocalResetStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the Module local reset actual status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDLRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_LRST</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 2's local reset status
     if (CSL_PSC_getModuleLocalResetStatus (2) == PSC_MDLRST_ASSERTED)
     {
         // Module 2's local reset asserted.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2a40e802cf6d71dadad19e0efcbd46de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> CSL_PSC_getModuleLocalResetStatus </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleLocalResetStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the Module local reset actual status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDLRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_LRST</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check Module 2's local reset status
     if (CSL_PSC_getModuleLocalResetStatus (pPscRegs, 2) == PSC_MDLRST_ASSERTED)
     {
         // Module 2's local reset asserted.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac2f7d56818b564166150f77a79148d69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a> CSL_PSC_getModuleLocalResetStatus2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleLocalResetStatus2</b> </p>
<p><b>Description</b> <br />
 This function returns the Module local reset actual status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number of instance 1 for which the status 
        must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDLRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_LRST</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 22's local reset status
     if (CSL_PSC_getModuleLocalResetStatus2 (CSL_PSC_EMIFB) == PSC_MDLRST_ASSERTED)
     {
         // Module 22's local reset asserted.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafb18baae028405ec60204951a51c4ca3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> CSL_PSC_getModuleNextState </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleNextState</b> </p>
<p><b>Description</b> <br />
 This function returns the next state configured for a given module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the state must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MODSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDCTL_NEXT</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 2's next state configured
     if (CSL_PSC_getModuleNextState (2) == PSC_MODSTATE_ENABLE)
     {
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga863f6aa60294e461091770a9e93d85bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> CSL_PSC_getModuleNextState </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleNextState</b> </p>
<p><b>Description</b> <br />
 This function returns the next state configured for a given module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the state must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MODSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDCTL_NEXT</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check Module 2's next state configured
     if (CSL_PSC_getModuleNextState (pPscRegs, 2) == PSC_MODSTATE_ENABLE)
     {
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae10a34101f6af856089e55d44f8c7f88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> CSL_PSC_getModuleNextState2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleNextState2</b> </p>
<p><b>Description</b> <br />
 This function returns the next state configured for a given module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number of instance 1 for which the state must 
        be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MODSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDCTL_NEXT</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 21's next state configured
     if (CSL_PSC_getModuleNextState2 (CSL_PSC_USB1) == PSC_MODSTATE_ENABLE)
     {
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaddfe8f0bfea7f2f39d038893e607c120"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga978a43aff53dc4b6345aada91a7adda5">CSL_PSC_MDRST</a> CSL_PSC_getModuleResetStatus </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleResetStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the Module reset actual status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MRST</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 2's reset status
     if (CSL_PSC_getModuleResetStatus (2) == PSC_MDRST_ASSERTED)
     {
         // Module 2's reset asserted.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac4b159765024a8184ae06627edc20da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga978a43aff53dc4b6345aada91a7adda5">CSL_PSC_MDRST</a> CSL_PSC_getModuleResetStatus </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleResetStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the Module reset actual status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MRST</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check Module 2's reset status
     if (CSL_PSC_getModuleResetStatus (pPscRegs, 2) == PSC_MDRST_ASSERTED)
     {
         // Module 2's reset asserted.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae6727811e2103541a4fa061510f18754"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga978a43aff53dc4b6345aada91a7adda5">CSL_PSC_MDRST</a> CSL_PSC_getModuleResetStatus2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleResetStatus2</b> </p>
<p><b>Description</b> <br />
 This function returns the Module reset actual status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number of instance 1 for which the status 
        must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MDRST</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MRST</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 22's reset status
     if (CSL_PSC_getModuleResetStatus2 (CSL_PSC_EMIFB) == PSC_MDRST_ASSERTED)
     {
         // Module 22's reset asserted.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac801999b12f3847bc0c79d2fd3d9b7c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> CSL_PSC_getModuleState </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleState</b> </p>
<p><b>Description</b> <br />
 This function returns the current state of a given module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the state must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MODSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power Domain status is returned</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_STATE</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check if Module 2's clock is enabled.
     if (CSL_PSC_getModuleState (2) == PSC_MODSTATE_ENABLE)
     {
         // Module 2's clock is enabled.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1ebb2c97382ea7af5b6dc8815c6dd30d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> CSL_PSC_getModuleState </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleState</b> </p>
<p><b>Description</b> <br />
 This function returns the current state of a given module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the state must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MODSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power Domain status is returned</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_STATE</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check if Module 2's clock is enabled.
     if (CSL_PSC_getModuleState (pPscRegs, 2) == PSC_MODSTATE_ENABLE)
     {
         // Module 2's clock is enabled.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga27c1d98aa6ef22e36c27bfa301c25aa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a> CSL_PSC_getModuleState2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getModuleState2</b> </p>
<p><b>Description</b> <br />
 This function returns the current state of a given module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number of instance 1 for which the state 
        must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_MODSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power Domain status is returned</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_STATE</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check if Module 22's clock is enabled.
     if (CSL_PSC_getModuleState2 (CSL_PSC_EMIFB) == PSC_MODSTATE_ENABLE)
     {
         // Module 2's clock is enabled.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga42a0b036fa507c380a62d68957e2291b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga370db44ee943415db4d3237456b90887">CSL_PSC_PDSTATE</a> CSL_PSC_getPowerDomainState </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getPowerDomainState</b> </p>
<p><b>Description</b> <br />
 This function returns the current state of a given power domain.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number for which the state must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_PDSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power Domain status is returned</p>
<p><b>Reads</b> <br />
 PSC_PDSTAT_STATE</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check if Power domain is On.
     if (CSL_PSC_getPowerDomainState(2) == PSC_PDSTATE_ON)
     {
         // Power domain 2 is on
         ...
     }
     else
     {
         // Power domain 2 is off
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa212b7399bb421ab87c06d240211b6fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga370db44ee943415db4d3237456b90887">CSL_PSC_PDSTATE</a> CSL_PSC_getPowerDomainState </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getPowerDomainState</b> </p>
<p><b>Description</b> <br />
 This function returns the current state of a given power domain.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     pwrDmnNum       Power domain number for which the state must be retrieved.</pre><p><b> Return Value </b> CSL_PSC_PDSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power Domain status is returned</p>
<p><b>Reads</b> <br />
 PSC_PDSTAT_STATE</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check if Power domain is On.
     if (CSL_PSC_getPowerDomainState(pPscRegs, 2) == PSC_PDSTATE_ON)
     {
         // Power domain 2 is on
         ...
     }
     else
     {
         // Power domain 2 is off
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8caca2e79d60377f0aa3abbb13a8c059"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga370db44ee943415db4d3237456b90887">CSL_PSC_PDSTATE</a> CSL_PSC_getPowerDomainState2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_getPowerDomainState2</b> </p>
<p><b>Description</b> <br />
 This function returns the current state of a given power domain in LPSC instance 1.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number for which the state must be retrieved in LPSC instance 1.</pre><p><b> Return Value </b> CSL_PSC_PDSTATE</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power Domain status is returned</p>
<p><b>Reads</b> <br />
 PSC_PDSTAT_STATE</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check if Power domain is On.
     if (CSL_PSC_getPowerDomainState2(1) == PSC_PDSTATE_ON)
     {
         // Power domain 1 is on
         ...
     }
     else
     {
         // Power domain 1 is off
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga17d9b8ff5c1b8b53c254bbbfb02b769f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_PSC_getVersionInfo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_getVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the PSC peripheral identification register contents.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint32 - version value</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_PID</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      versionInfo;

     versionInfo =   CSL_PSC_getVersionInfo ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3935f4a6b051b0d94cd345f6ff0c4b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_PSC_getVersionInfo </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_getVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the PSC peripheral identification register contents.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.</pre><p><b> Return Value </b> uint32_t - version value</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_PID</p>
<p><b>Example</b> </p><pre class="fragment">     uint32_t          versionInfo;
     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     versionInfo =   CSL_PSC_getVersionInfo (pPscRegs);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga828d1edabdb004d8243d53ec3085391a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_PSC_getVersionInfo2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_getVersionInfo2</b> </p>
<p><b>Description</b> <br />
 This function retrieves the PSC peripheral identification register contents for instance 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint32 - version value</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_PID</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      versionInfo;

     versionInfo =   CSL_PSC_getVersionInfo2 ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2d7846a2786f477dae3eede9951295f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_PSC_getVoltageControl </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_getVoltageControl</b> </p>
<p><b>Description</b> <br />
 This function retrieves the Smart reflex bits from the voltage control identification register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> Uint8</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_VCNTLID_VCNTL</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      vcntlInfo;

     vcntlInfo =   CSL_PSC_getVoltageControl ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae0846fb05bc513217322444abc04789e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CSL_PSC_getVoltageControl </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_getVoltageControl</b> </p>
<p><b>Description</b> <br />
 This function retrieves the Smart reflex bits from the voltage control identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.</pre><p><b> Return Value </b> uint8_t</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_VCNTLID_VCNTL</p>
<p><b>Example</b> </p><pre class="fragment">     uint32_t      vcntlInfo;
     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;

     vcntlInfo =   CSL_PSC_getVoltageControl (pPscRegs);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5ea1011218ad01af4de7e8b00caf06fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool CSL_PSC_isInvalidModuleNumber </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_isInvalidModuleNumber</b> </p>
<p><b>Description</b> <br />
 This function checks the LPSC module number is valid ar invalid contents.</p>
<p><b>Arguments</b> </p><pre class="fragment">       moduleNum      LPSC module number 
*   @n None
*
*   &lt;b&gt; Return Value &lt;/b&gt;  bool  - valid or invalid LPSC module Number
*
*
*   &lt;b&gt; Pre Condition &lt;/b&gt;
*   @n  None
*
*   &lt;b&gt; Post Condition &lt;/b&gt;
*   @n  None
*
*   @b Reads
*   @n PSC_PID
*
*   @b Example
*   @verbatim
       bool     validModuleNum;

       validModuleNum =   CSL_PSC_isInvalidModuleNumber (CSL_PSC_USB1);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1a9df2b36d97da0fa0022ca1e141e0dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Bool CSL_PSC_isModuleClockOn </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleClockOn</b> </p>
<p><b>Description</b> <br />
 This function returns the actual modclk output to module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the clock status must be retrieved.</pre><p><b> Return Value </b> Bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MCKOUT</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 2's modclk status
     if (CSL_PSC_isModuleClockOn (2))
     {
         // Module 2's modclk on.
         ...
     }
     else
     {
         // Module 2's modclk gated.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6c7ef9b921121309a2b52b6dc5f6052e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_PSC_isModuleClockOn </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleClockOn</b> </p>
<p><b>Description</b> <br />
 This function returns the actual modclk output to module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the clock status must be retrieved.</pre><p><b> Return Value </b> bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MCKOUT</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check Module 2's modclk status
     if (CSL_PSC_isModuleClockOn (pPscRegs, 2))
     {
         // Module 2's modclk on.
         ...
     }
     else
     {
         // Module 2's modclk gated.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga90598d93edbf0003efc14bd3216e7de6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Bool CSL_PSC_isModuleClockOn2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleClockOn2</b> </p>
<p><b>Description</b> <br />
 This function returns the actual modclk output to module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number of instance 1 for which the clock 
        status must be retrieved.</pre><p><b> Return Value </b> Bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MCKOUT</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 22's modclk status
     if (CSL_PSC_isModuleClockOn2 (CSL_PSC_EMIFB))
     {
         // Module 22's modclk on.
         ...
     }
     else
     {
         // Module 22's modclk gated.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9511a9d7f23e2f40c3304c95a96a4620"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Bool CSL_PSC_isModuleLocalResetDone </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleLocalResetDone</b> </p>
<p><b>Description</b> <br />
 This function returns the Module local reset initialization done status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> Bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_LRSTDONE</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 2's local reset initialization done status
     if (CSL_PSC_isModuleLocalResetDone (2))
     {
         // Module 2's local reset init done.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac0c19995d157fa6790fec05486ae4f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_PSC_isModuleLocalResetDone </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleLocalResetDone</b> </p>
<p><b>Description</b> <br />
 This function returns the Module local reset initialization done status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_LRSTDONE</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check Module 2's local reset initialization done status
     if (CSL_PSC_isModuleLocalResetDone (pPscRegs, 2))
     {
         // Module 2's local reset init done.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga958f54e8092ccae3cd31313854a6b2a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Bool CSL_PSC_isModuleLocalResetDone2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleLocalResetDone2</b> </p>
<p><b>Description</b> <br />
 This function returns the Module local reset initialization done status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number of instance 1 for which the status 
        must be retrieved.</pre><p><b> Return Value </b> Bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_LRSTDONE</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 22's local reset initialization done status
     if (CSL_PSC_isModuleLocalResetDone2 (CSL_PSC_EMIFB))
     {
         // Module 22's local reset init done.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab8d3d0d7e54f80a17289f72cff84b499"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Bool CSL_PSC_isModuleResetDone </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleResetDone</b> </p>
<p><b>Description</b> <br />
 This function returns the Module reset initialization done status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> Bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MRSTDONE</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 2's reset initialization done status
     if (CSL_PSC_isModuleResetDone (2))
     {
         // Module 2's reset init done.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf6964a793ae13eb11fbc116378d39e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_PSC_isModuleResetDone </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleResetDone</b> </p>
<p><b>Description</b> <br />
 This function returns the Module reset initialization done status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MRSTDONE</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check Module 2's reset initialization done status
     if (CSL_PSC_isModuleResetDone (pPscRegs, 2))
     {
         // Module 2's reset init done.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4b2193d6e391ab70aebda80429b1b1fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Bool CSL_PSC_isModuleResetDone2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleResetDone2</b> </p>
<p><b>Description</b> <br />
 This function returns the Module reset initialization done status.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number of instance 1 for which the status 
        must be retrieved.</pre><p><b> Return Value </b> Bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDSTAT_MRSTDONE</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 22's reset initialization done status
     if (CSL_PSC_isModuleResetDone2 (CSL_PSC_EMIFB))
     {
         // Module 22's reset init done.
         ...
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga324b12d773941edd62391b439ae539a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Bool CSL_PSC_isModuleResetIsolationEnabled </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleResetIsolationEnabled</b> </p>
<p><b>Description</b> <br />
 This function reads the Module reset isolation control bit.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> Bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDCTL_RSTISO</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Check Module 2's reset isolation configuration
     if (CSL_PSC_isModuleResetIsolationEnabled (2) == TRUE)
     {
         // Module 2 reset isolation enabled
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga553245c388fb42e50db1c1fa13909b04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSL_PSC_isModuleResetIsolationEnabled </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isModuleResetIsolationEnabled</b> </p>
<p><b>Description</b> <br />
 This function reads the Module reset isolation control bit.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the status must be retrieved.</pre><p><b> Return Value </b> bool</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PSC_MDCTL_RSTISO</p>
<p><b>Example</b> </p><pre class="fragment">     const CSL_PscRegs *pPscRegs = (const CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Check Module 2's reset isolation configuration
     if (CSL_PSC_isModuleResetIsolationEnabled (pPscRegs, 2) == TRUE)
     {
         // Module 2 reset isolation enabled
     }
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac2b22f9fb21b400cffcf128b3999de50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_PSC_isStateTransitionDone </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isStateTransitionDone</b> </p>
<p><b>Description</b> <br />
 This function gets the transition status of the power domain. This function returns 0 to indicate that the state transition initiated earlier using <em>CSL_PSC_startStateTransition</em> () API for the specified power domain has not yet been completed, and is in progress still. This function returns 1 to indicate when this transition is completed in the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number for which the state transition status
                     must be retrieved.</pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain transition status value is read</p>
<p><b>Reads</b> <br />
 PSC_PTSTAT</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Ensure no transition in progress for Power domain 2
     // before we start a new one.
     while (!CSL_PSC_isStateTransitionDone (2));

     // To Enable Power domain 2 and modules 3, 4
     CSL_PSC_enablePowerDomain (2);
     CSL_PSC_setModuleNextState (3, PSC_MODSTATE_ENABLE);
     CSL_PSC_setModuleNextState (4, PSC_MODSTATE_ENABLE);
     CSL_PSC_startStateTransition (2);

     // Wait until the transition process is completed.
     while (!CSL_PSC_isStateTransitionDone (2));
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa51b8ff490b4dac56f319053a1425648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_PSC_isStateTransitionDone </td>
          <td>(</td>
          <td class="paramtype">const CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isStateTransitionDone</b> </p>
<p><b>Description</b> <br />
 This function gets the transition status of the power domain. This function returns 0 to indicate that the state transition initiated earlier using <em>CSL_PSC_startStateTransition</em> () API for the specified power domain has not yet been completed, and is in progress still. This function returns 1 to indicate when this transition is completed in the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     pwrDmnNum       Power domain number for which the state transition status
                     must be retrieved.</pre><p><b> Return Value </b> uint32_t</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain transition status value is read</p>
<p><b>Reads</b> <br />
 PSC_PTSTAT</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_PscRegs *pPscRegs = (CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Ensure no transition in progress for Power domain 2
     // before we start a new one.
     while (!CSL_PSC_isStateTransitionDone (pPscRegs, 2));

     // To Enable Power domain 2 and modules 3, 4
     CSL_PSC_enablePowerDomain (pPscRegs, 2);
     CSL_PSC_setModuleNextState (pPscRegs, 3, PSC_MODSTATE_ENABLE);
     CSL_PSC_setModuleNextState (pPscRegs, 4, PSC_MODSTATE_ENABLE);
     CSL_PSC_startStateTransition (pPscRegs, 2);

     // Wait until the transition process is completed.
     while (!CSL_PSC_isStateTransitionDone (pPscRegs, 2));
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga14e98ca1ec25018bc2aa257750586ae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_PSC_isStateTransitionDone2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_isStateTransitionDone2</b> </p>
<p><b>Description</b> <br />
 This function gets the transition status of the power domain. This function returns 0 to indicate that the state transition initiated earlier using <em>CSL_PSC_startStateTransition</em> () API for the specified power domain has not yet been completed, and is in progress still. This function returns 1 to indicate when this transition is completed in the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number for which the state transition status
                     must be retrieved.</pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain transition status value is read</p>
<p><b>Reads</b> <br />
 PSC_PTSTAT</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Ensure no transition in progress for Power domain 1
     // before we start a new one.
     while (!CSL_PSC_isStateTransitionDone2 (1));

     // To Enable Power domain 1 and modules 3, 4
     CSL_PSC_enablePowerDomain2 (1);
     CSL_PSC_setModuleNextState (CSL_PSC_MCASP1, PSC_MODSTATE_ENABLE);
     CSL_PSC_setModuleNextState (CSL_PSC_MCASP2, PSC_MODSTATE_ENABLE);
     CSL_PSC_startStateTransition (1);

     // Wait until the transition process is completed.
     while (!CSL_PSC_isStateTransitionDone2 (1));
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad6bbed752504c9b9055a98d6f6272bd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_setModuleLocalReset </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td>
          <td class="paramname"><em>resetState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_setModuleLocalReset</b> </p>
<p><b>Description</b> <br />
 This function configures the Module local reset control.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number for which the status must be retrieved.
     resetState      Assert/Deassert module local reset.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_LRST</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Assert Module 2's local reset
     CSL_PSC_setModuleLocalReset (2, PSC_MDLRST_ASSERTED);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2fc603f663c4532471b995fd3b593b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_PSC_setModuleLocalReset </td>
          <td>(</td>
          <td class="paramtype">CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td>
          <td class="paramname"><em>resetState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_setModuleLocalReset</b> </p>
<p><b>Description</b> <br />
 This function configures the Module local reset control.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       Module number for which the status must be retrieved.
     resetState      Assert/Deassert module local reset.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_LRST</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_PscRegs *pPscRegs = (CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Assert Module 2's local reset
     CSL_PSC_setModuleLocalReset (pPscRegs, 2, PSC_MDLRST_ASSERTED);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga42accc6013d0100bd1a14e2019c6d090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_setModuleLocalReset2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#gaffdf2648a966485ea2b0961adfb69ab5">CSL_PSC_MDLRST</a>&#160;</td>
          <td class="paramname"><em>resetState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_PSC_setModuleLocalReset2</b> </p>
<p><b>Description</b> <br />
 This function configures the Module local reset control.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       Module number of instance 1 for which the status 
        must be retrieved.
     resetState      Assert/Deassert module local reset.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_LRST</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Assert Module 2's local reset
     CSL_PSC_setModuleLocalReset2 (CSL_PSC_EMAC, PSC_MDLRST_ASSERTED);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6bf4dbb847086a45ab16d3c9d8a1d4a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_setModuleNextState </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_setModuleNextState</b> </p>
<p><b>Description</b> <br />
 This function sets up the "Next" state the module should be transitioned for a given module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       LPSC Module for which the next state must be configured.
     state           Next state to which the module must be transitioned.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Module is moved to configured next state after transition is triggered using <em>CSL_PSC_startStateTransition</em> () API.</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_NEXT</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Enable Module 1's clock.
     CSL_PSC_setModuleNextState (1, PSC_MODSTATE_ENABLE);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4cd432de657125fedce3e18855bb03e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_PSC_setModuleNextState </td>
          <td>(</td>
          <td class="paramtype">CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_setModuleNextState</b> </p>
<p><b>Description</b> <br />
 This function sets up the "Next" state the module should be transitioned for a given module.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     moduleNum       LPSC Module for which the next state must be configured.
     state           Next state to which the module must be transitioned.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Module is moved to configured next state after transition is triggered using <em>CSL_PSC_startStateTransition</em> () API.</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_NEXT</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_PscRegs *pPscRegs = (CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // Enable Module 1's clock.
     CSL_PSC_setModuleNextState (pPscRegs, 1, PSC_MODSTATE_ENABLE);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac32022704c894b3eef58abf446a0b53d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_setModuleNextState2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>moduleNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___p_s_c___d_a_t_a_s_t_r_u_c_t.html#ga16b8ab4d969b9eb007e53f35e827b071">CSL_PSC_MODSTATE</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_setModuleNextState2</b> </p>
<p><b>Description</b> <br />
 This function sets up the "Next" state the module should be transitioned for a given module in LPSC instance 1.</p>
<p><b>Arguments</b> </p><pre class="fragment">     moduleNum       LPSC Module of instance 1 for which the next state 
        must be configured.
     state           Next state to which the module must be transitioned.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Module is moved to configured next state after transition is triggered using <em>CSL_PSC_startStateTransition</em> () API.</p>
<p><b>Writes</b> <br />
 PSC_MDCTL_NEXT</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // Enable Module 1's clock.
     CSL_PSC_setModuleNextState2 (CSL_PSC_USB1, PSC_MODSTATE_ENABLE);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8773ed44366cd6a55d451440a44c885c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_startStateTransition </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_startStateTransition</b> </p>
<p><b>Description</b> <br />
 This function sets the 'GO' bit in the PSC Command register. All state transitions marked for a specified power domain and all its modules are initiated by the hardware.</p>
<p>This function starts a given Power domain and all its modules state transition.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number for which the state transition
                     must be initiated.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain and modules are moved to a new "Next" state as marked earlier using APIs: <em>CSL_PSC_setModuleNextState</em> (), <em>CSL_PSC_enablePowerDomain</em> (), <em>CSL_PSC_disablePowerDomain</em> ().</p>
<p><b>Writes</b> <br />
 PSC_PTCMD</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // To Enable Power domain 2 and modules 3, 4
     CSL_PSC_enablePowerDomain (2);
     CSL_PSC_setModuleNextState  (3, PSC_MODSTATE_ENABLE);
     CSL_PSC_setModuleNextState (4, PSC_MODSTATE_ENABLE);
     CSL_PSC_startStateTransition (2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9f914012241e366d54506f91cc224e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_PSC_startStateTransition </td>
          <td>(</td>
          <td class="paramtype">CSL_PscRegs *&#160;</td>
          <td class="paramname"><em>pPscRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_startStateTransition</b> </p>
<p><b>Description</b> <br />
 This function sets the 'GO' bit in the PSC Command register. All state transitions marked for a specified power domain and all its modules are initiated by the hardware.</p>
<p>This function starts a given Power domain and all its modules state transition.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pPscRegs        Pointer to PSC register structure.
     pwrDmnNum       Power domain number for which the state transition
                     must be initiated.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain and modules are moved to a new "Next" state as marked earlier using APIs: <em>CSL_PSC_setModuleNextState</em> (), <em>CSL_PSC_enablePowerDomain</em> (), <em>CSL_PSC_disablePowerDomain</em> ().</p>
<p><b>Writes</b> <br />
 PSC_PTCMD</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_PscRegs *pPscRegs = (CSL_PscRegs *)CSL_PSC0_BASE;
     ...
     // To Enable Power domain 2 and modules 3, 4
     CSL_PSC_enablePowerDomain (pPscRegs, 2);
     CSL_PSC_setModuleNextState  (pPscRegs, 3, PSC_MODSTATE_ENABLE);
     CSL_PSC_setModuleNextState (pPscRegs, 4, PSC_MODSTATE_ENABLE);
     CSL_PSC_startStateTransition (pPscRegs, 2);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaccbebb2b2889287916d2da4991da0455"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_PSC_startStateTransition2 </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pwrDmnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_PSC_startStateTransition2</b> </p>
<p><b>Description</b> <br />
 This function sets the 'GO' bit in the PSC Command register. All state transitions marked for a specified power domain and all its modules are initiated by the hardware with respect to LPSC instance 1.</p>
<p>This function starts a given Power domain and all its modules state transition.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pwrDmnNum       Power domain number for which the state transition
                     must be initiated.</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Power domain and modules are moved to a new "Next" state as marked earlier using APIs: <em>CSL_PSC_setModuleNextState</em> (), <em>CSL_PSC_enablePowerDomain</em> (), <em>CSL_PSC_disablePowerDomain</em> ().</p>
<p><b>Writes</b> <br />
 PSC_PTCMD</p>
<p><b>Example</b> </p><pre class="fragment">     ...
     // To Enable Power domain 1 and modules 23, 24
     CSL_PSC_enablePowerDomain2 (1);
     CSL_PSC_setModuleNextState  (CSL_PSC_MCASP0, PSC_MODSTATE_ENABLE);
     CSL_PSC_setModuleNextState (CSL_PSC_MCASP1, PSC_MODSTATE_ENABLE);
     CSL_PSC_startStateTransition (CSL_PSC_MCASP0);
     ...</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
