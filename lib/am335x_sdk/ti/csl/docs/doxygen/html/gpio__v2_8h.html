<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gpio_v2.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_5c9827f39abcc28a92e5a02429a0e390.html">ip</a></li><li class="navelem"><a class="el" href="dir_a854e26f52e4e1c76ad305eb77e7d9ac.html">gpio</a></li><li class="navelem"><a class="el" href="dir_3af2834061925493d97f3a572953914c.html">V1</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gpio_v2.h File Reference<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a> &raquo; <a class="el" href="group___c_s_l___g_p_i_o.html">GPIO</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>GPIO Device Abstraction Layer APIs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="hw__types_8h.html">ti/csl/hw_types.h</a>&gt;</code><br />
<code>#include &lt;ti/csl/cslr_gpio.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a01d8de27d1ce1b948c862d4e5cdcb6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a01d8de27d1ce1b948c862d4e5cdcb6f9">GPIOModuleReset</a> (uint32_t baseAdd)</td></tr>
<tr class="memdesc:a01d8de27d1ce1b948c862d4e5cdcb6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API performs the module reset of the GPIO module. It also waits until the reset process is complete.  <a href="#a01d8de27d1ce1b948c862d4e5cdcb6f9">More...</a><br /></td></tr>
<tr class="separator:a01d8de27d1ce1b948c862d4e5cdcb6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae055980be57fa192a6f9aff1116222de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#ae055980be57fa192a6f9aff1116222de">GPIOModuleEnable</a> (uint32_t baseAdd)</td></tr>
<tr class="memdesc:ae055980be57fa192a6f9aff1116222de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to enable the GPIO module. When the GPIO module is enabled, the clocks to the module are not gated.  <a href="#ae055980be57fa192a6f9aff1116222de">More...</a><br /></td></tr>
<tr class="separator:ae055980be57fa192a6f9aff1116222de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e38916d70f40a27bd731b500a226fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a9e38916d70f40a27bd731b500a226fd3">GPIOModuleDisable</a> (uint32_t baseAdd)</td></tr>
<tr class="memdesc:a9e38916d70f40a27bd731b500a226fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to disable the GPIO module. When the GPIO module is disabled, the clocks to the module are gated.  <a href="#a9e38916d70f40a27bd731b500a226fd3">More...</a><br /></td></tr>
<tr class="separator:a9e38916d70f40a27bd731b500a226fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3061ad1df96774f5af289547e45c9422"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a3061ad1df96774f5af289547e45c9422">GPIODirModeSet</a> (uint32_t baseAdd, uint32_t pinNumber, uint32_t pinDirection)</td></tr>
<tr class="memdesc:a3061ad1df96774f5af289547e45c9422"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the direction of a specified GPIO pin as being either input or output.  <a href="#a3061ad1df96774f5af289547e45c9422">More...</a><br /></td></tr>
<tr class="separator:a3061ad1df96774f5af289547e45c9422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225be10c73f1c054ae399233da4f34f0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a225be10c73f1c054ae399233da4f34f0">GPIODirModeGet</a> (uint32_t baseAdd, uint32_t pinNumber)</td></tr>
<tr class="memdesc:a225be10c73f1c054ae399233da4f34f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the direction of a specified GPIO pin.  <a href="#a225be10c73f1c054ae399233da4f34f0">More...</a><br /></td></tr>
<tr class="separator:a225be10c73f1c054ae399233da4f34f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92817dd60df9d140a0c6140447fd046c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a92817dd60df9d140a0c6140447fd046c">GPIOPinWrite</a> (uint32_t baseAdd, uint32_t pinNumber, uint32_t pinValue)</td></tr>
<tr class="memdesc:a92817dd60df9d140a0c6140447fd046c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API drives an output GPIO pin to a logic HIGH or a logic LOW state.  <a href="#a92817dd60df9d140a0c6140447fd046c">More...</a><br /></td></tr>
<tr class="separator:a92817dd60df9d140a0c6140447fd046c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d167dfae652e560234a5ce73432d90b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a4d167dfae652e560234a5ce73432d90b">GPIOPinRead</a> (uint32_t baseAdd, uint32_t pinNumber)</td></tr>
<tr class="memdesc:a4d167dfae652e560234a5ce73432d90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the logic level(value) on a specified GPIO pin.  <a href="#a4d167dfae652e560234a5ce73432d90b">More...</a><br /></td></tr>
<tr class="separator:a4d167dfae652e560234a5ce73432d90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffc180a6ddde77ed05c05ba27f9c6e9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a0ffc180a6ddde77ed05c05ba27f9c6e9">GPIOPinRead2</a> (uint32_t baseAdd, uint32_t pinNumber)</td></tr>
<tr class="memdesc:a0ffc180a6ddde77ed05c05ba27f9c6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the logic level(value) on a specified GPIO pin.  <a href="#a0ffc180a6ddde77ed05c05ba27f9c6e9">More...</a><br /></td></tr>
<tr class="separator:a0ffc180a6ddde77ed05c05ba27f9c6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aec070e57c370dfc12ddc9866b4f6b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a0aec070e57c370dfc12ddc9866b4f6b1">GPIOMultiplePinsWrite</a> (uint32_t baseAdd, uint32_t setMask, uint32_t clrMask)</td></tr>
<tr class="memdesc:a0aec070e57c370dfc12ddc9866b4f6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to collectively set and collectively clear the specified output pins of a GPIO instance.  <a href="#a0aec070e57c370dfc12ddc9866b4f6b1">More...</a><br /></td></tr>
<tr class="separator:a0aec070e57c370dfc12ddc9866b4f6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5703596ec834913eb1e7879f64ca92"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#aef5703596ec834913eb1e7879f64ca92">GPIOMultiplePinsRead</a> (uint32_t baseAdd, uint32_t readMask)</td></tr>
<tr class="memdesc:aef5703596ec834913eb1e7879f64ca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the pin values of the specified pins of the GPIO instance.  <a href="#aef5703596ec834913eb1e7879f64ca92">More...</a><br /></td></tr>
<tr class="separator:aef5703596ec834913eb1e7879f64ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc018909808fee4fb0e4a859bcde86c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#acc018909808fee4fb0e4a859bcde86c9">GPIOPinIntEnable</a> (uint32_t baseAdd, uint32_t intLine, uint32_t pinNumber)</td></tr>
<tr class="memdesc:acc018909808fee4fb0e4a859bcde86c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the configured interrupt event on a specified input GPIO pin to trigger an interrupt request.  <a href="#acc018909808fee4fb0e4a859bcde86c9">More...</a><br /></td></tr>
<tr class="separator:acc018909808fee4fb0e4a859bcde86c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d6e9239cb93a7778974b577d24458b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#ae2d6e9239cb93a7778974b577d24458b">GPIOPinIntDisable</a> (uint32_t baseAdd, uint32_t intLine, uint32_t pinNumber)</td></tr>
<tr class="memdesc:ae2d6e9239cb93a7778974b577d24458b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables interrupt generation due to the detection of any event on a specified input GPIO pin.  <a href="#ae2d6e9239cb93a7778974b577d24458b">More...</a><br /></td></tr>
<tr class="separator:ae2d6e9239cb93a7778974b577d24458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a12b59ff6af29887899753da2b51753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a5a12b59ff6af29887899753da2b51753">GPIOIntTypeSet</a> (uint32_t baseAdd, uint32_t pinNumber, uint32_t eventType)</td></tr>
<tr class="memdesc:a5a12b59ff6af29887899753da2b51753"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the event type for a specified input GPIO pin so as to trigger an interrupt request. Whenever the selected event occurs on that GPIO pin, an interrupt request will be sent to the CPU.  <a href="#a5a12b59ff6af29887899753da2b51753">More...</a><br /></td></tr>
<tr class="separator:a5a12b59ff6af29887899753da2b51753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ba097f7de9cd75ddd400e98265e318"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#af3ba097f7de9cd75ddd400e98265e318">GPIOIntTypeGet</a> (uint32_t baseAdd, uint32_t pinNumber)</td></tr>
<tr class="memdesc:af3ba097f7de9cd75ddd400e98265e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the programmed event type for a specified input GPIO pin on occurence of which an interrupt request will be sent to the CPU.  <a href="#af3ba097f7de9cd75ddd400e98265e318">More...</a><br /></td></tr>
<tr class="separator:af3ba097f7de9cd75ddd400e98265e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cbc64017ac43595ab342e474b98819"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a19cbc64017ac43595ab342e474b98819">GPIOPinIntStatus</a> (uint32_t baseAdd, uint32_t intLine, uint32_t pinNumber)</td></tr>
<tr class="memdesc:a19cbc64017ac43595ab342e474b98819"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the enabled interrupt status of a specified pin.  <a href="#a19cbc64017ac43595ab342e474b98819">More...</a><br /></td></tr>
<tr class="separator:a19cbc64017ac43595ab342e474b98819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac135846bad6a97d3e1569c5459453537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#ac135846bad6a97d3e1569c5459453537">GPIOPinIntClear</a> (uint32_t baseAdd, uint32_t intLine, uint32_t pinNumber)</td></tr>
<tr class="memdesc:ac135846bad6a97d3e1569c5459453537"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the enabled interrupt status of a specified GPIO pin.  <a href="#ac135846bad6a97d3e1569c5459453537">More...</a><br /></td></tr>
<tr class="separator:ac135846bad6a97d3e1569c5459453537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8f466a8e2190252dfb9d0ca0749b65"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a1d8f466a8e2190252dfb9d0ca0749b65">GPIORawIntStatus</a> (uint32_t baseAdd, uint32_t intLine, uint32_t readMask)</td></tr>
<tr class="memdesc:a1d8f466a8e2190252dfb9d0ca0749b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the raw interrupt status of the specified GPIO pins in the instance corresponding to the specified interrupt line.  <a href="#a1d8f466a8e2190252dfb9d0ca0749b65">More...</a><br /></td></tr>
<tr class="separator:a1d8f466a8e2190252dfb9d0ca0749b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7c4befe4b86130a258a97a522ac349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a5c7c4befe4b86130a258a97a522ac349">GPIOTriggerPinInt</a> (uint32_t baseAdd, uint32_t intLine, uint32_t pinNumber)</td></tr>
<tr class="memdesc:a5c7c4befe4b86130a258a97a522ac349"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API manually triggers an interrupt request due to a specified GPIO pin.  <a href="#a5c7c4befe4b86130a258a97a522ac349">More...</a><br /></td></tr>
<tr class="separator:a5c7c4befe4b86130a258a97a522ac349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4f1b01b2b2c257f3bf1a2efc480b5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a8c4f1b01b2b2c257f3bf1a2efc480b5c">GPIOWakeupGlobalEnable</a> (uint32_t baseAdd)</td></tr>
<tr class="memdesc:a8c4f1b01b2b2c257f3bf1a2efc480b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the GPIO Wakeup Generation feature for all the pins of the GPIO module.  <a href="#a8c4f1b01b2b2c257f3bf1a2efc480b5c">More...</a><br /></td></tr>
<tr class="separator:a8c4f1b01b2b2c257f3bf1a2efc480b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a4cdf568e2eede664f1bb1267a3d1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#aa1a4cdf568e2eede664f1bb1267a3d1d">GPIOWakeupGlobalDisable</a> (uint32_t baseAdd)</td></tr>
<tr class="memdesc:aa1a4cdf568e2eede664f1bb1267a3d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the GPIO Wakeup generation feature for all the pins of the GPIO module.  <a href="#aa1a4cdf568e2eede664f1bb1267a3d1d">More...</a><br /></td></tr>
<tr class="separator:aa1a4cdf568e2eede664f1bb1267a3d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fe3cb8250b2a532f034786909517b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#ab1fe3cb8250b2a532f034786909517b0">GPIOPinIntWakeUpEnable</a> (uint32_t baseAdd, uint32_t swakeupLine, uint32_t pinNumber)</td></tr>
<tr class="memdesc:ab1fe3cb8250b2a532f034786909517b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the feature for the specified Input GPIO Pin (Interrupt Request Source) to generate an asynchronous wakeup signal to the CPU.  <a href="#ab1fe3cb8250b2a532f034786909517b0">More...</a><br /></td></tr>
<tr class="separator:ab1fe3cb8250b2a532f034786909517b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad906e6b3da5f75e458395e529bccd4d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#ad906e6b3da5f75e458395e529bccd4d8">GPIOPinIntWakeUpDisable</a> (uint32_t baseAdd, uint32_t swakeupLine, uint32_t pinNumber)</td></tr>
<tr class="memdesc:ad906e6b3da5f75e458395e529bccd4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the feature for the specified Input GPIO Pin (Interrupt Request Source) to generate an asynchronous wakeup signal to the CPU.  <a href="#ad906e6b3da5f75e458395e529bccd4d8">More...</a><br /></td></tr>
<tr class="separator:ad906e6b3da5f75e458395e529bccd4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140b8602e3ceff10f613ed30b95c349f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a140b8602e3ceff10f613ed30b95c349f">GPIOAutoIdleModeControl</a> (uint32_t baseAdd, uint32_t modeFlag)</td></tr>
<tr class="memdesc:a140b8602e3ceff10f613ed30b95c349f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to control(enable/disable) the Auto-Idle mode for GPIO.  <a href="#a140b8602e3ceff10f613ed30b95c349f">More...</a><br /></td></tr>
<tr class="separator:a140b8602e3ceff10f613ed30b95c349f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccf45b0a6f4e35b0710b72501d3ea03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#abccf45b0a6f4e35b0710b72501d3ea03">GPIOIdleModeConfigure</a> (uint32_t baseAdd, uint32_t modeFlag)</td></tr>
<tr class="memdesc:abccf45b0a6f4e35b0710b72501d3ea03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to configure the Power Management Request/Acknowledgement process for GPIO.  <a href="#abccf45b0a6f4e35b0710b72501d3ea03">More...</a><br /></td></tr>
<tr class="separator:abccf45b0a6f4e35b0710b72501d3ea03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b65472a3e215fc77b2a67d4f69ca2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#ad5b65472a3e215fc77b2a67d4f69ca2f">GPIOGatingRatioConfigure</a> (uint32_t baseAdd, uint32_t configFlag)</td></tr>
<tr class="memdesc:ad5b65472a3e215fc77b2a67d4f69ca2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the clock gating ratio for the event detection logic.  <a href="#ad5b65472a3e215fc77b2a67d4f69ca2f">More...</a><br /></td></tr>
<tr class="separator:ad5b65472a3e215fc77b2a67d4f69ca2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2272979e863b6b86b343132fdf971a2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a2272979e863b6b86b343132fdf971a2d">GPIODebounceFuncControl</a> (uint32_t baseAdd, uint32_t pinNumber, uint32_t controlFlag)</td></tr>
<tr class="memdesc:a2272979e863b6b86b343132fdf971a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables/disables debouncing feature for a specified input GPIO pin.  <a href="#a2272979e863b6b86b343132fdf971a2d">More...</a><br /></td></tr>
<tr class="separator:a2272979e863b6b86b343132fdf971a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4a3e231e0895dcfecc3c0ca01b914c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a9a4a3e231e0895dcfecc3c0ca01b914c">GPIODebounceTimeConfig</a> (uint32_t baseAdd, uint32_t debounceTime)</td></tr>
<tr class="memdesc:a9a4a3e231e0895dcfecc3c0ca01b914c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the debouncing time for all the input pins of a GPIO instance.  <a href="#a9a4a3e231e0895dcfecc3c0ca01b914c">More...</a><br /></td></tr>
<tr class="separator:a9a4a3e231e0895dcfecc3c0ca01b914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bfc747680529d173ff4c6eea868642"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#af7bfc747680529d173ff4c6eea868642">GPIORevisionInfoGet</a> (uint32_t baseAdd)</td></tr>
<tr class="memdesc:af7bfc747680529d173ff4c6eea868642"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the contents in the Revision register of the GPIO module.  <a href="#af7bfc747680529d173ff4c6eea868642">More...</a><br /></td></tr>
<tr class="separator:af7bfc747680529d173ff4c6eea868642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947192d9a1989da40657755d93c97447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a947192d9a1989da40657755d93c97447">GPIOIntrClearMask</a> (uint32_t baseAddr, uint32_t intrLine, uint32_t pinMask)</td></tr>
<tr class="memdesc:a947192d9a1989da40657755d93c97447"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the enabled interrupt status of a specified GPIO pin.  <a href="#a947192d9a1989da40657755d93c97447">More...</a><br /></td></tr>
<tr class="separator:a947192d9a1989da40657755d93c97447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8764b68e0ad153e9a63f0113e0904f58"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gpio__v2_8h.html#a8764b68e0ad153e9a63f0113e0904f58">GPIOPinOutValueRead</a> (uint32_t baseAddr, uint32_t pinNumber)</td></tr>
<tr class="memdesc:a8764b68e0ad153e9a63f0113e0904f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the output logic level(value) on a specified GPIO pin.  <a href="#a8764b68e0ad153e9a63f0113e0904f58">More...</a><br /></td></tr>
<tr class="separator:a8764b68e0ad153e9a63f0113e0904f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GPIO Device Abstraction Layer APIs. </p>
<p>This file contains the prototypes of the APIs present in the device abstraction layer file of GPIO. This also contains some related macros.</p>
<p>The detailed description of gpio is:</p><ol type="1">
<li>Each GPIO module provides 32 dedicated general-purpose pins with input and output capabilities.These pins can be configured for the following applications:<ol type="a">
<li>Data input (capture)/output (drive)</li>
<li>Keyboard interface with a debounce cell</li>
<li>Interrupt generation in active mode upon the detection of external events. Detected events are processed by two parallel independent interrupt-generation sub modules to support bi processor operations.</li>
</ol>
</li>
<li>Programming sequence of gpio module is:<ol type="a">
<li>Enable the functional clocks for the required GPIO instance.</li>
<li>Perform a pin multiplexing for the required GPIO pin.</li>
<li>Enable the GPIO module using the API <a class="el" href="gpio__v2_8h.html#ae055980be57fa192a6f9aff1116222de" title="This API is used to enable the GPIO module. When the GPIO module is enabled, the clocks to the module...">GPIOModuleEnable</a>.</li>
<li>Perform a module reset of the GPIO module using the API <a class="el" href="gpio__v2_8h.html#a01d8de27d1ce1b948c862d4e5cdcb6f9" title="This API performs the module reset of the GPIO module. It also waits until the reset process is compl...">GPIOModuleReset</a>.</li>
<li>When GPIO is input pin, following configuration is used<ol type="i">
<li>Enable/disable debouncing feature for the specified input GPIO pin if required, using the API <a class="el" href="gpio__v2_8h.html#a2272979e863b6b86b343132fdf971a2d" title="This API enables/disables debouncing feature for a specified input GPIO pin. ">GPIODebounceFuncControl</a>.</li>
<li>Program the debouncing time, if required using the API <a class="el" href="gpio__v2_8h.html#a9a4a3e231e0895dcfecc3c0ca01b914c" title="This API configures the debouncing time for all the input pins of a GPIO instance. ">GPIODebounceTimeConfig</a>.</li>
<li>Interrupt trigger conditions need to be configured using the API <a class="el" href="gpio__v2_8h.html#a5a12b59ff6af29887899753da2b51753" title="This API configures the event type for a specified input GPIO pin so as to trigger an interrupt reque...">GPIOIntTypeSet</a>.</li>
<li>Enable GPIO to generate interrupts on detection of the specified transitions on the decided GPIO pin using the API <a class="el" href="gpio__v2_8h.html#acc018909808fee4fb0e4a859bcde86c9" title="This API enables the configured interrupt event on a specified input GPIO pin to trigger an interrupt...">GPIOPinIntEnable</a>.</li>
</ol>
</li>
<li>When GPIO is output pin, following configuration is used<ol type="i">
<li>A logic HIGH or a logic LOW could be driven on the specified GPIO pin by invoking the API <a class="el" href="gpio__v2_8h.html#a92817dd60df9d140a0c6140447fd046c" title="This API drives an output GPIO pin to a logic HIGH or a logic LOW state. ">GPIOPinWrite</a>.</li>
</ol>
</li>
</ol>
</li>
<li>Note: If GPIO peripheral interrupts will be used, then the system interrupt settings need to be performed prior to enabling the GPIO peripheral interrupts. </li>
</ol>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a140b8602e3ceff10f613ed30b95c349f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOAutoIdleModeControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to control(enable/disable) the Auto-Idle mode for GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">modeFlag</td><td>This specifies whether to enable or disable the Auto-Idle mode for the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'modeFlag' can take one of the following two values:</p><ul>
<li>GPIO_AUTO_IDLE_MODE_ENABLE - to enable the Auto-Idle mode<br />
</li>
<li>GPIO_AUTO_IDLE_MODE_DISABLE - to disable the Auto-Idle mode<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a2272979e863b6b86b343132fdf971a2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIODebounceFuncControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables/disables debouncing feature for a specified input GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance </td></tr>
    <tr><td class="paramname">controlFlag</td><td>This specifies whether to enable/disable Debouncing feature for the specified input pin</td></tr>
  </table>
  </dd>
</dl>
<p>'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 'controlFlag' can take one of the following values:</p><ul>
<li>GPIO_DEBOUNCE_FUNC_ENABLE - to enable the debouncing feature for the specified input GPIO pin<br />
</li>
<li>GPIO_DEBOUNCE_FUNC_DISABLE - to disable the debouncing feature for the specified input GPIO pin<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a9a4a3e231e0895dcfecc3c0ca01b914c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIODebounceTimeConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>debounceTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the debouncing time for all the input pins of a GPIO instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">debounceTime</td><td>This specifies the number of debouncing clock pulses each of 31 microseconds int32_t to be used for debouncing time. The formula for debouncing time is: debounce time = ((debounceTime + 1)* 31) microseconds</td></tr>
  </table>
  </dd>
</dl>
<p>'debounceTime' can take a value as per below limits:</p><ul>
<li>(0x00 &lt;= debounceTime &lt;= 0xFF)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a225be10c73f1c054ae399233da4f34f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIODirModeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the direction of a specified GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 </p><dl class="section return"><dt>Returns</dt><dd>The direction of the specified pin. This returns one of the following two values:<ul>
<li>GPIO_DIR_INPUT - signifying that the pin is an input pin<br />
</li>
<li>GPIO_DIR_OUTPUT - signifying that the pin is an output pin<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3061ad1df96774f5af289547e45c9422"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIODirModeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the direction of a specified GPIO pin as being either input or output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance </td></tr>
    <tr><td class="paramname">pinDirection</td><td>The required direction for the GPIO pin</td></tr>
  </table>
  </dd>
</dl>
<p>'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 'pinDirection' can take one of the following values:</p><ul>
<li>GPIO_DIR_INPUT - to configure the pin as an input pin<br />
</li>
<li>GPIO_DIR_OUTPUT - to configure the pin as an output pin<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ad5b65472a3e215fc77b2a67d4f69ca2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOGatingRatioConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>configFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the clock gating ratio for the event detection logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">configFlag</td><td>This specifies the clock gating ratio value to be programmed</td></tr>
  </table>
  </dd>
</dl>
<p>'configFlag' can take one of the following values:</p>
<ul>
<li>GPIO_GR_FUNC_CLK_INTER_CLK_BY_1 - to program the functional clock as interface clock frequeny divided by 1<br />
</li>
<li>GPIO_GR_FUNC_CLK_INTER_CLK_BY_2 - to program the functional clock as interface clock frequency divided by 2<br />
</li>
<li>GPIO_GR_FUNC_CLK_INTER_CLK_BY_4 - to program the functional clock as interface clock frequency divided by 4<br />
</li>
<li>GPIO_GR_FUNC_CLK_INTER_CLK_BY_8 - to program the functional clock as interface clock frequency divided by 8<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="abccf45b0a6f4e35b0710b72501d3ea03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOIdleModeConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to configure the Power Management Request/Acknowledgement process for GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">modeFlag</td><td>This specifies the Power Management Request/Acknowledge mode(Idle Mode Request and Response) to be enabled for the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'modeFlag' can take one of the following values:</p><ul>
<li>GPIO_IDLE_MODE_FORCE_IDLE - to enable Force-Idle mode<br />
</li>
<li>GPIO_IDLE_MODE_NO_IDLE - to enable No-Idle mode<br />
</li>
<li>GPIO_IDLE_MODE_SMART_IDLE - to enable Smart-Idle mode<br />
</li>
<li>GPIO_IDLE_MODE_SMART_IDLE_WAKEUP - to enable Smart-Idle-Wakeup mode<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a947192d9a1989da40657755d93c97447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOIntrClearMask </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the enabled interrupt status of a specified GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>The memory address of the GPIO instance being used </td></tr>
    <tr><td class="paramname">intrLine</td><td>This specifies the interrupt line whose corresponding enabled interrupt status register has to be accessed. The status of the specified bit in it is cleared in this API. 'intrLine' can take one of the following two values:<ol type="1">
<li>0 - Interrupt line 0</li>
<li>1 - Interrupt line 1 </li>
</ol>
</td></tr>
    <tr><td class="paramname">pinMask</td><td>Mask of pins whose interrupts need to be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3ba097f7de9cd75ddd400e98265e318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIOIntTypeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the programmed event type for a specified input GPIO pin on occurence of which an interrupt request will be sent to the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns one or a combination of the following values:</dd></dl>
<ul>
<li>GPIO_INT_TYPE_NO_LEVEL - level trigger for interrupt request is disabled<br />
</li>
<li>GPIO_INT_TYPE_LEVEL_0 - logic LOW level event for interrupt request is enabled<br />
</li>
<li>GPIO_INT_TYPE_LEVEL_1 - logic HIGH level event for interrupt request is enabled<br />
</li>
<li>GPIO_INT_TYPE_BOTH_LEVEL - both logic LOW and logic HIGH level events for interrupt request are enabled<br />
</li>
<li>GPIO_INT_TYPE_NO_EDGE - edge trigger for interrupt request is disabled<br />
</li>
<li>GPIO_INT_TYPE_RISE_EDGE - rising edge event for interrupt request is enabled<br />
</li>
<li>GPIO_INT_TYPE_FALL_EDGE - falling edge event for interrupt request is enabled<br />
</li>
<li>GPIO_INT_TYPE_BOTH_EDGE - both rising and falling edge events for interrupt request are enabled<br />
</li>
</ul>

</div>
</div>
<a class="anchor" id="a5a12b59ff6af29887899753da2b51753"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOIntTypeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the event type for a specified input GPIO pin so as to trigger an interrupt request. Whenever the selected event occurs on that GPIO pin, an interrupt request will be sent to the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance </td></tr>
    <tr><td class="paramname">eventType</td><td>This specifies the event type on occurence of which an interrupt request is generated</td></tr>
  </table>
  </dd>
</dl>
<p>'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 'eventType' can take one of the following values:</p><ul>
<li>GPIO_INT_TYPE_NO_LEVEL - no interrupt request on occurence of either a logic LOW or a logic HIGH on the input GPIO pin<br />
</li>
<li>GPIO_INT_TYPE_LEVEL_0 - interrupt request on occurence of a LOW level (logic 0) on the input GPIO pin<br />
</li>
<li>GPIO_INT_TYPE_LEVEL_1 - interrupt request on occurence of a HIGH level (logic 1) on the input GPIO pin<br />
</li>
<li>GPIO_INT_TYPE_BOTH_LEVEL - interrupt request on the occurence of both the LOW level and HIGH level on the input GPIO pin<br />
</li>
<li>GPIO_INT_TYPE_NO_EDGE - no interrupt request on either rising or falling edges on the pin<br />
</li>
<li>GPIO_INT_TYPE_RISE_EDGE - interrupt request on occurence of a rising edge on the input GPIO pin<br />
</li>
<li>GPIO_INT_TYPE_FALL_EDGE - interrupt request on occurence of a falling edge on the input GPIO pin<br />
</li>
<li>GPIO_INT_TYPE_BOTH_EDGE - interrupt request on occurence of both a rising and a falling edge on the pin<br />
 <dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A typical use case of this API is explained below: <pre class="fragment">   If it is initially required that interrupt should be generated on
   LOW level only, then this API can be called with GPIO_INT_TYPE_LEVEL_0
   as the parameter. At a later point of time, if logic HIGH level only
   should be made as the interrupt generating event, then this API has to
   be first called with GPIO_INT_TYPE_NO_LEVEL as the parameter and
   later with GPIO_INT_TYPE_LEVEL_1 as the parameter. Doing this
   ensures that logic LOW level trigger for interrupts is disabled.</pre> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a9e38916d70f40a27bd731b500a226fd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOModuleDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to disable the GPIO module. When the GPIO module is disabled, the clocks to the module are gated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ae055980be57fa192a6f9aff1116222de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOModuleEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to enable the GPIO module. When the GPIO module is enabled, the clocks to the module are not gated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Enabling the GPIO module is a primary step before any other configurations can be done. </dd></dl>

</div>
</div>
<a class="anchor" id="a01d8de27d1ce1b948c862d4e5cdcb6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOModuleReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API performs the module reset of the GPIO module. It also waits until the reset process is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aef5703596ec834913eb1e7879f64ca92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIOMultiplePinsRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>readMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the pin values of the specified pins of the GPIO instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">readMask</td><td>The bit mask of the bits whose values have to be read from the Data Input Register(GPIO_DATAIN).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pin values of the specified pins of the GPIO instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a0aec070e57c370dfc12ddc9866b4f6b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOMultiplePinsWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>setMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to collectively set and collectively clear the specified output pins of a GPIO instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">setMask</td><td>The bit mask of the bits which have to be set in the GPIO Data Output Register(GPIO_DATAOUT) </td></tr>
    <tr><td class="paramname">clrMask</td><td>The bit mask of the bits which have to cleared in the GPIO Data Output Register(GPIO_DATAOUT)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ac135846bad6a97d3e1569c5459453537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOPinIntClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the enabled interrupt status of a specified GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">intLine</td><td>This specifies the interrupt line whose corresponding enabled interrupt status register has to be accessed. The status of the specified bit in it is cleared in this API. </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'intLine' can take one of the following two values:</p><ul>
<li>GPIO_INT_LINE_1 - to access the enabled interrupt status register corresponding to interrupt line 1<br />
</li>
<li>GPIO_INT_LINE_2 - to access the enabled interrupt status register corresponding to interrupt line 2<br />
 'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ae2d6e9239cb93a7778974b577d24458b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOPinIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables interrupt generation due to the detection of any event on a specified input GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">intLine</td><td>This specifies the interrupt requeset line which has to disabled to transmit interrupt requests due to transitions on a specified pin </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'intLine' can take one of the following two values:</p><ul>
<li>GPIO_INT_LINE_1 - signifying that the Interrupt Line 1 be disabled to transmit interrupt requests due to transitions on specified pin<br />
</li>
<li>GPIO_INT_LINE_2 - signifying that the Interrupt Line 2 be disabled to transmit interrupt requests due to transitions on specified pin<br />
 'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="acc018909808fee4fb0e4a859bcde86c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOPinIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the configured interrupt event on a specified input GPIO pin to trigger an interrupt request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">intLine</td><td>This specifies the interrupt request line on which the interrupt request due to the transitions on a specified pin be propagated </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'intLine' can take one of the following two values:</p><ul>
<li>GPIO_INT_LINE_1 - interrupt request be propagated over interrupt line 1<br />
</li>
<li>GPIO_INT_LINE_2 - interrupt request be propagated over interrupt line 2<br />
 'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a19cbc64017ac43595ab342e474b98819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIOPinIntStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the enabled interrupt status of a specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">intLine</td><td>This specifies the interrupt line whose corresponding enabled interrupt status register has to be accessed. The status of the specified pin is returned in this API. </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'intLine' can take one of the following two values:</p><ul>
<li>GPIO_INT_LINE_1 - to read the enabled interrupt status register corresponding to interrupt line 1<br />
</li>
<li>GPIO_INT_LINE_2 - to read the enabled interrupt status register corresponding to interrupt line 2<br />
 'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 <dl class="section return"><dt>Returns</dt><dd>The enabled interrupt status of the pin on the specified interrupt line. This could either be a non-zero or a zero value. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ad906e6b3da5f75e458395e529bccd4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOPinIntWakeUpDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swakeupLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the feature for the specified Input GPIO Pin (Interrupt Request Source) to generate an asynchronous wakeup signal to the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>The memory address of the GPIO instance being used. </td></tr>
    <tr><td class="paramname">swakeupLine</td><td>This specifies the Smart Wakeup Interupt Line which has to be disabled to propogate any asynchrounous wakeup signal due to the specified input GPIO Pin. </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance.</td></tr>
  </table>
  </dd>
</dl>
<p>'swakeupLine' can take one of the following values:</p><ul>
<li>GPIO_INT_SWAKEUP_LINE_1 - to propogate the wakeup request over Smart Wakeup Interrupt Line 1<br />
</li>
<li>GPIO_INT_SWAKEUP_LINE_2 - to propagate the wakeup request over Smart Wakeup Interrupt Line 2<br />
 'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ab1fe3cb8250b2a532f034786909517b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOPinIntWakeUpEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swakeupLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the feature for the specified Input GPIO Pin (Interrupt Request Source) to generate an asynchronous wakeup signal to the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>The memory address of the GPIO instance being used. </td></tr>
    <tr><td class="paramname">swakeupLine</td><td>This specifies the Smart Wakeup Interrupt Line over which the asynchrounous wakeup signal has to be propogated due to the specified Input GPIO pin. </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance.</td></tr>
  </table>
  </dd>
</dl>
<p>'swakeupLine' can take one of the following values:</p><ul>
<li>GPIO_INT_SWAKEUP_LINE_1 - to propogate the wakeup request over Smart Wakeup Interrupt Line 1<br />
</li>
<li>GPIO_INT_SWAKEUP_LINE_2 - to propagate the wakeup request over Smart Wakeup Interrupt Line 2<br />
 'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 <dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>1&gt; Make sure that the GPIO instance in context is allowed to generate Wakeup interrupts to the CPU. If allowed, then enable Wakeup interrupt generation feature for that GPIO instance in the Interrupt Controller.<br />
 2&gt; Usually an Input GPIO Pin acts as an Interrupt Request(IRQ) Source. An expected transition on an Input GPIO Pin can generate a Wakeup request.<br />
</dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a8764b68e0ad153e9a63f0113e0904f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIOPinOutValueRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the output logic level(value) on a specified GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>The memory address of the GPIO instance being used </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance 'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">GPIO_PIN_LOW</td><td>- indicating to drive a logic LOW(0) on the pin. </td></tr>
    <tr><td class="paramname">GPIO_PIN_HIGH</td><td>- indicating to drive a logic HIGH(1) on the pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d167dfae652e560234a5ce73432d90b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIOPinRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the logic level(value) on a specified GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 </p><dl class="section return"><dt>Returns</dt><dd>The pin value (0 or 1) &lt;&lt; pinNumber of the specified pin of the GPIO instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ffc180a6ddde77ed05c05ba27f9c6e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIOPinRead2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the logic level(value) on a specified GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance</td></tr>
  </table>
  </dd>
</dl>
<p>'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 </p><dl class="section return"><dt>Returns</dt><dd>The pin value (0 or 1) of the specified pin of the GPIO instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a92817dd60df9d140a0c6140447fd046c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOPinWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API drives an output GPIO pin to a logic HIGH or a logic LOW state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance </td></tr>
    <tr><td class="paramname">pinValue</td><td>This specifies whether a logic HIGH or a logic LOW should be driven on the output pin</td></tr>
  </table>
  </dd>
</dl>
<p>'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 'pinValue' can take one of the following values:</p><ul>
<li>GPIO_PIN_LOW - indicating to drive a logic LOW(logic 0) on the pin.</li>
<li>GPIO_PIN_HIGH - indicating to drive a logic HIGH(logic 1) on the pin.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a1d8f466a8e2190252dfb9d0ca0749b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIORawIntStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>readMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the raw interrupt status of the specified GPIO pins in the instance corresponding to the specified interrupt line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">intLine</td><td>This specifies the interrupt line whose corresponding raw interrupt status register has to be read. </td></tr>
    <tr><td class="paramname">readMask</td><td>The bit mask of the bits whose values have to be read from the Raw Interrupt Status Register (GPIO_IRQSTATUS_RAW).</td></tr>
  </table>
  </dd>
</dl>
<p>'intLine' can take one of the following two values:</p><ul>
<li>GPIO_INT_LINE_1 - to read the raw interrupt status register corresponding to interrupt line 1<br />
</li>
<li>GPIO_INT_LINE_2 - to read the raw interrupt status register corresponding to interrupt line 2<br />
 <dl class="section return"><dt>Returns</dt><dd>The raw interrupt status of the specified pins of the GPIO instance corresponding to a specified interrupt line. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="af7bfc747680529d173ff4c6eea868642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GPIORevisionInfoGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the contents in the Revision register of the GPIO module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the GPIO_REVISION register. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c7c4befe4b86130a258a97a522ac349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOTriggerPinInt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API manually triggers an interrupt request due to a specified GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>GPIO base address </td></tr>
    <tr><td class="paramname">intLine</td><td>This specifies the interrupt line over which the manually triggered interrupt request has to be propogated </td></tr>
    <tr><td class="paramname">pinNumber</td><td>The number of the pin in the GPIO instance.</td></tr>
  </table>
  </dd>
</dl>
<p>'intLine' can take one of the following values:</p><ul>
<li>GPIO_INT_LINE_1 - to propogate the interrupt request over interrupt line 1<br />
</li>
<li>GPIO_INT_LINE_2 - to propogate the interrupt request over interrupt line 2<br />
 'pinNumber' can take one of the following values: (0 &lt;= pinNumber &lt;= 31)<br />
 <dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Here an interrupt request is manually triggered by writing to a specified bit in the Raw Interrupt Status register. As a pre-requisite, the interrupt generation should be enabled for the GPIO pin. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="aa1a4cdf568e2eede664f1bb1267a3d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOWakeupGlobalDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the GPIO Wakeup generation feature for all the pins of the GPIO module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>The memory address of the GPIO instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a8c4f1b01b2b2c257f3bf1a2efc480b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPIOWakeupGlobalEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the GPIO Wakeup Generation feature for all the pins of the GPIO module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAdd</td><td>The memory address of the GPIO instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>1&gt; A Wakeup signal is generated by an Input GPIO pin when an expected transition happens on that GPIO pin.<br />
 2&gt; For any Input pin of the GPIO module to generate Wakeup signal, the respective global feature for the module has to be enabled by invoking this API.<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
