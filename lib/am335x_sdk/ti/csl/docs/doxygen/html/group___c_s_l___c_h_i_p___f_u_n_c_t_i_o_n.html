<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CHIP Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CHIP Functions<div class="ingroups"><a class="el" href="group___c_s_l___c_h_i_p___a_p_i.html">CHIP</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab2a5fcb123bdd4220a22c6c632f5ef4d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gab2a5fcb123bdd4220a22c6c632f5ef4d">CSL_chipReadAMR</a> (void)</td></tr>
<tr class="separator:gab2a5fcb123bdd4220a22c6c632f5ef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf723600b26a65f552e99bafea5459f29"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gaf723600b26a65f552e99bafea5459f29">CSL_chipReadCSR</a> (void)</td></tr>
<tr class="separator:gaf723600b26a65f552e99bafea5459f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65f983bd7a590a5104a05f1d6744b07"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gac65f983bd7a590a5104a05f1d6744b07">CSL_chipReadIFR</a> (void)</td></tr>
<tr class="separator:gac65f983bd7a590a5104a05f1d6744b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2f26ba61691637fc486928638c5934"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gabf2f26ba61691637fc486928638c5934">CSL_chipReadIER</a> (void)</td></tr>
<tr class="separator:gabf2f26ba61691637fc486928638c5934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb50d93c7fd385d0fcf49e9948986b6"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga7fb50d93c7fd385d0fcf49e9948986b6">CSL_chipReadISTP</a> (void)</td></tr>
<tr class="separator:ga7fb50d93c7fd385d0fcf49e9948986b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d1aa9485fb147d399307ddbc8bb4076"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga9d1aa9485fb147d399307ddbc8bb4076">CSL_chipReadIRP</a> (void)</td></tr>
<tr class="separator:ga9d1aa9485fb147d399307ddbc8bb4076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02d5d742c3732e36337f3d6c01fedca"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gad02d5d742c3732e36337f3d6c01fedca">CSL_chipReadNRP</a> (void)</td></tr>
<tr class="separator:gad02d5d742c3732e36337f3d6c01fedca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82cf1f17337074e695732bdced36b239"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga82cf1f17337074e695732bdced36b239">CSL_chipReadERP</a> (void)</td></tr>
<tr class="separator:ga82cf1f17337074e695732bdced36b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd49f5e07042d928fe197fcc331af0aa"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gafd49f5e07042d928fe197fcc331af0aa">CSL_chipReadTSCL</a> (void)</td></tr>
<tr class="separator:gafd49f5e07042d928fe197fcc331af0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8346f97d17f08b26156240336093c8"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga3f8346f97d17f08b26156240336093c8">CSL_chipReadTSCH</a> (void)</td></tr>
<tr class="separator:ga3f8346f97d17f08b26156240336093c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1d1cf22820af9fc445738db4e2f18e"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga7e1d1cf22820af9fc445738db4e2f18e">CSL_chipReadARP</a> (void)</td></tr>
<tr class="separator:ga7e1d1cf22820af9fc445738db4e2f18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga079f56ba1b67efe032e0ed90569f657d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga079f56ba1b67efe032e0ed90569f657d">CSL_chipReadILC</a> (void)</td></tr>
<tr class="separator:ga079f56ba1b67efe032e0ed90569f657d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64cfb5dca2f106814570e98010a7c980"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga64cfb5dca2f106814570e98010a7c980">CSL_chipReadRILC</a> (void)</td></tr>
<tr class="separator:ga64cfb5dca2f106814570e98010a7c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf5c59c99cab052e961a61dd35bdb02"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga0cf5c59c99cab052e961a61dd35bdb02">CSL_chipReadREP</a> (void)</td></tr>
<tr class="separator:ga0cf5c59c99cab052e961a61dd35bdb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ca6f50bf09a851443dc97f8c4ef41a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gac6ca6f50bf09a851443dc97f8c4ef41a">CSL_chipReadPCE1</a> (void)</td></tr>
<tr class="separator:gac6ca6f50bf09a851443dc97f8c4ef41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca882b2fff96e280b14db39133b724f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga0ca882b2fff96e280b14db39133b724f">CSL_chipReadDNUM</a> (void)</td></tr>
<tr class="separator:ga0ca882b2fff96e280b14db39133b724f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf20a8891e13522d8e3f59e892316260b"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gaf20a8891e13522d8e3f59e892316260b">CSL_chipReadSSR</a> (void)</td></tr>
<tr class="separator:gaf20a8891e13522d8e3f59e892316260b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42215b500c65cabae3d8414e3f14a416"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga42215b500c65cabae3d8414e3f14a416">CSL_chipReadGPLYA</a> (void)</td></tr>
<tr class="separator:ga42215b500c65cabae3d8414e3f14a416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325b9173f4491df332ab03767543d165"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga325b9173f4491df332ab03767543d165">CSL_chipReadGPLYB</a> (void)</td></tr>
<tr class="separator:ga325b9173f4491df332ab03767543d165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5461de5cd898973802616faf61406a19"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga5461de5cd898973802616faf61406a19">CSL_chipReadGFPGFR</a> (void)</td></tr>
<tr class="separator:ga5461de5cd898973802616faf61406a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33fc06a4247b5cdcbeb7355ac7a8faaa"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga33fc06a4247b5cdcbeb7355ac7a8faaa">CSL_chipReadDIER</a> (void)</td></tr>
<tr class="separator:ga33fc06a4247b5cdcbeb7355ac7a8faaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781180be48b1b1524e72af7b5806a5a4"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga781180be48b1b1524e72af7b5806a5a4">CSL_chipReadTSR</a> (void)</td></tr>
<tr class="separator:ga781180be48b1b1524e72af7b5806a5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae040810333748e522087567a328400ac"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gae040810333748e522087567a328400ac">CSL_chipReadITSR</a> (void)</td></tr>
<tr class="separator:gae040810333748e522087567a328400ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ea06d79107c60b2d010e76e533d103"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gab3ea06d79107c60b2d010e76e533d103">CSL_chipReadNTSR</a> (void)</td></tr>
<tr class="separator:gab3ea06d79107c60b2d010e76e533d103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f4dd50045a99cccad2470d873fe47a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gad7f4dd50045a99cccad2470d873fe47a">CSL_chipReadEFR</a> (void)</td></tr>
<tr class="separator:gad7f4dd50045a99cccad2470d873fe47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436fa956a70e8db3d255206e695140dc"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga436fa956a70e8db3d255206e695140dc">CSL_chipReadIERR</a> (void)</td></tr>
<tr class="separator:ga436fa956a70e8db3d255206e695140dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183cb223d9b20fef83f7116f53e96da6"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga183cb223d9b20fef83f7116f53e96da6">CSL_chipWriteAMR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga183cb223d9b20fef83f7116f53e96da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab89462820d32790c61b3ab0553a27c31"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gab89462820d32790c61b3ab0553a27c31">CSL_chipWriteCSR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gab89462820d32790c61b3ab0553a27c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6066ae51e30126a0ae83e99a8488f072"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga6066ae51e30126a0ae83e99a8488f072">CSL_chipWriteISR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga6066ae51e30126a0ae83e99a8488f072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a6348715ef9ce1bb8441b9f179bc65"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga55a6348715ef9ce1bb8441b9f179bc65">CSL_chipWriteICR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga55a6348715ef9ce1bb8441b9f179bc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b38f22a856ffb57a07977b84d29483b"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga3b38f22a856ffb57a07977b84d29483b">CSL_chipWriteIER</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga3b38f22a856ffb57a07977b84d29483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b3ada9b25bc5afa4f2536b5bc1557d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gab6b3ada9b25bc5afa4f2536b5bc1557d">CSL_chipWriteISTP</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gab6b3ada9b25bc5afa4f2536b5bc1557d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65536019ac6194c50eb58a72561627b5"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga65536019ac6194c50eb58a72561627b5">CSL_chipWriteIRP</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga65536019ac6194c50eb58a72561627b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049169a24993ae7dc5b4556519d39d4b"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga049169a24993ae7dc5b4556519d39d4b">CSL_chipWriteNRP</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga049169a24993ae7dc5b4556519d39d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54182443864c50469111f4c8f73e698"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gac54182443864c50469111f4c8f73e698">CSL_chipWriteERP</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gac54182443864c50469111f4c8f73e698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4e4d498d3a8535365b75a4db37a111"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga8e4e4d498d3a8535365b75a4db37a111">CSL_chipWriteTSCL</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga8e4e4d498d3a8535365b75a4db37a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ed0059824db959d022aeec49743209"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gab6ed0059824db959d022aeec49743209">CSL_chipWriteARP</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gab6ed0059824db959d022aeec49743209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d796db8b64f29bd0420d8f7e16799f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga05d796db8b64f29bd0420d8f7e16799f">CSL_chipWriteILC</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga05d796db8b64f29bd0420d8f7e16799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac93ed5b951f659db39b8ec63a7285baa"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gac93ed5b951f659db39b8ec63a7285baa">CSL_chipWriteRILC</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gac93ed5b951f659db39b8ec63a7285baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dce058b3d244d5c72579a698ec5ee5d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga2dce058b3d244d5c72579a698ec5ee5d">CSL_chipWriteREP</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga2dce058b3d244d5c72579a698ec5ee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d6040d486e2d774a0668a039d8a3e2"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gae5d6040d486e2d774a0668a039d8a3e2">CSL_chipWriteSSR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gae5d6040d486e2d774a0668a039d8a3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad787d2265ad50d4ac15e293f9c181dc3"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gad787d2265ad50d4ac15e293f9c181dc3">CSL_chipWriteGPLYA</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gad787d2265ad50d4ac15e293f9c181dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7add339080672254aa0b88806969e659"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga7add339080672254aa0b88806969e659">CSL_chipWriteGPLYB</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga7add339080672254aa0b88806969e659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45a133ec20f101913a402a7c6b4d7ac"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gaf45a133ec20f101913a402a7c6b4d7ac">CSL_chipWriteGFPGFR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gaf45a133ec20f101913a402a7c6b4d7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524890fcac7b6edb0ba599e209218ca2"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga524890fcac7b6edb0ba599e209218ca2">CSL_chipWriteDIER</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga524890fcac7b6edb0ba599e209218ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac029909d0a07914c6d750c7646b79e8f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gac029909d0a07914c6d750c7646b79e8f">CSL_chipWriteTSR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gac029909d0a07914c6d750c7646b79e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac4b7c59eb68cda79587ce28e1d8026"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gafac4b7c59eb68cda79587ce28e1d8026">CSL_chipWriteITSR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gafac4b7c59eb68cda79587ce28e1d8026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c07adf968c0b58bb5b266e6cf177c5f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga0c07adf968c0b58bb5b266e6cf177c5f">CSL_chipWriteNTSR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:ga0c07adf968c0b58bb5b266e6cf177c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a1d4a46bfd6f1aad38297ddb70fc87"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gac2a1d4a46bfd6f1aad38297ddb70fc87">CSL_chipWriteECR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gac2a1d4a46bfd6f1aad38297ddb70fc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4f5d60c32a66aec1b6ff3fa52be1b4"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#gadd4f5d60c32a66aec1b6ff3fa52be1b4">CSL_chipWriteIERR</a> (CSL_Reg32 val)</td></tr>
<tr class="separator:gadd4f5d60c32a66aec1b6ff3fa52be1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab2a5fcb123bdd4220a22c6c632f5ef4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadAMR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadAMR</b> </p>
<p><b>Description</b> <br />
 This API reads the Addressing Mode (AMR) control register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 AMR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 amrVal;
     amrVal = CSL_chipReadAMR ();</pre><hr/>
 <p>Addressing Mode Register </p>

</div>
</div>
<a class="anchor" id="ga7e1d1cf22820af9fc445738db4e2f18e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadARP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadARP</b> </p>
<p><b>Description</b> <br />
 This API reads the Analysis Return Pointer (ARP) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ARP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 arpVal;
     arpVal = CSL_chipReadARP (void);</pre><hr/>
 <p>Analysis Return Pointer </p>

</div>
</div>
<a class="anchor" id="gaf723600b26a65f552e99bafea5459f29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadCSR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadCSR</b> </p>
<p><b>Description</b> <br />
 This API reads the Control Status (CSR) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 csrVal;
     csrVal = CSL_chipReadCSR ();</pre><hr/>
 <p>Control Status Register </p>

</div>
</div>
<a class="anchor" id="ga33fc06a4247b5cdcbeb7355ac7a8faaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadDIER </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadDIER</b> </p>
<p><b>Description</b> <br />
 This API reads the Debug Interrupt Enable Register (DIER) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 DIER</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 dierVal;
     dierVal = CSL_chipReadDIER (void);</pre><hr/>
 <p>Debug Interrupt Enable Register </p>

</div>
</div>
<a class="anchor" id="ga0ca882b2fff96e280b14db39133b724f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadDNUM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadDNUM</b> </p>
<p><b>Description</b> <br />
 This API reads the DSP Core Number (DSPNUM) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 DNUM</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 dnumVal;
     dnumVal = CSL_chipReadDNUM (void);</pre><hr/>
 <p>DSP Core Number Register </p>

</div>
</div>
<a class="anchor" id="gad7f4dd50045a99cccad2470d873fe47a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadEFR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadEFR</b> </p>
<p><b>Description</b> <br />
 This API reads the Exception Flag Register (EFR) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 EFR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 efrVal;
     efrVal = CSL_chipReadEFR (void);</pre><hr/>
 <p>Exception Flag Register </p>

</div>
</div>
<a class="anchor" id="ga82cf1f17337074e695732bdced36b239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadERP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadERP</b> </p>
<p><b>Description</b> <br />
 This API reads the Exception Return Pointer register (ERP) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 NRP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 erpVal;
     erpVal = CSL_chipReadERP (void);</pre><hr/>
 <p>Exception Return Pointer Registers </p>

</div>
</div>
<a class="anchor" id="ga5461de5cd898973802616faf61406a19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadGFPGFR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadGFPGFR</b> </p>
<p><b>Description</b> <br />
 This API reads the Galios Field Multiply Control Register (GFPGFR) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 GFPGFR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 gfpgfrVal;
     gfpgfrVal = CSL_chipReadGFPGFR (void);</pre><hr/>
 <p>Galois Field Polynomial Generator Function Register </p>

</div>
</div>
<a class="anchor" id="ga42215b500c65cabae3d8414e3f14a416"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadGPLYA </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadGPLYA</b> </p>
<p><b>Description</b> <br />
 This API reads the GMPY A-side polynomial Register (GPLYA) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 GPLYA</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 gplyaVal;
     gplyaVal = CSL_chipReadGPLYA (void);</pre><hr/>
 <p>GMPY Polynomial.A Side Register </p>

</div>
</div>
<a class="anchor" id="ga325b9173f4491df332ab03767543d165"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadGPLYB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadGPLYB</b> </p>
<p><b>Description</b> <br />
 This API reads the GMPY B-side polynomial Register (GPLYB) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 GPLYB</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 gplybVal;
     gplybVal = CSL_chipReadGPLYB (void);</pre><hr/>
 <p>GMPY Polynomial.B Side Register </p>

</div>
</div>
<a class="anchor" id="gabf2f26ba61691637fc486928638c5934"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadIER </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadIER</b> </p>
<p><b>Description</b> <br />
 This API reads the Interrrupt Enable register (IER) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 IER</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 ierVal;
     ierVal = CSL_chipReadIER (void);</pre><hr/>
 <p>Interrupt Enable Register </p>

</div>
</div>
<a class="anchor" id="ga436fa956a70e8db3d255206e695140dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadIERR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadIERR</b> </p>
<p><b>Description</b> <br />
 This API reads the Internal Exception Report Register (IERR) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 IERR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 ierrVal;
     ierrVal = CSL_chipReadIERR (void);</pre><hr/>
 <p>Internal Exception Report Register </p>

</div>
</div>
<a class="anchor" id="gac65f983bd7a590a5104a05f1d6744b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadIFR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadIFR</b> </p>
<p><b>Description</b> <br />
 This API reads the Interrrupt Flag register (IFR) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 IFR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 ifrVal;
     ifrVal = CSL_chipReadIFR (void);</pre><hr/>
 <p>Interrupt Flag Register </p>

</div>
</div>
<a class="anchor" id="ga079f56ba1b67efe032e0ed90569f657d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadILC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadILC</b> </p>
<p><b>Description</b> <br />
 This API reads the Inner Loop SPL Buffer Count (ILC) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ILC</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 ilcVal;
     ilcVal = CSL_chipReadILC (void);</pre><hr/>
 <p>SPLOOP Inner Loop Count Register </p>

</div>
</div>
<a class="anchor" id="ga9d1aa9485fb147d399307ddbc8bb4076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadIRP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadIRP</b> </p>
<p><b>Description</b> <br />
 This API reads the Interrrupt Return Pointer register (IRP) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 IRP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 irpVal;
     irpVal = CSL_chipReadIRP (void);</pre><hr/>
 <p>Interrupt Return Pointer Register </p>

</div>
</div>
<a class="anchor" id="ga7fb50d93c7fd385d0fcf49e9948986b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadISTP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadISTP</b> </p>
<p><b>Description</b> <br />
 This API reads the Interrrupt Service Table Pointer register (ISTP) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ISTP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 istpVal;
     istpVal = CSL_chipReadISTP (void);</pre><hr/>
 <p>Interrupt Service Table Pointer Register </p>

</div>
</div>
<a class="anchor" id="gae040810333748e522087567a328400ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadITSR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadITSR</b> </p>
<p><b>Description</b> <br />
 This API reads the Interrupt Task State Register (ITSR) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ITSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 itsrVal;
     itsrVal = CSL_chipReadITSR (void);</pre><hr/>
 <p>Interrupt Task State Register </p>

</div>
</div>
<a class="anchor" id="gad02d5d742c3732e36337f3d6c01fedca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadNRP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadNRP</b> </p>
<p><b>Description</b> <br />
 This API reads the Nonmaskable Interrupt Return Pointer register (NRP) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 NRP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 nrpVal;
     nrpVal = CSL_chipReadNRP (void);</pre><hr/>
 <p>Nonmaskable Interrupt (NMI) Registers </p>

</div>
</div>
<a class="anchor" id="gab3ea06d79107c60b2d010e76e533d103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadNTSR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadNTSR</b> </p>
<p><b>Description</b> <br />
 This API reads the NMI/Exception Task State Register (NTSR) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 NTSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 ntsrVal;
     ntsrVal = CSL_chipReadNTSR (void);</pre><hr/>
 <p>NMI/Exception Task State Register </p>

</div>
</div>
<a class="anchor" id="gac6ca6f50bf09a851443dc97f8c4ef41a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadPCE1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadPCE1</b> </p>
<p><b>Description</b> <br />
 This API reads the Program Counter, E1 Phase (PCE1) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PCE1</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 pce1Val;
     pce1Val = CSL_chipReadPCE1 (void);</pre><hr/>
 <p>E1 Phase Program Counter </p>

</div>
</div>
<a class="anchor" id="ga0cf5c59c99cab052e961a61dd35bdb02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadREP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadREP</b> </p>
<p><b>Description</b> <br />
 This API reads the Restricted Entry Point Address (REP) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 REP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 repVal;
     repVal = CSL_chipReadREP (void);</pre><hr/>
 <p>Restricted Entry Point Address Register </p>

</div>
</div>
<a class="anchor" id="ga64cfb5dca2f106814570e98010a7c980"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadRILC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadRILC</b> </p>
<p><b>Description</b> <br />
 This API reads the Reload Inner Loop SPL Buffer Count (RILC) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 RILC</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 rilcVal;
     rilcVal = CSL_chipReadRILC (void);</pre><hr/>
 <p>SPLOOP Reload Inner Loop Count Register </p>

</div>
</div>
<a class="anchor" id="gaf20a8891e13522d8e3f59e892316260b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadSSR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadSSR</b> </p>
<p><b>Description</b> <br />
 This API reads the Saturation Status Register (SSR) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 ssrVal;
     ssrVal = CSL_chipReadSSR (void);</pre><hr/>
 <p>Saturation Status Register </p>

</div>
</div>
<a class="anchor" id="ga3f8346f97d17f08b26156240336093c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadTSCH </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadTSCH</b> </p>
<p><b>Description</b> <br />
 This API reads the Time Stamp Counter Higher Order 32-bits (TSCH) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 <em><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga8e4e4d498d3a8535365b75a4db37a111">CSL_chipWriteTSCL()</a></em> must be called with any arbitrary value to enable the TSC first before this API is called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TSCH</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 tschVal;
     tschVal = CSL_chipReadTSCH (void);</pre><hr/>
 <p>Time Stamp Counter Registers - High </p>

</div>
</div>
<a class="anchor" id="gafd49f5e07042d928fe197fcc331af0aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadTSCL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadTSCL</b> </p>
<p><b>Description</b> <br />
 This API reads the Time Stamp Counter Lower Order 32-bits (TSCL) register and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 <em><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html#ga8e4e4d498d3a8535365b75a4db37a111">CSL_chipWriteTSCL()</a></em> must be called with any arbitrary value to enable the TSC first before this API is called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TSCL</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 tsclVal;
     tsclVal = CSL_chipReadTSCL (void);</pre><hr/>
 <p>Time Stamp Counter Register - Low </p>

</div>
</div>
<a class="anchor" id="ga781180be48b1b1524e72af7b5806a5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipReadTSR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipReadTSR</b> </p>
<p><b>Description</b> <br />
 This API reads the Task State Register (TSR) and returns its contents.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32 </p><ul>
<li>The control register value read</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 tsrVal;
     tsrVal = CSL_chipReadTSR (void);</pre><hr/>
 <p>Task State Register </p>

</div>
</div>
<a class="anchor" id="ga183cb223d9b20fef83f7116f53e96da6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteAMR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteAMR</b> </p>
<p><b>Description</b> <br />
 This API configures the Addressing Mode Register (AMR) with the specified new value 'val'. This API returns the old AMR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The AMR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 AMR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldamr;
     oldamr = CSL_chipWriteAMR (56);</pre><hr/>
 <p>Addressing Mode Register </p>

</div>
</div>
<a class="anchor" id="gab6ed0059824db959d022aeec49743209"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteARP </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteARP</b> </p>
<p><b>Description</b> <br />
 This API writes to the Analysis Return Pointer (ARP) with the specified value 'val'. This API returns the old ARP value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from ARP register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The ARP control register is written with the value passed</p>
<p><b>Writes</b> <br />
 ARP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldARP;
     oldARP = CSL_chipWriteARP (56);</pre><hr/>
 <p>Analysis Return Point Register </p>

</div>
</div>
<a class="anchor" id="gab89462820d32790c61b3ab0553a27c31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteCSR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteCSR</b> </p>
<p><b>Description</b> <br />
 This API configures the Control Status Register (CSR) with the specified new value 'val'. This API returns the old CSR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The CSR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 CSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldcsr;
     oldcsr = CSL_chipWriteCSR (56);</pre><hr/>
 <p>Control Status Register </p>

</div>
</div>
<a class="anchor" id="ga524890fcac7b6edb0ba599e209218ca2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteDIER </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteDIER</b> </p>
<p><b>Description</b> <br />
 This API writes to the Debug Interrupt Enable Register (DIER) with the specified value 'val'. This API returns the old DIER value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from DIER register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The DIER control register is written with the value passed</p>
<p><b>Writes</b> <br />
 DIER</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldDIER;
     oldDIER = CSL_chipWriteDIER (56);</pre><hr/>
 <p>Debug Interrupt Enable Register </p>

</div>
</div>
<a class="anchor" id="gac2a1d4a46bfd6f1aad38297ddb70fc87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteECR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteECR</b> </p>
<p><b>Description</b> <br />
 This API writes to the Exception Clear Register (ECR) with the specified value 'val' to clear the corresponding bits in the EFR. This API returns the old EFR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from EFR register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The ECR control register is written with the value passed and the corresponding exception bits in the EFR register are cleared.</p>
<p><b>Writes</b> <br />
 EFR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldEFR;
     oldEFR = CSL_chipWriteECR (56);</pre><hr/>
 <p>Return the old value from Exception Flag Register and set the Clear Register</p>

</div>
</div>
<a class="anchor" id="gac54182443864c50469111f4c8f73e698"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteERP </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteERP</b> </p>
<p><b>Description</b> <br />
 This API writes to the Exception Return Pointer Register (ERP) with the specified value 'val' to setup a return point in the program to continue execution after an exception has occured. This API returns the old ERP value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from NRP register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The NRP control register is written with the value passed</p>
<p><b>Writes</b> <br />
 NRP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldERP;
     oldERP = CSL_chipWriteERP (56);</pre><hr/>
 <p>Exception Return Point (ERP) Registers </p>

</div>
</div>
<a class="anchor" id="gaf45a133ec20f101913a402a7c6b4d7ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteGFPGFR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteGFPGFR</b> </p>
<p><b>Description</b> <br />
 This API writes to the Galios Field Polynomial Generator Function Register (GFPGFR) with the specified value 'val'. This API returns the old GFPGFR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from GFPGFR register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The GFPGFR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 GFPGFR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldGFPGFR;
     oldGFPGFR = CSL_chipWriteGFPGFR (56);</pre><hr/>
 <p>Galois Field Polynomial Generator Function Register </p>

</div>
</div>
<a class="anchor" id="gad787d2265ad50d4ac15e293f9c181dc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteGPLYA </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteGPLYA</b> </p>
<p><b>Description</b> <br />
 This API writes to the GMPY Polynomial-A side Register (GPLYA) with the specified value 'val'. This API returns the old GPLYA value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from GPLYA register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The GPLYA control register is written with the value passed</p>
<p><b>Writes</b> <br />
 GPLYA</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldGPLYA;
     oldGPLYA = CSL_chipWriteGPLYA (56);</pre><hr/>
 <p>GMPY Polynomial.A Side Register </p>

</div>
</div>
<a class="anchor" id="ga7add339080672254aa0b88806969e659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteGPLYB </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteGPLYB</b> </p>
<p><b>Description</b> <br />
 This API writes to the GMPY Polynomial-B side Register (GPLYB) with the specified value 'val'. This API returns the old GPLYB value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from GPLYB register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The GPLYB control register is written with the value passed</p>
<p><b>Writes</b> <br />
 GPLYB</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldGPLYB;
     oldGPLYB = CSL_chipWriteGPLYB (56);</pre><hr/>
 <p>GMPY Polynomial.B Side Register </p>

</div>
</div>
<a class="anchor" id="ga55a6348715ef9ce1bb8441b9f179bc65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteICR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteICR</b> </p>
<p><b>Description</b> <br />
 This API writes to the Interrupt Clear Register (ICR) with the specified new value 'val' to clear the maskable interrupts configured in the IFR register. This API returns the old interrupt state from IFR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from IFR</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The ICR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 ICR</p>
<p><b>Affects</b> <br />
 IFR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldIFR;
     oldIFR = CSL_chipWriteICR (56);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3b38f22a856ffb57a07977b84d29483b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteIER </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteIER</b> </p>
<p><b>Description</b> <br />
 This API writes to the Interrupt Enable Register (IER) with the specified new value 'val' to enable/disable individual interrupts in the system. This API returns the old interrupt enable state from IER value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from IER</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The IER control register is written with the value passed</p>
<p><b>Writes</b> <br />
 IER</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldIER;
     oldIER = CSL_chipWriteIER (56);</pre><hr/>
 <p>Interrupt Enable Register </p>

</div>
</div>
<a class="anchor" id="gadd4f5d60c32a66aec1b6ff3fa52be1b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteIERR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteIERR</b> </p>
<p><b>Description</b> <br />
 This API writes to the Internal Exception Report Register (IERR) with the specified value 'val'. This API returns the old IERR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from IERR register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The IERR control register is written with the value passed.</p>
<p><b>Writes</b> <br />
 IERR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldIERR;
     oldIERR = CSL_chipWriteIERR (56);</pre><hr/>
 <p>Internal Exception Report Register </p>

</div>
</div>
<a class="anchor" id="ga05d796db8b64f29bd0420d8f7e16799f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteILC </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteILC</b> </p>
<p><b>Description</b> <br />
 This API writes to the SPLOOP Inner Loop Count Register (ILC) with the specified value 'val'. This API returns the old ILC value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from ILC register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The ILC control register is written with the value passed</p>
<p><b>Writes</b> <br />
 ILC</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldILC;
     oldILC = CSL_chipWriteILC (56);</pre><hr/>
 <p>SPLOOP Inner Loop Count Register </p>

</div>
</div>
<a class="anchor" id="ga65536019ac6194c50eb58a72561627b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteIRP </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteIRP</b> </p>
<p><b>Description</b> <br />
 This API writes to the Interrupt Return Pointer Register (IRP) with the specified value 'val' to setup a return point in the program to continue execution after a maskable interrupt is executed. This API returns the old IRP value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from IRP</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The IRP control register is written with the value passed</p>
<p><b>Writes</b> <br />
 IRP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldIRP;
     oldIRP = CSL_chipWriteIRP (56);</pre><hr/>
 <p>Interrupt Return Pointer Register </p>

</div>
</div>
<a class="anchor" id="ga6066ae51e30126a0ae83e99a8488f072"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteISR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteISR</b> </p>
<p><b>Description</b> <br />
 This API configures the Interrupt Set Register (ISR) with the specified new value 'val'. This API returns the old ISR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The ISR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 ISR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldISR;
     oldISR = CSL_chipWriteISR (56);</pre><hr/>
 <p>Read Interrupt Flag Register and write to the Interrupt Set Register </p>

</div>
</div>
<a class="anchor" id="gab6b3ada9b25bc5afa4f2536b5bc1557d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteISTP </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteISTP</b> </p>
<p><b>Description</b> <br />
 This API writes to the Interrupt Service Table Pointer Register (ISTP) with the specified value 'val' to setup a ISR base address for a given interrupt in the ISTB. This API returns the old ISTP value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from ISTP</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The ISTP control register is written with the value passed</p>
<p><b>Writes</b> <br />
 ISTP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldISTP;
     oldISTP = CSL_chipWriteISTP (56);</pre><hr/>
 <p>Interrupt Service Table Pointer Register </p>

</div>
</div>
<a class="anchor" id="gafac4b7c59eb68cda79587ce28e1d8026"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteITSR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteITSR</b> </p>
<p><b>Description</b> <br />
 This API writes to the Interrupt Task State Register (ITSR) with the specified value 'val'. This API returns the old ITSR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from ITSR register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The ITSR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 ITSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldITSR;
     oldITSR = CSL_chipWriteITSR (56);</pre><hr/>
 <p>Interrupt Task State Register </p>

</div>
</div>
<a class="anchor" id="ga049169a24993ae7dc5b4556519d39d4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteNRP </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteNRP</b> </p>
<p><b>Description</b> <br />
 This API writes to the NMI Return Pointer Register (NRP) with the specified value 'val' to setup a return point in the program to continue execution after an NMI has occured. This API returns the old NRP value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from NRP</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The NRP control register is written with the value passed</p>
<p><b>Writes</b> <br />
 NRP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldNRP;
     oldNRP = CSL_chipWriteNRP (56);</pre><hr/>
 <p>Nonmaskable Interrupt (NMI) Registers </p>

</div>
</div>
<a class="anchor" id="ga0c07adf968c0b58bb5b266e6cf177c5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteNTSR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteNTSR</b> </p>
<p><b>Description</b> <br />
 This API writes to the NMI/Exception Task State Register (NTSR) with the specified value 'val'. This API returns the old NTSR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from NTSR register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The NTSR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 NTSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldNTSR;
     oldNTSR = CSL_chipWriteNTSR (56);</pre><hr/>
 <p>NMI/Exception Task State Register </p>

</div>
</div>
<a class="anchor" id="ga2dce058b3d244d5c72579a698ec5ee5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteREP </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteREP</b> </p>
<p><b>Description</b> <br />
 This API writes to the Restricted Entry-Point Register (REP) with the specified value 'val'. This API returns the old REP value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from REP register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The REP control register is written with the value passed</p>
<p><b>Writes</b> <br />
 REP</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldREP;
     oldREP = CSL_chipWriteREP (56);</pre><hr/>
 <p>Restricted Entry Point Address Register </p>

</div>
</div>
<a class="anchor" id="gac93ed5b951f659db39b8ec63a7285baa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteRILC </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteRILC</b> </p>
<p><b>Description</b> <br />
 This API writes to the SPLOOP Reload Inner Loop Count Register (RILC) with the specified value 'val'. This API returns the old RILC value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from RILC register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The RILC control register is written with the value passed</p>
<p><b>Writes</b> <br />
 RILC</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldRILC;
     oldRILC = CSL_chipWriteRILC (56);</pre><hr/>
 <p>SPLOOP Reload Inner Loop Count Register </p>

</div>
</div>
<a class="anchor" id="gae5d6040d486e2d774a0668a039d8a3e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteSSR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteSSR</b> </p>
<p><b>Description</b> <br />
 This API writes to the Saturation Status Register (SSR) with the specified value 'val'. This API returns the old SSR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from SSR register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The SSR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 SSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldSSR;
     oldSSR = CSL_chipWriteSSR (56);</pre><hr/>
 <p>Saturation Status Register </p>

</div>
</div>
<a class="anchor" id="ga8e4e4d498d3a8535365b75a4db37a111"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteTSCL </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteTSCL</b> </p>
<p><b>Description</b> <br />
 This API writes to the Time-Stamp Counter (low order 32 bits) Register (TSCL) with the specified value 'val' to enable the TSC. This API returns the old TSCL value on return. The actual value written "val" to TSCL has no effect on the Time stamp counter. The value is simply ignored by the hardware, and a write to TSCL is used only to enable the Time Stamp Counter.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from TSCL register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The TSCL control register is written with the value passed</p>
<p><b>Writes</b> <br />
 TSCL</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldTSCL;
     oldTSCL = CSL_chipWriteTSCL (56);</pre><hr/>
 <p>Time Stamp Counter Register - Low </p>

</div>
</div>
<a class="anchor" id="gac029909d0a07914c6d750c7646b79e8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_chipWriteTSR </td>
          <td>(</td>
          <td class="paramtype">CSL_Reg32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_chipWriteTSR</b> </p>
<p><b>Description</b> <br />
 This API writes to the Task State Register (TSR) with the specified value 'val'. This API returns the old TSR value on return.</p>
<p><b>Arguments</b> </p><pre class="fragment">     val         Value to be written.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>New programmed value from TSR register</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The TSR control register is written with the value passed</p>
<p><b>Writes</b> <br />
 TSR</p>
<p><b> Usage Constraints: </b> <br />
 Please refer to the C64x+ user guide for constraints while accessing registers in different privilege levels.</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32 oldTSR;
     oldTSR = CSL_chipWriteTSR (56);</pre><hr/>
 <p>Task State Register </p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
