<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Uart</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Uart<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3a81b3c151c252d6bfc84485b48e0bc3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga3a81b3c151c252d6bfc84485b48e0bc3">UARTOperatingModeSelect</a> (uint32_t baseAddr, uint32_t modeFlag)</td></tr>
<tr class="memdesc:ga3a81b3c151c252d6bfc84485b48e0bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the operating mode for the UART instance. The different operating modes are:  <a href="#ga3a81b3c151c252d6bfc84485b48e0bc3">More...</a><br /></td></tr>
<tr class="separator:ga3a81b3c151c252d6bfc84485b48e0bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20281eb052ab875e89e73234623f2262"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga20281eb052ab875e89e73234623f2262">UARTDivisorValCompute</a> (uint32_t moduleClk, uint32_t baudRate, uint32_t modeFlag, uint32_t mirOverSampRate)</td></tr>
<tr class="memdesc:ga20281eb052ab875e89e73234623f2262"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API computes the divisor value for the specified operating mode. Not part of this API, the divisor value returned is written to the Divisor Latches to configure the Baud Rate.  <a href="#ga20281eb052ab875e89e73234623f2262">More...</a><br /></td></tr>
<tr class="separator:ga20281eb052ab875e89e73234623f2262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c3153d105bed260fdc7dd0083b1ad8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga88c3153d105bed260fdc7dd0083b1ad8">UARTDivisorLatchWrite</a> (uint32_t baseAddr, uint32_t divisorValue)</td></tr>
<tr class="memdesc:ga88c3153d105bed260fdc7dd0083b1ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to write the specified divisor value to Divisor Latch registers DLL and DLH.  <a href="#ga88c3153d105bed260fdc7dd0083b1ad8">More...</a><br /></td></tr>
<tr class="separator:ga88c3153d105bed260fdc7dd0083b1ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafea08502a48186cbf103d98a3360a467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gafea08502a48186cbf103d98a3360a467">UARTDivisorLatchEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gafea08502a48186cbf103d98a3360a467"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables write access to Divisor Latch registers DLL and DLH.  <a href="#gafea08502a48186cbf103d98a3360a467">More...</a><br /></td></tr>
<tr class="separator:gafea08502a48186cbf103d98a3360a467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e80954aa960fc9fba99b38c9680222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga39e80954aa960fc9fba99b38c9680222">UARTDivisorLatchDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga39e80954aa960fc9fba99b38c9680222"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables write access to Divisor Latch registers DLL and DLH.  <a href="#ga39e80954aa960fc9fba99b38c9680222">More...</a><br /></td></tr>
<tr class="separator:ga39e80954aa960fc9fba99b38c9680222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae236fbd76a12187f133cacf394b8d719"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gae236fbd76a12187f133cacf394b8d719">UARTRegConfigModeEnable</a> (uint32_t baseAddr, uint32_t modeFlag)</td></tr>
<tr class="memdesc:gae236fbd76a12187f133cacf394b8d719"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the specified Register Configuration mode for the UART.  <a href="#gae236fbd76a12187f133cacf394b8d719">More...</a><br /></td></tr>
<tr class="separator:gae236fbd76a12187f133cacf394b8d719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690a93bbf457c306904ca6b09c713caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga690a93bbf457c306904ca6b09c713caa">UARTRegConfModeRestore</a> (uint32_t baseAddr, uint32_t lcrRegValue)</td></tr>
<tr class="memdesc:ga690a93bbf457c306904ca6b09c713caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to restore the UART to the specified Register Configuration Mode.  <a href="#ga690a93bbf457c306904ca6b09c713caa">More...</a><br /></td></tr>
<tr class="separator:ga690a93bbf457c306904ca6b09c713caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c41950042da5c69d21e8f68d5d38eb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga8c41950042da5c69d21e8f68d5d38eb4">UARTBreakCtl</a> (uint32_t baseAddr, uint32_t breakState)</td></tr>
<tr class="memdesc:ga8c41950042da5c69d21e8f68d5d38eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to introduce or to remove a Break condition.  <a href="#ga8c41950042da5c69d21e8f68d5d38eb4">More...</a><br /></td></tr>
<tr class="separator:ga8c41950042da5c69d21e8f68d5d38eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb6d0f98628957ed2b908b11e4e9dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaaeb6d0f98628957ed2b908b11e4e9dde">UARTLineCharacConfig</a> (uint32_t baseAddr, uint32_t wLenStbFlag, uint32_t parityFlag)</td></tr>
<tr class="memdesc:gaaeb6d0f98628957ed2b908b11e4e9dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the Line Characteristics for the UART instance. The Line Characteristics include:  <a href="#gaaeb6d0f98628957ed2b908b11e4e9dde">More...</a><br /></td></tr>
<tr class="separator:gaaeb6d0f98628957ed2b908b11e4e9dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a657656a0377614fd1f293f95913d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga66a657656a0377614fd1f293f95913d1">UARTParityModeSet</a> (uint32_t baseAddr, uint32_t parityFlag)</td></tr>
<tr class="memdesc:ga66a657656a0377614fd1f293f95913d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the Parity feature for the UART.  <a href="#ga66a657656a0377614fd1f293f95913d1">More...</a><br /></td></tr>
<tr class="separator:ga66a657656a0377614fd1f293f95913d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a3083c6d9000dc5021ac5d58309dac"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga50a3083c6d9000dc5021ac5d58309dac">UARTParityModeGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga50a3083c6d9000dc5021ac5d58309dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the Parity configuration being set in the UART.  <a href="#ga50a3083c6d9000dc5021ac5d58309dac">More...</a><br /></td></tr>
<tr class="separator:ga50a3083c6d9000dc5021ac5d58309dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290dd8d0726bfcef0eb21c92c0e1443c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga290dd8d0726bfcef0eb21c92c0e1443c">UARTDMAEnable</a> (uint32_t baseAddr, uint32_t dmaModeFlag)</td></tr>
<tr class="memdesc:ga290dd8d0726bfcef0eb21c92c0e1443c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the DMA mode of operation for the UART instance.  <a href="#ga290dd8d0726bfcef0eb21c92c0e1443c">More...</a><br /></td></tr>
<tr class="separator:ga290dd8d0726bfcef0eb21c92c0e1443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1cd45c047c7e47f512349fcbbb2c6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gadf1cd45c047c7e47f512349fcbbb2c6e">UARTDMADisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gadf1cd45c047c7e47f512349fcbbb2c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the DMA mode of operation.  <a href="#gadf1cd45c047c7e47f512349fcbbb2c6e">More...</a><br /></td></tr>
<tr class="separator:gadf1cd45c047c7e47f512349fcbbb2c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20f52578fbb06eb057843718a3557ca2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga20f52578fbb06eb057843718a3557ca2">UARTFIFOConfig</a> (uint32_t baseAddr, uint32_t fifoConfig)</td></tr>
<tr class="memdesc:ga20f52578fbb06eb057843718a3557ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the FIFO settings for the UART instance. Specifically, this does the following configurations: 1&gt; Configures the Transmitter and Receiver FIFO Trigger Level granularity<br />
 2&gt; Configures the Transmitter and Receiver FIFO Trigger Level<br />
 3&gt; Configures the bits which clear/not clear the TX and RX FIFOs<br />
 4&gt; Configures the DMA mode of operation<br />
.  <a href="#ga20f52578fbb06eb057843718a3557ca2">More...</a><br /></td></tr>
<tr class="separator:ga20f52578fbb06eb057843718a3557ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5529baf7747fbb28c627290d273723a6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga5529baf7747fbb28c627290d273723a6">UARTEnhanFuncEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga5529baf7747fbb28c627290d273723a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets a certain bit in Enhanced Feature Register(EFR) which shall avail the UART to use some Enhanced Features.  <a href="#ga5529baf7747fbb28c627290d273723a6">More...</a><br /></td></tr>
<tr class="separator:ga5529baf7747fbb28c627290d273723a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46501fb460edec940270b508db3e647c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga46501fb460edec940270b508db3e647c">UARTEnhanFuncBitValRestore</a> (uint32_t baseAddr, uint32_t enhanFnBitVal)</td></tr>
<tr class="memdesc:ga46501fb460edec940270b508db3e647c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API restores the ENHANCEDEN bit value of EFR register(EFR[4]) to the corresponding bit value in 'enhanFnBitVal' passed as a parameter to this API.  <a href="#ga46501fb460edec940270b508db3e647c">More...</a><br /></td></tr>
<tr class="separator:ga46501fb460edec940270b508db3e647c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2cf4a1d681f19af614449954739966b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gac2cf4a1d681f19af614449954739966b">UARTSubConfigMSRSPRModeEn</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gac2cf4a1d681f19af614449954739966b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the MSR_SPR Sub-Configuration Mode of operation.  <a href="#gac2cf4a1d681f19af614449954739966b">More...</a><br /></td></tr>
<tr class="separator:gac2cf4a1d681f19af614449954739966b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d90dd46b42106ffabb9bf83d7446cb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga25d90dd46b42106ffabb9bf83d7446cb">UARTSubConfigTCRTLRModeEn</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga25d90dd46b42106ffabb9bf83d7446cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the TCR_TLR Sub_Configuration Mode of operation.  <a href="#ga25d90dd46b42106ffabb9bf83d7446cb">More...</a><br /></td></tr>
<tr class="separator:ga25d90dd46b42106ffabb9bf83d7446cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13788f3465f5dbe3183b0fa1602483a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga13788f3465f5dbe3183b0fa1602483a4">UARTSubConfigXOFFModeEn</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga13788f3465f5dbe3183b0fa1602483a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the XOFF Sub-Configuration Mode of operation.  <a href="#ga13788f3465f5dbe3183b0fa1602483a4">More...</a><br /></td></tr>
<tr class="separator:ga13788f3465f5dbe3183b0fa1602483a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33dd96e5cdbb06fef0c58d57f2e7baf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga33dd96e5cdbb06fef0c58d57f2e7baf9">UARTTCRTLRBitValRestore</a> (uint32_t baseAddr, uint32_t tcrTlrBitVal)</td></tr>
<tr class="memdesc:ga33dd96e5cdbb06fef0c58d57f2e7baf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API restores the TCRTLR bit(MCR[6]) value in Modem Control Register(MCR) to the corresponding bit value in 'tcrTlrBitVal' passed as a parameter to this API.  <a href="#ga33dd96e5cdbb06fef0c58d57f2e7baf9">More...</a><br /></td></tr>
<tr class="separator:ga33dd96e5cdbb06fef0c58d57f2e7baf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de3bcf1e548d2a77a25cd8e31df35d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga6de3bcf1e548d2a77a25cd8e31df35d1">UARTIntEnable</a> (uint32_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:ga6de3bcf1e548d2a77a25cd8e31df35d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the specified interrupts in the UART mode of operation.  <a href="#ga6de3bcf1e548d2a77a25cd8e31df35d1">More...</a><br /></td></tr>
<tr class="separator:ga6de3bcf1e548d2a77a25cd8e31df35d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f90556a4ff4d3d936c9e2861b6d0e27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga3f90556a4ff4d3d936c9e2861b6d0e27">UARTIntDisable</a> (uint32_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:ga3f90556a4ff4d3d936c9e2861b6d0e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the specified interrupts in the UART mode of operation.  <a href="#ga3f90556a4ff4d3d936c9e2861b6d0e27">More...</a><br /></td></tr>
<tr class="separator:ga3f90556a4ff4d3d936c9e2861b6d0e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232f92fb9dba5795c62869d61ce35cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga232f92fb9dba5795c62869d61ce35cc0">UARTInt2Enable</a> (uint32_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:ga232f92fb9dba5795c62869d61ce35cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the specified interrupts in the UART mode of operation for IER2.  <a href="#ga232f92fb9dba5795c62869d61ce35cc0">More...</a><br /></td></tr>
<tr class="separator:ga232f92fb9dba5795c62869d61ce35cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb147d6336141e24dc34e919d604f8d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaeb147d6336141e24dc34e919d604f8d8">UARTInt2Disable</a> (uint32_t baseAddr, uint32_t intFlag)</td></tr>
<tr class="memdesc:gaeb147d6336141e24dc34e919d604f8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the specified interrupts in the UART mode of operation for IER2.  <a href="#gaeb147d6336141e24dc34e919d604f8d8">More...</a><br /></td></tr>
<tr class="separator:gaeb147d6336141e24dc34e919d604f8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669fd98ae5d873f04de48c9287e829fe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga669fd98ae5d873f04de48c9287e829fe">UARTSpaceAvail</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga669fd98ae5d873f04de48c9287e829fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API checks whether the TX FIFO (or THR in non-FIFO mode) is empty or not.  <a href="#ga669fd98ae5d873f04de48c9287e829fe">More...</a><br /></td></tr>
<tr class="separator:ga669fd98ae5d873f04de48c9287e829fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6c6bf463b24a0a1dc751f6efc34eda"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga8a6c6bf463b24a0a1dc751f6efc34eda">UARTCharsAvail</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga8a6c6bf463b24a0a1dc751f6efc34eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API checks if the RX FIFO (or RHR in non-FIFO mode) has atleast one byte of data to be read.  <a href="#ga8a6c6bf463b24a0a1dc751f6efc34eda">More...</a><br /></td></tr>
<tr class="separator:ga8a6c6bf463b24a0a1dc751f6efc34eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51094b8f4cd6996f6ed46d0ae1e407b6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga51094b8f4cd6996f6ed46d0ae1e407b6">UARTCharPutNonBlocking</a> (uint32_t baseAddr, uint8_t byteWrite)</td></tr>
<tr class="memdesc:ga51094b8f4cd6996f6ed46d0ae1e407b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API attempts to write a byte into Transmitter Holding Register (THR). It checks only once if the transmitter is empty.  <a href="#ga51094b8f4cd6996f6ed46d0ae1e407b6">More...</a><br /></td></tr>
<tr class="separator:ga51094b8f4cd6996f6ed46d0ae1e407b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf18eb8c68b6ca3bcab5ab55efc0a5132"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaf18eb8c68b6ca3bcab5ab55efc0a5132">UARTCharGetNonBlocking</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaf18eb8c68b6ca3bcab5ab55efc0a5132"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads a byte from the Receiver Buffer Register (RBR). It checks once if any character is ready to be read.  <a href="#gaf18eb8c68b6ca3bcab5ab55efc0a5132">More...</a><br /></td></tr>
<tr class="separator:gaf18eb8c68b6ca3bcab5ab55efc0a5132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c4911e4c316c71130b5530848dfdc4"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga07c4911e4c316c71130b5530848dfdc4">UARTCharGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga07c4911e4c316c71130b5530848dfdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API waits indefinitely for the arrival of a byte in the receiver FIFO. Once a byte has arrived, it returns that byte.  <a href="#ga07c4911e4c316c71130b5530848dfdc4">More...</a><br /></td></tr>
<tr class="separator:ga07c4911e4c316c71130b5530848dfdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4320994020807deb6f1a2982ea0a961"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaa4320994020807deb6f1a2982ea0a961">UARTCharGetTimeout</a> (uint32_t baseAddr, uint32_t timeOutVal)</td></tr>
<tr class="memdesc:gaa4320994020807deb6f1a2982ea0a961"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API waits for the arrival of atleast one byte into the Receiver FIFO or until a specified timeout value gets decremented to zero, whichever happens first.  <a href="#gaa4320994020807deb6f1a2982ea0a961">More...</a><br /></td></tr>
<tr class="separator:gaa4320994020807deb6f1a2982ea0a961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b5fde86a308a4626f7dfe4f3349ee44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga0b5fde86a308a4626f7dfe4f3349ee44">UARTCharPut</a> (uint32_t baseAddr, uint8_t byteTx)</td></tr>
<tr class="memdesc:ga0b5fde86a308a4626f7dfe4f3349ee44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API waits indefinitely until the Transmitter FIFO (THR register in non-FIFO mode) and Transmitter Shift Register are empty. On empty, it writes a byte to the THR.  <a href="#ga0b5fde86a308a4626f7dfe4f3349ee44">More...</a><br /></td></tr>
<tr class="separator:ga0b5fde86a308a4626f7dfe4f3349ee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc185467be94c861bef1024d59592e02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gacc185467be94c861bef1024d59592e02">UARTFIFOCharPut</a> (uint32_t baseAddr, uint8_t byteTx)</td></tr>
<tr class="memdesc:gacc185467be94c861bef1024d59592e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API writes a byte to the Transmitter FIFO without checking for the emptiness of the Transmitter FIFO or the Transmitter Shift Register(TSR).  <a href="#gacc185467be94c861bef1024d59592e02">More...</a><br /></td></tr>
<tr class="separator:gacc185467be94c861bef1024d59592e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6489885d9bd255ec04e249ff13fe738"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaa6489885d9bd255ec04e249ff13fe738">UARTFIFOCharGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaa6489885d9bd255ec04e249ff13fe738"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the data present at the top of the RX FIFO, that is, the data in the Receive Holding Register(RHR). However before reading the data from RHR, it does not check whether RHR has fresh data or not.  <a href="#gaa6489885d9bd255ec04e249ff13fe738">More...</a><br /></td></tr>
<tr class="separator:gaa6489885d9bd255ec04e249ff13fe738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f1febfc148074b65774ba64cc952c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga33f1febfc148074b65774ba64cc952c5">UARTFIFOWrite</a> (uint32_t baseAddr, const uint8_t *pBuffer, uint32_t numTxBytes)</td></tr>
<tr class="memdesc:ga33f1febfc148074b65774ba64cc952c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API copies the requested amount of data from the pointed data block to the UART Transmit FIFO.  <a href="#ga33f1febfc148074b65774ba64cc952c5">More...</a><br /></td></tr>
<tr class="separator:ga33f1febfc148074b65774ba64cc952c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e8788b4c79a7f9d56b2338a8b8c3863"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga8e8788b4c79a7f9d56b2338a8b8c3863">UARTRxErrorGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga8e8788b4c79a7f9d56b2338a8b8c3863"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the receiver data error status.  <a href="#ga8e8788b4c79a7f9d56b2338a8b8c3863">More...</a><br /></td></tr>
<tr class="separator:ga8e8788b4c79a7f9d56b2338a8b8c3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ffe20c7705cac72f752a04b2676bb01"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga8ffe20c7705cac72f752a04b2676bb01">UARTIntIdentityGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga8ffe20c7705cac72f752a04b2676bb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the UART Interrupt Status.  <a href="#ga8ffe20c7705cac72f752a04b2676bb01">More...</a><br /></td></tr>
<tr class="separator:ga8ffe20c7705cac72f752a04b2676bb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd54d7be20d59800e99f36c41c4e4a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gafbd54d7be20d59800e99f36c41c4e4a9">UARTIntPendingStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gafbd54d7be20d59800e99f36c41c4e4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines whether any UART interrupt condition is still alive and is pending to be serviced.  <a href="#gafbd54d7be20d59800e99f36c41c4e4a9">More...</a><br /></td></tr>
<tr class="separator:gafbd54d7be20d59800e99f36c41c4e4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a38f5622f0f0f5b67e09755c62e9458"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga3a38f5622f0f0f5b67e09755c62e9458">UARTInt2StatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga3a38f5622f0f0f5b67e09755c62e9458"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the UART Interrupt Status 2.  <a href="#ga3a38f5622f0f0f5b67e09755c62e9458">More...</a><br /></td></tr>
<tr class="separator:ga3a38f5622f0f0f5b67e09755c62e9458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35eb7ec25a2fbb687573bdb11917b55a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga35eb7ec25a2fbb687573bdb11917b55a">UARTFIFOEnableStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga35eb7ec25a2fbb687573bdb11917b55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines whether FIFO mode of operation is enabled for the UART instance or not.  <a href="#ga35eb7ec25a2fbb687573bdb11917b55a">More...</a><br /></td></tr>
<tr class="separator:ga35eb7ec25a2fbb687573bdb11917b55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405f46713f53bda3a934414a3d70fe28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga405f46713f53bda3a934414a3d70fe28">UARTAutoRTSAutoCTSControl</a> (uint32_t baseAddr, uint32_t autoCtsControl, uint32_t autoRtsControl)</td></tr>
<tr class="memdesc:ga405f46713f53bda3a934414a3d70fe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls the use of Auto-RTS and Auto-CTS features which are used in Hardware Flow Control Mode of operation. The Auto-RTS and Auto-CTS functions can be individually enabled or disabled.  <a href="#ga405f46713f53bda3a934414a3d70fe28">More...</a><br /></td></tr>
<tr class="separator:ga405f46713f53bda3a934414a3d70fe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff7d75c1f3b2e91716ea127fbd379b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaaff7d75c1f3b2e91716ea127fbd379b4">UARTSpecialCharDetectControl</a> (uint32_t baseAddr, uint32_t controlFlag)</td></tr>
<tr class="memdesc:gaaff7d75c1f3b2e91716ea127fbd379b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls the feature of detecting a Special Character arriving in the receiver.  <a href="#gaaff7d75c1f3b2e91716ea127fbd379b4">More...</a><br /></td></tr>
<tr class="separator:gaaff7d75c1f3b2e91716ea127fbd379b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d1644a292f5299f336b07cab006f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga84d1644a292f5299f336b07cab006f96">UARTSoftwareFlowCtrlOptSet</a> (uint32_t baseAddr, uint32_t swFlowCtrl)</td></tr>
<tr class="memdesc:ga84d1644a292f5299f336b07cab006f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the options for Software Flow Control.  <a href="#ga84d1644a292f5299f336b07cab006f96">More...</a><br /></td></tr>
<tr class="separator:ga84d1644a292f5299f336b07cab006f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561f7fe73110c83b8f1e57110e0a4da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga561f7fe73110c83b8f1e57110e0a4da4">UARTPulseShapingControl</a> (uint32_t baseAddr, uint32_t shapeControl)</td></tr>
<tr class="memdesc:ga561f7fe73110c83b8f1e57110e0a4da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used only in UART mode, this API is used to control the pulse shaping feature. Pulse shaping feature could either be enabled or disabled in UART mode.  <a href="#ga561f7fe73110c83b8f1e57110e0a4da4">More...</a><br /></td></tr>
<tr class="separator:ga561f7fe73110c83b8f1e57110e0a4da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a547294b77bb3ddfc3e55ce57d517cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga1a547294b77bb3ddfc3e55ce57d517cf">UARTModuleReset</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga1a547294b77bb3ddfc3e55ce57d517cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API performs a module reset of the UART instance. It also waits until the reset process is complete.  <a href="#ga1a547294b77bb3ddfc3e55ce57d517cf">More...</a><br /></td></tr>
<tr class="separator:ga1a547294b77bb3ddfc3e55ce57d517cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e9c2629f790909103ace69dac5a6a48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga6e9c2629f790909103ace69dac5a6a48">UARTIdleModeConfigure</a> (uint32_t baseAddr, uint32_t modeFlag)</td></tr>
<tr class="memdesc:ga6e9c2629f790909103ace69dac5a6a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API can be used to control the Power Management request/acknowledgement process.  <a href="#ga6e9c2629f790909103ace69dac5a6a48">More...</a><br /></td></tr>
<tr class="separator:ga6e9c2629f790909103ace69dac5a6a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4f7704b508475a36144ed595bcc1c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga8d4f7704b508475a36144ed595bcc1c8">UARTWakeUpControl</a> (uint32_t baseAddr, uint32_t controlFlag)</td></tr>
<tr class="memdesc:ga8d4f7704b508475a36144ed595bcc1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to control(enable/disable) the Wake-Up feature of the UART.  <a href="#ga8d4f7704b508475a36144ed595bcc1c8">More...</a><br /></td></tr>
<tr class="separator:ga8d4f7704b508475a36144ed595bcc1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga440eaaceba1a21305d0f031ce5c3ca4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga440eaaceba1a21305d0f031ce5c3ca4c">UARTAutoIdleModeControl</a> (uint32_t baseAddr, uint32_t modeFlag)</td></tr>
<tr class="memdesc:ga440eaaceba1a21305d0f031ce5c3ca4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to control(enable/disable) the Auto-Idle mode of operation of the UART.  <a href="#ga440eaaceba1a21305d0f031ce5c3ca4c">More...</a><br /></td></tr>
<tr class="separator:ga440eaaceba1a21305d0f031ce5c3ca4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033e6a93243bec9f3b6b978ff968510c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga033e6a93243bec9f3b6b978ff968510c">UARTFlowCtrlTrigLvlConfig</a> (uint32_t baseAddr, uint32_t rtsHaltFlag, uint32_t rtsStartFlag)</td></tr>
<tr class="memdesc:ga033e6a93243bec9f3b6b978ff968510c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the Receiver FIFO threshold level to start/stop transmission during Hardware Flow Control.  <a href="#ga033e6a93243bec9f3b6b978ff968510c">More...</a><br /></td></tr>
<tr class="separator:ga033e6a93243bec9f3b6b978ff968510c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81156b31b6cd21d88a58e9af38cec993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga81156b31b6cd21d88a58e9af38cec993">UARTXON1XOFF1ValProgram</a> (uint32_t baseAddr, uint8_t xon1Value, uint8_t xoff1Value)</td></tr>
<tr class="memdesc:ga81156b31b6cd21d88a58e9af38cec993"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API programs the XON1/ADDR1 and XOFF1 registers.  <a href="#ga81156b31b6cd21d88a58e9af38cec993">More...</a><br /></td></tr>
<tr class="separator:ga81156b31b6cd21d88a58e9af38cec993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6634a6de9dd264c75c1109dd010d8068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga6634a6de9dd264c75c1109dd010d8068">UARTXON2XOFF2ValProgram</a> (uint32_t baseAddr, uint8_t xon2Value, uint8_t xoff2Value)</td></tr>
<tr class="memdesc:ga6634a6de9dd264c75c1109dd010d8068"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API programs the XON2/ADDR2 and XOFF2 registers.  <a href="#ga6634a6de9dd264c75c1109dd010d8068">More...</a><br /></td></tr>
<tr class="separator:ga6634a6de9dd264c75c1109dd010d8068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf8a4caebd7b63e7d34817b7a1e87fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gadf8a4caebd7b63e7d34817b7a1e87fe6">UARTXONAnyFeatureControl</a> (uint32_t baseAddr, uint32_t controlFlag)</td></tr>
<tr class="memdesc:gadf8a4caebd7b63e7d34817b7a1e87fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls(enables/disables) the XON-any feature in Modem Control Register(MCR).  <a href="#gadf8a4caebd7b63e7d34817b7a1e87fe6">More...</a><br /></td></tr>
<tr class="separator:gadf8a4caebd7b63e7d34817b7a1e87fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ff14bb997f3f31a451adb27fcdb4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga08ff14bb997f3f31a451adb27fcdb4d3">UARTLoopbackModeControl</a> (uint32_t baseAddr, uint32_t controlFlag)</td></tr>
<tr class="memdesc:ga08ff14bb997f3f31a451adb27fcdb4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls(enables/disables) the Loopback mode of operation for the UART instance.  <a href="#ga08ff14bb997f3f31a451adb27fcdb4d3">More...</a><br /></td></tr>
<tr class="separator:ga08ff14bb997f3f31a451adb27fcdb4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0101ffe0cd88ba1694c0e5132e3b677c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga0101ffe0cd88ba1694c0e5132e3b677c">UARTModemControlSet</a> (uint32_t baseAddr, uint32_t modeFlag)</td></tr>
<tr class="memdesc:ga0101ffe0cd88ba1694c0e5132e3b677c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API switches the specified Modem Control Signals to active state. The Modem Control signals in context are DCD, RI, RTS and DTR.  <a href="#ga0101ffe0cd88ba1694c0e5132e3b677c">More...</a><br /></td></tr>
<tr class="separator:ga0101ffe0cd88ba1694c0e5132e3b677c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee54c805927f674f01e50326d18d5c7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaee54c805927f674f01e50326d18d5c7b">UARTModemControlClear</a> (uint32_t baseAddr, uint32_t modeFlag)</td></tr>
<tr class="memdesc:gaee54c805927f674f01e50326d18d5c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API switches the specified Modem Control signals to inactive state. The Modem Control signals in context are DCD, RI, RTS and DTR.  <a href="#gaee54c805927f674f01e50326d18d5c7b">More...</a><br /></td></tr>
<tr class="separator:gaee54c805927f674f01e50326d18d5c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga178f89605f0d59b41bd62e9c632052fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga178f89605f0d59b41bd62e9c632052fd">UARTModemStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga178f89605f0d59b41bd62e9c632052fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the values on Modem Signal Lines. The Modem Signals in context are: 1&gt; Data Carrier Detect(DCD)<br />
 2&gt; Ring Indicator(RI)<br />
 3&gt; Data Set Ready(DSR)<br />
 4&gt; Clear To Send(CTS)<br />
.  <a href="#ga178f89605f0d59b41bd62e9c632052fd">More...</a><br /></td></tr>
<tr class="separator:ga178f89605f0d59b41bd62e9c632052fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5450538e2953fbfb766f534f41672ad8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga5450538e2953fbfb766f534f41672ad8">UARTModemStatusChangeCheck</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga5450538e2953fbfb766f534f41672ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines if the values on Modem Signal Lines have changed since the last read of Modem Status Register(MSR). The Modem Signals in context are DCD, RI, DSR, CTS.  <a href="#ga5450538e2953fbfb766f534f41672ad8">More...</a><br /></td></tr>
<tr class="separator:ga5450538e2953fbfb766f534f41672ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb71792e8b1185f83e1858a938980eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gacbb71792e8b1185f83e1858a938980eb">UARTResumeOperation</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gacbb71792e8b1185f83e1858a938980eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the RESUME register which clears the internal flags.  <a href="#gacbb71792e8b1185f83e1858a938980eb">More...</a><br /></td></tr>
<tr class="separator:gacbb71792e8b1185f83e1858a938980eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad79e79a94033753b1414ddd08cfa8cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gad79e79a94033753b1414ddd08cfa8cf6">UARTWakeUpEventsEnable</a> (uint32_t baseAddr, uint32_t wakeUpFlag)</td></tr>
<tr class="memdesc:gad79e79a94033753b1414ddd08cfa8cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the Wake-Up capability for the specified events. On enabling Wake-Up capability for them, the occurence of the corresponding event shall wake up the system.  <a href="#gad79e79a94033753b1414ddd08cfa8cf6">More...</a><br /></td></tr>
<tr class="separator:gad79e79a94033753b1414ddd08cfa8cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c59236b00585fe48fef822b48ae2a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga9c59236b00585fe48fef822b48ae2a77">UARTWakeUpEventsDisable</a> (uint32_t baseAddr, uint32_t wakeUpFlag)</td></tr>
<tr class="memdesc:ga9c59236b00585fe48fef822b48ae2a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the Wake-Up capability for the specified events. On disabling Wake-Up capability for them, the occurence of the corresponding event shall not wake up the system.  <a href="#ga9c59236b00585fe48fef822b48ae2a77">More...</a><br /></td></tr>
<tr class="separator:ga9c59236b00585fe48fef822b48ae2a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1b299eeb07448b9dcc25d0d355f835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga5d1b299eeb07448b9dcc25d0d355f835">UARTFIFOTrigLvlGranControl</a> (uint32_t baseAddr, uint32_t rxFIFOGranCtrl, uint32_t txFIFOGranCtrl)</td></tr>
<tr class="memdesc:ga5d1b299eeb07448b9dcc25d0d355f835"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls the feature of setting the Trigger Level granularity as 1 for Transmitter and Receiver FIFOs.  <a href="#ga5d1b299eeb07448b9dcc25d0d355f835">More...</a><br /></td></tr>
<tr class="separator:ga5d1b299eeb07448b9dcc25d0d355f835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c903873332779effaabcf64d188673c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga4c903873332779effaabcf64d188673c">UARTDSRInterruptControl</a> (uint32_t baseAddr, uint32_t controlFlag)</td></tr>
<tr class="memdesc:ga4c903873332779effaabcf64d188673c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls the interrupt enable and disable feature for Data Set Ready(DSRn) interrupt.  <a href="#ga4c903873332779effaabcf64d188673c">More...</a><br /></td></tr>
<tr class="separator:ga4c903873332779effaabcf64d188673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f22914d9b985081a37b04c6429fdfa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga4f22914d9b985081a37b04c6429fdfa0">UARTTxEmptyIntControl</a> (uint32_t baseAddr, uint32_t controlFlag)</td></tr>
<tr class="memdesc:ga4f22914d9b985081a37b04c6429fdfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to choose a condition under which a Transmit Holding Register(THR) Interrupt should occur. A THR interrupt can be configured to occur either when:<br />
 1&gt; TX FIFO becoming empty OR<br />
 2&gt; TX FIFO and TX Shift register becoming empty.  <a href="#ga4f22914d9b985081a37b04c6429fdfa0">More...</a><br /></td></tr>
<tr class="separator:ga4f22914d9b985081a37b04c6429fdfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990644cfc774c0fb962d035994d8d0a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga990644cfc774c0fb962d035994d8d0a7">UARTRXCTSDSRWakeUpConfigure</a> (uint32_t baseAddr, uint32_t wakeUpFlag)</td></tr>
<tr class="memdesc:ga990644cfc774c0fb962d035994d8d0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls (enables/disables) a feature where a falling edge on the RX, CTSn or DSRs could send a wake-up interrupt to the CPU.  <a href="#ga990644cfc774c0fb962d035994d8d0a7">More...</a><br /></td></tr>
<tr class="separator:ga990644cfc774c0fb962d035994d8d0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd691b151d8647c8ac3ee2f32443bb2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaccd691b151d8647c8ac3ee2f32443bb2">UARTRXCTSDSRTransitionStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaccd691b151d8647c8ac3ee2f32443bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines whether a falling edge occured on RX, CTSn or DSRn lines.  <a href="#gaccd691b151d8647c8ac3ee2f32443bb2">More...</a><br /></td></tr>
<tr class="separator:gaccd691b151d8647c8ac3ee2f32443bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07427f0abc20a37cf64ef1e68f67796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gae07427f0abc20a37cf64ef1e68f67796">UARTDMACounterResetControl</a> (uint32_t baseAddr, uint32_t controlFlag)</td></tr>
<tr class="memdesc:gae07427f0abc20a37cf64ef1e68f67796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls the DMA Counter Reset options.  <a href="#gae07427f0abc20a37cf64ef1e68f67796">More...</a><br /></td></tr>
<tr class="separator:gae07427f0abc20a37cf64ef1e68f67796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6a8b466ba0dcc623dbbb81e94b5b06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaaf6a8b466ba0dcc623dbbb81e94b5b06">UARTTxFIFOFullStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaaf6a8b466ba0dcc623dbbb81e94b5b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines whether the Transmitter FIFO is full or not.  <a href="#gaaf6a8b466ba0dcc623dbbb81e94b5b06">More...</a><br /></td></tr>
<tr class="separator:gaaf6a8b466ba0dcc623dbbb81e94b5b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29a6269235ceb56e4e9db6c9ae1a9d2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gad29a6269235ceb56e4e9db6c9ae1a9d2">UARTTxFIFOLevelGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gad29a6269235ceb56e4e9db6c9ae1a9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the current level of the Transmitter FIFO.  <a href="#gad29a6269235ceb56e4e9db6c9ae1a9d2">More...</a><br /></td></tr>
<tr class="separator:gad29a6269235ceb56e4e9db6c9ae1a9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78b9ffaadf65cb23b2f59bd62cb764ae"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga78b9ffaadf65cb23b2f59bd62cb764ae">UARTRxFIFOLevelGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga78b9ffaadf65cb23b2f59bd62cb764ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the current level of the Receiver FIFO.  <a href="#ga78b9ffaadf65cb23b2f59bd62cb764ae">More...</a><br /></td></tr>
<tr class="separator:ga78b9ffaadf65cb23b2f59bd62cb764ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ff1b9206a4856d4d5eae334472611f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaf2ff1b9206a4856d4d5eae334472611f">UARTAutobaudParityGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaf2ff1b9206a4856d4d5eae334472611f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the Parity mode being configured by the system in the UART Autobauding mode.  <a href="#gaf2ff1b9206a4856d4d5eae334472611f">More...</a><br /></td></tr>
<tr class="separator:gaf2ff1b9206a4856d4d5eae334472611f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad550807c845da9a6a15f4e2bbe8c8d14"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gad550807c845da9a6a15f4e2bbe8c8d14">UARTAutobaudWordLenGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gad550807c845da9a6a15f4e2bbe8c8d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the word length per frame(character length) being configured by the system in UART Autobauding mode.  <a href="#gad550807c845da9a6a15f4e2bbe8c8d14">More...</a><br /></td></tr>
<tr class="separator:gad550807c845da9a6a15f4e2bbe8c8d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace506d6e5013fbbce6647942d67b19a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gace506d6e5013fbbce6647942d67b19a3">UARTAutobaudSpeedGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gace506d6e5013fbbce6647942d67b19a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API determines the baud rate being configured by the system in UART Autobauding mode.  <a href="#gace506d6e5013fbbce6647942d67b19a3">More...</a><br /></td></tr>
<tr class="separator:gace506d6e5013fbbce6647942d67b19a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ab7d4028d687fdc53ed2698b9a1a86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga09ab7d4028d687fdc53ed2698b9a1a86">UARTScratchPadRegWrite</a> (uint32_t baseAddr, uint32_t scratchValue)</td></tr>
<tr class="memdesc:ga09ab7d4028d687fdc53ed2698b9a1a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API programs the Scratchpad Register with the specified value.  <a href="#ga09ab7d4028d687fdc53ed2698b9a1a86">More...</a><br /></td></tr>
<tr class="separator:ga09ab7d4028d687fdc53ed2698b9a1a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8299261a242e55ad452bf89826e24d93"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga8299261a242e55ad452bf89826e24d93">UARTScratchPadRegRead</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga8299261a242e55ad452bf89826e24d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the value in Scratchpad Register.  <a href="#ga8299261a242e55ad452bf89826e24d93">More...</a><br /></td></tr>
<tr class="separator:ga8299261a242e55ad452bf89826e24d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97f634eaf2b09043c5e490f5f4ca52a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga97f634eaf2b09043c5e490f5f4ca52a9">UARTModuleVersionNumberGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga97f634eaf2b09043c5e490f5f4ca52a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the Revision Number of the module from the Module Version Register(MVR).  <a href="#ga97f634eaf2b09043c5e490f5f4ca52a9">More...</a><br /></td></tr>
<tr class="separator:ga97f634eaf2b09043c5e490f5f4ca52a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443648e452f9ce4da9208fdeb97692a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga443648e452f9ce4da9208fdeb97692a4">UARTFIFORegisterWrite</a> (uint32_t baseAddr, uint32_t fcrValue)</td></tr>
<tr class="memdesc:ga443648e452f9ce4da9208fdeb97692a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to write a specified value to the FIFO Control Register(FCR).  <a href="#ga443648e452f9ce4da9208fdeb97692a4">More...</a><br /></td></tr>
<tr class="separator:ga443648e452f9ce4da9208fdeb97692a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81860bc183410362ec4d25abe68f36a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga81860bc183410362ec4d25abe68f36a4">UARTTxDMAThresholdControl</a> (uint32_t baseAddr, uint32_t thrsCtrlFlag)</td></tr>
<tr class="memdesc:ga81860bc183410362ec4d25abe68f36a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function controls the method of setting the Transmit DMA Threshold Value. The Transmit DMA Threshold Value can be set to a default value of 64 characters or can take the value in TX_DMA_THRESHOLD register.  <a href="#ga81860bc183410362ec4d25abe68f36a4">More...</a><br /></td></tr>
<tr class="separator:ga81860bc183410362ec4d25abe68f36a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382408d0252b77ae5996d9fcff9def92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga382408d0252b77ae5996d9fcff9def92">UARTTxDMAThresholdValConfig</a> (uint32_t baseAddr, uint32_t thrsValue)</td></tr>
<tr class="memdesc:ga382408d0252b77ae5996d9fcff9def92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the TX_DMA_THRESHOLD register which holds Transmit DMA Threshold value to be used. When a TX DMA Threshold value other than 64 characters is required, this function can be used to program the same.  <a href="#ga382408d0252b77ae5996d9fcff9def92">More...</a><br /></td></tr>
<tr class="separator:ga382408d0252b77ae5996d9fcff9def92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5b097f54041cccbaea7d1d399e25cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gabf5b097f54041cccbaea7d1d399e25cd">UARTFIFOLevelSet</a> (uint32_t baseAddr, uint32_t rxLevel)</td></tr>
<tr class="memdesc:gabf5b097f54041cccbaea7d1d399e25cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the receiver FIFO trigger level.<br />
.  <a href="#gabf5b097f54041cccbaea7d1d399e25cd">More...</a><br /></td></tr>
<tr class="separator:gabf5b097f54041cccbaea7d1d399e25cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3327190e282d72745af2d94c215b6b03"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga3327190e282d72745af2d94c215b6b03">UARTModemControlGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga3327190e282d72745af2d94c215b6b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of the RTS and AFE bits in the MCR register.  <a href="#ga3327190e282d72745af2d94c215b6b03">More...</a><br /></td></tr>
<tr class="separator:ga3327190e282d72745af2d94c215b6b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236f2c7cf13e04d7831e4589f9100e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga236f2c7cf13e04d7831e4589f9100e79">UARTFIFOCtrlRegWrite</a> (uint32_t baseAddr, uint32_t fcrValue)</td></tr>
<tr class="memdesc:ga236f2c7cf13e04d7831e4589f9100e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to write a specified value to the FIFO Control Register(FCR) without disabling the divisor values. Preferable setting FCR during runtime.  <a href="#ga236f2c7cf13e04d7831e4589f9100e79">More...</a><br /></td></tr>
<tr class="separator:ga236f2c7cf13e04d7831e4589f9100e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764bb955fbab05d449e615e3b0a275c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga764bb955fbab05d449e615e3b0a275c0">UARTModemControlReset</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga764bb955fbab05d449e615e3b0a275c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API resets the Modem control register.  <a href="#ga764bb955fbab05d449e615e3b0a275c0">More...</a><br /></td></tr>
<tr class="separator:ga764bb955fbab05d449e615e3b0a275c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f7ea9dbead60774537985e69a9c391"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga33f7ea9dbead60774537985e69a9c391">UARTReadStatus</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga33f7ea9dbead60774537985e69a9c391"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the line status register value.  <a href="#ga33f7ea9dbead60774537985e69a9c391">More...</a><br /></td></tr>
<tr class="separator:ga33f7ea9dbead60774537985e69a9c391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744770c35a232538cfdc701169ec8c7f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga744770c35a232538cfdc701169ec8c7f">UARTIsTransmitterEmpty</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga744770c35a232538cfdc701169ec8c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the transmitter empty status i.e. if Transmitter FIFO (THR register in non-FIFO mode) and Transmitter Shift Register are empty.  <a href="#ga744770c35a232538cfdc701169ec8c7f">More...</a><br /></td></tr>
<tr class="separator:ga744770c35a232538cfdc701169ec8c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b34796324a485d5e7113f79bb30382"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga66b34796324a485d5e7113f79bb30382">UARTCharGetNonBlocking2</a> (uint32_t baseAddr, uint8_t *pChar)</td></tr>
<tr class="memdesc:ga66b34796324a485d5e7113f79bb30382"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads a byte from the Receiver Buffer Register (RBR). It checks once if any character is ready to be read.  <a href="#ga66b34796324a485d5e7113f79bb30382">More...</a><br /></td></tr>
<tr class="separator:ga66b34796324a485d5e7113f79bb30382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fed615d3dd19cbccb91847e62532ff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga94fed615d3dd19cbccb91847e62532ff">UARTCharGetTimeout2</a> (uint32_t baseAddr, uint32_t timeOutVal, uint8_t *pChar)</td></tr>
<tr class="memdesc:ga94fed615d3dd19cbccb91847e62532ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API waits for the arrival of atleast one byte into the Receiver FIFO or until a specified timeout value gets decremented to zero, whichever happens first.This is a replacement for the UARTCharGetTimeout which will incorrectly return timeout if the UART receives 0xFF as data.  <a href="#ga94fed615d3dd19cbccb91847e62532ff">More...</a><br /></td></tr>
<tr class="separator:ga94fed615d3dd19cbccb91847e62532ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
The size of the Transmitter FIFO.</h2></td></tr>
<tr class="memitem:ga88540454f43c07e91701dd077089dcfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga88540454f43c07e91701dd077089dcfe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TX_FIFO_SIZE</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="separator:ga88540454f43c07e91701dd077089dcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
The size of the Receiver FIFO.</h2></td></tr>
<tr class="memitem:ga2ed3de709f08b7f5a44048c990cdaaa8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ed3de709f08b7f5a44048c990cdaaa8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RX_FIFO_SIZE</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="separator:ga2ed3de709f08b7f5a44048c990cdaaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values to configure the Operating modes of UART.</h2></td></tr>
<tr class="memitem:ga0782e58e0f0e73de80a0b5e53d89f493"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0782e58e0f0e73de80a0b5e53d89f493"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART16x_OPER_MODE</b>&#160;&#160;&#160;(UART_MDR1_MODE_SELECT_UART16X)</td></tr>
<tr class="separator:ga0782e58e0f0e73de80a0b5e53d89f493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14c7c0a2c4f555995fefae69cc1ec7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac14c7c0a2c4f555995fefae69cc1ec7b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_SIR_OPER_MODE</b>&#160;&#160;&#160;(UART_MDR1_MODE_SELECT_SIR)</td></tr>
<tr class="separator:gac14c7c0a2c4f555995fefae69cc1ec7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0115f2021f6a63aaf30c19dec88e9e9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0115f2021f6a63aaf30c19dec88e9e9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART16x_AUTO_BAUD_OPER_MODE</b>&#160;&#160;&#160;(UART_MDR1_MODE_SELECT_UART16XAUTO)</td></tr>
<tr class="separator:ga0115f2021f6a63aaf30c19dec88e9e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a893d24778c987e0fcfc51b6ba7c57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0a893d24778c987e0fcfc51b6ba7c57"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART13x_OPER_MODE</b>&#160;&#160;&#160;(UART_MDR1_MODE_SELECT_UART13X)</td></tr>
<tr class="separator:gaa0a893d24778c987e0fcfc51b6ba7c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8114b13d4689e9e3634c64ecc8647b73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8114b13d4689e9e3634c64ecc8647b73"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MIR_OPER_MODE</b>&#160;&#160;&#160;(UART_MDR1_MODE_SELECT_MIR)</td></tr>
<tr class="separator:ga8114b13d4689e9e3634c64ecc8647b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4325b175597c949dc791a7512c09295"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4325b175597c949dc791a7512c09295"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIR_OPER_MODE</b>&#160;&#160;&#160;(UART_MDR1_MODE_SELECT_FIR)</td></tr>
<tr class="separator:gaf4325b175597c949dc791a7512c09295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ac380822993873420b56057a089fc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga46ac380822993873420b56057a089fc0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_CIR_OPER_MODE</b>&#160;&#160;&#160;(UART_MDR1_MODE_SELECT_CIR)</td></tr>
<tr class="separator:ga46ac380822993873420b56057a089fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7cf8db5e234d923633e09d625b2d94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5d7cf8db5e234d923633e09d625b2d94"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DISABLED_MODE</b>&#160;&#160;&#160;(UART_MDR1_MODE_SELECT_MASK)</td></tr>
<tr class="separator:ga5d7cf8db5e234d923633e09d625b2d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values to control the Line characteristics.</h2></td></tr>
<tr class="memitem:gaa59b7ccc9af4d923fa7406eddf76eed3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaa59b7ccc9af4d923fa7406eddf76eed3">UART_BREAK_COND_DISABLE</a></td></tr>
<tr class="separator:gaa59b7ccc9af4d923fa7406eddf76eed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb80988cf1045495b792131ab0d15385"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb80988cf1045495b792131ab0d15385"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_BREAK_COND_ENABLE</b></td></tr>
<tr class="separator:gaeb80988cf1045495b792131ab0d15385"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values to control parity feature.</h2></td></tr>
<tr class="memitem:ga8fde3d1b15170b50661be687e02e0239"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8fde3d1b15170b50661be687e02e0239"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_PARITY_REPR_1</b></td></tr>
<tr class="separator:ga8fde3d1b15170b50661be687e02e0239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16bf11faf1862d9a08f7eab1a103a68d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga16bf11faf1862d9a08f7eab1a103a68d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_PARITY_REPR_0</b></td></tr>
<tr class="separator:ga16bf11faf1862d9a08f7eab1a103a68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2599f3938b5ad4fbf3ee15a472124c38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2599f3938b5ad4fbf3ee15a472124c38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_ODD_PARITY</b></td></tr>
<tr class="separator:ga2599f3938b5ad4fbf3ee15a472124c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd5c6a113a40e90661f81b9fe53e6f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaffd5c6a113a40e90661f81b9fe53e6f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_EVEN_PARITY</b></td></tr>
<tr class="separator:gaffd5c6a113a40e90661f81b9fe53e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270dea6e1a92dd83fe58802450bdd60c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga270dea6e1a92dd83fe58802450bdd60c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_PARITY_NONE</b></td></tr>
<tr class="separator:ga270dea6e1a92dd83fe58802450bdd60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab90abaa86319f3cbaf4eba1c6697b3a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab90abaa86319f3cbaf4eba1c6697b3a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gab90abaa86319f3cbaf4eba1c6697b3a7">UART_FRAME_NUM_STB_1</a></td></tr>
<tr class="memdesc:gab90abaa86319f3cbaf4eba1c6697b3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Stop Bits per frame. <br /></td></tr>
<tr class="separator:gab90abaa86319f3cbaf4eba1c6697b3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeea8611e5c1e4913f407e3233e0de66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadeea8611e5c1e4913f407e3233e0de66"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FRAME_NUM_STB_1_5_2</b></td></tr>
<tr class="separator:gadeea8611e5c1e4913f407e3233e0de66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973cbe73978ee354e72b60997af3dc58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga973cbe73978ee354e72b60997af3dc58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga973cbe73978ee354e72b60997af3dc58">UART_FRAME_WORD_LENGTH_5</a></td></tr>
<tr class="memdesc:ga973cbe73978ee354e72b60997af3dc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word Length per frame. <br /></td></tr>
<tr class="separator:ga973cbe73978ee354e72b60997af3dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d9085dcf360d9fcccab05ad911a83b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66d9085dcf360d9fcccab05ad911a83b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FRAME_WORD_LENGTH_6</b></td></tr>
<tr class="separator:ga66d9085dcf360d9fcccab05ad911a83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga993d09bbdccd9ca010a85dacce945e69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga993d09bbdccd9ca010a85dacce945e69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FRAME_WORD_LENGTH_7</b></td></tr>
<tr class="separator:ga993d09bbdccd9ca010a85dacce945e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa91c5f0d5928c06d6e1c311257eae30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa91c5f0d5928c06d6e1c311257eae30"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FRAME_WORD_LENGTH_8</b></td></tr>
<tr class="separator:gafa91c5f0d5928c06d6e1c311257eae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values associated with setting the Trigger Levels and DMA mode</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3b2d76f31899a43f578ebf8fde5e9ce3"></a> selection. </p>
</td></tr>
<tr class="memitem:gac223dd5db451ca62493cb822c7f42baa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac223dd5db451ca62493cb822c7f42baa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gac223dd5db451ca62493cb822c7f42baa">UART_FCR_RX_TRIG_LVL_8</a></td></tr>
<tr class="memdesc:gac223dd5db451ca62493cb822c7f42baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for trigger level for the Receiver FIFO. <br /></td></tr>
<tr class="separator:gac223dd5db451ca62493cb822c7f42baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc2275a812ca2eb52ed9c4a1bd9904d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6fc2275a812ca2eb52ed9c4a1bd9904d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_RX_TRIG_LVL_16</b></td></tr>
<tr class="separator:ga6fc2275a812ca2eb52ed9c4a1bd9904d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c175ce5214e6d1038afe6154259a6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0c175ce5214e6d1038afe6154259a6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_RX_TRIG_LVL_56</b></td></tr>
<tr class="separator:gaa0c175ce5214e6d1038afe6154259a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38af8bc22938f4e787d2f1359eefbc14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38af8bc22938f4e787d2f1359eefbc14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_RX_TRIG_LVL_60</b></td></tr>
<tr class="separator:ga38af8bc22938f4e787d2f1359eefbc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab45910719564f36568b912f03b0a6ce6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab45910719564f36568b912f03b0a6ce6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gab45910719564f36568b912f03b0a6ce6">UART_FCR_TX_TRIG_LVL_8</a></td></tr>
<tr class="memdesc:gab45910719564f36568b912f03b0a6ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for the trigger level for the Transmitter FIFO. <br /></td></tr>
<tr class="separator:gab45910719564f36568b912f03b0a6ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe86a1f2c604e0ddcc4bd843b4d17eaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe86a1f2c604e0ddcc4bd843b4d17eaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_TX_TRIG_LVL_16</b></td></tr>
<tr class="separator:gabe86a1f2c604e0ddcc4bd843b4d17eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ea0a4076849a4119d4c548348990f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9ea0a4076849a4119d4c548348990f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_TX_TRIG_LVL_32</b></td></tr>
<tr class="separator:gae9ea0a4076849a4119d4c548348990f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9dacbf76696482b3980f2710fbe98d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c9dacbf76696482b3980f2710fbe98d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_TX_TRIG_LVL_56</b></td></tr>
<tr class="separator:ga2c9dacbf76696482b3980f2710fbe98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6adfbd68eb8a0d71bcaf09ee83b6e80b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6adfbd68eb8a0d71bcaf09ee83b6e80b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga6adfbd68eb8a0d71bcaf09ee83b6e80b">UART_DMA_MODE_0_ENABLE</a></td></tr>
<tr class="memdesc:ga6adfbd68eb8a0d71bcaf09ee83b6e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values corresponding to DMA mode selection. <br /></td></tr>
<tr class="separator:ga6adfbd68eb8a0d71bcaf09ee83b6e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7fada7f97b4d41f8d89cb869db3f1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc7fada7f97b4d41f8d89cb869db3f1b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DMA_MODE_1_ENABLE</b></td></tr>
<tr class="separator:gadc7fada7f97b4d41f8d89cb869db3f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18618cb09fe4f2a687f292c4738477a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga18618cb09fe4f2a687f292c4738477a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DMA_MODE_2_ENABLE</b></td></tr>
<tr class="separator:ga18618cb09fe4f2a687f292c4738477a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9d38509d1923b4ff22e4f468660c71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b9d38509d1923b4ff22e4f468660c71"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DMA_MODE_3_ENABLE</b></td></tr>
<tr class="separator:ga5b9d38509d1923b4ff22e4f468660c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab078212307684a5ac7f20cfb72b54cc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab078212307684a5ac7f20cfb72b54cc5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gab078212307684a5ac7f20cfb72b54cc5">UART_DMA_EN_PATH_FCR</a></td></tr>
<tr class="memdesc:gab078212307684a5ac7f20cfb72b54cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values used to choose the path for configuring the DMA Mode. DMA Mode could be configured either through FCR or SCR. <br /></td></tr>
<tr class="separator:gab078212307684a5ac7f20cfb72b54cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40729f2f67102d2fe7e2b5267be84286"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga40729f2f67102d2fe7e2b5267be84286"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DMA_EN_PATH_SCR</b></td></tr>
<tr class="separator:ga40729f2f67102d2fe7e2b5267be84286"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values related to enabling/disabling of Interrupts.</h2></td></tr>
<tr class="memitem:ga472c99c1eb574eec1fc60231358939b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga472c99c1eb574eec1fc60231358939b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga472c99c1eb574eec1fc60231358939b2">UART_INT_CTS</a>&#160;&#160;&#160;(UART_IER_CTS_IT_MASK)</td></tr>
<tr class="memdesc:ga472c99c1eb574eec1fc60231358939b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for enabling/disabling the interrupts of UART. <br /></td></tr>
<tr class="separator:ga472c99c1eb574eec1fc60231358939b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga352f83de58d46d6f15b4a1aad73e78b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga352f83de58d46d6f15b4a1aad73e78b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT_RTS</b>&#160;&#160;&#160;(UART_IER_RTS_IT_MASK)</td></tr>
<tr class="separator:ga352f83de58d46d6f15b4a1aad73e78b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac986824d098d5e691c3a86a5496bee20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac986824d098d5e691c3a86a5496bee20"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT_XOFF</b>&#160;&#160;&#160;(UART_IER_XOFF_IT_MASK)</td></tr>
<tr class="separator:gac986824d098d5e691c3a86a5496bee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab119335cf7cbda7f5849b243d9383d65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab119335cf7cbda7f5849b243d9383d65"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT_SLEEPMODE</b>&#160;&#160;&#160;(UART_IER_SLEEP_MODE_MASK)</td></tr>
<tr class="separator:gab119335cf7cbda7f5849b243d9383d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f6e5c5e5831ea0ca8771f0de27d06b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad7f6e5c5e5831ea0ca8771f0de27d06b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT_MODEM_STAT</b>&#160;&#160;&#160;(UART_IER_MODEM_STS_IT_MASK)</td></tr>
<tr class="separator:gad7f6e5c5e5831ea0ca8771f0de27d06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95cbe7943d8308e39bd1dbaca4315b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf95cbe7943d8308e39bd1dbaca4315b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT_LINE_STAT</b>&#160;&#160;&#160;(UART_IER_LINE_STS_IT_MASK)</td></tr>
<tr class="separator:gaf95cbe7943d8308e39bd1dbaca4315b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac493046dab97d570a487def7c4b90133"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac493046dab97d570a487def7c4b90133"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT_THR</b>&#160;&#160;&#160;(UART_IER_THR_IT_MASK)</td></tr>
<tr class="separator:gac493046dab97d570a487def7c4b90133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c9c06aaca4d8285b809827b44a24ebc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3c9c06aaca4d8285b809827b44a24ebc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT_RHR_CTI</b>&#160;&#160;&#160;(UART_IER_RHR_IT_MASK)</td></tr>
<tr class="separator:ga3c9c06aaca4d8285b809827b44a24ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eec6209a37c37926b7e46467b9706c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9eec6209a37c37926b7e46467b9706c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT2_RX_EMPTY</b>&#160;&#160;&#160;(UART_IER2_EN_RXFIFO_EMPTY_MASK)</td></tr>
<tr class="separator:ga9eec6209a37c37926b7e46467b9706c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05387b2f1de772d266561c4f30170024"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05387b2f1de772d266561c4f30170024"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INT2_TX_EMPTY</b>&#160;&#160;&#160;(UART_IER2_EN_TXFIFO_EMPTY_MASK)</td></tr>
<tr class="separator:ga05387b2f1de772d266561c4f30170024"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values related to Line Status information.</h2></td></tr>
<tr class="memitem:ga5531dd62b683cdd5802a51a5b2875e02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5531dd62b683cdd5802a51a5b2875e02"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga5531dd62b683cdd5802a51a5b2875e02">UART_FIFO_PE_FE_BI_DETECTED</a>&#160;&#160;&#160;(UART_LSR_RX_FIFO_STS_MASK)</td></tr>
<tr class="memdesc:ga5531dd62b683cdd5802a51a5b2875e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values pertaining to UART Line Status information. <br /></td></tr>
<tr class="separator:ga5531dd62b683cdd5802a51a5b2875e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6dd2059347f86004eed9026140f23e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac6dd2059347f86004eed9026140f23e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_BREAK_DETECTED_ERROR</b>&#160;&#160;&#160;(UART_LSR_RX_BI_MASK)</td></tr>
<tr class="separator:gac6dd2059347f86004eed9026140f23e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d37ef27139eda65ba7e8da0fbf4c1cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d37ef27139eda65ba7e8da0fbf4c1cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FRAMING_ERROR</b>&#160;&#160;&#160;(UART_LSR_RX_FE_MASK)</td></tr>
<tr class="separator:ga1d37ef27139eda65ba7e8da0fbf4c1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946e3d317937e003d2057bf19e96dd1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga946e3d317937e003d2057bf19e96dd1d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_PARITY_ERROR</b>&#160;&#160;&#160;(UART_LSR_RX_PE_MASK)</td></tr>
<tr class="separator:ga946e3d317937e003d2057bf19e96dd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3183177e3613d8785d8cc8516931beb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3183177e3613d8785d8cc8516931beb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_OVERRUN_ERROR</b>&#160;&#160;&#160;(UART_LSR_RX_OE_MASK)</td></tr>
<tr class="separator:ga3183177e3613d8785d8cc8516931beb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values related to status of Interrupt souces.</h2></td></tr>
<tr class="memitem:gaab5a3ff44e6032a4a3b6455c06ad9da9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab5a3ff44e6032a4a3b6455c06ad9da9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaab5a3ff44e6032a4a3b6455c06ad9da9">UART_INTID_MODEM_STAT</a></td></tr>
<tr class="memdesc:gaab5a3ff44e6032a4a3b6455c06ad9da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values pertaining to status of UART Interrupt sources. <br /></td></tr>
<tr class="separator:gaab5a3ff44e6032a4a3b6455c06ad9da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb5a9d88a4609afc8f2ef8ac1c232d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5eb5a9d88a4609afc8f2ef8ac1c232d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INTID_TX_THRES_REACH</b></td></tr>
<tr class="separator:ga5eb5a9d88a4609afc8f2ef8ac1c232d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad192aa0fbba1cc23c4eeb5f5274a0cb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad192aa0fbba1cc23c4eeb5f5274a0cb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INTID_RX_THRES_REACH</b></td></tr>
<tr class="separator:gad192aa0fbba1cc23c4eeb5f5274a0cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9b1021cd4a4da063855ad6a0e5f78b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f9b1021cd4a4da063855ad6a0e5f78b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INTID_RX_LINE_STAT_ERROR</b></td></tr>
<tr class="separator:ga6f9b1021cd4a4da063855ad6a0e5f78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade5024077937c3e8933a400f42da11b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gade5024077937c3e8933a400f42da11b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INTID_CHAR_TIMEOUT</b></td></tr>
<tr class="separator:gade5024077937c3e8933a400f42da11b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97bad0a2bb8b9bdf81818fed6677d83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab97bad0a2bb8b9bdf81818fed6677d83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INTID_XOFF_SPEC_CHAR_DETECT</b></td></tr>
<tr class="separator:gab97bad0a2bb8b9bdf81818fed6677d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11309d06f6fc8d2528d6da05adf8780a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga11309d06f6fc8d2528d6da05adf8780a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_INTID_MODEM_SIG_STATE_CHANGE</b></td></tr>
<tr class="separator:ga11309d06f6fc8d2528d6da05adf8780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc938e06ae87a22373c6b79801df1c9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc938e06ae87a22373c6b79801df1c9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gacc938e06ae87a22373c6b79801df1c9f">UART_INT_PENDING</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gacc938e06ae87a22373c6b79801df1c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values indicating the UART Interrupt pending status. <br /></td></tr>
<tr class="separator:gacc938e06ae87a22373c6b79801df1c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b54752221f5cd871ce024fce0a75b79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b54752221f5cd871ce024fce0a75b79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_N0_INT_PENDING</b>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ga5b54752221f5cd871ce024fce0a75b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values pertaining to control of Enhanced Features.</h2></td></tr>
<tr class="memitem:ga11ec0842605ed6cfe3be76352ed397bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga11ec0842605ed6cfe3be76352ed397bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga11ec0842605ed6cfe3be76352ed397bc">UART_AUTO_CTS_ENABLE</a></td></tr>
<tr class="memdesc:ga11ec0842605ed6cfe3be76352ed397bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for controlling Auto-CTS and Auto-RTS features. <br /></td></tr>
<tr class="separator:ga11ec0842605ed6cfe3be76352ed397bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4847741a89b10bc614401271d2ca48b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab4847741a89b10bc614401271d2ca48b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTO_CTS_DISABLE</b></td></tr>
<tr class="separator:gab4847741a89b10bc614401271d2ca48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0bbda641a405acccdde2a6f4c392b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c0bbda641a405acccdde2a6f4c392b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTO_RTS_ENABLE</b></td></tr>
<tr class="separator:ga2c0bbda641a405acccdde2a6f4c392b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca48470a2e8b0ab7bb5414fc4444c6f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaca48470a2e8b0ab7bb5414fc4444c6f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTO_RTS_DISABLE</b></td></tr>
<tr class="separator:gaca48470a2e8b0ab7bb5414fc4444c6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8125b3fe1ef70c5119c3f4a465de4647"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8125b3fe1ef70c5119c3f4a465de4647"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga8125b3fe1ef70c5119c3f4a465de4647">UART_SPECIAL_CHAR_DETECT_ENABLE</a>&#160;&#160;&#160;(UART_EFR_SPECIAL_CHAR_DETECT_MASK)</td></tr>
<tr class="memdesc:ga8125b3fe1ef70c5119c3f4a465de4647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to enable/disable detection of Special Character. <br /></td></tr>
<tr class="separator:ga8125b3fe1ef70c5119c3f4a465de4647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea1a23511c597bb1feb5dbbb4ef771f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaea1a23511c597bb1feb5dbbb4ef771f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_SPECIAL_CHAR_DETECT_DISABLE</b></td></tr>
<tr class="separator:gaaea1a23511c597bb1feb5dbbb4ef771f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3d9c8c923ee3a0dd9a89a996c571d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac9d3d9c8c923ee3a0dd9a89a996c571d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gac9d3d9c8c923ee3a0dd9a89a996c571d">UART_NO_SOFTWARE_FLOW_CONTROL</a></td></tr>
<tr class="memdesc:gac9d3d9c8c923ee3a0dd9a89a996c571d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to configure the options for Software Flow Control. <br /></td></tr>
<tr class="separator:gac9d3d9c8c923ee3a0dd9a89a996c571d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69135613ebd20e242ba3e56f83941cc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69135613ebd20e242ba3e56f83941cc4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_TX_RX_XON1_XOFF1</b></td></tr>
<tr class="separator:ga69135613ebd20e242ba3e56f83941cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b409ab19686a9eba8ecea6ad48c3b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6b409ab19686a9eba8ecea6ad48c3b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_TX_RX_XON2_XOFF2</b></td></tr>
<tr class="separator:gad6b409ab19686a9eba8ecea6ad48c3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c12a3c3e74c3d046b881677c5a7ed56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9c12a3c3e74c3d046b881677c5a7ed56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_TX_RX_XON1_XOFF1_XON2_XOFF2</b></td></tr>
<tr class="separator:ga9c12a3c3e74c3d046b881677c5a7ed56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values corresponding to Mode Definition Register 2(MDR2).</h2></td></tr>
<tr class="memitem:ga519ab82567e3fce5d45d3eca787c1070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga519ab82567e3fce5d45d3eca787c1070"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga519ab82567e3fce5d45d3eca787c1070">UART_PULSE_NORMAL</a></td></tr>
<tr class="memdesc:ga519ab82567e3fce5d45d3eca787c1070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to enable/disable Pulse shaping for UART. <br /></td></tr>
<tr class="separator:ga519ab82567e3fce5d45d3eca787c1070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3300ffd49461aa398e4c839501b11ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3300ffd49461aa398e4c839501b11ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_PULSE_SHAPING</b></td></tr>
<tr class="separator:gab3300ffd49461aa398e4c839501b11ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values corresponding to Mode Definition Register 3(MDR3).</h2></td></tr>
<tr class="memitem:gaa4677c53dba2d46c0e7417164a075ea5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4677c53dba2d46c0e7417164a075ea5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaa4677c53dba2d46c0e7417164a075ea5">UART_TX_DMA_THRESHOLD_64</a></td></tr>
<tr class="memdesc:gaa4677c53dba2d46c0e7417164a075ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values used to control the method of setting the TX DMA Threshold value. <br /></td></tr>
<tr class="separator:gaa4677c53dba2d46c0e7417164a075ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d04d89769f1159dc68e75ba737571f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54d04d89769f1159dc68e75ba737571f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_TX_DMA_THRESHOLD_REG</b></td></tr>
<tr class="separator:ga54d04d89769f1159dc68e75ba737571f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Macros related to control and status of Modem Signals.</h2></td></tr>
<tr class="memitem:gaef2863c8e142b4d33b1c3cb57474bae1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaef2863c8e142b4d33b1c3cb57474bae1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaef2863c8e142b4d33b1c3cb57474bae1">UART_XON_ANY_ENABLE</a></td></tr>
<tr class="memdesc:gaef2863c8e142b4d33b1c3cb57474bae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to enable/disable XON any feature. <br /></td></tr>
<tr class="separator:gaef2863c8e142b4d33b1c3cb57474bae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83fe1f42257a227f807bdd993ffcf1ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83fe1f42257a227f807bdd993ffcf1ce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_XON_ANY_DISABLE</b></td></tr>
<tr class="separator:ga83fe1f42257a227f807bdd993ffcf1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774b626502e91959dd0820946ab014eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga774b626502e91959dd0820946ab014eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga774b626502e91959dd0820946ab014eb">UART_LOOPBACK_MODE_ENABLE</a></td></tr>
<tr class="memdesc:ga774b626502e91959dd0820946ab014eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to enable/disable Loopback mode of operation. <br /></td></tr>
<tr class="separator:ga774b626502e91959dd0820946ab014eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e2bddc559399295854f3a3e0705bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga34e2bddc559399295854f3a3e0705bfb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_LOOPBACK_MODE_DISABLE</b></td></tr>
<tr class="separator:ga34e2bddc559399295854f3a3e0705bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89d2df567a0d4382ed8610caeca38ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf89d2df567a0d4382ed8610caeca38ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaf89d2df567a0d4382ed8610caeca38ba">UART_DCD_CONTROL</a>&#160;&#160;&#160;(UART_MCR_CD_STS_CH_MASK)</td></tr>
<tr class="memdesc:gaf89d2df567a0d4382ed8610caeca38ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macros used to force the Modem Control lines to active/inactive states. <br /></td></tr>
<tr class="separator:gaf89d2df567a0d4382ed8610caeca38ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ecded7555d1afeb08963159ceb6c05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6ecded7555d1afeb08963159ceb6c05"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_RI_CONTROL</b>&#160;&#160;&#160;(UART_MCR_RI_STS_CH_MASK)</td></tr>
<tr class="separator:gab6ecded7555d1afeb08963159ceb6c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada54ade060a7de6ac08dfd224541badb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada54ade060a7de6ac08dfd224541badb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_RTS_CONTROL</b>&#160;&#160;&#160;(UART_MCR_RTS_MASK)</td></tr>
<tr class="separator:gada54ade060a7de6ac08dfd224541badb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4fb3b3cd0a516b36ae0457fdd0052df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4fb3b3cd0a516b36ae0457fdd0052df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DTR_CONTROL</b>&#160;&#160;&#160;(UART_MCR_DTR_MASK)</td></tr>
<tr class="separator:gac4fb3b3cd0a516b36ae0457fdd0052df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7e27fd84a166543dbc6a9e2a52545b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9d7e27fd84a166543dbc6a9e2a52545b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga9d7e27fd84a166543dbc6a9e2a52545b">UART_DCD_VALUE</a>&#160;&#160;&#160;(UART_MSR_NCD_STS_MASK)</td></tr>
<tr class="memdesc:ga9d7e27fd84a166543dbc6a9e2a52545b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that indicate the values on Modem Control lines. <br /></td></tr>
<tr class="separator:ga9d7e27fd84a166543dbc6a9e2a52545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2340e8dc4314064dc600e39e48b7260"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2340e8dc4314064dc600e39e48b7260"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_RI_VALUE</b>&#160;&#160;&#160;(UART_MSR_NRI_STS_MASK)</td></tr>
<tr class="separator:gac2340e8dc4314064dc600e39e48b7260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cc55322fc8ae3985c2641db03039c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab4cc55322fc8ae3985c2641db03039c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DSR_VALUE</b>&#160;&#160;&#160;(UART_MSR_NDSR_STS_MASK)</td></tr>
<tr class="separator:gab4cc55322fc8ae3985c2641db03039c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8c7a4385acba903c1a9297ce77e3f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa8c7a4385acba903c1a9297ce77e3f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_CTS_VALUE</b>&#160;&#160;&#160;(UART_MSR_NCTS_STS_MASK)</td></tr>
<tr class="separator:gafa8c7a4385acba903c1a9297ce77e3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0bd1d9d5e30d18df3eb43b5d7560fe7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac0bd1d9d5e30d18df3eb43b5d7560fe7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gac0bd1d9d5e30d18df3eb43b5d7560fe7">UART_DCD_STS_CHANGED</a>&#160;&#160;&#160;(UART_MSR_DCD_STS_MASK)</td></tr>
<tr class="memdesc:gac0bd1d9d5e30d18df3eb43b5d7560fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values used to detect the changes in Modem Control lines. <br /></td></tr>
<tr class="separator:gac0bd1d9d5e30d18df3eb43b5d7560fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69955740d57094d086f50f0dbd85e1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa69955740d57094d086f50f0dbd85e1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_RI_STS_CHANGED</b>&#160;&#160;&#160;(UART_MSR_RI_STS_MASK)</td></tr>
<tr class="separator:gaa69955740d57094d086f50f0dbd85e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9929f3b07decac3b2ad8ce3f12f40762"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9929f3b07decac3b2ad8ce3f12f40762"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DSR_STS_CHANGED</b>&#160;&#160;&#160;(UART_MSR_DSR_STS_MASK)</td></tr>
<tr class="separator:ga9929f3b07decac3b2ad8ce3f12f40762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb4345a5aced37e3c66056a15e3a63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7fcb4345a5aced37e3c66056a15e3a63"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_CTS_STS_CHANGED</b>&#160;&#160;&#160;(UART_MSR_CTS_STS_MASK)</td></tr>
<tr class="separator:ga7fcb4345a5aced37e3c66056a15e3a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values related to the control and status of Supplementary registers.</h2></td></tr>
<tr class="memitem:ga4ab029e595b4f98e049eb5a17609531e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ab029e595b4f98e049eb5a17609531e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga4ab029e595b4f98e049eb5a17609531e">UART_RX_TRIG_LVL_GRAN_1_DISABLE</a></td></tr>
<tr class="memdesc:ga4ab029e595b4f98e049eb5a17609531e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values used to enable/disable a granularity of 1 for TX and RX FIFO triggerlevels. <br /></td></tr>
<tr class="separator:ga4ab029e595b4f98e049eb5a17609531e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ab0057b2930922d10a71df49a81bce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga76ab0057b2930922d10a71df49a81bce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_RX_TRIG_LVL_GRAN_1_ENABLE</b></td></tr>
<tr class="separator:ga76ab0057b2930922d10a71df49a81bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26361966d1376db8cb33d0537116ed4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae26361966d1376db8cb33d0537116ed4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_TX_TRIG_LVL_GRAN_1_DISABLE</b></td></tr>
<tr class="separator:gae26361966d1376db8cb33d0537116ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe885aa39fe88149da10fbc2130d6bfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe885aa39fe88149da10fbc2130d6bfd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_TX_FIFO_LVL_GRAN_1_ENABLE</b></td></tr>
<tr class="separator:gafe885aa39fe88149da10fbc2130d6bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad984b57494758e954ef83728f11ceb4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad984b57494758e954ef83728f11ceb4e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gad984b57494758e954ef83728f11ceb4e">UART_DSRn_INT_DISABLE</a></td></tr>
<tr class="memdesc:gad984b57494758e954ef83728f11ceb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value used to enable/disable DSRn interrupt. <br /></td></tr>
<tr class="separator:gad984b57494758e954ef83728f11ceb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f45ac2499161cc1778427bb67289722"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f45ac2499161cc1778427bb67289722"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DSRn_INT_ENABLE</b></td></tr>
<tr class="separator:ga4f45ac2499161cc1778427bb67289722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5877bbe5ad83c6e401080afb2fcb20cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5877bbe5ad83c6e401080afb2fcb20cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga5877bbe5ad83c6e401080afb2fcb20cb">UART_RX_CTS_DSR_WAKEUP_DISABLE</a></td></tr>
<tr class="memdesc:ga5877bbe5ad83c6e401080afb2fcb20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to control the module Wake-Up rights for RX, CTSn and DSRn pins. <br /></td></tr>
<tr class="separator:ga5877bbe5ad83c6e401080afb2fcb20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c645486f0c5b96e8ec01f39b5e1ec0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0c645486f0c5b96e8ec01f39b5e1ec0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_RX_CTS_DSR_WAKEUP_ENABLE</b></td></tr>
<tr class="separator:gaa0c645486f0c5b96e8ec01f39b5e1ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa79d920d492a5edbe7d9d88eb2d41cae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa79d920d492a5edbe7d9d88eb2d41cae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaa79d920d492a5edbe7d9d88eb2d41cae">UART_THR_INT_NORMAL</a></td></tr>
<tr class="memdesc:gaa79d920d492a5edbe7d9d88eb2d41cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to control the THR interrupt modes. <br /></td></tr>
<tr class="separator:gaa79d920d492a5edbe7d9d88eb2d41cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8190688763233879b5d8752980bc75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaef8190688763233879b5d8752980bc75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_THR_INT_FIFO_TSR_EMPTY</b></td></tr>
<tr class="separator:gaef8190688763233879b5d8752980bc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5d4dabb877c0c690117b511b3b17ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a5d4dabb877c0c690117b511b3b17ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga6a5d4dabb877c0c690117b511b3b17ba">UART_DMA_CNTR_NO_RESET_FIFO_RESET</a></td></tr>
<tr class="memdesc:ga6a5d4dabb877c0c690117b511b3b17ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to control the DMA counter reset features. <br /></td></tr>
<tr class="separator:ga6a5d4dabb877c0c690117b511b3b17ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5e3ed186f6876efbc57e42cc1ba773"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabd5e3ed186f6876efbc57e42cc1ba773"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_DMA_CNTR_RESET_FIFO_RESET</b></td></tr>
<tr class="separator:gabd5e3ed186f6876efbc57e42cc1ba773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf219694c6a93ca83f85e92a8462f5975"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf219694c6a93ca83f85e92a8462f5975"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gaf219694c6a93ca83f85e92a8462f5975">UART_RX_CTS_DSR_NO_FALL_EDGE</a></td></tr>
<tr class="memdesc:gaf219694c6a93ca83f85e92a8462f5975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values indicating the Falling edge status on RX, CTSn and DSRn pins. <br /></td></tr>
<tr class="separator:gaf219694c6a93ca83f85e92a8462f5975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e8a506b6144db5b4e965ef10a3e989"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4e8a506b6144db5b4e965ef10a3e989"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_RX_CTS_DSR_FALL_EDGE</b></td></tr>
<tr class="separator:gad4e8a506b6144db5b4e965ef10a3e989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4363dbbfd950a9cd28c131be032f47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a4363dbbfd950a9cd28c131be032f47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga4a4363dbbfd950a9cd28c131be032f47">UART_TX_FIFO_NOT_FULL</a></td></tr>
<tr class="memdesc:ga4a4363dbbfd950a9cd28c131be032f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values indicating the filled status of TX FIFO. <br /></td></tr>
<tr class="separator:ga4a4363dbbfd950a9cd28c131be032f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga419f4ec8962fb682c7502ef75f8cc86d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga419f4ec8962fb682c7502ef75f8cc86d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_TX_FIFO_FULL</b></td></tr>
<tr class="separator:ga419f4ec8962fb682c7502ef75f8cc86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values related to Auxilliary Control Register(ACREG).</h2></td></tr>
<tr class="memitem:gae905f407e6becfe438ec4fafa5bbb7df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae905f407e6becfe438ec4fafa5bbb7df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gae905f407e6becfe438ec4fafa5bbb7df">UART_SD_PIN_LOW</a></td></tr>
<tr class="memdesc:gae905f407e6becfe438ec4fafa5bbb7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to set/clear the SD pin. <br /></td></tr>
<tr class="separator:gae905f407e6becfe438ec4fafa5bbb7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f35b07e6b53e23bfc61a1516e3c5c30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0f35b07e6b53e23bfc61a1516e3c5c30"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_SD_PIN_HIGH</b></td></tr>
<tr class="separator:ga0f35b07e6b53e23bfc61a1516e3c5c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values controlling System Configuration functions.</h2></td></tr>
<tr class="memitem:ga2eb85703cc753078ae4c464e1be8cabd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2eb85703cc753078ae4c464e1be8cabd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga2eb85703cc753078ae4c464e1be8cabd">UART_IDLEMODE_FORCE_IDLE</a></td></tr>
<tr class="memdesc:ga2eb85703cc753078ae4c464e1be8cabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values controlling Power Management Request/Acknowledgement modes. <br /></td></tr>
<tr class="separator:ga2eb85703cc753078ae4c464e1be8cabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbcd9524f76454378a569c017577b16a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafbcd9524f76454378a569c017577b16a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_IDLEMODE_NO_IDLE</b></td></tr>
<tr class="separator:gafbcd9524f76454378a569c017577b16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff2f69e5eb2fe6482d0db117d79ac7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ff2f69e5eb2fe6482d0db117d79ac7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_IDLEMODE_SMART_IDLE</b></td></tr>
<tr class="separator:ga0ff2f69e5eb2fe6482d0db117d79ac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09eb8ac57ce127b92168b010c8be992e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga09eb8ac57ce127b92168b010c8be992e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_IDLEMODE_SMART_IDLE_WAKEUP</b></td></tr>
<tr class="separator:ga09eb8ac57ce127b92168b010c8be992e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1614898bf58ec93cb77bfaa361f3975"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae1614898bf58ec93cb77bfaa361f3975"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gae1614898bf58ec93cb77bfaa361f3975">UART_WAKEUP_ENABLE</a></td></tr>
<tr class="memdesc:gae1614898bf58ec93cb77bfaa361f3975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values enabling/disabling WakeUp capability. <br /></td></tr>
<tr class="separator:gae1614898bf58ec93cb77bfaa361f3975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8feff9c34736cef9fd3a3c43b8e5d2d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8feff9c34736cef9fd3a3c43b8e5d2d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_WAKEUP_DISABLE</b></td></tr>
<tr class="separator:ga8feff9c34736cef9fd3a3c43b8e5d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364723356a432287d9b786fa13231304"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga364723356a432287d9b786fa13231304"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga364723356a432287d9b786fa13231304">UART_AUTO_IDLE_MODE_ENABLE</a></td></tr>
<tr class="memdesc:ga364723356a432287d9b786fa13231304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to enable /disable Autoidle mode. <br /></td></tr>
<tr class="separator:ga364723356a432287d9b786fa13231304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85251d3e0f99195ff78e3c5b45d0e7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa85251d3e0f99195ff78e3c5b45d0e7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTO_IDLE_MODE_DISABLE</b></td></tr>
<tr class="separator:gaa85251d3e0f99195ff78e3c5b45d0e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values configuring Wake-up modes for the UART in Wake-Up Enable</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7b80f93ba9c06871f64fe37af185a3b3"></a>Register. </p>
</td></tr>
<tr class="memitem:gab870bc314a868536a0de8872f2b49ed3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab870bc314a868536a0de8872f2b49ed3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gab870bc314a868536a0de8872f2b49ed3">UART_WAKEUP_TX_INTERRUPT</a>&#160;&#160;&#160;(UART_WER_EVENT_7_TX_WAKEUP_EN_MASK)</td></tr>
<tr class="memdesc:gab870bc314a868536a0de8872f2b49ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that enable/disable Wake-Up generation ability for various signals. <br /></td></tr>
<tr class="separator:gab870bc314a868536a0de8872f2b49ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54bde57bfc1265148dd86399b15e278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab54bde57bfc1265148dd86399b15e278"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_WAKEUP_RLS_INTERRUPT</b></td></tr>
<tr class="separator:gab54bde57bfc1265148dd86399b15e278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac120c2aadcccd8ab51d0393a13112993"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac120c2aadcccd8ab51d0393a13112993"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_WAKEUP_RHR_INTERRUPT</b></td></tr>
<tr class="separator:gac120c2aadcccd8ab51d0393a13112993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bac3e114ccf67122bb2c6a5d6e54b83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0bac3e114ccf67122bb2c6a5d6e54b83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_WAKEUP_RX_ACTIVITY</b>&#160;&#160;&#160;(UART_WER_EVENT_4_RX_ACTIVITY_MASK)</td></tr>
<tr class="separator:ga0bac3e114ccf67122bb2c6a5d6e54b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f95072729d5b48f090d6c64283ed446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f95072729d5b48f090d6c64283ed446"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_WAKEUP_DCD_ACTIVITY</b></td></tr>
<tr class="separator:ga6f95072729d5b48f090d6c64283ed446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb2d34e494bb1649d207c63131a614f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7cb2d34e494bb1649d207c63131a614f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_WAKEUP_RI_ACTIVITY</b>&#160;&#160;&#160;(UART_WER_EVENT_2_RI_ACTIVITY_MASK)</td></tr>
<tr class="separator:ga7cb2d34e494bb1649d207c63131a614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313deab4ec3bdb300e22d1ab35fc5959"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga313deab4ec3bdb300e22d1ab35fc5959"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_WAKEUP_DSR_ACTIVITY</b>&#160;&#160;&#160;(UART_WER_EVENT_1_DSR_ACTIVITY_MASK)</td></tr>
<tr class="separator:ga313deab4ec3bdb300e22d1ab35fc5959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609ac831fd797fc7493419891eb26788"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga609ac831fd797fc7493419891eb26788"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_WAKEUP_CTS_ACTIVITY</b>&#160;&#160;&#160;(UART_WER_EVENT_0_CTS_ACTIVITY_MASK)</td></tr>
<tr class="separator:ga609ac831fd797fc7493419891eb26788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Values indicating the line characteristics of UART Autobauding mode</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpee1c6ee848bda76dc851af1d493fa56b"></a>communication. </p>
</td></tr>
<tr class="memitem:ga38dc3347c0f75f2d89a68ece091fdd3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38dc3347c0f75f2d89a68ece091fdd3c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga38dc3347c0f75f2d89a68ece091fdd3c">UART_AUTOBAUD_NO_PARITY</a></td></tr>
<tr class="memdesc:ga38dc3347c0f75f2d89a68ece091fdd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values indicating the parity in UART Autobauding mode. <br /></td></tr>
<tr class="separator:ga38dc3347c0f75f2d89a68ece091fdd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0b055c30b5214ae84a3f07ff794995"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b0b055c30b5214ae84a3f07ff794995"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_PARITY_SPACE</b></td></tr>
<tr class="separator:ga4b0b055c30b5214ae84a3f07ff794995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87331f19d61aaff0af6d3cd37f8953f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae87331f19d61aaff0af6d3cd37f8953f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_EVEN_PARITY</b></td></tr>
<tr class="separator:gae87331f19d61aaff0af6d3cd37f8953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe65bad5d14892d5b39f1e694f7f5ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6fe65bad5d14892d5b39f1e694f7f5ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_ODD_PARITY</b></td></tr>
<tr class="separator:ga6fe65bad5d14892d5b39f1e694f7f5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058b22d4052e3fac2d9f7beda95a857f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga058b22d4052e3fac2d9f7beda95a857f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga058b22d4052e3fac2d9f7beda95a857f">UART_AUTOBAUD_CHAR_LENGTH_7</a></td></tr>
<tr class="memdesc:ga058b22d4052e3fac2d9f7beda95a857f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values indicating the word length in UART Autobaud mode. <br /></td></tr>
<tr class="separator:ga058b22d4052e3fac2d9f7beda95a857f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d48ac22da33895c25f1130be97864f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1d48ac22da33895c25f1130be97864f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_CHAR_LENGTH_8</b></td></tr>
<tr class="separator:gaa1d48ac22da33895c25f1130be97864f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dabd7475ebdbf60c95d122f1c5aa35a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4dabd7475ebdbf60c95d122f1c5aa35a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga4dabd7475ebdbf60c95d122f1c5aa35a">UART_AUTOBAUD_NO_SPEED_IDEN</a>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_0)</td></tr>
<tr class="memdesc:ga4dabd7475ebdbf60c95d122f1c5aa35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values indicating the baud rate in UART Autobaud mode. <br /></td></tr>
<tr class="separator:ga4dabd7475ebdbf60c95d122f1c5aa35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1a4bc03a73255ffa7f1157d162b01c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0e1a4bc03a73255ffa7f1157d162b01c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_115200</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_1)</td></tr>
<tr class="separator:ga0e1a4bc03a73255ffa7f1157d162b01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb261524920f8bde7dd649537f9294ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb261524920f8bde7dd649537f9294ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_57600</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_2)</td></tr>
<tr class="separator:gadb261524920f8bde7dd649537f9294ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa595c3d6c8e551cd9ee1fe18dc92cc40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa595c3d6c8e551cd9ee1fe18dc92cc40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_38400</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_3)</td></tr>
<tr class="separator:gaa595c3d6c8e551cd9ee1fe18dc92cc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf45d0cc72de05a2e22a309c1763bde6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf45d0cc72de05a2e22a309c1763bde6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_28800</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_4)</td></tr>
<tr class="separator:gadf45d0cc72de05a2e22a309c1763bde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd71c6b937f3f3793b92fd800156307"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7cd71c6b937f3f3793b92fd800156307"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_19200</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_5)</td></tr>
<tr class="separator:ga7cd71c6b937f3f3793b92fd800156307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829e3e18307d66dc532a258e6f0377b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga829e3e18307d66dc532a258e6f0377b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_14400</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_6)</td></tr>
<tr class="separator:ga829e3e18307d66dc532a258e6f0377b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f761f2ddeafccd0ffc6800dd6d1fca3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f761f2ddeafccd0ffc6800dd6d1fca3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_9600</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_7)</td></tr>
<tr class="separator:ga9f761f2ddeafccd0ffc6800dd6d1fca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fa2697950198d8c874156df05765aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9fa2697950198d8c874156df05765aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_4800</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_8)</td></tr>
<tr class="separator:gab9fa2697950198d8c874156df05765aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebce5fb95fefa4fd40e09c70b096d94d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaebce5fb95fefa4fd40e09c70b096d94d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_2400</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_9)</td></tr>
<tr class="separator:gaebce5fb95fefa4fd40e09c70b096d94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea66cb936ca685cc88e9fec7d668ccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadea66cb936ca685cc88e9fec7d668ccf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_AUTOBAUD_SPEED_1200</b>&#160;&#160;&#160;(UART_UASR_SPEED_SPEED_VALUE_10)</td></tr>
<tr class="separator:gadea66cb936ca685cc88e9fec7d668ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Miscellaneous macros.</h2></td></tr>
<tr class="memitem:ga211f8d46dc4ea8725cd1f8513e7dfd5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga211f8d46dc4ea8725cd1f8513e7dfd5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga211f8d46dc4ea8725cd1f8513e7dfd5e">UART_TRIG_LVL_GRANULARITY_4</a>&#160;&#160;&#160;((uint32_t) 0x0000U)</td></tr>
<tr class="memdesc:ga211f8d46dc4ea8725cd1f8513e7dfd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values used to choose the trigger level granularity. <br /></td></tr>
<tr class="separator:ga211f8d46dc4ea8725cd1f8513e7dfd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d7511269e304782b832c1f453db456"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85d7511269e304782b832c1f453db456"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_TRIG_LVL_GRANULARITY_1</b>&#160;&#160;&#160;((uint32_t) 0x0001U)</td></tr>
<tr class="separator:ga85d7511269e304782b832c1f453db456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f2a3366b48ee03e808dd7d6a3c2623a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f2a3366b48ee03e808dd7d6a3c2623a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga8f2a3366b48ee03e808dd7d6a3c2623a">UART_REG_CONFIG_MODE_A</a>&#160;&#160;&#160;(uint32_t) (0x0080)</td></tr>
<tr class="memdesc:ga8f2a3366b48ee03e808dd7d6a3c2623a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values to be used while switching between register configuration modes. <br /></td></tr>
<tr class="separator:ga8f2a3366b48ee03e808dd7d6a3c2623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804955392185adcb7405a8a8cfc10a54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga804955392185adcb7405a8a8cfc10a54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_REG_CONFIG_MODE_B</b>&#160;&#160;&#160;(uint32_t) (0x00BF)</td></tr>
<tr class="separator:ga804955392185adcb7405a8a8cfc10a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f089a45540b5d353ce27c04defc9b59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f089a45540b5d353ce27c04defc9b59"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_REG_OPERATIONAL_MODE</b>&#160;&#160;&#160;(uint32_t) (0x007F)</td></tr>
<tr class="separator:ga1f089a45540b5d353ce27c04defc9b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28303e3a04d97c5c746742ca593cc556"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga28303e3a04d97c5c746742ca593cc556"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga28303e3a04d97c5c746742ca593cc556">UART_FIFO_CONFIG</a>(txGra,  rxGra,  txTrig,  rxTrig,  txClr,  rxClr,  dmaEnPath,  dmaMode)</td></tr>
<tr class="memdesc:ga28303e3a04d97c5c746742ca593cc556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized macro to configure the FIFO settings. <br /></td></tr>
<tr class="separator:ga28303e3a04d97c5c746742ca593cc556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae86ab5a598928feadf002efaa87f0197"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae86ab5a598928feadf002efaa87f0197"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#gae86ab5a598928feadf002efaa87f0197">UART_FCR_PROGRAM</a>(rxFIFOTrig,  txFIFOTrig,  dmaMode,  txClr,  rxClr,  fifoEn)</td></tr>
<tr class="memdesc:gae86ab5a598928feadf002efaa87f0197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized macro used to determine a value to be written to FCR. <br /></td></tr>
<tr class="separator:gae86ab5a598928feadf002efaa87f0197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c2fb0c5dd7f753c9876a0762bc6883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69c2fb0c5dd7f753c9876a0762bc6883"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIFO_CONFIG_TXGRA</b>&#160;&#160;&#160;((uint32_t) 0xFU &lt;&lt; 26)</td></tr>
<tr class="separator:ga69c2fb0c5dd7f753c9876a0762bc6883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23cc476382b8233633eb93f5d1f34bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac23cc476382b8233633eb93f5d1f34bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIFO_CONFIG_RXGRA</b>&#160;&#160;&#160;((uint32_t) 0xFU &lt;&lt; 22)</td></tr>
<tr class="separator:gac23cc476382b8233633eb93f5d1f34bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bca286cb1964810919b6cfbf449ea5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga64bca286cb1964810919b6cfbf449ea5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIFO_CONFIG_TXTRIG</b>&#160;&#160;&#160;((uint32_t) 0xFFU &lt;&lt; 14)</td></tr>
<tr class="separator:ga64bca286cb1964810919b6cfbf449ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a857022399d5330535b4959e71b8703"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a857022399d5330535b4959e71b8703"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIFO_CONFIG_RXTRIG</b>&#160;&#160;&#160;((uint32_t) 0xFFU &lt;&lt; 6)</td></tr>
<tr class="separator:ga5a857022399d5330535b4959e71b8703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2303229af96ff4b300725c676d360fc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2303229af96ff4b300725c676d360fc2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIFO_CONFIG_TXCLR</b>&#160;&#160;&#160;((uint32_t) 0x1U &lt;&lt; 5)</td></tr>
<tr class="separator:ga2303229af96ff4b300725c676d360fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9c0c94e323da94424f888ce1637b6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b9c0c94e323da94424f888ce1637b6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIFO_CONFIG_RXCLR</b>&#160;&#160;&#160;((uint32_t) 0x1U &lt;&lt; 4)</td></tr>
<tr class="separator:ga6b9c0c94e323da94424f888ce1637b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f99f80d9693d3f1c17d9fa4042d691"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38f99f80d9693d3f1c17d9fa4042d691"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIFO_CONFIG_DMAENPATH</b>&#160;&#160;&#160;((uint32_t) 0x1U &lt;&lt; 3)</td></tr>
<tr class="separator:ga38f99f80d9693d3f1c17d9fa4042d691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c3cf6466b1ecffaf1ff423fe273be5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga09c3cf6466b1ecffaf1ff423fe273be5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FIFO_CONFIG_DMAMODE</b>&#160;&#160;&#160;((uint32_t) 0x7U &lt;&lt; 0)</td></tr>
<tr class="separator:ga09c3cf6466b1ecffaf1ff423fe273be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga816ec13494495b3b8f4d9606ef582425"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga816ec13494495b3b8f4d9606ef582425"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga816ec13494495b3b8f4d9606ef582425">UART_MIR_OVERSAMPLING_RATE_41</a>&#160;&#160;&#160;((uint32_t) 41U)</td></tr>
<tr class="memdesc:ga816ec13494495b3b8f4d9606ef582425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Over-sampling rate for MIR mode used to obtain the Divisor Values. <br /></td></tr>
<tr class="separator:ga816ec13494495b3b8f4d9606ef582425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79dd0005a796e2ecd2237ec823071b36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79dd0005a796e2ecd2237ec823071b36"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MIR_OVERSAMPLING_RATE_42</b>&#160;&#160;&#160;((uint32_t) 42U)</td></tr>
<tr class="separator:ga79dd0005a796e2ecd2237ec823071b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7498c9685a0a2ef06d30736792d1fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f7498c9685a0a2ef06d30736792d1fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_TX_FIFO_TRIG_8SPACES</b>&#160;&#160;&#160;((uint32_t) 0x0U)</td></tr>
<tr class="separator:ga7f7498c9685a0a2ef06d30736792d1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ae997bc6d4b1895670ce934576398a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5ae997bc6d4b1895670ce934576398a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_TX_FIFO_TRIG_16SPACES</b>&#160;&#160;&#160;((uint32_t) 0x1U)</td></tr>
<tr class="separator:gae5ae997bc6d4b1895670ce934576398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7750fc79546d4e182e2fce6acac71186"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7750fc79546d4e182e2fce6acac71186"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_TX_FIFO_TRIG_32SPACES</b>&#160;&#160;&#160;((uint32_t) 0x2U)</td></tr>
<tr class="separator:ga7750fc79546d4e182e2fce6acac71186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8653611189dca0cb1ede72f877e33794"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8653611189dca0cb1ede72f877e33794"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_TX_FIFO_TRIG_56SPACES</b>&#160;&#160;&#160;((uint32_t) 0x3U)</td></tr>
<tr class="separator:ga8653611189dca0cb1ede72f877e33794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781c5938995cd86ffe51cb074fec2b78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga781c5938995cd86ffe51cb074fec2b78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___u_a_r_t.html#ga781c5938995cd86ffe51cb074fec2b78">UART_LCR_STB_SHIFT</a>&#160;&#160;&#160;((uint32_t) 0x00000002U)</td></tr>
<tr class="memdesc:ga781c5938995cd86ffe51cb074fec2b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in uart console init function <br /></td></tr>
<tr class="separator:ga781c5938995cd86ffe51cb074fec2b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d189dc40eb3113ddb8b79921050fcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91d189dc40eb3113ddb8b79921050fcc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_LCR_PEN_SHIFT</b>&#160;&#160;&#160;((uint32_t) 0x00000003U)</td></tr>
<tr class="separator:ga91d189dc40eb3113ddb8b79921050fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5296837b630a8b3ba4e27c9f5f5319cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5296837b630a8b3ba4e27c9f5f5319cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_LCR_BC_SHIFT</b>&#160;&#160;&#160;((uint32_t) 0x00000006U)</td></tr>
<tr class="separator:ga5296837b630a8b3ba4e27c9f5f5319cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713a2fb5785e89492333074971bf4e8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga713a2fb5785e89492333074971bf4e8a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_LCR_PARITY_EN_DISABLE</b>&#160;&#160;&#160;((uint32_t) 0x0U)</td></tr>
<tr class="separator:ga713a2fb5785e89492333074971bf4e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c7663be0ded118bb1523224d770f21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab7c7663be0ded118bb1523224d770f21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR1_MODE_SELECT_CIR</b>&#160;&#160;&#160;((uint32_t) 0x6U)</td></tr>
<tr class="separator:gab7c7663be0ded118bb1523224d770f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f2f5a8f13d328db7fc3bb87a630ee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga46f2f5a8f13d328db7fc3bb87a630ee5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR1_MODE_SELECT_DISABLED</b>&#160;&#160;&#160;((uint32_t) 0x7U)</td></tr>
<tr class="separator:ga46f2f5a8f13d328db7fc3bb87a630ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758ddb4b293af1b89575eab66208743e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga758ddb4b293af1b89575eab66208743e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR1_MODE_SELECT_FIR</b>&#160;&#160;&#160;((uint32_t) 0x5U)</td></tr>
<tr class="separator:ga758ddb4b293af1b89575eab66208743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e7d6f98a1d34e456b435ba7c8f861b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4e7d6f98a1d34e456b435ba7c8f861b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR1_MODE_SELECT_MIR</b>&#160;&#160;&#160;((uint32_t) 0x4U)</td></tr>
<tr class="separator:gaa4e7d6f98a1d34e456b435ba7c8f861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aaf3b33c8a56440cc8069b0e4dfc92c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0aaf3b33c8a56440cc8069b0e4dfc92c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR1_MODE_SELECT_SIR</b>&#160;&#160;&#160;((uint32_t) 0x1U)</td></tr>
<tr class="separator:ga0aaf3b33c8a56440cc8069b0e4dfc92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257614e8b5ebd31780b604da1c6c8071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga257614e8b5ebd31780b604da1c6c8071"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR1_MODE_SELECT_UART13X</b>&#160;&#160;&#160;((uint32_t) 0x3U)</td></tr>
<tr class="separator:ga257614e8b5ebd31780b604da1c6c8071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8292b5773ca8f579c073d80c553d4c6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8292b5773ca8f579c073d80c553d4c6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR1_MODE_SELECT_UART16X</b>&#160;&#160;&#160;((uint32_t) 0x0U)</td></tr>
<tr class="separator:ga8292b5773ca8f579c073d80c553d4c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade8fd2f1289a426c208470c804ffdfb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gade8fd2f1289a426c208470c804ffdfb8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR1_MODE_SELECT_UART16XAUTO</b>&#160;&#160;&#160;((uint32_t) 0x2U)</td></tr>
<tr class="separator:gade8fd2f1289a426c208470c804ffdfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac49c6af9ffbfac46e072a26777ae2021"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac49c6af9ffbfac46e072a26777ae2021"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_RX_FIFO_TRIG_16CHAR</b>&#160;&#160;&#160;((uint32_t) 0x1U)</td></tr>
<tr class="separator:gac49c6af9ffbfac46e072a26777ae2021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9dba74ffa399de67fb07b4b896e5e9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9dba74ffa399de67fb07b4b896e5e9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_RX_FIFO_TRIG_56CHAR</b>&#160;&#160;&#160;((uint32_t) 0x2U)</td></tr>
<tr class="separator:gab9dba74ffa399de67fb07b4b896e5e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0843ee73c09501d6b6104eb4ea6767a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0843ee73c09501d6b6104eb4ea6767a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_RX_FIFO_TRIG_60CHAR</b>&#160;&#160;&#160;((uint32_t) 0x3U)</td></tr>
<tr class="separator:ga0843ee73c09501d6b6104eb4ea6767a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884e997a94a35c61b2e204a9e5fa2921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga884e997a94a35c61b2e204a9e5fa2921"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_FCR_RX_FIFO_TRIG_8CHAR</b>&#160;&#160;&#160;((uint32_t) 0x0U)</td></tr>
<tr class="separator:ga884e997a94a35c61b2e204a9e5fa2921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86fc8a9e34cfb9cb02b1567b5c545ddd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga86fc8a9e34cfb9cb02b1567b5c545ddd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_EFR_SW_FLOW_CONTROL_RX_SHIFT</b>&#160;&#160;&#160;((uint32_t) 0x0U)</td></tr>
<tr class="separator:ga86fc8a9e34cfb9cb02b1567b5c545ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62eb23b236df40787cbb528cd5ef1503"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga62eb23b236df40787cbb528cd5ef1503"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_EFR_SW_FLOW_CONTROL_TX_SHIFT</b>&#160;&#160;&#160;((uint32_t) 0x2U)</td></tr>
<tr class="separator:ga62eb23b236df40787cbb528cd5ef1503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef7fdce2392dbb298b81d76e369372c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ef7fdce2392dbb298b81d76e369372c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR3_SET_DMA_TX_THRESHOLD_64</b>&#160;&#160;&#160;((uint32_t) 0x0U)</td></tr>
<tr class="separator:ga5ef7fdce2392dbb298b81d76e369372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2ea0bf187769c57f9009b9e2ac3fb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b2ea0bf187769c57f9009b9e2ac3fb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UART_MDR3_SET_DMA_TX_THRESHOLD_REG</b>&#160;&#160;&#160;((uint32_t) 0x1U)</td></tr>
<tr class="separator:ga4b2ea0bf187769c57f9009b9e2ac3fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaa59b7ccc9af4d923fa7406eddf76eed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_BREAK_COND_DISABLE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(UART_LCR_BREAK_EN_BREAK_EN_VALUE_0 \</div>
<div class="line">                                             &lt;&lt;                                 \</div>
<div class="line">                                             UART_LCR_BREAK_EN_SHIFT)</div>
</div><!-- fragment --><p>Break condition generation controls. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf2ff1b9206a4856d4d5eae334472611f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTAutobaudParityGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the Parity mode being configured by the system in the UART Autobauding mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns one of the following values:<ul>
<li>UART_AUTOBAUD_NO_PARITY - indicating that no parity was identified<br />
</li>
<li>UART_AUTOBAUD_PARITY_SPACE - indicating that space parity has been configured<br />
</li>
<li>UART_AUTOBAUD_EVEN_PARITY - indicating that even parity has been configured<br />
</li>
<li>UART_AUTOBAUD_ODD_PARITY - indicating that odd parity has been configured<br />
 </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>UASR register used in this API can be accessed only when the UART is in Configuration Mode A or Configuration Mode B of operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gace506d6e5013fbbce6647942d67b19a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTAutobaudSpeedGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the baud rate being configured by the system in UART Autobauding mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns one of the following values:<ul>
<li>UART_AUTOBAUD_SPEED_115200 - for baud rate of 115200 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_57600 - for baud rate of 57600 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_38400 - for baud rate of 38400 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_28800 - for baud rate of 28800 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_19200 - for baud rate of 19200 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_14400 - for baud rate of 14400 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_9600 - for baud rate of 9600 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_4800 - for baud rate of 4800 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_2400 - for baud rate of 2400 bps<br />
</li>
<li>UART_AUTOBAUD_SPEED_1200 - for baud ratebaud rate of 1200 bps<br />
</li>
<li>UART_AUTOBAUD_NO_SPEED_IDEN - for no speed identified<br />
 </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>UASR register used in this API can be accessed only when the UART is in Configuration Mode A or Configuration Mode B of operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gad550807c845da9a6a15f4e2bbe8c8d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTAutobaudWordLenGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the word length per frame(character length) being configured by the system in UART Autobauding mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns one of the following two values:<ul>
<li>UART_AUTOBAUD_CHAR_LENGTH_7 - indicating word length of 7 bits<br />
</li>
<li>UART_AUTOBAUD_CHAR_LENGTH_8 - indicating word length of 8 bits<br />
 </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>UASR register used in this API can be accessed only when the UART is in Configuration Mode A or Configuration Mode B of operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga440eaaceba1a21305d0f031ce5c3ca4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTAutoIdleModeControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to control(enable/disable) the Auto-Idle mode of operation of the UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">modeFlag</td><td>This specifies whether to enable or disable the Auto-Idle mode of the UART</td></tr>
  </table>
  </dd>
</dl>
<p>'modeFlag' can take one of the following two values:</p><ul>
<li>UART_AUTO_IDLE_MODE_DISABLE - to disable Auto-Idle mode<br />
</li>
<li>UART_AUTO_IDLE_MODE_ENABLE - to enable Auto-Idle mode<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga405f46713f53bda3a934414a3d70fe28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTAutoRTSAutoCTSControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>autoCtsControl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>autoRtsControl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls the use of Auto-RTS and Auto-CTS features which are used in Hardware Flow Control Mode of operation. The Auto-RTS and Auto-CTS functions can be individually enabled or disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">autoCtsControl</td><td>This specifies whether to enable or disable Auto-CTS functionality </td></tr>
    <tr><td class="paramname">autoRtsControl</td><td>This specifies whether to enable or disable Auto-RTS functionality</td></tr>
  </table>
  </dd>
</dl>
<p>'autoCtsControl' can take one of the following values:</p><ul>
<li>UART_AUTO_CTS_DISABLE - to disable Auto-CTS functionality<br />
</li>
<li>UART_AUTO_CTS_ENABLE - to enable Auto-CTS functionality<br />
 'autoRtsControl' can take either of the following values:</li>
<li>UART_AUTO_RTS_DISABLE - to disable Auto-RTS functionality<br />
</li>
<li>UART_AUTO_RTS_ENABLE - to enable Auto-RTS functionality<br />
 <dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API switches UART to Configuration Mode B, programs AUTOCTSEN and AUTORTSEN bits in EFR and reverts the UART back to the original mode of operation. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga8c41950042da5c69d21e8f68d5d38eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTBreakCtl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>breakState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to introduce or to remove a Break condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">breakState</td><td>This specifies whether the break condition should be introduced or removed.</td></tr>
  </table>
  </dd>
</dl>
<p>'breakState' can take one of the following two values:</p><ul>
<li>UART_BREAK_COND_DISABLE - to disable the Break condition if it has already been enabled<br />
</li>
<li>UART_BREAK_COND_ENABLE - to enable the Break condition<br />
 <dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When the Break Condition is imposed, the Transmitter output line TX goes low to alert the communication terminal. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga07c4911e4c316c71130b5530848dfdc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t UARTCharGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API waits indefinitely for the arrival of a byte in the receiver FIFO. Once a byte has arrived, it returns that byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns the read byte. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf18eb8c68b6ca3bcab5ab55efc0a5132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t UARTCharGetNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads a byte from the Receiver Buffer Register (RBR). It checks once if any character is ready to be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the RX FIFO(or RHR) was found to have atleast one byte of data, then this API reads and returns that byte. Else it returns -1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga66b34796324a485d5e7113f79bb30382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTCharGetNonBlocking2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads a byte from the Receiver Buffer Register (RBR). It checks once if any character is ready to be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
    <tr><td class="paramname">pChar</td><td>Pointer to the byte variable which saves the byte read from RBR if there is any char ready to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the RX FIFO(or RHR) was found to have atleast one byte of data, then this API returns TRUE. Else it returns FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4320994020807deb6f1a2982ea0a961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t UARTCharGetTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOutVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API waits for the arrival of atleast one byte into the Receiver FIFO or until a specified timeout value gets decremented to zero, whichever happens first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">timeOutVal</td><td>The timeout value that is to be used. This timeout value gets decremented once per iteration of the wait loop. wait loop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns either of the below two values:<br />
 1) If a character was keyed in before the timeout value gets decremented to zero, this API returns the entered byte.<br />
 2) If no character was input within the timeout value getting decremented to zero, this API returns 0xFF.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga94fed615d3dd19cbccb91847e62532ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTCharGetTimeout2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOutVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API waits for the arrival of atleast one byte into the Receiver FIFO or until a specified timeout value gets decremented to zero, whichever happens first.This is a replacement for the UARTCharGetTimeout which will incorrectly return timeout if the UART receives 0xFF as data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">timeOutVal</td><td>The timeout value that is to be used. This timeout value gets decremented once per iteration of the wait loop. wait loop. </td></tr>
    <tr><td class="paramname">pChar</td><td>Pointer to the byte variable which saves the byte read from RHR if there is any char ready to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns either of the below two values:<br />
 1) If a character was read in before the timeout value gets decremented to zero, this API returns TRUE.<br />
 2) If no character was read within the timeout value getting decremented to zero, this API returns FASLE.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0b5fde86a308a4626f7dfe4f3349ee44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTCharPut </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byteTx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API waits indefinitely until the Transmitter FIFO (THR register in non-FIFO mode) and Transmitter Shift Register are empty. On empty, it writes a byte to the THR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used </td></tr>
    <tr><td class="paramname">byteTx</td><td>The byte to be transmitted by the UART.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga51094b8f4cd6996f6ed46d0ae1e407b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTCharPutNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byteWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API attempts to write a byte into Transmitter Holding Register (THR). It checks only once if the transmitter is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">byteWrite</td><td>Byte to be written into the THR register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the transmitter FIFO(or THR register in non-FIFO mode) was empty and the character was written. Else it returns FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a6c6bf463b24a0a1dc751f6efc34eda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTCharsAvail </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API checks if the RX FIFO (or RHR in non-FIFO mode) has atleast one byte of data to be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE - if there is atleast one data byte present in the RX FIFO (or RHR in non-FIFO mode)<br />
 FALSE - if there are no data bytes present in the RX FIFO(or RHR in non-FIFO mode)<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga39e80954aa960fc9fba99b38c9680222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTDivisorLatchDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables write access to Divisor Latch registers DLL and DLH. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Disabling write access to Divisor Latch Registers enables access to MCR, FCR, IER, BLR, EBLR, RHR registers. </dd></dl>

</div>
</div>
<a class="anchor" id="gafea08502a48186cbf103d98a3360a467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTDivisorLatchEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables write access to Divisor Latch registers DLL and DLH. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88c3153d105bed260fdc7dd0083b1ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTDivisorLatchWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>divisorValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to write the specified divisor value to Divisor Latch registers DLL and DLH. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">divisorValue</td><td>The 14-bit value whose least 8 bits go to DLL and highest 6 bits go to DLH.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A concatenated value of DLH and DLL registers(DLH:DLL, a 14-bit value) before they are modified in the current API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga20281eb052ab875e89e73234623f2262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTDivisorValCompute </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mirOverSampRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API computes the divisor value for the specified operating mode. Not part of this API, the divisor value returned is written to the Divisor Latches to configure the Baud Rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleClk</td><td>The frequency of the input clock to the UART module </td></tr>
    <tr><td class="paramname">modeFlag</td><td>A value which represents the current operating mode </td></tr>
    <tr><td class="paramname">baudRate</td><td>The required baud rate of communication in bits per second(bps) </td></tr>
    <tr><td class="paramname">mirOverSampRate</td><td>Over-sampling rate for MIR mode.This is applicable only when MIR mode of operation is chosen. Otherwise, this value is not considered.</td></tr>
  </table>
  </dd>
</dl>
<p>'modeFlag' can take one of the following values:<br />
</p><ul>
<li>UART16x_OPER_MODE - indicating 16x operating mode<br />
</li>
<li>UART13x_OPER_MODE - indicating 13x operating mode<br />
</li>
<li>UART_SIR_OPER_MODE - indicating SIR operating mode<br />
</li>
<li>UART_MIR_OPER_MODE - indicating MIR operating mode<br />
</li>
<li>UART_FIR_OPER_MODE - indicating FIR operating mode<br />
 'mirOverSampRate' can take one of the following values:</li>
<li>UART_MIR_OVERSAMPLING_RATE_41 - for an over-sampling rate of 41<br />
</li>
<li>UART_MIR_OVERSAMPLING_RATE_42 - for an over-smapling rate of 42<br />
 <dl class="section return"><dt>Returns</dt><dd>The divisor value computed for the specified mode.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refer to the section in the user guide that specifies the baud rate computation method to find the supported values of baud rates. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gae07427f0abc20a37cf64ef1e68f67796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTDMACounterResetControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls the DMA Counter Reset options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used </td></tr>
    <tr><td class="paramname">controlFlag</td><td>This specifies the DMA Counter Reset options</td></tr>
  </table>
  </dd>
</dl>
<p>'controlFlag' can take either of the following values:</p><ul>
<li>UART_DMA_CNTR_NO_RESET_FIFO_RESET - indicating that the DMA counter shall not be reset if the corresponding FIFO is reset<br />
</li>
<li>UART_DMA_CNTR_RESET_FIFO_RESET - indicating that the DMA counter shall be reset if the corresponding FIFO is reset<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gadf1cd45c047c7e47f512349fcbbb2c6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTDMADisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the DMA mode of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga290dd8d0726bfcef0eb21c92c0e1443c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTDMAEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dmaModeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the DMA mode of operation for the UART instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">dmaModeFlag</td><td>This specifies the DMA mode to be enabled for the UART instance.</td></tr>
  </table>
  </dd>
</dl>
<p>'dmaModeFlag' can take one of the following four values:</p><ul>
<li>UART_DMA_MODE_0_ENABLE - to enable DMA Mode 0(No DMA)<br />
</li>
<li>UART_DMA_MODE_1_ENABLE - to enable DMA Mode 1(DMA for both TX and RX)<br />
</li>
<li>UART_DMA_MODE_2_ENABLE - to enable DMA Mode 2(DMA only for RX)<br />
</li>
<li>UART_DMA_MODE_3_ENABLE - to enable DMA Mode 3(DMA only for TX)<br />
 <dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API enables the specified DMA modes always in SCR and FCR is not used. This is because SCR[2:1] allows the program to enable any of the four available DMA modes while FCR[3] allows the program to use either DMA Mode 0 or DMA Mode 1.<br />
</dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga4c903873332779effaabcf64d188673c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTDSRInterruptControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls the interrupt enable and disable feature for Data Set Ready(DSRn) interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used </td></tr>
    <tr><td class="paramname">controlFlag</td><td>This specifies whether to enable or disable DSRn interrupt</td></tr>
  </table>
  </dd>
</dl>
<p>'controlFlag' can take one of the following values:</p><ul>
<li>UART_DSRn_INT_DISABLE - to disable DSRn interrupt<br />
</li>
<li>UART_DSRn_INT_ENABLE - to enable DSRn interrupt<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga46501fb460edec940270b508db3e647c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTEnhanFuncBitValRestore </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enhanFnBitVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API restores the ENHANCEDEN bit value of EFR register(EFR[4]) to the corresponding bit value in 'enhanFnBitVal' passed as a parameter to this API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">enhanFnBitVal</td><td>The 4th bit of this 32-bit value shall hold a value to which the ENHANCEDEN bit of EFR (EFR[4]) has to be restored to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The APIs <a class="el" href="group___c_s_l___u_a_r_t.html#ga5529baf7747fbb28c627290d273723a6" title="This API sets a certain bit in Enhanced Feature Register(EFR) which shall avail the UART to use some ...">UARTEnhanFuncEnable()</a> and the current one are used hand-in-hand. While <a class="el" href="group___c_s_l___u_a_r_t.html#ga5529baf7747fbb28c627290d273723a6" title="This API sets a certain bit in Enhanced Feature Register(EFR) which shall avail the UART to use some ...">UARTEnhanFuncEnable()</a> collects the EFR[4] bit value before modifying it, <a class="el" href="group___c_s_l___u_a_r_t.html#ga46501fb460edec940270b508db3e647c" title="This API restores the ENHANCEDEN bit value of EFR register(EFR[4]) to the corresponding bit value in ...">UARTEnhanFuncBitValRestore()</a> can be used to restore EFR[4] bit value after the necessary operation is complete. This API switches the UART to Configuration Mode B, does the needful and reverts it back to original mode of operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5529baf7747fbb28c627290d273723a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTEnhanFuncEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets a certain bit in Enhanced Feature Register(EFR) which shall avail the UART to use some Enhanced Features. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of ENHANCEDEN bit in EFR before it is modified in this API.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API switches UART to Configuration Mode B, sets the ENHANCEDEN bit in EFR and reverts the UART back to the original mode of operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6489885d9bd255ec04e249ff13fe738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t UARTFIFOCharGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the data present at the top of the RX FIFO, that is, the data in the Receive Holding Register(RHR). However before reading the data from RHR, it does not check whether RHR has fresh data or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data read from the RHR.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) Since this API does not check whether RX FIFO(RHR) has fresh data before reading the same, the application should ensure that RX FIFO has data before calling this API. The API <a class="el" href="group___c_s_l___u_a_r_t.html#ga8a6c6bf463b24a0a1dc751f6efc34eda" title="This API checks if the RX FIFO (or RHR in non-FIFO mode) has atleast one byte of data to be read...">UARTCharsAvail()</a> can be used to check if the RX FIFO has atleast one byte of data.<br />
 2) If the RX FIFO did not have any fresh data and this API is called, this API would return an unknown value.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gacc185467be94c861bef1024d59592e02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTFIFOCharPut </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byteTx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API writes a byte to the Transmitter FIFO without checking for the emptiness of the Transmitter FIFO or the Transmitter Shift Register(TSR). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">byteTx</td><td>The byte to be transmitted by the UART.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the APIs <a class="el" href="group___c_s_l___u_a_r_t.html#ga0b5fde86a308a4626f7dfe4f3349ee44" title="This API waits indefinitely until the Transmitter FIFO (THR register in non-FIFO mode) and Transmitte...">UARTCharPut()</a> or <a class="el" href="group___c_s_l___u_a_r_t.html#ga51094b8f4cd6996f6ed46d0ae1e407b6" title="This API attempts to write a byte into Transmitter Holding Register (THR). It checks only once if the...">UARTCharPutNonBlocking()</a>, this API does not check for the emptiness of the TX FIFO or TSR. This API is ideal for use in FIFO mode of operation where the 64-byte TX FIFO has to be written with successive bytes. If transmit interrupt is enabled, it provides a mechanism to control the writes to the TX FIFO. </dd></dl>

</div>
</div>
<a class="anchor" id="ga20f52578fbb06eb057843718a3557ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTFIFOConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fifoConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the FIFO settings for the UART instance. Specifically, this does the following configurations: 1&gt; Configures the Transmitter and Receiver FIFO Trigger Level granularity<br />
 2&gt; Configures the Transmitter and Receiver FIFO Trigger Level<br />
 3&gt; Configures the bits which clear/not clear the TX and RX FIFOs<br />
 4&gt; Configures the DMA mode of operation<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">fifoConfig</td><td>This specifies the desired FIFO configurations. Use the macro UART_FIFO_CONFIG to pass the required FIFO settings.</td></tr>
  </table>
  </dd>
</dl>
<p>The parameters of UART_FIFO_CONFIG can take the following values:<br />
&ndash; txGra - the Transmitter FIFO trigger level granularity<br />
&ndash; rxGra - the Receiver FIFO trigger level granularity<br />
 These can take one of the following two values:<br />
</p><ul>
<li>UART_TRIG_LVL_GRANULARITY_1 - for a granularity of 1,<br />
</li>
<li>UART_TRIG_LVL_GRANULARITY_4 - for a granularity of 4.<br />
 &ndash; txTrig - the Transmitter FIFO trigger level<br />
 For 'txGra' being UART_TRIG_LVL_GRANULARITY_4, this can take one of the values from one of the following two sets: Set 1&gt; UART_FCR_TX_TRIG_LVL_n, where n = 8,16,32,56. These are programmed to the FCR[5:4] in FCR register. Set 2&gt; m , where (1 &lt;= m &lt;= 15). The trigger level would then be (m * 4). For example: If m = 9, then trigger level = 36. The value 'm' is programmed into TLR[3:0] field in TLR register.</li>
</ul>
<p>For granularity being UART_TRIG_LVL_GRANULARITY_1, this can take any decimal value from 1 to 63.</p>
<p>&ndash; rxTrig - the Receiver FIFO Trigger level<br />
 For granularity being UART_TRIG_LVL_GRANULARITY_4, this can take one of the macro from one of the following two sets: Set 1&gt; UART_FCR_RX_TRIG_LVL_n, where n = 8,16,56,60. These are programmed into FCR[7:6] field in FCR register. Set 2&gt; m , where (1 &lt;= m &lt;= 15). The trigger level would then be (m * 4). For example: If m = 7, then trigger level = 28. The value 'm' is programmed to the TLR[7:4] field of TLR.</p>
<p>For granularity being UART_TRIG_LVL_GRANULARITY_1, this can take any decimal value from 1 to 63.</p>
<p>&ndash; txClr - the Transmitter FIFO clear flag<br />
&ndash; rxClr - the Receiver FIFO clear flag<br />
 These can take the following values: 0 - to not clear the FIFO<br />
 1 - to clear the FIFO. Clearing the FIFO also results in resetting the FIFO counter logic to 0.<br />
 &ndash; dmaEnPath - specifies whether DMA Mode settings should be configured through FCR or SCR. This can take one of the following two values: UART_DMA_EN_PATH_FCR - to configure DMA through FCR<br />
 UART_DMA_EN_PATH_SCR - to configure DMA through SCR<br />
 &ndash; dmaMode - specifies the DMA Mode to be used<br />
 This can take one of the following four values:</p><ul>
<li>UART_DMA_MODE_m_ENABLE, where m = 0, 1, 2 or 3.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The value that was written to the FIFO Control Register(FCR).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>1&gt; FIFO Control Register(FCR) is a write-only register and its contents cannot be read. Hence, it is not possible for a read-modify-write operation on this register. Therefore it is expected that the FIFO configuration is done at once for both TX and RX directions and always the entire FCR related information is required during modification of the FIFO settings. Also the FIFO related settings are valid only when the FIFO is enabled. This means that FIFO mode of operation should be enabled for FIFO related settings to take effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ga236f2c7cf13e04d7831e4589f9100e79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTFIFOCtrlRegWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fcrValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to write a specified value to the FIFO Control Register(FCR) without disabling the divisor values. Preferable setting FCR during runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">fcrValue</td><td>This specifies the value to be written to the FCR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35eb7ec25a2fbb687573bdb11917b55a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTFIFOEnableStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines whether FIFO mode of operation is enabled for the UART instance or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE - if FIFO mode of operation is enabled<br />
 FALSE - if FIFO mode of operation is disabled<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gabf5b097f54041cccbaea7d1d399e25cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTFIFOLevelSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the receiver FIFO trigger level.<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance used.<br />
 </td></tr>
    <tr><td class="paramname">rxLevel</td><td>This contains the settings for the FIFO threshold level. While setting the FIFO threshold, it shall be assumed that the FIFO is being enabled.This can take one of the four following values: 1&gt; UART_RX_TRIG_LEVEL_1 2&gt; UART_RX_TRIG_LEVEL_4 3&gt; UART_RX_TRIG_LEVEL_8 4&gt; UART_RX_TRIG_LEVEL_14 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.<br />
 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API needs needs to be called to configure the FIFO without enabling the DMA mode. If DMA mode is being used, the <a class="el" href="group___c_s_l___u_a_r_t.html#ga290dd8d0726bfcef0eb21c92c0e1443c" title="This API enables the DMA mode of operation for the UART instance. ">UARTDMAEnable()</a> should be used to configure the FIFO.</dd>
<dd>
FIFO Control Register(FCR) and the Interrupt Identification Register (IIR) share a common offset address. FCR register has write-only <br />
 permissions and IIR register has read-only permissions. Therefore, reading from this address will read the value in IIR register and <br />
 writing to this address will write the value into the FCR register. Since these share the same address, the integrity of bits in FCR <br />
 register are at risk if we read from IIR register, modify this value and write the new value into the FCR register. Thus, we retain the status of the FIFOEN bit and the RXFIFTL bit in the FCR register by reinstating them to their previous values.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga443648e452f9ce4da9208fdeb97692a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTFIFORegisterWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fcrValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to write a specified value to the FIFO Control Register(FCR). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">fcrValue</td><td>This specifies the value to be written to the FCR.</td></tr>
  </table>
  </dd>
</dl>
<p>'fcrValue' can be determined using a parameterized macro named 'UART_FCR_PROGRAM'. The parameters of 'UART_FCR_PROGRAM' are described below:</p><ul>
<li>rxFIFOTrig - specifies the Receiver FIFO Trigger Level<br />
</li>
<li>txFIFOTrig - specifies the Transmitter FIFO Trigger Level<br />
</li>
<li>dmaMode - specifies the DMA Mode of operation to be selected:<br />
 Write 0 - for DMA Mode 0<br />
 1 - for DMA Mode 1<br />
</li>
<li>txClr - specifies whether or not to clear the Transmitter FIFO and resetting the counter logic to 0.<br />
</li>
<li>rxClr - specifies whether or not to clear the Receiver FIFO and resetting the counter logic to 0.</li>
<li>fifoEn - specifies whether to enable the FIFO mode for the UART or not<br />
 0 - to enable Non-FIFO mode of operation<br />
 1 - to enable FIFO mode of operation<br />
 <dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>1&gt; The FIFO_EN and DMA_MODE bits of FCR can be written to only when the Baud Clock is not running(DLL and DLH register are cleared to 0). Modifying DLL and DLH registers in turn requires that the UART be operated in Disabled Mode(MDR1[2:0] = 0x7).<br />
 2&gt; Writing to 'TX_FIFO_TRIG' field in FCR requires that the ENHANCEDEN bit in EFR(EFR[4]) be set to 1.<br />
 Prior to writing to the FCR, this API does the above two operations. It also restores the respective bit values after FCR has been written to.<br />
</dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga5d1b299eeb07448b9dcc25d0d355f835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTFIFOTrigLvlGranControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxFIFOGranCtrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txFIFOGranCtrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls the feature of setting the Trigger Level granularity as 1 for Transmitter and Receiver FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">rxFIFOGranCtrl</td><td>This specifies whether the trigger level granularity for the RX FIFO is to be 1 or not </td></tr>
    <tr><td class="paramname">txFIFOGranCtrl</td><td>This specifies whether the trigger level granularity for the TX FIFO is to be 1 or not</td></tr>
  </table>
  </dd>
</dl>
<p>'rxFIFOGranCtrl' can take either of the following values:</p><ul>
<li>UART_RX_TRIG_LVL_GRAN_1_DISABLE - to disable usage of a granularity of 1 for RX FIFO Trigger level<br />
</li>
<li>UART_RX_TRIG_LVL_GRAN_1_ENABLE - to set a granularity of 1 for RX FIFO Trigger level<br />
 'txFIFOGranCtrl' can take either of the following values:</li>
<li>UART_TX_TRIG_LVL_GRAN_1_DISABLE - to disable usage of a granularity of 1 for TX FIFO Trigger level<br />
</li>
<li>UART_TX_FIFO_LVL_GRAN_1_ENABLE - to set a granularity of 1 for TX FIFO Trigger level<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga33f1febfc148074b65774ba64cc952c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTFIFOWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numTxBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API copies the requested amount of data from the pointed data block to the UART Transmit FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">pBuffer</td><td>The starting address of the data block. </td></tr>
    <tr><td class="paramname">numTxBytes</td><td>The number of data bytes to be transmitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data bytes that were written to the TX FIFO.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API does not check for the emptiness of the TX FIFO or for its space availability before writing to it. The application calling this API has the responsibility of checking the TX FIFO status before using this API.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga033e6a93243bec9f3b6b978ff968510c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTFlowCtrlTrigLvlConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rtsHaltFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rtsStartFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the Receiver FIFO threshold level to start/stop transmission during Hardware Flow Control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">rtsHaltFlag</td><td>The receiver FIFO threshold level on attaining which the RTS line is deasserted signalling the transmitter of its counterpart to stop trasmitting. </td></tr>
    <tr><td class="paramname">rtsStartFlag</td><td>The receiver FIFO threshold level on attaining which the RTS line is asserted signalling the transmitter of its counterpart to start transmitting.</td></tr>
  </table>
  </dd>
</dl>
<p>'rtsHaltFlag' can take one among the following values:<br />
</p><ul>
<li>m, where (0 &lt;= m &lt;= 15).<br />
 The HALT trigger level would then be (m * 4).<br />
'rtsStartFlag' can take one among the following values:<br />
</li>
<li>n, where (0 &lt;= n &lt;= 15).<br />
 The RESTORE trigger level would then be (n * 4).<br />
 For Example: If m = 8 and n = 5, then the receiver trigger levels would be:<br />
HALT = (8 * 4) = 32, RESTORE = (5 * 4) = 20.<br />
 <dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Here two things should be taken care of:<br />
 1&gt; RX FIFO Threshold Level to Halt Transmission should be greater than the Threshold level to Start transmission i.e. TCR[3:0] &gt; TCR[7:4].<br />
 2&gt; In FIFO Interrupt mode with Flow Control, the RX FIFO threshold level to Halt Transmission (TCR[3:0]) should be greater than or equal to the Receiver FIFO trigger level(TLR[7:4] or FCR[7:6]).<br />
</dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga6e9c2629f790909103ace69dac5a6a48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTIdleModeConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API can be used to control the Power Management request/acknowledgement process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">modeFlag</td><td>This specifies the Power Management request/acknowledgement process to be followed</td></tr>
  </table>
  </dd>
</dl>
<p>'modeFlag' can take one of the following values:</p><ul>
<li>UART_IDLEMODE_FORCE_IDLE - to enable Force Idle mode<br />
</li>
<li>UART_IDLEMODE_NO_IDLE - to enable No-Idle mode<br />
</li>
<li>UART_IDLEMODE_SMART_IDLE - to enable Smart Idle mode<br />
</li>
<li>UART_IDLEMODE_SMART_IDLE_WAKEUP - to enable Smart Idle Wakeup mode<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gaeb147d6336141e24dc34e919d604f8d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTInt2Disable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the specified interrupts in the UART mode of operation for IER2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">intFlag</td><td>Bit mask value of the bits corresponding to Interrupt Enable Register(IER2). This specifies the UART interrupts to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>'intFlag' can take one or a combination of the following macros:</p><ul>
<li>UART_INT2_RX_EMPTY - to enable receive FIFO empty interrupt</li>
<li>UART_INT2_TX_EMPTY - to enable TX FIFO empty interrupt</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The note section of <a class="el" href="group___c_s_l___u_a_r_t.html#ga232f92fb9dba5795c62869d61ce35cc0" title="This API enables the specified interrupts in the UART mode of operation for IER2. ...">UARTInt2Enable()</a> also applies to this API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga232f92fb9dba5795c62869d61ce35cc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTInt2Enable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the specified interrupts in the UART mode of operation for IER2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">intFlag</td><td>Bit mask value of the bits corresponding to Interrupt Enable Register(IER2). This specifies the UART interrupts to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>'intFlag' can take one or a combination of the following macros:</p><ul>
<li>UART_INT2_RX_EMPTY - to enable receive FIFO empty interrupt</li>
<li>UART_INT2_TX_EMPTY - to enable TX FIFO empty interrupt</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API modifies the contents of UART Interrupt Enable Register 2 (IER2). </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a38f5622f0f0f5b67e09755c62e9458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTInt2StatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the UART Interrupt Status 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns one or a combination of the following macros:<ul>
<li>UART_INT2_RX_EMPTY - to enable receive FIFO empty interrupt<br />
</li>
<li>UART_INT2_TX_EMPTY - to enable TX FIFO empty interrupt<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3f90556a4ff4d3d936c9e2861b6d0e27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the specified interrupts in the UART mode of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">intFlag</td><td>Bit mask value of the bits corresponding to Interrupt Enable Register(IER). This specifies the UART interrupts to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>'intFlag' can take one or a combination of the following macros:</p><ul>
<li>UART_INT_CTS - to disable Clear-To-Send interrupt,</li>
<li>UART_INT_RTS - to disable Request-To-Send interrupt,</li>
<li>UART_INT_XOFF - to disable XOFF interrupt,</li>
<li>UART_INT_SLEEPMODE - to disable Sleep Mode,</li>
<li>UART_INT_MODEM_STAT - to disable Modem Status interrupt,</li>
<li>UART_INT_LINE_STAT - to disable Line Status interrupt,</li>
<li>UART_INT_THR - to disable Transmitter Holding Register Empty interrupt,</li>
<li>UART_INT_RHR_CTI - to disable Receiver Data available interrupt and Character timeout indication interrupt.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The note section of <a class="el" href="group___c_s_l___u_a_r_t.html#ga6de3bcf1e548d2a77a25cd8e31df35d1" title="This API enables the specified interrupts in the UART mode of operation. ">UARTIntEnable()</a> also applies to this API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6de3bcf1e548d2a77a25cd8e31df35d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the specified interrupts in the UART mode of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">intFlag</td><td>Bit mask value of the bits corresponding to Interrupt Enable Register(IER). This specifies the UART interrupts to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>'intFlag' can take one or a combination of the following macros:</p><ul>
<li>UART_INT_CTS - to enable Clear-To-Send interrupt,</li>
<li>UART_INT_RTS - to enable Request-To-Send interrupt,</li>
<li>UART_INT_XOFF - to enable XOFF interrupt,</li>
<li>UART_INT_SLEEPMODE - to enable Sleep Mode,</li>
<li>UART_INT_MODEM_STAT - to enable Modem Status interrupt,</li>
<li>UART_INT_LINE_STAT - to enable Line Status interrupt,</li>
<li>UART_INT_THR - to enable Transmitter Holding Register Empty interrupt,</li>
<li>UART_INT_RHR_CTI - to enable Receiver Data available interrupt and Character timeout indication interrupt.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API modifies the contents of UART Interrupt Enable Register (IER). Modifying the bits IER[7:4] requires that EFR[4] be set. This API does the needful before it accesses IER. Moreover, this API should be called when UART is operating in UART 16x Mode, UART 13x Mode or UART 16x Auto-baud mode.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8ffe20c7705cac72f752a04b2676bb01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTIntIdentityGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the UART Interrupt Status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns one or a combination of the following macros:<ul>
<li>UART_INTID_MODEM_STAT - indicating the occurence of a Modem Status interrupt<br />
</li>
<li>UART_INTID_TX_THRES_REACH - indicating that the TX FIFO Threshold number of bytes can be written to the TX FIFO.</li>
<li>UART_INTID_RX_THRES_REACH - indicating that the RX FIFO has reached its programmed Trigger Level<br />
</li>
<li>UART_INTID_RX_LINE_STAT_ERROR - indicating the occurence of a receiver Line Status error<br />
</li>
<li>UART_INTID_CHAR_TIMEOUT - indicating the occurence of a Receiver Timeout<br />
</li>
<li>UART_INTID_XOFF_SPEC_CHAR_DETECT - indicating the detection of XOFF or a Special character<br />
</li>
<li>UART_INTID_MODEM_SIG_STATE_CHANGE - indicating that atleast one of the Modem signals among CTSn, RTSn and DSRn have changed states from active(low) to inactive(high)<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gafbd54d7be20d59800e99f36c41c4e4a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTIntPendingStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines whether any UART interrupt condition is still alive and is pending to be serviced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART_INT_PENDING - if servicing an interrupt is still pending<br />
 UART_N0_INT_PENDING - if there are no interrupts to be serviced<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga744770c35a232538cfdc701169ec8c7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTIsTransmitterEmpty </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the transmitter empty status i.e. if Transmitter FIFO (THR register in non-FIFO mode) and Transmitter Shift Register are empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transmitter empty status TRUE: Transmitter is empty FALSE: Transmitter is not empty </dd></dl>

</div>
</div>
<a class="anchor" id="gaaeb6d0f98628957ed2b908b11e4e9dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTLineCharacConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wLenStbFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>parityFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the Line Characteristics for the UART instance. The Line Characteristics include: </p>
<ul>
<li>Word length per frame<br />
</li>
<li>Number of Stop Bits per frame<br />
</li>
<li>Parity feature configuration<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">wLenStbFlag</td><td>Bit mask value of the bits pertaining to word length selection and stop bits selection in LCR. </td></tr>
    <tr><td class="paramname">parityFlag</td><td>Bit mask value of the bits pertaining to parity feature selection in LCR.</td></tr>
  </table>
  </dd>
</dl>
'wLenStbFlag' can take one of the following macros: &ndash; (UART_FRAME_WORD_LENGTH_n | UART_FRAME_NUM_STB_1), where n = 5,6,7 or 8. &ndash; This signifies that 1 stop bit and one among 5,6,7 and 8 bits are chosen as the word length per frame.<br />
 &ndash; (UART_FRAME_WORD_LENGTH_n | UART_FRAME_NUM_STB_1_5_2), where n = 5,6,7 or 8. &ndash; This signifies that the word length and number of stop bits per frame could be one among the below four choices: &mdash; WL = 5 NUM_STB = 1.5 &mdash; WL = 6,7 or 8 NUM_STB = 2</li>
</ul>
<p>'parityFlag' can take one of the following macros:</p><ul>
<li>(UART_ODD_PARITY) - signifying that odd parity be enabled and the parity bit be represented in a default manner.<br />
</li>
<li>(UART_EVEN_PARITY) - signifying that even parity be enabled and the parity bit be represented in a default manner.<br />
</li>
<li>(UART_PARITY_REPR_1) - signifying that the parity bit be represented by a logic 1 in the transmitted and received data.<br />
</li>
<li>(UART_PARITY_REPR_0) - signifying that the parity bit be represented by a logic 0 in the transmitted and received data.<br />
</li>
<li>(UART_PARITY_NONE) - signifying that no parity be enabled.<br />
 <dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga08ff14bb997f3f31a451adb27fcdb4d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTLoopbackModeControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls(enables/disables) the Loopback mode of operation for the UART instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used </td></tr>
    <tr><td class="paramname">controlFlag</td><td>This specifies whether to enable or disable Loopback mode of operation 'controlFlag' can take one of the following values:<ul>
<li>UART_LOOPBACK_MODE_ENABLE - to enable Loopback mode of operation<br />
</li>
<li>UART_LOOPBACK_MODE_DISABLE - to disable Loopback mode and thus resulting in switching to Normal operating mode<br />
 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaee54c805927f674f01e50326d18d5c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTModemControlClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API switches the specified Modem Control signals to inactive state. The Modem Control signals in context are DCD, RI, RTS and DTR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">modeFlag</td><td>This specifies the signals that are required to be switched to inactive state. Bits MCR[3:0] hold control for switching Modem Control Signals to active/inactive state. 'modeFlag' can take one or a combination of the following values:<br />
<ul>
<li>UART_DCD_CONTROL - specifying to force DCDn input to inactive state(high)<br />
</li>
<li>UART_RI_CONTROL - specifying to force RIn input to inactive state (high)<br />
</li>
<li>UART_RTS_CONTROL - specifying to force RTSn output to inactive state(high)<br />
</li>
<li>UART_DTR_CONTROL - specifying to force DTRn output to inactive state(high)<br />
 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga3327190e282d72745af2d94c215b6b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTModemControlGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of the RTS and AFE bits in the MCR register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of RTS and AFE bits if MCR </dd></dl>

</div>
</div>
<a class="anchor" id="ga764bb955fbab05d449e615e3b0a275c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTModemControlReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API resets the Modem control register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0101ffe0cd88ba1694c0e5132e3b677c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTModemControlSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API switches the specified Modem Control Signals to active state. The Modem Control signals in context are DCD, RI, RTS and DTR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">modeFlag</td><td>This specifies the signals that are required to be switched to active state. Bits MCR[3:0] hold control for switching Modem Control Signals to active/inactive state.</td></tr>
  </table>
  </dd>
</dl>
<p>'modeFlag' can take one or a combination of the following values:<br />
</p><ul>
<li>UART_DCD_CONTROL - specifying to force DCDn input to active state(low)<br />
</li>
<li>UART_RI_CONTROL - specifying to force RIn input to active state(low)<br />
</li>
<li>UART_RTS_CONTROL - specifying to force RTSn output to active state (low)<br />
</li>
<li>UART_DTR_CONTROL - specifying to force DTRn output to active state (low)<br />
 <dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga5450538e2953fbfb766f534f41672ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTModemStatusChangeCheck </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines if the values on Modem Signal Lines have changed since the last read of Modem Status Register(MSR). The Modem Signals in context are DCD, RI, DSR, CTS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned could be one of the following macros, a combination or all of it.<ul>
<li>UART_DCD_STS_CHANGED - indicating that DCDn input changed state since the last read of MSR<br />
</li>
<li>UART_RI_STS_CHANGED - indicating that RIn input changed state since the last read of MSR<br />
</li>
<li>UART_DSR_STS_CHANGED - indicating that DSRn input changed state since the last read of MSR<br />
</li>
<li>UART_CTS_STS_CHANGED - indicating that CTSn input changed state since the last read of MSR<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga178f89605f0d59b41bd62e9c632052fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTModemStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the values on Modem Signal Lines. The Modem Signals in context are: 1&gt; Data Carrier Detect(DCD)<br />
 2&gt; Ring Indicator(RI)<br />
 3&gt; Data Set Ready(DSR)<br />
 4&gt; Clear To Send(CTS)<br />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned could be one of the following macros, a combination or all of it.<br />
<ul>
<li>UART_DCD_VALUE - indicating DCDn line is active(low)<br />
</li>
<li>UART_RI_VALUE - indicating RIn line is active(low)<br />
</li>
<li>UART_DSR_VALUE - indicating DSRn line is active(low)<br />
</li>
<li>UART_CTS_VALUE - indicating CTSn line is active(low)<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1a547294b77bb3ddfc3e55ce57d517cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTModuleReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API performs a module reset of the UART instance. It also waits until the reset process is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API accesses the System Configuration Register(SYSC) and System Status Register(SYSS) to perform module reset and to wait until the same is complete. </dd></dl>

</div>
</div>
<a class="anchor" id="ga97f634eaf2b09043c5e490f5f4ca52a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTModuleVersionNumberGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the Revision Number of the module from the Module Version Register(MVR). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns the Major Revision Number(MVR[7:4] and Minor Revision Number(MVR[3:0])) of the module. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a81b3c151c252d6bfc84485b48e0bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTOperatingModeSelect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the operating mode for the UART instance. The different operating modes are: </p>
<ul>
<li>UART(16x, 13x, 16x Auto-Baud)<br />
</li>
<li>IrDA(SIR, MIR, FIR)<br />
</li>
<li>CIR<br />
</li>
<li>Disabled state(default state)<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">modeFlag</td><td>A value which holds the mode number. This mode number is referred from the MODESELECT field in MDR1.</td></tr>
  </table>
  </dd>
</dl>
'modeFlag' can take one of the following values: UART16x_OPER_MODE : to switch to UART 16x operating mode<br />
 UART_SIR_OPER_MODE : to swith to IrDA SIR operating mode<br />
 UART16x_AUTO_BAUD_OPER_MODE : to switch to UART 16x Auto Baud operating mode<br />
 UART13x_OPER_MODE : to switch to UART 13x operating mode<br />
 UART_MIR_OPER_MODE : to switch to IrDA MIR operating mode<br />
 UART_FIR_OPER_MODE : to switch to IrDA FIR operating mode<br />
 UART_CIR_OPER_MODE : to switch to CIR operating mode<br />
 UART_DISABLED_MODE : to switch to Disabled state<br />
 <dl class="section return"><dt>Returns</dt><dd>The mode number in the MODESELECT field of MDR1 before it was modified. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga50a3083c6d9000dc5021ac5d58309dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTParityModeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the Parity configuration being set in the UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returs one of the following values:<ul>
<li>(UART_ODD_PARITY) - signifying that odd parity is enabled and the parity bit is represented in a default manner<br />
</li>
<li>(UART_EVEN_PARITY) - signifying that even parity is enabled and the parity bit is represented in a default manner<br />
</li>
<li>(UART_ODD_PARITY_REPR_1) - signifying that odd parity is enabled and the parity bit is represented by a logic 1<br />
</li>
<li>(UART_EVEN_PARITY_REPR_0)- signifying that even parity is enabled and the parity bit is represented by a logic 0<br />
</li>
<li>(UART_PARITY_NONE) - signifying that no parity is enabled<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga66a657656a0377614fd1f293f95913d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTParityModeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>parityFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the Parity feature for the UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used </td></tr>
    <tr><td class="paramname">parityFlag</td><td>This specifies the parity configuration to be programmed to the Line Control Register(LCR)</td></tr>
  </table>
  </dd>
</dl>
<p>'parityFlag' can take one of the following values:</p><ul>
<li>(UART_ODD_PARITY) - signifying that odd parity be enabled and the parity bit be represented in a default manner<br />
</li>
<li>(UART_EVEN_PARITY) - signifying that even parity be enabled and the parity bit be represented in a default manner<br />
</li>
<li>(UART_ODD_PARITY_REPR_1) - signifying that odd parity be enabled and the parity bit be represented by a logic 1<br />
</li>
<li>(UART_EVEN_PARITY_REPR_0)- signifying that even parity be enabled and the parity bit be represented by a logic 0<br />
</li>
<li>(UART_PARITY_NONE) - signifying that no parity be enabled<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga561f7fe73110c83b8f1e57110e0a4da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTPulseShapingControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shapeControl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used only in UART mode, this API is used to control the pulse shaping feature. Pulse shaping feature could either be enabled or disabled in UART mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">shapeControl</td><td>This specifies whether to enable or disable Pulse shaping feature in UART mode</td></tr>
  </table>
  </dd>
</dl>
<p>'shapeControl' can take either of the two following values:<br />
</p><ul>
<li>UART_PULSE_NORMAL - to disable Pulse Shaping feature which is the Normal and default configuration<br />
</li>
<li>UART_PULSE_SHAPING - to enable Pulse Shaping feature<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga33f7ea9dbead60774537985e69a9c391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTReadStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the line status register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns the line status register value. </dd></dl>

</div>
</div>
<a class="anchor" id="gae236fbd76a12187f133cacf394b8d719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTRegConfigModeEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>modeFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the specified Register Configuration mode for the UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">modeFlag</td><td>This specifies the register configuration mode to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the Line Control Register(LCR) before it was modified.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since the UART module registers that can be accessed at any time depends on the value in the Line Control Register(LCR), three register configuration modes have been defined, each corresponding to a specific state of the LCR. The three register configuration modes are:<br />
<ul>
<li>Configuration Mode A: LCR[7] = 1 and LCR[7:0] != 0xBF.<br />
</li>
<li>Configuration Mode B: LCR[7:0] = 0xBF.<br />
</li>
<li>Operational Mode : LCR[7] = 0.<br />
 Refer to the Register Listing in the UART/IrDA/CIR peripheral document for more information.<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga690a93bbf457c306904ca6b09c713caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTRegConfModeRestore </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lcrRegValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to restore the UART to the specified Register Configuration Mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">lcrRegValue</td><td>The value to be loaded to the Line Control Register(LCR).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The API <a class="el" href="group___c_s_l___u_a_r_t.html#gae236fbd76a12187f133cacf394b8d719" title="This API configures the specified Register Configuration mode for the UART. ">UARTRegConfigModeEnable()</a> and the current API are used hand-in-hand. While <a class="el" href="group___c_s_l___u_a_r_t.html#gae236fbd76a12187f133cacf394b8d719" title="This API configures the specified Register Configuration mode for the UART. ">UARTRegConfigModeEnable()</a> switches the UART to the requested operating mode, the current API restores the UART to that register configuration mode prevalent before <a class="el" href="group___c_s_l___u_a_r_t.html#gae236fbd76a12187f133cacf394b8d719" title="This API configures the specified Register Configuration mode for the UART. ">UARTRegConfigModeEnable()</a> was called. </dd></dl>

</div>
</div>
<a class="anchor" id="gacbb71792e8b1185f83e1858a938980eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTResumeOperation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the RESUME register which clears the internal flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>UART_RESUME is read only register that always reads 0x0. When conditions like TX Underrun/RX Overrun errors occur, the transmission/reception gets halted and some internal flags are set. Clearing these flags would resume the halted operation. Dummy operations are carried out in this API to remove compiler warnings. </dd></dl>

</div>
</div>
<a class="anchor" id="gaccd691b151d8647c8ac3ee2f32443bb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTRXCTSDSRTransitionStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines whether a falling edge occured on RX, CTSn or DSRn lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns one of the following values:<ul>
<li>UART_RX_CTS_DSR_NO_FALL_EDGE - indicating that no falling edge occured on RX, CTSn and DSRn lines<br />
</li>
<li>UART_RX_CTS_DSR_FALL_EDGE - indicating that a falling edge occured on RX, CTSn and DSRn lines<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga990644cfc774c0fb962d035994d8d0a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTRXCTSDSRWakeUpConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeUpFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls (enables/disables) a feature where a falling edge on the RX, CTSn or DSRs could send a wake-up interrupt to the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">wakeUpFlag</td><td>This specifies whether or not a wake-up interrupt should be sent to the CPU when a falling edge occurs on RX, CTSn or DSRn lines.</td></tr>
  </table>
  </dd>
</dl>
<p>'wakeUpFlag' can take one of the following values:</p><ul>
<li>UART_RX_CTS_DSR_WAKEUP_DISABLE - to disable generation of a Wake-Up interrupt due to occurence of a falling edge on RX, CTSn or DSRn lines.</li>
<li>UART_RX_CTS_DSR_WAKEUP_ENABLE - to enable generation of a Wake-Up interrupt due to occurence of a falling edge on RX, CTSn, DSRn lines.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e8788b4c79a7f9d56b2338a8b8c3863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTRxErrorGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the receiver data error status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns the error status. This can be one or a combination of the below values:<ul>
<li>UART_OVERRUN_ERROR - indicating Overrun error occured<br />
</li>
<li>UART_PARITY_ERROR - indicating Parity error occured<br />
</li>
<li>UART_FRAMING_ERROR - indicating Framing error occured<br />
</li>
<li>UART_BREAK_DETECTED_ERROR - indicating a Break condition was detected<br />
</li>
<li>UART_FIFO_PE_FE_BI_DETECTED - indicating that atleast one parity error, framing error or a break indication is present in the RX FIFO<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga78b9ffaadf65cb23b2f59bd62cb764ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTRxFIFOLevelGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the current level of the Receiver FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current level of the Receiver FIFO. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8299261a242e55ad452bf89826e24d93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTScratchPadRegRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the value in Scratchpad Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value in Scratchpad Register </dd></dl>

</div>
</div>
<a class="anchor" id="ga09ab7d4028d687fdc53ed2698b9a1a86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTScratchPadRegWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>scratchValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API programs the Scratchpad Register with the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used </td></tr>
    <tr><td class="paramname">scratchValue</td><td>This is the scratch value(temporary data) to be loaded to the Scratchpad Register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga84d1644a292f5299f336b07cab006f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTSoftwareFlowCtrlOptSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swFlowCtrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the options for Software Flow Control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">swFlowCtrl</td><td>This specifies one of the options available for software flow control.</td></tr>
  </table>
  </dd>
</dl>
<p>'swFlowCtrl' can take one of the following values:</p><ul>
<li>UART_NO_SOFTWARE_FLOW_CONTROL - To disable Software Flow control<br />
</li>
<li>UART_TX_RX_XON1_XOFF1 - Transmitter transmits XON1, XOFF1; Receiver expects XON1, XOFF1<br />
</li>
<li>UART_TX_RX_XON2_XOFF2 - Transmitter transmits XON2, XOFF2; Receiver expects XON2, XOFF2<br />
</li>
<li>UART_TX_RX_XON1_XOFF1_XON2_XOFF2 - Transmitter transmits XON1,XON2, XOFF1 and XOFF2; Receiver expects XON1,XON2, XOFF1, XOFF2<br />
 <dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API switches the UART to Configuration Mode B, programs SWFLOWCONTROL field in EFR and reverts the UART back to the original mode of operation. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga669fd98ae5d873f04de48c9287e829fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTSpaceAvail </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API checks whether the TX FIFO (or THR in non-FIFO mode) is empty or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE - if the Transmitter FIFO(or THR in non-FIFO mode) is empty. FALSE - if the Transmitter FIFO(or THR in non-FIFO mode) is not empty.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaaff7d75c1f3b2e91716ea127fbd379b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTSpecialCharDetectControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls the feature of detecting a Special Character arriving in the receiver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">controlFlag</td><td>This specifies whether to enable or disable detection of Special Character.</td></tr>
  </table>
  </dd>
</dl>
<p>'controlFlag' can take either of the following two values:<br />
</p><ul>
<li>UART_SPECIAL_CHAR_DETECT_DISABLE - to disable detection of Special Character<br />
</li>
<li>UART_SPECIAL_CHAR_DETECT_ENABLE - to enable detection of Special Character<br />
 <dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API switches the UART to Configuration Mode B, programs SPECIALCHARDETECT field in EFR and reverts the UART back to the original mode of operation. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gac2cf4a1d681f19af614449954739966b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTSubConfigMSRSPRModeEn </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the MSR_SPR Sub-Configuration Mode of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the TCRTLR bit in MCR (MCR[6]) before it is modified in this API.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>1&gt; Each Register configuration mode(A, B and operational) has further sub-configuration modes corresponding to accesses to offset addresses 0x18 and 0x1C. They are:<br />
 For Register Configuration Mode A:<br />
 1&gt; MSR_SPR: EFR[4] = 0 or MCR[6] = 0<br />
 2&gt; TCR_TLR: EFR[4] = 1 and MCR[6] = 1<br />
 For Register Configuration Mode B:<br />
 1&gt; TCR_TLR - EFR[4] = 1 and MCR[6] = 1<br />
 2&gt; XOFF - EFR[4] = 0 or MCR[6] = 0<br />
 For Register Operational Mode:<br />
 1&gt; MSR_SPR - EFR[4] = 0 or MCR[6] = 0<br />
 2&gt; TCR_TLR - EFR[4] = 1 and MCR[6] = 1<br />
 In any configuration mode, enabling one of the sub-configuration mode would disable access to the registers of the other sub-configuration mode.<br />
 2&gt; The current API enables access to Modem Status Register(MSR) and Scratch Pad Register(SPR). This is applicable for Register Configuration Mode A and Operational mode of operation.<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga25d90dd46b42106ffabb9bf83d7446cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTSubConfigTCRTLRModeEn </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the TCR_TLR Sub_Configuration Mode of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the TCRTLR bit in MCR (MCR[6]) before it is modified in this API.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current API enables access to Transmission Control Register(TCR) and Trigger Level Register(TLR). This is applicable for all the three register configuration modes. Refer to the comments of <a class="el" href="group___c_s_l___u_a_r_t.html#gac2cf4a1d681f19af614449954739966b" title="This API enables the MSR_SPR Sub-Configuration Mode of operation. ">UARTSubConfigMSRSPRModeEn()</a> API for more details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13788f3465f5dbe3183b0fa1602483a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTSubConfigXOFFModeEn </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the XOFF Sub-Configuration Mode of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the TCRTLR bit in MCR (MCR[6]) before it is modified in this API.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current API enables access to the XOFF (XOFF1 and XOFF2) registers. The XOFF registers can be accessed in Register Configuration Mode B of operation. Refer to the comments of <a class="el" href="group___c_s_l___u_a_r_t.html#gac2cf4a1d681f19af614449954739966b" title="This API enables the MSR_SPR Sub-Configuration Mode of operation. ">UARTSubConfigMSRSPRModeEn()</a> API for more details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga33dd96e5cdbb06fef0c58d57f2e7baf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTTCRTLRBitValRestore </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tcrTlrBitVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API restores the TCRTLR bit(MCR[6]) value in Modem Control Register(MCR) to the corresponding bit value in 'tcrTlrBitVal' passed as a parameter to this API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">tcrTlrBitVal</td><td>The 6th bit in this 32-bit value shall hold a value to which the TCRTLR bit(MCR[6]) of MCR has to be restored to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga81860bc183410362ec4d25abe68f36a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTTxDMAThresholdControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thrsCtrlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function controls the method of setting the Transmit DMA Threshold Value. The Transmit DMA Threshold Value can be set to a default value of 64 characters or can take the value in TX_DMA_THRESHOLD register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">thrsCtrlFlag</td><td>A value which signifies the method of setting the Transmit DMA Threshold Value.</td></tr>
  </table>
  </dd>
</dl>
<p>'thrsCtrlFlag' can take one of the following values:<br />
</p><ul>
<li>UART_TX_DMA_THRESHOLD_64 - for 64 characters TX DMA Threshold value<br />
</li>
<li>UART_TX_DMA_THRESHOLD_REG - for Transmit DMA Threshold value to be the value in TX_DMA_THRESHOLD register.<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga382408d0252b77ae5996d9fcff9def92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTTxDMAThresholdValConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thrsValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the TX_DMA_THRESHOLD register which holds Transmit DMA Threshold value to be used. When a TX DMA Threshold value other than 64 characters is required, this function can be used to program the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">thrsValue</td><td>The Transmit DMA Threshold Value.</td></tr>
  </table>
  </dd>
</dl>
<p>'thrsValue' can take one of the following value - (0 &lt;= thrsValue &lt;= 63).<br />
 </p><dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f22914d9b985081a37b04c6429fdfa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTTxEmptyIntControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to choose a condition under which a Transmit Holding Register(THR) Interrupt should occur. A THR interrupt can be configured to occur either when:<br />
 1&gt; TX FIFO becoming empty OR<br />
 2&gt; TX FIFO and TX Shift register becoming empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used </td></tr>
    <tr><td class="paramname">controlFlag</td><td>This specifies the condition under which a Transmitter Holding Register Interrupt should occur.</td></tr>
  </table>
  </dd>
</dl>
<p>'controlFlag' can take either of the following two values:</p><ul>
<li>UART_THR_INT_NORMAL - for THR Interrupt to be raised under normal conditions(guided by the TX FIFO Threshold value)<br />
</li>
<li>UART_THR_INT_FIFO_TSR_EMPTY - for THR Interrupt to be raised when both Transmitter FIFO and Transmitter Shift Register are empty<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gaaf6a8b466ba0dcc623dbbb81e94b5b06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTTxFIFOFullStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines whether the Transmitter FIFO is full or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns either of the following values:<ul>
<li>UART_TX_FIFO_NOT_FULL - indicating that the TX FIFO is not full<br />
</li>
<li>UART_TX_FIFO_FULL - indicating that the TX FIFO is full<br />
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad29a6269235ceb56e4e9db6c9ae1a9d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UARTTxFIFOLevelGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API determines the current level of the Transmitter FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current level of the Transmitter FIFO. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d4f7704b508475a36144ed595bcc1c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTWakeUpControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to control(enable/disable) the Wake-Up feature of the UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">controlFlag</td><td>This specifies whether the Wake Up feature should be enabled or disabled for the UART instance</td></tr>
  </table>
  </dd>
</dl>
<p>'controlFlag' can take one of the following two values:</p><ul>
<li>UART_WAKEUP_ENABLE - to enable Wake-Up feature<br />
</li>
<li>UART_WAKEUP_DISABLE - to disable Wake-Up feature<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga9c59236b00585fe48fef822b48ae2a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTWakeUpEventsDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeUpFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the Wake-Up capability for the specified events. On disabling Wake-Up capability for them, the occurence of the corresponding event shall not wake up the system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">wakeUpFlag</td><td>This specifies the event(s) for which Wake-Up capability needs to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>'wakeUpFlag' can take one or a combination of the following values:</p><ul>
<li>UART_WAKEUP_TX_INTERRUPT - disabling THR, TXDMA and TXSTATUS interrupts to wake up the system<br />
</li>
<li>UART_WAKEUP_RLS_INTERRUPT - disabling the Receiver Line Status interrupt to wake up the system<br />
</li>
<li>UART_WAKEUP_RHR_INTERRUPT - disabling the RHR interrupt(RX FIFO threshold level reached) to wake up the system<br />
</li>
<li>UART_WAKEUP_RX_ACTIVITY - disabling any activity on the Receiver line (RX) to wake up the system<br />
</li>
<li>UART_WAKEUP_DCD_ACTIVITY - disabling any activity on DCD line to wake up the system<br />
</li>
<li>UART_WAKEUP_RI_ACTIVITY - disabling any activity on RI line to wake up the system<br />
</li>
<li>UART_WAKEUP_DSR_ACTIVITY - disabling any acivity on DSR line to wake up the system<br />
</li>
<li>UART_WAKEUP_CTS_ACTIVITY - disabling any activity on CTS line to wake up the system<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gad79e79a94033753b1414ddd08cfa8cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTWakeUpEventsEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeUpFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the Wake-Up capability for the specified events. On enabling Wake-Up capability for them, the occurence of the corresponding event shall wake up the system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">wakeUpFlag</td><td>This specifies the event(s) for which Wake-Up capability needs to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>'wakeUpFlag' can take one or a combination of the following values:</p><ul>
<li>UART_WAKEUP_TX_INTERRUPT - enabling THR, TXDMA and TXSTATUS interrupts to wake up the system<br />
</li>
<li>UART_WAKEUP_RLS_INTERRUPT - enabling the Receiver Line Status interrupt to wake up the system<br />
</li>
<li>UART_WAKEUP_RHR_INTERRUPT - enabling the RHR interrupt(RX FIFO threshold level reached) to wake up the system<br />
</li>
<li>UART_WAKEUP_RX_ACTIVITY - enabling any activity on the Receiver line (RX) to wake up the system<br />
</li>
<li>UART_WAKEUP_DCD_ACTIVITY - enabling any activity on DCD line to wake up the system<br />
</li>
<li>UART_WAKEUP_RI_ACTIVITY - enabling any activity on RI line to wake up the system<br />
</li>
<li>UART_WAKEUP_DSR_ACTIVITY - enabling any acivity on DSR line to wake up the system<br />
</li>
<li>UART_WAKEUP_CTS_ACTIVITY - enabling any activity on CTS line to wake up the system<br />
 <dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga81156b31b6cd21d88a58e9af38cec993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTXON1XOFF1ValProgram </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>xon1Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>xoff1Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API programs the XON1/ADDR1 and XOFF1 registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">xon1Value</td><td>The XON1 character. </td></tr>
    <tr><td class="paramname">xoff1Value</td><td>The XOFF1 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In UART mode, the character in XON1/ADDR1 register is the XON1 character. In IrDA mode, this is the address ADDR1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6634a6de9dd264c75c1109dd010d8068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTXON2XOFF2ValProgram </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>xon2Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>xoff2Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API programs the XON2/ADDR2 and XOFF2 registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">xon2Value</td><td>The XON2 character. </td></tr>
    <tr><td class="paramname">xoff2Value</td><td>The XOFF2 character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In UART mode, the character in XON2/ADDR2 register is the XON2 character. In IrDA mode, this is the address ADDR2. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf8a4caebd7b63e7d34817b7a1e87fe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UARTXONAnyFeatureControl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controlFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls(enables/disables) the XON-any feature in Modem Control Register(MCR). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Memory address of the UART instance being used. </td></tr>
    <tr><td class="paramname">controlFlag</td><td>This specifies whether to enable or disable XON any feature 'xonAnyControl' can take one of the following values:<ul>
<li>UART_XON_ANY_ENABLE - to enable XON any functionality<br />
</li>
<li>UART_XON_ANY_DISABLE - to disable XON any functionality<br />
 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When XON-any feature is enabled, the transmission will resume after receiving any character after recognizing the XOFF character. The XON-any character is written into the RX FIFO even if it is a software flow character.<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
