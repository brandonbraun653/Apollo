<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IPC Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IPC Functions<div class="ingroups"><a class="el" href="group___c_s_l___i_p_c___a_p_i.html">IPC</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1915b5f313e963e225cd7c9494ba9d92"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#ga1915b5f313e963e225cd7c9494ba9d92">CSL_IPC_genNMIEvent</a> (Uint32 index)</td></tr>
<tr class="separator:ga1915b5f313e963e225cd7c9494ba9d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa57b6f02072faafab3f58baa189b8b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#gadfa57b6f02072faafab3f58baa189b8b">CSL_IPC_genGEMInterrupt</a> (Uint32 index, Uint32 srcId)</td></tr>
<tr class="separator:gadfa57b6f02072faafab3f58baa189b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e4d7c3f762d742336a6554e6cd3b331"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#ga0e4d7c3f762d742336a6554e6cd3b331">CSL_IPC_isGEMInterruptSourceSet</a> (Uint32 index, Uint32 srcId)</td></tr>
<tr class="separator:ga0e4d7c3f762d742336a6554e6cd3b331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720d4944ea87e5ff05f73aebdd90e16d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#ga720d4944ea87e5ff05f73aebdd90e16d">CSL_IPC_isGEMInterruptAckSet</a> (Uint32 index, Uint32 srcId)</td></tr>
<tr class="separator:ga720d4944ea87e5ff05f73aebdd90e16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949e2b6800612ed7e6bd60cbcea74626"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#ga949e2b6800612ed7e6bd60cbcea74626">CSL_IPC_clearGEMInterruptSource</a> (Uint32 index, Uint32 srcId)</td></tr>
<tr class="separator:ga949e2b6800612ed7e6bd60cbcea74626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635835d80efff84fda3ddc90a8671f92"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#ga635835d80efff84fda3ddc90a8671f92">CSL_IPC_genHostInterrupt</a> (Uint32 srcId)</td></tr>
<tr class="separator:ga635835d80efff84fda3ddc90a8671f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14edebc0a54dd95c169166e966805de2"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#ga14edebc0a54dd95c169166e966805de2">CSL_IPC_isHostInterruptSourceSet</a> (Uint32 srcId)</td></tr>
<tr class="separator:ga14edebc0a54dd95c169166e966805de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1946a50055d1f8e29c2d9dfea5b7841"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#gae1946a50055d1f8e29c2d9dfea5b7841">CSL_IPC_isHostInterruptAckSet</a> (Uint32 srcId)</td></tr>
<tr class="separator:gae1946a50055d1f8e29c2d9dfea5b7841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4fbd34a6bfb8c7d9c97eee9ead769b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___i_p_c___f_u_n_c_t_i_o_n.html#ga6b4fbd34a6bfb8c7d9c97eee9ead769b">CSL_IPC_clearHostInterruptSource</a> (Uint32 srcId)</td></tr>
<tr class="separator:ga6b4fbd34a6bfb8c7d9c97eee9ead769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga949e2b6800612ed7e6bd60cbcea74626"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_IPC_clearGEMInterruptSource </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>srcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_clearGEMInterruptSource</b> </p>
<p><b>Description</b> <br />
 This function clears the interrupt source IDs by setting the SRCCx bit of the IPC Acknowledgment Register (IPCARx) and SRCSx bit of IPC Generation Register (IPCGRx) corresponding to the GEM index and Source ID specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       GEM number for which the interrupt surce is to be cleared.
     srcId       Indicates which of the 0-27 SRCSx/SRCCx bits needs to be cleared
                 in the IPCGRx/IPCARx registers corresponding to the index specified. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 SRCSx/SRCCx bits in the corresponding IPCGRx/IPCARx register are cleared.</p>
<p><b>Writes</b> <br />
 IPC_IPCAR_SRCC0=0; IPC_IPCAR_SRCC1=0; IPC_IPCAR_SRCC2=0; IPC_IPCAR_SRCC3=0; IPC_IPCAR_SRCC4=0; IPC_IPCAR_SRCC5=0; IPC_IPCAR_SRCC6=0; IPC_IPCAR_SRCC7=0; IPC_IPCAR_SRCC8=0; IPC_IPCAR_SRCC9=0; IPC_IPCAR_SRCC10=0; IPC_IPCAR_SRCC11=0; IPC_IPCAR_SRCC12=0; IPC_IPCAR_SRCC13=0; IPC_IPCAR_SRCC14=0; IPC_IPCAR_SRCC15=0; IPC_IPCAR_SRCC16=0; IPC_IPCAR_SRCC17=0; IPC_IPCAR_SRCC18=0; IPC_IPCAR_SRCC19=0; IPC_IPCAR_SRCC20=0; IPC_IPCAR_SRCC21=0; IPC_IPCAR_SRCC22=0; IPC_IPCAR_SRCC23=0; IPC_IPCAR_SRCC24=0; IPC_IPCAR_SRCC25=0; IPC_IPCAR_SRCC26=0; IPC_IPCAR_SRCC27=0</p>
<p><b>Affects</b> <br />
 IPC_IPCGR_SRCS0=0, IPC_IPCGR_SRCS1=0; IPC_IPCGR_SRCS2=0; IPC_IPCGR_SRCS3=0; IPC_IPCGR_SRCS4=0; IPC_IPCGR_SRCS5=0; IPC_IPCGR_SRCS6=0; IPC_IPCGR_SRCS7=0; IPC_IPCGR_SRCS8=0; IPC_IPCGR_SRCS9=0; IPC_IPCGR_SRCS10=0; IPC_IPCGR_SRCS11=0; IPC_IPCGR_SRCS12=0; IPC_IPCGR_SRCS13=0; IPC_IPCGR_SRCS14=0; IPC_IPCGR_SRCS15=0; IPC_IPCGR_SRCS16=0; IPC_IPCGR_SRCS17=0; IPC_IPCGR_SRCS18=0; IPC_IPCGR_SRCS19=0; IPC_IPCGR_SRCS20=0; IPC_IPCGR_SRCS21=0; IPC_IPCGR_SRCS22=0; IPC_IPCGR_SRCS23=0; IPC_IPCGR_SRCS24=0; IPC_IPCGR_SRCS25=0; IPC_IPCGR_SRCS26=0; IPC_IPCGR_SRCS27=0</p>
<p><b>Example</b> </p><pre class="fragment">     Example 1: Clear the interrupt for Gem 1 raised by Gem 2. 
     Uint32     index = 1;
     Uint32     srcId = 2;

     CSL_IPC_clearGEMInterruptSource (index, srcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6b4fbd34a6bfb8c7d9c97eee9ead769b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_IPC_clearHostInterruptSource </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>srcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_clearHostInterruptSource</b> </p>
<p><b>Description</b> <br />
 This function clears the interrupt source IDs by setting the SRCCx bit of the Host IPC Acknowledgment Register (IPCARH) and SRCSx bit of Host IPC Generation Register (IPCGRH) corresponding to the Source ID specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">     srcId       Indicates which of the 0-27 SRCSx/SRCCx bits needs to be cleared
                 in the IPCGRH/IPCARH registers. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 SRCSx/SRCCx bits in the corresponding IPCGRH/IPCARH register are cleared.</p>
<p><b>Writes</b> <br />
 IPC_IPCARH_SRCC0=0; IPC_IPCARH_SRCC1=0; IPC_IPCARH_SRCC2=0; IPC_IPCARH_SRCC3=0; IPC_IPCARH_SRCC4=0; IPC_IPCARH_SRCC5=0; IPC_IPCARH_SRCC6=0; IPC_IPCARH_SRCC7=0; IPC_IPCARH_SRCC8=0; IPC_IPCARH_SRCC9=0; IPC_IPCARH_SRCC10=0; IPC_IPCARH_SRCC11=0; IPC_IPCARH_SRCC12=0; IPC_IPCARH_SRCC13=0; IPC_IPCARH_SRCC14=0; IPC_IPCARH_SRCC15=0; IPC_IPCARH_SRCC16=0; IPC_IPCARH_SRCC17=0; IPC_IPCARH_SRCC18=0; IPC_IPCARH_SRCC19=0; IPC_IPCARH_SRCC20=0; IPC_IPCARH_SRCC21=0; IPC_IPCARH_SRCC22=0; IPC_IPCARH_SRCC23=0; IPC_IPCARH_SRCC24=0; IPC_IPCARH_SRCC25=0; IPC_IPCARH_SRCC26=0; IPC_IPCARH_SRCC27=0</p>
<p><b>Affects</b> <br />
 IPC_IPCGRH_SRCS0=0; IPC_IPCGRH_SRCS1=0; IPC_IPCGRH_SRCS2=0; IPC_IPCGRH_SRCS3=0; IPC_IPCGRH_SRCS4=0; IPC_IPCGRH_SRCS5=0; IPC_IPCGRH_SRCS6=0; IPC_IPCGRH_SRCS7=0; IPC_IPCGRH_SRCS8=0; IPC_IPCGRH_SRCS9=0; IPC_IPCGRH_SRCS10=0; IPC_IPCGRH_SRCS11=0; IPC_IPCGRH_SRCS12=0; IPC_IPCGRH_SRCS13=0; IPC_IPCGRH_SRCS14=0; IPC_IPCGRH_SRCS15=0; IPC_IPCGRH_SRCS16=0; IPC_IPCGRH_SRCS17=0; IPC_IPCGRH_SRCS18=0; IPC_IPCGRH_SRCS19=0; IPC_IPCGRH_SRCS20=0; IPC_IPCGRH_SRCS21=0; IPC_IPCGRH_SRCS22=0; IPC_IPCGRH_SRCS23=0; IPC_IPCGRH_SRCS24=0; IPC_IPCGRH_SRCS25=0; IPC_IPCGRH_SRCS26=0; IPC_IPCGRH_SRCS27=0;</p>
<p><b>Example</b> </p><pre class="fragment">     Example 1: Clear the host interrupt raised by Gem 2. 
     Uint32     srcId = 2;

     CSL_IPC_clearHostInterruptSource (srcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadfa57b6f02072faafab3f58baa189b8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_IPC_genGEMInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>srcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_genGEMInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the IPCG bit of the IPC Generation Register (IPCGRx) to create an inter-DSP pulse to the GEM corresponding to the index specified here. This API also configures the source ID for this interrupt by setting the SRCSx bit of the IPCGRx register based on the source ID specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       GEM number for which the interrupt is to be raised.
     srcId       Indicates which of the 0-27 SRCSx bits needs to be set 
                 in the IPCGRx registers corresponding to the index specified. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 IPCG and SRCSx/SRCCx bits in the corresponding IPCGRx/IPCARx register configured.</p>
<p><b>Writes</b> <br />
 IPC_IPCGR_IPCG=1, IPC_IPCGR_SRCS0=1; IPC_IPCGR_SRCS1=1; IPC_IPCGR_SRCS2=1; IPC_IPCGR_SRCS3=1; IPC_IPCGR_SRCS4=1; IPC_IPCGR_SRCS5=1; IPC_IPCGR_SRCS6=1; IPC_IPCGR_SRCS7=1; IPC_IPCGR_SRCS8=1; IPC_IPCGR_SRCS9=1; IPC_IPCGR_SRCS10=1; IPC_IPCGR_SRCS11=1; IPC_IPCGR_SRCS12=1; IPC_IPCGR_SRCS13=1; IPC_IPCGR_SRCS14=1; IPC_IPCGR_SRCS15=1; IPC_IPCGR_SRCS16=1; IPC_IPCGR_SRCS17=1; IPC_IPCGR_SRCS18=1; IPC_IPCGR_SRCS19=1; IPC_IPCGR_SRCS20=1; IPC_IPCGR_SRCS21=1; IPC_IPCGR_SRCS22=1; IPC_IPCGR_SRCS23=1; IPC_IPCGR_SRCS24=1; IPC_IPCGR_SRCS25=1; IPC_IPCGR_SRCS26=1; IPC_IPCGR_SRCS27=1;</p>
<p><b>Affects</b> <br />
 IPC_IPCAR_SRCC0=1; IPC_IPCAR_SRCC1=1; IPC_IPCAR_SRCC2=1; IPC_IPCAR_SRCC3=1; IPC_IPCAR_SRCC4=1; IPC_IPCAR_SRCC5=1; IPC_IPCAR_SRCC6=1; IPC_IPCAR_SRCC7=1; IPC_IPCAR_SRCC8=1; IPC_IPCAR_SRCC9=1; IPC_IPCAR_SRCC10=1; IPC_IPCAR_SRCC11=1; IPC_IPCAR_SRCC12=1; IPC_IPCAR_SRCC13=1; IPC_IPCAR_SRCC14=1; IPC_IPCAR_SRCC15=1; IPC_IPCAR_SRCC16=1; IPC_IPCAR_SRCC17=1; IPC_IPCAR_SRCC18=1; IPC_IPCAR_SRCC19=1; IPC_IPCAR_SRCC20=1; IPC_IPCAR_SRCC21=1; IPC_IPCAR_SRCC22=1; IPC_IPCAR_SRCC23=1; IPC_IPCAR_SRCC24=1; IPC_IPCAR_SRCC25=1; IPC_IPCAR_SRCC26=1; IPC_IPCAR_SRCC27=1</p>
<p><b>Example</b> </p><pre class="fragment">     Example 1: An application running on GEM 2 is trying to raise
     an interrupt to Gem 1. The source Id for Gem 2 say is 2. 
     Uint32     index = 1;
     Uint32     srcId = 2;

     CSL_IPC_genGEMInterrupt (index, srcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga635835d80efff84fda3ddc90a8671f92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_IPC_genHostInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>srcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_genHostInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the IPCG bit of the Host IPC Generation Register (IPCGRH) to create an interrupt pulse on the device pin. This API also configures the source ID for this interrupt by setting the SRCSx bit of the IPCGRHx register based on the source ID specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">     srcId       Indicates which of the 0-27 SRCSx bits needs to be set 
                 in the IPCGRH register. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 IPCG and SRCSx/SRCCx bits in the IPCGRH/IPCARH register configured.</p>
<p><b>Writes</b> <br />
 IPC_IPCGRH_IPCG=1, IPC_IPCGRH_SRCS0=1; IPC_IPCGRH_SRCS1=1; IPC_IPCGRH_SRCS2=1; IPC_IPCGRH_SRCS3=1; IPC_IPCGRH_SRCS4=1; IPC_IPCGRH_SRCS5=1; IPC_IPCGRH_SRCS6=1; IPC_IPCGRH_SRCS7=1; IPC_IPCGRH_SRCS8=1; IPC_IPCGRH_SRCS9=1; IPC_IPCGRH_SRCS10=1; IPC_IPCGRH_SRCS11=1; IPC_IPCGRH_SRCS12=1; IPC_IPCGRH_SRCS13=1; IPC_IPCGRH_SRCS14=1; IPC_IPCGRH_SRCS15=1; IPC_IPCGRH_SRCS16=1; IPC_IPCGRH_SRCS17=1; IPC_IPCGRH_SRCS18=1; IPC_IPCGRH_SRCS19=1; IPC_IPCGRH_SRCS20=1; IPC_IPCGRH_SRCS21=1; IPC_IPCGRH_SRCS22=1; IPC_IPCGRH_SRCS23=1; IPC_IPCGRH_SRCS24=1; IPC_IPCGRH_SRCS25=1; IPC_IPCGRH_SRCS26=1; IPC_IPCGRH_SRCS27=1</p>
<p><b>Affects</b> IPC_IPCARH_SRCC0=1; IPC_IPCARH_SRCC1=1; IPC_IPCARH_SRCC2=1; IPC_IPCARH_SRCC3=1; IPC_IPCARH_SRCC4=1; IPC_IPCARH_SRCC5=1; IPC_IPCARH_SRCC6=1; IPC_IPCARH_SRCC7=1; IPC_IPCARH_SRCC8=1; IPC_IPCARH_SRCC9=1; IPC_IPCARH_SRCC10=1; IPC_IPCARH_SRCC11=1; IPC_IPCARH_SRCC12=1; IPC_IPCARH_SRCC13=1; IPC_IPCARH_SRCC14=1; IPC_IPCARH_SRCC15=1; IPC_IPCARH_SRCC16=1; IPC_IPCARH_SRCC17=1; IPC_IPCARH_SRCC18=1; IPC_IPCARH_SRCC19=1; IPC_IPCARH_SRCC20=1; IPC_IPCARH_SRCC21=1; IPC_IPCARH_SRCC22=1; IPC_IPCARH_SRCC23=1; IPC_IPCARH_SRCC24=1; IPC_IPCARH_SRCC25=1; IPC_IPCARH_SRCC26=1; IPC_IPCARH_SRCC27=1</p>
<p><b>Example</b> </p><pre class="fragment">     Example 1: An application running on GEM 2 is trying to raise
     a host interrupt. 
     Uint32     srcId = 2;

     CSL_IPC_genHostInterrupt (srcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1915b5f313e963e225cd7c9494ba9d92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_IPC_genNMIEvent </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_genNMIEvent</b> </p>
<p><b>Description</b> <br />
 This function sets the NMIG bit of the NMI Generation Register (NMIGRx) to create an NMI pulse to the GEM corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       GEM number for which the NMI event is to be raised.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 NMIG bit in the corresponding NMIGRx register configured.</p>
<p><b>Writes</b> <br />
 IPC_NMIGR_NMIG=1</p>
<p><b>Example</b> </p><pre class="fragment">     Example 1: Raise an NMI interrupt to Gem 2
     Uint32 index = 2;

     CSL_IPC_genNMIEvent (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga720d4944ea87e5ff05f73aebdd90e16d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_IPC_isGEMInterruptAckSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>srcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_isGEMInterruptAckSet</b> </p>
<p><b>Description</b> <br />
 This function checks if the SRCCx bit of the IPCARx register is set. It returns 1 if the SRCCx bit corresponding to the srcId is set in the IPCARx register corresponding to the index specified. Otherwise it returns 0.</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       GEM number for which the IPCARx register needs to be checked.
     srcId       Indicates which of the 0-27 SRCCx bits needs to be read 
                 in the IPCARx registers corresponding to the index specified. </pre><p><b> Return Value </b> <br />
 1 - Indicates that the corresponding SRCCx bit is set and the srcId specified is in fact the source for the IPC Gem interrupt. <br />
 0 - Indicates that corresponding SRCCx bit not set and the srcId specified is not the IPC source.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 IPC_IPCAR_SRCC0; IPC_IPCAR_SRCC1; IPC_IPCAR_SRCC2; IPC_IPCAR_SRCC3; IPC_IPCAR_SRCC4; IPC_IPCAR_SRCC5; IPC_IPCAR_SRCC6; IPC_IPCAR_SRCC7; IPC_IPCAR_SRCC8; IPC_IPCAR_SRCC9; IPC_IPCAR_SRCC10; IPC_IPCAR_SRCC11; IPC_IPCAR_SRCC12; IPC_IPCAR_SRCC13; IPC_IPCAR_SRCC14; IPC_IPCAR_SRCC15; IPC_IPCAR_SRCC16; IPC_IPCAR_SRCC17; IPC_IPCAR_SRCC18; IPC_IPCAR_SRCC19; IPC_IPCAR_SRCC20; IPC_IPCAR_SRCC21; IPC_IPCAR_SRCC22; IPC_IPCAR_SRCC23; IPC_IPCAR_SRCC24; IPC_IPCAR_SRCC25; IPC_IPCAR_SRCC26; IPC_IPCAR_SRCC27</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32  index = 1;
     Uint32  srcId = 2;
     Uint32  retVal;

     retVal = CSL_IPC_isGEMInterruptAckSet (index, srcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0e4d7c3f762d742336a6554e6cd3b331"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_IPC_isGEMInterruptSourceSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>srcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_isGEMInterruptSourceSet</b> </p>
<p><b>Description</b> <br />
 This function checks if the SRCSx bit of the IPCGRx register is set. It returns 1 if the SRCSx bit corresponding to the srcId is set in the IPCGRx register corresponding to the index specified. Otherwise it returns 0.</p>
<p><b>Arguments</b> </p><pre class="fragment">     index       GEM number for which the IPCGRx register needs to be checked.
     srcId       Indicates which of the 0-27 SRCSx bits needs to be read 
                 in the IPCGRx registers corresponding to the index specified. </pre><p><b> Return Value </b> <br />
 1 - Indicates that the corresponding SRCSx bit is set and the srcId specified is in fact the source for the IPC Gem interrupt. <br />
 0 - Indicates that corresponding SRCSx bit not set and the srcId specified is not the IPC source.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 IPC_IPCGR_SRCS0; IPC_IPCGR_SRCS1; IPC_IPCGR_SRCS2; IPC_IPCGR_SRCS3; IPC_IPCGR_SRCS4; IPC_IPCGR_SRCS5; IPC_IPCGR_SRCS6; IPC_IPCGR_SRCS7; IPC_IPCGR_SRCS8; IPC_IPCGR_SRCS9; IPC_IPCGR_SRCS10; IPC_IPCGR_SRCS11; IPC_IPCGR_SRCS12; IPC_IPCGR_SRCS13; IPC_IPCGR_SRCS14; IPC_IPCGR_SRCS15; IPC_IPCGR_SRCS16; IPC_IPCGR_SRCS17; IPC_IPCGR_SRCS18; IPC_IPCGR_SRCS19; IPC_IPCGR_SRCS20; IPC_IPCGR_SRCS21; IPC_IPCGR_SRCS22; IPC_IPCGR_SRCS23; IPC_IPCGR_SRCS24; IPC_IPCGR_SRCS25; IPC_IPCGR_SRCS26; IPC_IPCGR_SRCS27</p>
<p><b>Example</b> </p><pre class="fragment">     Example 1: An application running on Gem 1 received an interrupt and
     wants to check if the interrupt was from the core it was waiting on, 
     i.e., the Gem 2.

     Uint32     index = 1;
     Uint32     srcId = 2;
     Uint32     retVal;

     retVal = CSL_IPC_isGEMInterruptSourceSet (index, srcId);
     
     if (retVal == 0)
     {
        ...             // Maybe cotinue waiting for the IPC/message
        }
        else
        {
                ...             // Do the needful processing.
        }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae1946a50055d1f8e29c2d9dfea5b7841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_IPC_isHostInterruptAckSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>srcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_isHostInterruptAckSet</b> </p>
<p><b>Description</b> <br />
 This function checks if the SRCCx bit of the IPCARH register is set. It returns 1 if the SRCCx bit corresponding to the srcId is set in the IPCARH register. Otherwise it returns 0.</p>
<p><b>Arguments</b> </p><pre class="fragment">     srcId       Indicates which of the 0-27 SRCCx bits needs to be read 
                 in the IPCARH register. </pre><p><b> Return Value </b> <br />
 1 - Indicates that the corresponding SRCCx bit is set and the srcId specified is in fact the source for the IPC Host interrupt. <br />
 0 - Indicates that corresponding SRCCx bit not set and the srcId specified is not the IPC source.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 IPC_IPCARH_SRCC0; IPC_IPCARH_SRCC1; IPC_IPCARH_SRCC2; IPC_IPCARH_SRCC3; IPC_IPCARH_SRCC4; IPC_IPCARH_SRCC5; IPC_IPCARH_SRCC6; IPC_IPCARH_SRCC7; IPC_IPCARH_SRCC8; IPC_IPCARH_SRCC9; IPC_IPCARH_SRCC10; IPC_IPCARH_SRCC11; IPC_IPCARH_SRCC12; IPC_IPCARH_SRCC13; IPC_IPCARH_SRCC14; IPC_IPCARH_SRCC15; IPC_IPCARH_SRCC16; IPC_IPCARH_SRCC17; IPC_IPCARH_SRCC18; IPC_IPCARH_SRCC19; IPC_IPCARH_SRCC20; IPC_IPCARH_SRCC21; IPC_IPCARH_SRCC22; IPC_IPCARH_SRCC23; IPC_IPCARH_SRCC24; IPC_IPCARH_SRCC25; IPC_IPCARH_SRCC26; IPC_IPCARH_SRCC27</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32  srcId = 2;
     Uint32  retVal;

     retVal = CSL_IPC_isHostInterruptAckSet (srcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga14edebc0a54dd95c169166e966805de2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_IPC_isHostInterruptSourceSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>srcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_IPC_isHostInterruptSourceSet</b> </p>
<p><b>Description</b> <br />
 This function checks if the SRCSx bit of the IPCGRH register is set. It returns 1 if the SRCSx bit corresponding to the srcId is set in the IPCGRH register. Otherwise it returns 0.</p>
<p><b>Arguments</b> </p><pre class="fragment">     srcId       Indicates which of the 0-27 SRCSx bits needs to be read 
                 in the IPCGRH register. </pre><p><b> Return Value </b> <br />
 1 - Indicates that the corresponding SRCSx bit is set and the srcId specified is in fact the source for the IPC Host interrupt. <br />
 0 - Indicates that corresponding SRCSx bit not set and the srcId specified is not the IPC source.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 IPC_IPCGRH_SRCS0; IPC_IPCGRH_SRCS1; IPC_IPCGRH_SRCS2; IPC_IPCGRH_SRCS3; IPC_IPCGRH_SRCS4; IPC_IPCGRH_SRCS5; IPC_IPCGRH_SRCS6; IPC_IPCGRH_SRCS7; IPC_IPCGRH_SRCS8; IPC_IPCGRH_SRCS9; IPC_IPCGRH_SRCS10; IPC_IPCGRH_SRCS11; IPC_IPCGRH_SRCS12; IPC_IPCGRH_SRCS13; IPC_IPCGRH_SRCS14; IPC_IPCGRH_SRCS15; IPC_IPCGRH_SRCS16; IPC_IPCGRH_SRCS17; IPC_IPCGRH_SRCS18; IPC_IPCGRH_SRCS19; IPC_IPCGRH_SRCS20; IPC_IPCGRH_SRCS21; IPC_IPCGRH_SRCS22; IPC_IPCGRH_SRCS23; IPC_IPCGRH_SRCS24; IPC_IPCGRH_SRCS25; IPC_IPCGRH_SRCS26; IPC_IPCGRH_SRCS27</p>
<p><b>Example</b> </p><pre class="fragment">     Example 1: Check if the host interrupt's source was set correctly
     to 2, i.e., the Gem 2 the source of the host interrupt.

     Uint32     srcId = 2;
     Uint32     retVal;

     retVal = CSL_IPC_isHostInterruptSourceSet (srcId);
     
     if (retVal == 0)
     {
         ...            // Do something.
     }
     else
     {
         ...            // Do the needful processing.
     }</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
