<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CPSW Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CPSW Functions<div class="ingroups"><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v0.html">Ethernet switch submodule (CPSW - V0)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v1.html">Ethernet switch submodule (CPSW - V1)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v2.html">Ethernet switch submodule (CPSW - V2)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v3.html">Ethernet switch submodule (CPSW - V3)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v4.html">Ethernet switch submodule (CPSW - V4)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v0.html">Ethernet switch submodule (CPSW - V0)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v1.html">Ethernet switch submodule (CPSW - V1)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v2.html">Ethernet switch submodule (CPSW - V2)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v3.html">Ethernet switch submodule (CPSW - V3)</a><a class="el" href="group___c_s_l___c_p_s_w___a_p_i.html">Ethernet switch submodule (CPSW)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___a_p_i___v4.html">Ethernet switch submodule (CPSW - V4)</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w___d_a_t_a_s_t_r_u_c_t.html">CPSW Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa19b06c8ea11eccdbc6b7c8ea14c31e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa19b06c8ea11eccdbc6b7c8ea14c31e5">CSL_CPSW_getCpswVersionInfo</a> (<a class="el" href="struct_c_s_l___c_p_s_w___v_e_r_s_i_o_n.html">CSL_CPSW_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:gaa19b06c8ea11eccdbc6b7c8ea14c31e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef81ad7581b330ea24a5e22ec86fe3bd"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaef81ad7581b330ea24a5e22ec86fe3bd">CSL_CPSW_isFIFOLoopbackEnabled</a> (void)</td></tr>
<tr class="separator:gaef81ad7581b330ea24a5e22ec86fe3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac10f577a2b168b82882c47dce117d93"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaac10f577a2b168b82882c47dce117d93">CSL_CPSW_enableFIFOLoopback</a> (void)</td></tr>
<tr class="separator:gaac10f577a2b168b82882c47dce117d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb9e8aa48c4ca2f7cc3a4c4bd19d505"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafeb9e8aa48c4ca2f7cc3a4c4bd19d505">CSL_CPSW_disableFIFOLoopback</a> (void)</td></tr>
<tr class="separator:gafeb9e8aa48c4ca2f7cc3a4c4bd19d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6a83239cef87146d70497071c72963"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacf6a83239cef87146d70497071c72963">CSL_CPSW_isVlanAwareEnabled</a> (void)</td></tr>
<tr class="separator:gacf6a83239cef87146d70497071c72963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42709039b5b9ff26f35af091e8ad8236"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga42709039b5b9ff26f35af091e8ad8236">CSL_CPSW_enableVlanAware</a> (void)</td></tr>
<tr class="separator:ga42709039b5b9ff26f35af091e8ad8236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga096dfd36aac3b432f2f0b71ceeee4c43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga096dfd36aac3b432f2f0b71ceeee4c43">CSL_CPSW_disableVlanAware</a> (void)</td></tr>
<tr class="separator:ga096dfd36aac3b432f2f0b71ceeee4c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41b6d3ff23d63105a48e25c5e1eae20"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf41b6d3ff23d63105a48e25c5e1eae20">CSL_CPSW_isPort0Enabled</a> (void)</td></tr>
<tr class="separator:gaf41b6d3ff23d63105a48e25c5e1eae20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa997daa46c3204ba75af8ee2876ef0c2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa997daa46c3204ba75af8ee2876ef0c2">CSL_CPSW_enablePort0</a> (void)</td></tr>
<tr class="separator:gaa997daa46c3204ba75af8ee2876ef0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a328d7ebc1a5606c37cecc380ad9b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga78a328d7ebc1a5606c37cecc380ad9b0">CSL_CPSW_disablePort0</a> (void)</td></tr>
<tr class="separator:ga78a328d7ebc1a5606c37cecc380ad9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b3faf27b839e10016e3c0bdab91290"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga59b3faf27b839e10016e3c0bdab91290">CSL_CPSW_isPort0PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga59b3faf27b839e10016e3c0bdab91290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190045d2845d98965b0152ff09d9bcce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga190045d2845d98965b0152ff09d9bcce">CSL_CPSW_enablePort0PassPriTag</a> (void)</td></tr>
<tr class="separator:ga190045d2845d98965b0152ff09d9bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c25fbb1d5ca58a5944bd6563c6425e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf7c25fbb1d5ca58a5944bd6563c6425e">CSL_CPSW_disablePort0PassPriTag</a> (void)</td></tr>
<tr class="separator:gaf7c25fbb1d5ca58a5944bd6563c6425e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c67d56975c68a8fcb047cc7c87b0ba"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga33c67d56975c68a8fcb047cc7c87b0ba">CSL_CPSW_isPort1PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga33c67d56975c68a8fcb047cc7c87b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9906ba44a237c31e4e2ea9d1c26932fa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9906ba44a237c31e4e2ea9d1c26932fa">CSL_CPSW_enablePort1PassPriTag</a> (void)</td></tr>
<tr class="separator:ga9906ba44a237c31e4e2ea9d1c26932fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae60b1f8de4e9f2c1aa5160116a2fcc88"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae60b1f8de4e9f2c1aa5160116a2fcc88">CSL_CPSW_disablePort1PassPriTag</a> (void)</td></tr>
<tr class="separator:gae60b1f8de4e9f2c1aa5160116a2fcc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00cb40a07dda6fc94f70340d78635d6"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf00cb40a07dda6fc94f70340d78635d6">CSL_CPSW_isPort2PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:gaf00cb40a07dda6fc94f70340d78635d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae934d0bcb4bc8b44f1f6abbd4ed6967"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaae934d0bcb4bc8b44f1f6abbd4ed6967">CSL_CPSW_enablePort2PassPriTag</a> (void)</td></tr>
<tr class="separator:gaae934d0bcb4bc8b44f1f6abbd4ed6967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e3919abe57f045f73cce4e5337ae86c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga5e3919abe57f045f73cce4e5337ae86c">CSL_CPSW_disablePort2PassPriTag</a> (void)</td></tr>
<tr class="separator:ga5e3919abe57f045f73cce4e5337ae86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aec269edb62dfc3f16463f7c0554401"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3aec269edb62dfc3f16463f7c0554401">CSL_CPSW_getCpswControlReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *pControlRegInfo)</td></tr>
<tr class="separator:ga3aec269edb62dfc3f16463f7c0554401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92dcf5fed038e39c2af75ad2727e48e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga92dcf5fed038e39c2af75ad2727e48e5">CSL_CPSW_setCpswControlReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *pControlRegInfo)</td></tr>
<tr class="separator:ga92dcf5fed038e39c2af75ad2727e48e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae29d79ae8023203c435743820ac08380"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae29d79ae8023203c435743820ac08380">CSL_CPSW_getEmulationControlReg</a> (Uint32 *pFree, Uint32 *pSoft)</td></tr>
<tr class="separator:gae29d79ae8023203c435743820ac08380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fab2fd9ce96ff98f32e28a5a26a6267"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2fab2fd9ce96ff98f32e28a5a26a6267">CSL_CPSW_setEmulationControlReg</a> (Uint32 free, Uint32 soft)</td></tr>
<tr class="separator:ga2fab2fd9ce96ff98f32e28a5a26a6267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d43e80b94ef9664c6bac27db7e2255f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7d43e80b94ef9664c6bac27db7e2255f">CSL_CPSW_getPortStatsEnableReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *pPortStatsCfg)</td></tr>
<tr class="separator:ga7d43e80b94ef9664c6bac27db7e2255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e8bb4a20cde89179f52bdf2a98c80f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga09e8bb4a20cde89179f52bdf2a98c80f">CSL_CPSW_setPortStatsEnableReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *pPortStatsCfg)</td></tr>
<tr class="separator:ga09e8bb4a20cde89179f52bdf2a98c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a64891e17b258842f6d7666f3b4396"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae8a64891e17b258842f6d7666f3b4396">CSL_CPSW_getPrioTypeReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *pTypeCfg)</td></tr>
<tr class="separator:gae8a64891e17b258842f6d7666f3b4396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4497889171427a1931f1f47befaf1bd3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4497889171427a1931f1f47befaf1bd3">CSL_CPSW_setPrioTypeReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *pTypeCfg)</td></tr>
<tr class="separator:ga4497889171427a1931f1f47befaf1bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2017f86eecaa81eb19932559c7036089"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2017f86eecaa81eb19932559c7036089">CSL_CPSW_getShortGapThreshold</a> (void)</td></tr>
<tr class="separator:ga2017f86eecaa81eb19932559c7036089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d2b6864e7271448d1a7d8cb4f7a39c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae5d2b6864e7271448d1a7d8cb4f7a39c">CSL_CPSW_setShortGapThreshold</a> (Uint32 gapThreshVal)</td></tr>
<tr class="separator:gae5d2b6864e7271448d1a7d8cb4f7a39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5629a453313036c762ced0d9b06319"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaac5629a453313036c762ced0d9b06319">CSL_CPSW_getTxStartWordsReg</a> (void)</td></tr>
<tr class="separator:gaac5629a453313036c762ced0d9b06319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591dbfa1c9b824e7155783692ed94410"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga591dbfa1c9b824e7155783692ed94410">CSL_CPSW_setTxStartWordsReg</a> (Uint32 startWordsVal)</td></tr>
<tr class="separator:ga591dbfa1c9b824e7155783692ed94410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d441d484e63c3fdcfd195899670a7a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3d441d484e63c3fdcfd195899670a7a5">CSL_CPSW_getFlowControlReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w___f_l_o_w_c_n_t_l.html">CSL_CPSW_FLOWCNTL</a> *pFlowControlCfg)</td></tr>
<tr class="separator:ga3d441d484e63c3fdcfd195899670a7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa866233097b1e0ee0c4b053b6e8732"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacaa866233097b1e0ee0c4b053b6e8732">CSL_CPSW_setFlowControlReg</a> (<a class="el" href="struct_c_s_l___c_p_s_w___f_l_o_w_c_n_t_l.html">CSL_CPSW_FLOWCNTL</a> *pFlowControlCfg)</td></tr>
<tr class="separator:gacaa866233097b1e0ee0c4b053b6e8732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cd2e4e39d25aad0c33304664a02e2e3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2cd2e4e39d25aad0c33304664a02e2e3">CSL_CPSW_getCppiSourceIdReg</a> (Uint32 *pTxASrcId, Uint32 *pTxBSrcId)</td></tr>
<tr class="separator:ga2cd2e4e39d25aad0c33304664a02e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac77c4f25c7b8e5b8e7babd108bf8a07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaac77c4f25c7b8e5b8e7babd108bf8a07">CSL_CPSW_setCppiSourceIdReg</a> (Uint32 txASrcId, Uint32 txBSrcId)</td></tr>
<tr class="separator:gaac77c4f25c7b8e5b8e7babd108bf8a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0897b77bf12420ba288d94b996f14a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga5c0897b77bf12420ba288d94b996f14a">CSL_CPSW_getPort0VlanReg</a> (Uint32 *pPortVID, Uint32 *pPortCFI, Uint32 *pPortPRI)</td></tr>
<tr class="separator:ga5c0897b77bf12420ba288d94b996f14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fccd286117a681fb73ec359114ede6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7fccd286117a681fb73ec359114ede6f">CSL_CPSW_setPort0VlanReg</a> (Uint32 portVID, Uint32 portCFI, Uint32 portPRI)</td></tr>
<tr class="separator:ga7fccd286117a681fb73ec359114ede6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857cad0f0e7167bb491cb1b3cea20ad7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga857cad0f0e7167bb491cb1b3cea20ad7">CSL_CPSW_getPort0RxPriMapReg</a> (Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:ga857cad0f0e7167bb491cb1b3cea20ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af0d04508abc33391b5a799ee5500b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6af0d04508abc33391b5a799ee5500b7">CSL_CPSW_setPort0RxPriMapReg</a> (Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:ga6af0d04508abc33391b5a799ee5500b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf9ae7aab9a7bf6798e85b47ec0c62f8"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaaf9ae7aab9a7bf6798e85b47ec0c62f8">CSL_CPSW_getPort0RxMaxLen</a> (void)</td></tr>
<tr class="separator:gaaf9ae7aab9a7bf6798e85b47ec0c62f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3c995baa9f5f8b4cd91e79ed03f7bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9f3c995baa9f5f8b4cd91e79ed03f7bf">CSL_CPSW_setPort0RxMaxLen</a> (Uint32 rxMaxLen)</td></tr>
<tr class="separator:ga9f3c995baa9f5f8b4cd91e79ed03f7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bc391b94d671a1bff6fe57c91f34c4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga08bc391b94d671a1bff6fe57c91f34c4">CSL_CPSW_getPortMaxBlocksReg</a> (Uint32 portNum, Uint32 *pRxMaxBlks, Uint32 *pTxMaxBlks)</td></tr>
<tr class="separator:ga08bc391b94d671a1bff6fe57c91f34c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87715ad84d4f793ff6be8324c0c093e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga87715ad84d4f793ff6be8324c0c093e8">CSL_CPSW_setPortMaxBlocksReg</a> (Uint32 portNum, Uint32 rxMaxBlks, Uint32 txMaxBlks)</td></tr>
<tr class="separator:ga87715ad84d4f793ff6be8324c0c093e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba35a0a62b940cfa3d98c091f79af58"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gadba35a0a62b940cfa3d98c091f79af58">CSL_CPSW_getPortBlockCountReg</a> (Uint32 portNum, Uint32 *pRxBlkCnt, Uint32 *pTxBlkCnt)</td></tr>
<tr class="separator:gadba35a0a62b940cfa3d98c091f79af58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666c77f7148145576d58d5d6192fd5a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga666c77f7148145576d58d5d6192fd5a4">CSL_CPSW_getPortVlanReg</a> (Uint32 portNum, Uint32 *pPortVID, Uint32 *pPortCFI, Uint32 *pPortPRI)</td></tr>
<tr class="separator:ga666c77f7148145576d58d5d6192fd5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ce29809fda9cb894170687b4e82327"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga51ce29809fda9cb894170687b4e82327">CSL_CPSW_setPortVlanReg</a> (Uint32 portNum, Uint32 portVID, Uint32 portCFI, Uint32 portPRI)</td></tr>
<tr class="separator:ga51ce29809fda9cb894170687b4e82327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847d06b174b625c1d1d3101ec4352381"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga847d06b174b625c1d1d3101ec4352381">CSL_CPSW_getPortTxPriMapReg</a> (Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:ga847d06b174b625c1d1d3101ec4352381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8efb80f1cfcc76f6fb224f479c0fee7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac8efb80f1cfcc76f6fb224f479c0fee7">CSL_CPSW_setPortTxPriMapReg</a> (Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:gac8efb80f1cfcc76f6fb224f479c0fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1441c77645c1406615421a02d4851109"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga1441c77645c1406615421a02d4851109">CSL_CPSW_getPortMACAddress</a> (Uint32 portNum, Uint8 *pMacAddress)</td></tr>
<tr class="separator:ga1441c77645c1406615421a02d4851109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694e841c56c9532d6915bcfa572549da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga694e841c56c9532d6915bcfa572549da">CSL_CPSW_setPortMACAddress</a> (Uint32 portNum, Uint8 *pMacAddress)</td></tr>
<tr class="separator:ga694e841c56c9532d6915bcfa572549da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6545a150acbe0a63281d46e6cee3c130"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6545a150acbe0a63281d46e6cee3c130">CSL_CPSW_getPortTimeSyncCntlReg</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_n_t_l.html">CSL_CPSW_TSCNTL</a> *pTimeSyncCntlCfg)</td></tr>
<tr class="separator:ga6545a150acbe0a63281d46e6cee3c130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga099b9532f5caa1dd049c88bb2117e55b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga099b9532f5caa1dd049c88bb2117e55b">CSL_CPSW_setPortTimeSyncCntlReg</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_n_t_l.html">CSL_CPSW_TSCNTL</a> *pTimeSyncCntlCfg)</td></tr>
<tr class="separator:ga099b9532f5caa1dd049c88bb2117e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ad2bc722042b7c92f1bca6563a0fc6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga65ad2bc722042b7c92f1bca6563a0fc6">CSL_CPSW_getPortTimeSyncSeqIdReg</a> (Uint32 portNum, Uint32 *pTsLtype, Uint32 *pTsSeqIdOffset)</td></tr>
<tr class="separator:ga65ad2bc722042b7c92f1bca6563a0fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8149489b2c3d0441e37be1b21bbf7b9c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8149489b2c3d0441e37be1b21bbf7b9c">CSL_CPSW_setPortTimeSyncSeqIdReg</a> (Uint32 portNum, Uint32 tsLtype, Uint32 tsSeqIdOffset)</td></tr>
<tr class="separator:ga8149489b2c3d0441e37be1b21bbf7b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e98cdf2ccebf62c09f6376f7189048"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga33e98cdf2ccebf62c09f6376f7189048">CSL_CPSW_getPortTimeSyncVlanLTypeReg</a> (Uint32 portNum, Uint32 *pTsVlanLtype1, Uint32 *pTsVlanLtype2)</td></tr>
<tr class="separator:ga33e98cdf2ccebf62c09f6376f7189048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17421dc8d8b8afeb092ee302191946d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga17421dc8d8b8afeb092ee302191946d8">CSL_CPSW_setPortTimeSyncVlanLTypeReg</a> (Uint32 portNum, Uint32 tsVlanLtype1, Uint32 tsVlanLtype2)</td></tr>
<tr class="separator:ga17421dc8d8b8afeb092ee302191946d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658c6291a84782908c8bf3a90d6821d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga658c6291a84782908c8bf3a90d6821d7">CSL_CPSW_getStats</a> (<a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *pCpswStats)</td></tr>
<tr class="separator:ga658c6291a84782908c8bf3a90d6821d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf359bd7be6c484ed6c5e36107ec0bec5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf359bd7be6c484ed6c5e36107ec0bec5">CSL_CPSW_getRawStats</a> (<a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *pCpswStats)</td></tr>
<tr class="separator:gaf359bd7be6c484ed6c5e36107ec0bec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae236bb905e2e1280b4aadce6a650af32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae236bb905e2e1280b4aadce6a650af32">CSL_CPSW_getAleVersionInfo</a> (<a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_e_r_s_i_o_n.html">CSL_CPSW_ALE_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:gae236bb905e2e1280b4aadce6a650af32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga971b8b779ac906e8e518f1983c8a28bd"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga971b8b779ac906e8e518f1983c8a28bd">CSL_CPSW_isAleRateLimitEnabled</a> (void)</td></tr>
<tr class="separator:ga971b8b779ac906e8e518f1983c8a28bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32940fbc01d05b4d420728109fdf8225"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga32940fbc01d05b4d420728109fdf8225">CSL_CPSW_enableAleRateLimit</a> (void)</td></tr>
<tr class="separator:ga32940fbc01d05b4d420728109fdf8225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e97f01109f666212665e49b5b0107b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga71e97f01109f666212665e49b5b0107b">CSL_CPSW_disableAleRateLimit</a> (void)</td></tr>
<tr class="separator:ga71e97f01109f666212665e49b5b0107b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5ade410785f8934e31f5766e5e9c6a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6a5ade410785f8934e31f5766e5e9c6a">CSL_CPSW_isAleMacAuthModeEnabled</a> (void)</td></tr>
<tr class="separator:ga6a5ade410785f8934e31f5766e5e9c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18dd684c13a30ee8b5cd1ae5884838f5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga18dd684c13a30ee8b5cd1ae5884838f5">CSL_CPSW_enableAleMacAuthMode</a> (void)</td></tr>
<tr class="separator:ga18dd684c13a30ee8b5cd1ae5884838f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4832bb7916d4a28c88963218affb3d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad4832bb7916d4a28c88963218affb3d8">CSL_CPSW_disableAleMacAuthMode</a> (void)</td></tr>
<tr class="separator:gad4832bb7916d4a28c88963218affb3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96c1be88aac74cbf4e672e87f7449e8"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad96c1be88aac74cbf4e672e87f7449e8">CSL_CPSW_isAleVlanAwareEnabled</a> (void)</td></tr>
<tr class="separator:gad96c1be88aac74cbf4e672e87f7449e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac384d4446da92c423025538044077895"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac384d4446da92c423025538044077895">CSL_CPSW_enableAleVlanAware</a> (void)</td></tr>
<tr class="separator:gac384d4446da92c423025538044077895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35874ec9a40687f0659c49745b58b77b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga35874ec9a40687f0659c49745b58b77b">CSL_CPSW_disableAleVlanAware</a> (void)</td></tr>
<tr class="separator:ga35874ec9a40687f0659c49745b58b77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a29bf0a7d532d4215cf622c52d07d0"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga49a29bf0a7d532d4215cf622c52d07d0">CSL_CPSW_isAleTxRateLimitEnabled</a> (void)</td></tr>
<tr class="separator:ga49a29bf0a7d532d4215cf622c52d07d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e06196311b238dbd9a32255cd9e24fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3e06196311b238dbd9a32255cd9e24fc">CSL_CPSW_enableAleTxRateLimit</a> (void)</td></tr>
<tr class="separator:ga3e06196311b238dbd9a32255cd9e24fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafb5e19c1052b76158c5a586b3603a9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaafb5e19c1052b76158c5a586b3603a9b">CSL_CPSW_disableAleTxRateLimit</a> (void)</td></tr>
<tr class="separator:gaafb5e19c1052b76158c5a586b3603a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b52d0952ab1efa933e8a460cfd2cc6"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga65b52d0952ab1efa933e8a460cfd2cc6">CSL_CPSW_isAleBypassEnabled</a> (void)</td></tr>
<tr class="separator:ga65b52d0952ab1efa933e8a460cfd2cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c06a7bbe9c24604339fc29fa92e2bdf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2c06a7bbe9c24604339fc29fa92e2bdf">CSL_CPSW_enableAleBypass</a> (void)</td></tr>
<tr class="separator:ga2c06a7bbe9c24604339fc29fa92e2bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7de05be39fbd1ffbeccf5eedb81f22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafc7de05be39fbd1ffbeccf5eedb81f22">CSL_CPSW_disableAleBypass</a> (void)</td></tr>
<tr class="separator:gafc7de05be39fbd1ffbeccf5eedb81f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga667e1c45c6a5f9664d36504ff4991224"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga667e1c45c6a5f9664d36504ff4991224">CSL_CPSW_isAleOUIDenyModeEnabled</a> (void)</td></tr>
<tr class="separator:ga667e1c45c6a5f9664d36504ff4991224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55db9918f18c719a4853f5d59a22824"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gab55db9918f18c719a4853f5d59a22824">CSL_CPSW_enableAleOUIDenyMode</a> (void)</td></tr>
<tr class="separator:gab55db9918f18c719a4853f5d59a22824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051001df426cb6d759f3e03c58884f68"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga051001df426cb6d759f3e03c58884f68">CSL_CPSW_disableAleOUIDenyMode</a> (void)</td></tr>
<tr class="separator:ga051001df426cb6d759f3e03c58884f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6ddcdf383906b50c6c3d687574be12"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8e6ddcdf383906b50c6c3d687574be12">CSL_CPSW_isAleVID0ModeEnabled</a> (void)</td></tr>
<tr class="separator:ga8e6ddcdf383906b50c6c3d687574be12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafea1ebd3c767ef2aacf9b9bb526ab80b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafea1ebd3c767ef2aacf9b9bb526ab80b">CSL_CPSW_enableAleVID0Mode</a> (void)</td></tr>
<tr class="separator:gafea1ebd3c767ef2aacf9b9bb526ab80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc870e1c5f6dce29e02d30b005313a88"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafc870e1c5f6dce29e02d30b005313a88">CSL_CPSW_disableAleVID0Mode</a> (void)</td></tr>
<tr class="separator:gafc870e1c5f6dce29e02d30b005313a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa514ccd9d94c302fbedf6b8f09f5c674"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa514ccd9d94c302fbedf6b8f09f5c674">CSL_CPSW_isAleLearnNoVIDEnabled</a> (void)</td></tr>
<tr class="separator:gaa514ccd9d94c302fbedf6b8f09f5c674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0b47902ab6fed924c443eb1fe5a4e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9f0b47902ab6fed924c443eb1fe5a4e5">CSL_CPSW_enableAleLearnNoVID</a> (void)</td></tr>
<tr class="separator:ga9f0b47902ab6fed924c443eb1fe5a4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe696477524e4233aa66a612bdbc1de3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafe696477524e4233aa66a612bdbc1de3">CSL_CPSW_disableAleLearnNoVID</a> (void)</td></tr>
<tr class="separator:gafe696477524e4233aa66a612bdbc1de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e3eaea7d750a74cc90cd9f4df9c88f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga70e3eaea7d750a74cc90cd9f4df9c88f">CSL_CPSW_startAleAgeOutNow</a> (void)</td></tr>
<tr class="separator:ga70e3eaea7d750a74cc90cd9f4df9c88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3179da61fa905e452b84bafee00c7619"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3179da61fa905e452b84bafee00c7619">CSL_CPSW_isAleAgeOutDone</a> (void)</td></tr>
<tr class="separator:ga3179da61fa905e452b84bafee00c7619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c52548f7197b4d74106c69b70794a5b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga5c52548f7197b4d74106c69b70794a5b">CSL_CPSW_clearAleTable</a> (void)</td></tr>
<tr class="separator:ga5c52548f7197b4d74106c69b70794a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc328766c13a643871c5c1424bfc65f7"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacc328766c13a643871c5c1424bfc65f7">CSL_CPSW_isAleEnabled</a> (void)</td></tr>
<tr class="separator:gacc328766c13a643871c5c1424bfc65f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0be10dd9b43c5f36fddeddcb2d1724"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gadc0be10dd9b43c5f36fddeddcb2d1724">CSL_CPSW_enableAle</a> (void)</td></tr>
<tr class="separator:gadc0be10dd9b43c5f36fddeddcb2d1724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd4bcbae84ad775d8e7c9af018d110bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gabd4bcbae84ad775d8e7c9af018d110bf">CSL_CPSW_disableAle</a> (void)</td></tr>
<tr class="separator:gabd4bcbae84ad775d8e7c9af018d110bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ff4a34944a488f280cd28a7f98faab"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga04ff4a34944a488f280cd28a7f98faab">CSL_CPSW_getAleControlReg</a> (void)</td></tr>
<tr class="separator:ga04ff4a34944a488f280cd28a7f98faab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8687e7ee5eef346c5a795f466a90b8f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa8687e7ee5eef346c5a795f466a90b8f">CSL_CPSW_setAleControlReg</a> (Uint32 aleCtrlVal)</td></tr>
<tr class="separator:gaa8687e7ee5eef346c5a795f466a90b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56124a2b5af4c20f57bfab20c71b185e"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga56124a2b5af4c20f57bfab20c71b185e">CSL_CPSW_getAlePrescaleReg</a> (void)</td></tr>
<tr class="separator:ga56124a2b5af4c20f57bfab20c71b185e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176a31b66e28db448bf7de932bc089ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga176a31b66e28db448bf7de932bc089ad">CSL_CPSW_setAlePrescaleReg</a> (Uint32 alePrescaleVal)</td></tr>
<tr class="separator:ga176a31b66e28db448bf7de932bc089ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e58cb3727a11a46206bc770318882fa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2e58cb3727a11a46206bc770318882fa">CSL_CPSW_getAleUnkownVlanReg</a> (Uint32 *pUnVlanMemList, Uint32 *pUnMcastFloodMask, Uint32 *pUnRegMcastFloodMask, Uint32 *pUnForceUntagEgress)</td></tr>
<tr class="separator:ga2e58cb3727a11a46206bc770318882fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84bf1bbe73f6077eb7724dfefbe0112b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga84bf1bbe73f6077eb7724dfefbe0112b">CSL_CPSW_setAleUnkownVlanReg</a> (Uint32 unVlanMemList, Uint32 unMcastFloodMask, Uint32 unRegMcastFloodMask, Uint32 unForceUntagEgress)</td></tr>
<tr class="separator:ga84bf1bbe73f6077eb7724dfefbe0112b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee41a0be367b8a51b61e2e281721779"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6ee41a0be367b8a51b61e2e281721779">CSL_CPSW_getAleTableEntry</a> (Uint32 index, Uint32 *pAleInfoWd0, Uint32 *pAleInfoWd1, Uint32 *pAleInfoWd2)</td></tr>
<tr class="separator:ga6ee41a0be367b8a51b61e2e281721779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3b77625043068257dcd4d636c7f97e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9d3b77625043068257dcd4d636c7f97e">CSL_CPSW_setAleTableEntry</a> (Uint32 index, Uint32 aleInfoWd0, Uint32 aleInfoWd1, Uint32 aleInfoWd2)</td></tr>
<tr class="separator:ga9d3b77625043068257dcd4d636c7f97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3123e54dad2e730b70a5a549fef149"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga6ea23133eb6b1517c106ca3f1a8b7729">CSL_CPSW_ALE_ENTRYTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6d3123e54dad2e730b70a5a549fef149">CSL_CPSW_getALEEntryType</a> (Uint32 index)</td></tr>
<tr class="separator:ga6d3123e54dad2e730b70a5a549fef149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe56e4b3f10fdc7c36a59b8fc9be71a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#gac08366dceb5ccaea33ad2555f63471d5">CSL_CPSW_ALE_ADDRTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacbe56e4b3f10fdc7c36a59b8fc9be71a">CSL_CPSW_getALEAddressType</a> (Uint32 index)</td></tr>
<tr class="separator:gacbe56e4b3f10fdc7c36a59b8fc9be71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac828b71412cf6b0a6e2a5ed79bf590a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac828b71412cf6b0a6e2a5ed79bf590a6">CSL_CPSW_getAleMcastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *pMcastAddrCfg)</td></tr>
<tr class="separator:gac828b71412cf6b0a6e2a5ed79bf590a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728a2aeef7997963360a9639c150308a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga728a2aeef7997963360a9639c150308a">CSL_CPSW_setAleMcastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *pMcastAddrCfg)</td></tr>
<tr class="separator:ga728a2aeef7997963360a9639c150308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01b71c7bb11e7e7178c43f1861e35fde"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga01b71c7bb11e7e7178c43f1861e35fde">CSL_CPSW_getAleVlanMcastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *pVlanMcastAddrCfg)</td></tr>
<tr class="separator:ga01b71c7bb11e7e7178c43f1861e35fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc20485c91f87261d2678db85aace57"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8dc20485c91f87261d2678db85aace57">CSL_CPSW_setAleVlanMcastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *pVlanMcastAddrCfg)</td></tr>
<tr class="separator:ga8dc20485c91f87261d2678db85aace57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b288e8d3d9c20effc9c8f9ba7ab946"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga04b288e8d3d9c20effc9c8f9ba7ab946">CSL_CPSW_getAleUnicastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *pUcastAddrCfg)</td></tr>
<tr class="separator:ga04b288e8d3d9c20effc9c8f9ba7ab946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a21c30cb2ef548fd641fba977cd0cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga49a21c30cb2ef548fd641fba977cd0cb">CSL_CPSW_setAleUnicastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *pUcastAddrCfg)</td></tr>
<tr class="separator:ga49a21c30cb2ef548fd641fba977cd0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e4f6bd3bb08bb1086b6937507c83f40"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4e4f6bd3bb08bb1086b6937507c83f40">CSL_CPSW_getAleOUIAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *pOUIAddrCfg)</td></tr>
<tr class="separator:ga4e4f6bd3bb08bb1086b6937507c83f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96529608927d1d0f73bb78526055fe18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga96529608927d1d0f73bb78526055fe18">CSL_CPSW_setAleOUIAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *pOUIAddrCfg)</td></tr>
<tr class="separator:ga96529608927d1d0f73bb78526055fe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b9a1c3454447108d7ce1c235708081"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf1b9a1c3454447108d7ce1c235708081">CSL_CPSW_getAleVlanUnicastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *pVlanUcastAddrCfg)</td></tr>
<tr class="separator:gaf1b9a1c3454447108d7ce1c235708081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524d267027691d56e66050b3cd4d681e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga524d267027691d56e66050b3cd4d681e">CSL_CPSW_setAleVlanUnicastAddrEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *pVlanUcastAddrCfg)</td></tr>
<tr class="separator:ga524d267027691d56e66050b3cd4d681e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012e77301032c51187442eba2fd15621"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga012e77301032c51187442eba2fd15621">CSL_CPSW_getAleVlanEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *pVlanCfg)</td></tr>
<tr class="separator:ga012e77301032c51187442eba2fd15621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111a0c955e21790d81dc931e6e9c2513"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga111a0c955e21790d81dc931e6e9c2513">CSL_CPSW_setAleVlanEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *pVlanCfg)</td></tr>
<tr class="separator:ga111a0c955e21790d81dc931e6e9c2513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8fbb25b17d4908dba3d1ec3d8844aef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf8fbb25b17d4908dba3d1ec3d8844aef">CSL_CPSW_clearAleEntry</a> (Uint32 index)</td></tr>
<tr class="separator:gaf8fbb25b17d4908dba3d1ec3d8844aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382a664f0f4af7c44ef11af15758a290"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga382a664f0f4af7c44ef11af15758a290">CSL_CPSW_getAlePortControlReg</a> (Uint32 portNo, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *pPortControlInfo)</td></tr>
<tr class="separator:ga382a664f0f4af7c44ef11af15758a290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga371835b4cbd79351e9a83b87a6b55545"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga371835b4cbd79351e9a83b87a6b55545">CSL_CPSW_setAlePortControlReg</a> (Uint32 portNo, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *pPortControlInfo)</td></tr>
<tr class="separator:ga371835b4cbd79351e9a83b87a6b55545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed289e4c07b0f8fa1f7482558044da7"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8ed289e4c07b0f8fa1f7482558044da7">CSL_CPSW_isPort3PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga8ed289e4c07b0f8fa1f7482558044da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861b87dc984fcdde59ec2eb7b22fd20e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga861b87dc984fcdde59ec2eb7b22fd20e">CSL_CPSW_enablePort3PassPriTag</a> (void)</td></tr>
<tr class="separator:ga861b87dc984fcdde59ec2eb7b22fd20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2995e060055d15eea1a9300ba01223d1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2995e060055d15eea1a9300ba01223d1">CSL_CPSW_disablePort3PassPriTag</a> (void)</td></tr>
<tr class="separator:ga2995e060055d15eea1a9300ba01223d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd9de741cfc4d60100ec92f94065cc2"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafbd9de741cfc4d60100ec92f94065cc2">CSL_CPSW_isPort4PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:gafbd9de741cfc4d60100ec92f94065cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c568f05b03e4aeeebfe5fbe9b2f617"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad3c568f05b03e4aeeebfe5fbe9b2f617">CSL_CPSW_enablePort4PassPriTag</a> (void)</td></tr>
<tr class="separator:gad3c568f05b03e4aeeebfe5fbe9b2f617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefc0b37afe0170c81c04764610266af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaeefc0b37afe0170c81c04764610266af">CSL_CPSW_disablePort4PassPriTag</a> (void)</td></tr>
<tr class="separator:gaeefc0b37afe0170c81c04764610266af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8694694062539527e3add069759f8b2c"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8694694062539527e3add069759f8b2c">CSL_CPSW_isPort5PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga8694694062539527e3add069759f8b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a9c0fbbcd283d544d787329db1bb955"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8a9c0fbbcd283d544d787329db1bb955">CSL_CPSW_enablePort5PassPriTag</a> (void)</td></tr>
<tr class="separator:ga8a9c0fbbcd283d544d787329db1bb955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b64066f7658e18da34c1d9bf4e5f64"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga22b64066f7658e18da34c1d9bf4e5f64">CSL_CPSW_disablePort5PassPriTag</a> (void)</td></tr>
<tr class="separator:ga22b64066f7658e18da34c1d9bf4e5f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76495e877686af8030bed618936009b8"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga76495e877686af8030bed618936009b8">CSL_CPSW_isPort6PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga76495e877686af8030bed618936009b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed209704e77f0a320d9a39fb50f3fe2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3ed209704e77f0a320d9a39fb50f3fe2">CSL_CPSW_enablePort6PassPriTag</a> (void)</td></tr>
<tr class="separator:ga3ed209704e77f0a320d9a39fb50f3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa9c71863840a5ba863c190c9c71785"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacfa9c71863840a5ba863c190c9c71785">CSL_CPSW_disablePort6PassPriTag</a> (void)</td></tr>
<tr class="separator:gacfa9c71863840a5ba863c190c9c71785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0476ef563f02e8896d45e270b2f97d57"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga0476ef563f02e8896d45e270b2f97d57">CSL_CPSW_isPort7PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga0476ef563f02e8896d45e270b2f97d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae60bd0096abb1d7649f10a1a71cc79fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae60bd0096abb1d7649f10a1a71cc79fd">CSL_CPSW_enablePort7PassPriTag</a> (void)</td></tr>
<tr class="separator:gae60bd0096abb1d7649f10a1a71cc79fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa833f906c500266da80bc10291572e02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa833f906c500266da80bc10291572e02">CSL_CPSW_disablePort7PassPriTag</a> (void)</td></tr>
<tr class="separator:gaa833f906c500266da80bc10291572e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05660def00de6b505aeacf785a23ff4f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga05660def00de6b505aeacf785a23ff4f">CSL_CPSW_isPort8PassPriTagEnabled</a> (void)</td></tr>
<tr class="separator:ga05660def00de6b505aeacf785a23ff4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b56ee3193df1a3fd1645502039906ee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2b56ee3193df1a3fd1645502039906ee">CSL_CPSW_enablePort8PassPriTag</a> (void)</td></tr>
<tr class="separator:ga2b56ee3193df1a3fd1645502039906ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1d68badc04b0dfc8e7e7f14a7937c34"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae1d68badc04b0dfc8e7e7f14a7937c34">CSL_CPSW_disablePort8PassPriTag</a> (void)</td></tr>
<tr class="separator:gae1d68badc04b0dfc8e7e7f14a7937c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a70b3ff4d83531fdf6d0a681eb219e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6a70b3ff4d83531fdf6d0a681eb219e4">CSL_CPSW_getCppiSourceIdReg</a> (Uint32 *pTxSrcId)</td></tr>
<tr class="separator:ga6a70b3ff4d83531fdf6d0a681eb219e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4aa529232f7d81b8f45455d6a71c752"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa4aa529232f7d81b8f45455d6a71c752">CSL_CPSW_setCppiSourceIdReg</a> (Uint32 *pTxSrcId)</td></tr>
<tr class="separator:gaa4aa529232f7d81b8f45455d6a71c752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6c9796c839530be29343e14ffd60c6"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9d6c9796c839530be29343e14ffd60c6">CSL_CPSW_isSoftIdle</a> (void)</td></tr>
<tr class="separator:ga9d6c9796c839530be29343e14ffd60c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d5ee0b6c1bdcc49d13ec7e3bb7dc18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga89d5ee0b6c1bdcc49d13ec7e3bb7dc18">CSL_CPSW_enableSoftIdle</a> (void)</td></tr>
<tr class="separator:ga89d5ee0b6c1bdcc49d13ec7e3bb7dc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e951cd8359c7757582fcd555653b6b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga83e951cd8359c7757582fcd555653b6b">CSL_CPSW_disableSoftIdle</a> (void)</td></tr>
<tr class="separator:ga83e951cd8359c7757582fcd555653b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f046c4b7269d6f4be9425234b09c59"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad7f046c4b7269d6f4be9425234b09c59">CSL_CPSW_getPortControlReg</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t___c_o_n_t_r_o_l.html">CSL_CPSW_PORT_CONTROL</a> *pControlInfo)</td></tr>
<tr class="separator:gad7f046c4b7269d6f4be9425234b09c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4e0c08eb042fb1cea6496d7a468291"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6c4e0c08eb042fb1cea6496d7a468291">CSL_CPSW_setPortControlReg</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t___c_o_n_t_r_o_l.html">CSL_CPSW_PORT_CONTROL</a> *pControlInfo)</td></tr>
<tr class="separator:ga6c4e0c08eb042fb1cea6496d7a468291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae212dd26831921161335917420965a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8ae212dd26831921161335917420965a">CSL_CPSW_getPort0FlowIdOffset</a> (void)</td></tr>
<tr class="separator:ga8ae212dd26831921161335917420965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51c209775ce98b54ab597025ea8c296"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad51c209775ce98b54ab597025ea8c296">CSL_CPSW_setPort0FlowIdOffset</a> (Uint32 flowIdOffset)</td></tr>
<tr class="separator:gad51c209775ce98b54ab597025ea8c296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe7f44c7148dc1b52918a3c5a46133a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacbe7f44c7148dc1b52918a3c5a46133a">CSL_CPSW_getPortRxMaxLen</a> (Uint32 portNum)</td></tr>
<tr class="separator:gacbe7f44c7148dc1b52918a3c5a46133a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155b64a30cf1bd2a47cc179dccf3d1c0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga155b64a30cf1bd2a47cc179dccf3d1c0">CSL_CPSW_setPortRxMaxLen</a> (Uint32 portNum, Uint32 rxMaxLen)</td></tr>
<tr class="separator:ga155b64a30cf1bd2a47cc179dccf3d1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b0cd4a654b3a0b9463e169b9b45385f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga0b0cd4a654b3a0b9463e169b9b45385f">CSL_CPSW_getPortRxPriMapReg</a> (Uint32 portNum, Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:ga0b0cd4a654b3a0b9463e169b9b45385f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20dd9d4fc9e373dff0c03dcddffce4b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac20dd9d4fc9e373dff0c03dcddffce4b">CSL_CPSW_setPortRxPriMapReg</a> (Uint32 portNum, Uint32 *pPortRxPriMap)</td></tr>
<tr class="separator:gac20dd9d4fc9e373dff0c03dcddffce4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097caf9f000186ac932fd39dd40191ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga097caf9f000186ac932fd39dd40191ba">CSL_CPSW_getPortRxDscpMap</a> (Uint32 portNum, Uint32 *pRxDscpPriMap)</td></tr>
<tr class="separator:ga097caf9f000186ac932fd39dd40191ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6c16122c7a870de42235103e05cfa2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga0a6c16122c7a870de42235103e05cfa2">CSL_CPSW_setPortRxDscpMap</a> (Uint32 portNum, Uint32 *pRxDscpPriMap)</td></tr>
<tr class="separator:ga0a6c16122c7a870de42235103e05cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c712b06aa5a3383718fddd9f8c1b87"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac5c712b06aa5a3383718fddd9f8c1b87">CSL_CPSW_getRxRLimConfig</a> (<a class="el" href="struct_c_s_l___c_p_s_w___r_x___r_a_t_e___l_i_m_i_t___c_o_n_f_i_g.html">CSL_CPSW_RX_RATE_LIMIT_CONFIG</a> *pRLimConfig)</td></tr>
<tr class="separator:gac5c712b06aa5a3383718fddd9f8c1b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f1baa8dfa1c981b63d5a69d8b6a235"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga03f1baa8dfa1c981b63d5a69d8b6a235">CSL_CPSW_setRxRLimConfig</a> (<a class="el" href="struct_c_s_l___c_p_s_w___r_x___r_a_t_e___l_i_m_i_t___c_o_n_f_i_g.html">CSL_CPSW_RX_RATE_LIMIT_CONFIG</a> *pRLimConfig)</td></tr>
<tr class="separator:ga03f1baa8dfa1c981b63d5a69d8b6a235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37aecb54cadfcf0e2e462c2d9f3aaeae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga37aecb54cadfcf0e2e462c2d9f3aaeae">CSL_CPSW_getEEEGlobConfig</a> (<a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_EEE_GLOB_CONFIG</a> *pGlobConfig)</td></tr>
<tr class="separator:ga37aecb54cadfcf0e2e462c2d9f3aaeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73a7b8d20eeafb6da83cf8dfd9528308"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga73a7b8d20eeafb6da83cf8dfd9528308">CSL_CPSW_setEEEGlobConfig</a> (<a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_EEE_GLOB_CONFIG</a> *pGlobConfig)</td></tr>
<tr class="separator:ga73a7b8d20eeafb6da83cf8dfd9528308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d31ccf7ee22af955b7e351e87fecf08"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8d31ccf7ee22af955b7e351e87fecf08">CSL_CPSW_getEEEPortConfig</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___c_o_n_f_i_g.html">CSL_CPSW_EEE_PORT_CONFIG</a> *pPortConfig)</td></tr>
<tr class="separator:ga8d31ccf7ee22af955b7e351e87fecf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf479b3f461cfde92ac54c7d1a8bb577"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaaf479b3f461cfde92ac54c7d1a8bb577">CSL_CPSW_setEEEPortConfig</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___c_o_n_f_i_g.html">CSL_CPSW_EEE_PORT_CONFIG</a> *pPortConfig)</td></tr>
<tr class="separator:gaaf479b3f461cfde92ac54c7d1a8bb577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c8b3ba0258c46a4e1f2e510c50c804"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga98c8b3ba0258c46a4e1f2e510c50c804">CSL_CPSW_EEEPortStatus</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___s_t_a_t_u_s.html">CSL_CPSW_EEE_PORT_STATUS</a> *pPortStatus)</td></tr>
<tr class="separator:ga98c8b3ba0258c46a4e1f2e510c50c804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8cfd91739fb1d3beb50a8376b5b60f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6e8cfd91739fb1d3beb50a8376b5b60f">CSL_CPSW_getPortMaxBlksReg</a> (Uint32 portNum, Uint32 *pRxMaxBlks, Uint32 *pTxMaxBlks)</td></tr>
<tr class="separator:ga6e8cfd91739fb1d3beb50a8376b5b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24f015c179eea3fb7f4eb86cb29c48f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa24f015c179eea3fb7f4eb86cb29c48f">CSL_CPSW_setPortMaxBlksReg</a> (Uint32 portNum, Uint32 rxMaxBlks, Uint32 txMaxBlks)</td></tr>
<tr class="separator:gaa24f015c179eea3fb7f4eb86cb29c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f013d8b53e79a6e9ee6298252db8ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac6f013d8b53e79a6e9ee6298252db8ba">CSL_CPSW_getPortTimeSyncConfig</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_o_n_f_i_g.html">CSL_CPSW_TSCONFIG</a> *pTimeSyncConfig)</td></tr>
<tr class="separator:gac6f013d8b53e79a6e9ee6298252db8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7527cc88d372000b84663bc97fc21fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac7527cc88d372000b84663bc97fc21fd">CSL_CPSW_setPortTimeSyncConfig</a> (Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_o_n_f_i_g.html">CSL_CPSW_TSCONFIG</a> *pTimeSyncConfig)</td></tr>
<tr class="separator:gac7527cc88d372000b84663bc97fc21fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf128b00e4892f479c0e3036def8cac9d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf128b00e4892f479c0e3036def8cac9d">CSL_CPSW_isAleUUNIToHostEnabled</a> (void)</td></tr>
<tr class="separator:gaf128b00e4892f479c0e3036def8cac9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaadbda43472b8f81f2cd155f1c81236e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaaadbda43472b8f81f2cd155f1c81236e">CSL_CPSW_enableAleUUNIToHost</a> (void)</td></tr>
<tr class="separator:gaaadbda43472b8f81f2cd155f1c81236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051c41c3d267866406ac3a959a1a45ee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga051c41c3d267866406ac3a959a1a45ee">CSL_CPSW_disableAleUUNIToHost</a> (void)</td></tr>
<tr class="separator:ga051c41c3d267866406ac3a959a1a45ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fbf4f970a7ab0da9ef66e247dee9be2"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga0fbf4f970a7ab0da9ef66e247dee9be2">CSL_CPSW_isAleUVLANNoLearnEnabled</a> (void)</td></tr>
<tr class="separator:ga0fbf4f970a7ab0da9ef66e247dee9be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1791c4ec3fd57ec8156b72c6be1a8f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaab1791c4ec3fd57ec8156b72c6be1a8f">CSL_CPSW_enableAleUVLANNoLearn</a> (void)</td></tr>
<tr class="separator:gaab1791c4ec3fd57ec8156b72c6be1a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ab39274c6f9ac60c1dbedb52134a51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga05ab39274c6f9ac60c1dbedb52134a51">CSL_CPSW_disableAleUVLANNoLearn</a> (void)</td></tr>
<tr class="separator:ga05ab39274c6f9ac60c1dbedb52134a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b4e09c85a3d353535017e22118915bd"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7b4e09c85a3d353535017e22118915bd">CSL_CPSW_getAleUpdateBW</a> (void)</td></tr>
<tr class="separator:ga7b4e09c85a3d353535017e22118915bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadafe1eb2be82c731bb317c268a1fff0a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gadafe1eb2be82c731bb317c268a1fff0a">CSL_CPSW_setAleUpdateBW</a> (Uint32 aleUpdBW)</td></tr>
<tr class="separator:gadafe1eb2be82c731bb317c268a1fff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e2c64a99069df58a6b823b5472b095"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga65e2c64a99069df58a6b823b5472b095">CSL_CPSW_getAleStatusReg</a> (Uint32 *pNumPolicers, Uint32 *pNumEntries)</td></tr>
<tr class="separator:ga65e2c64a99069df58a6b823b5472b095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga445958e883475a680420d559ecfcab61"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga445958e883475a680420d559ecfcab61">CSL_CPSW_getAleAgingTimerReg</a> (Uint32 *pAgingPrescale, Uint32 *pAgingPeriod)</td></tr>
<tr class="separator:ga445958e883475a680420d559ecfcab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9bb8854b785e82fe0c4db74814daba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafb9bb8854b785e82fe0c4db74814daba">CSL_CPSW_setAleAgingTimerReg</a> (Uint32 agingPrescale, Uint32 agingPeriod)</td></tr>
<tr class="separator:gafb9bb8854b785e82fe0c4db74814daba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9c64ad4f9c954f38839783053e2500"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaaa9c64ad4f9c954f38839783053e2500">CSL_CPSW_getAleVlanMaskMuxReg</a> (Uint32 *vlanMaskMux)</td></tr>
<tr class="separator:gaaa9c64ad4f9c954f38839783053e2500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ce0a286e7dbe4cab8e242678fcbe67"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gab2ce0a286e7dbe4cab8e242678fcbe67">CSL_CPSW_setAleVlanMaskMuxReg</a> (Uint32 *vlanMaskMux)</td></tr>
<tr class="separator:gab2ce0a286e7dbe4cab8e242678fcbe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce8adedb2ce4e6835a5ef554fe12a59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga13963cf3e07219d0a5b09cfb6c376b27">CSL_CPSW_ALE_POLICER_ENTRYTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6ce8adedb2ce4e6835a5ef554fe12a59">CSL_CPSW_getALEPolicerEntryType</a> (Uint32 index)</td></tr>
<tr class="separator:ga6ce8adedb2ce4e6835a5ef554fe12a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c0de43395468d209264dd19061d7a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga20c0de43395468d209264dd19061d7a7">CSL_CPSW_getAleOutValnEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *pOutValnCfg)</td></tr>
<tr class="separator:ga20c0de43395468d209264dd19061d7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da256d0b9a50f76afbec18b788909e0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6da256d0b9a50f76afbec18b788909e0">CSL_CPSW_setAleOutValnEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *pOutValnCfg)</td></tr>
<tr class="separator:ga6da256d0b9a50f76afbec18b788909e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4253dbbd48a4c81e6c61abe98a4be3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8e4253dbbd48a4c81e6c61abe98a4be3">CSL_CPSW_getAleEthertypeEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *pEthertypeCfg)</td></tr>
<tr class="separator:ga8e4253dbbd48a4c81e6c61abe98a4be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7fa3f7e8a48cbabe41faea56721263f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae7fa3f7e8a48cbabe41faea56721263f">CSL_CPSW_setAleEthertypeEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *pEthertypeCfg)</td></tr>
<tr class="separator:gae7fa3f7e8a48cbabe41faea56721263f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf526c49f41748487b45bfbddba718ef7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf526c49f41748487b45bfbddba718ef7">CSL_CPSW_getAleIPv4Entry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *pIPv4Cfg)</td></tr>
<tr class="separator:gaf526c49f41748487b45bfbddba718ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c62f0d4d4a7600d8e5caa0688a122c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga80c62f0d4d4a7600d8e5caa0688a122c">CSL_CPSW_setAleIPv4Entry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *pIPv4Cfg)</td></tr>
<tr class="separator:ga80c62f0d4d4a7600d8e5caa0688a122c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531649f10efcf9e05949e4c2846fb10c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga531649f10efcf9e05949e4c2846fb10c">CSL_CPSW_getAleIPv6Entry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *pIPv6Cfg)</td></tr>
<tr class="separator:ga531649f10efcf9e05949e4c2846fb10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3e4806177d60d16335d1a3ad5d4709"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga5b3e4806177d60d16335d1a3ad5d4709">CSL_CPSW_setAleIPv6Entry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *pIPv6Cfg)</td></tr>
<tr class="separator:ga5b3e4806177d60d16335d1a3ad5d4709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae081ad01297c5336fb5ee1ab7681f5d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae081ad01297c5336fb5ee1ab7681f5d5">CSL_CPSW_getAlePolicerGlobConfig</a> (<a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_ALE_POLICER_GLOB_CONFIG</a> *pGlobConfig)</td></tr>
<tr class="separator:gae081ad01297c5336fb5ee1ab7681f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb0879fe7e0339c8c3c8838039ecfe84"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacb0879fe7e0339c8c3c8838039ecfe84">CSL_CPSW_setAlePolicerGlobConfig</a> (<a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_ALE_POLICER_GLOB_CONFIG</a> *pGlobConfig)</td></tr>
<tr class="separator:gacb0879fe7e0339c8c3c8838039ecfe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d1269e1a7ab6caf8bdff05ebc544933"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2d1269e1a7ab6caf8bdff05ebc544933">CSL_CPSW_getAlePolicerEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___e_n_t_r_y.html">CSL_CPSW_ALE_POLICER_ENTRY</a> *pPolCfg)</td></tr>
<tr class="separator:ga2d1269e1a7ab6caf8bdff05ebc544933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029a45efa6412c54f107ffa6e6628dd0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga029a45efa6412c54f107ffa6e6628dd0">CSL_CPSW_setAlePolicerEntry</a> (Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___e_n_t_r_y.html">CSL_CPSW_ALE_POLICER_ENTRY</a> *pPolCfg)</td></tr>
<tr class="separator:ga029a45efa6412c54f107ffa6e6628dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936efb6cbfbe75548998683bf76b39d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga936efb6cbfbe75548998683bf76b39d3">CSL_CPSW_getCpswVersionInfo</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___v_e_r_s_i_o_n.html">CSL_CPSW_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:ga936efb6cbfbe75548998683bf76b39d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9584111f819912b2a66ad6ff2b697469"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9584111f819912b2a66ad6ff2b697469">CSL_CPSW_isFIFOLoopbackEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga9584111f819912b2a66ad6ff2b697469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga660f3391da319b0d311154c24491cc6a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga660f3391da319b0d311154c24491cc6a">CSL_CPSW_enableFIFOLoopback</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga660f3391da319b0d311154c24491cc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a54fb49e16129911b4ed48b10309b64"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6a54fb49e16129911b4ed48b10309b64">CSL_CPSW_disableFIFOLoopback</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga6a54fb49e16129911b4ed48b10309b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77edd6baea97da006c723e9b8c3e72f3"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga77edd6baea97da006c723e9b8c3e72f3">CSL_CPSW_isVlanAwareEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga77edd6baea97da006c723e9b8c3e72f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55759b5e4e2db97ecf54038f83e36f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gab55759b5e4e2db97ecf54038f83e36f0">CSL_CPSW_enableVlanAware</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gab55759b5e4e2db97ecf54038f83e36f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad709c76d7458b4420cc367da18f94081"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad709c76d7458b4420cc367da18f94081">CSL_CPSW_disableVlanAware</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gad709c76d7458b4420cc367da18f94081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21310e87e4587f4b14dbc40f430f78b9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga21310e87e4587f4b14dbc40f430f78b9">CSL_CPSW_getCpswControlReg</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *pControlRegInfo)</td></tr>
<tr class="separator:ga21310e87e4587f4b14dbc40f430f78b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b93090f858706aaa618e8973edbee3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa8b93090f858706aaa618e8973edbee3">CSL_CPSW_setCpswControlReg</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *pControlRegInfo)</td></tr>
<tr class="separator:gaa8b93090f858706aaa618e8973edbee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4ebffd268d69391f3f80830be1b4c8"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6d4ebffd268d69391f3f80830be1b4c8">CSL_CPSW_isResetDone</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga6d4ebffd268d69391f3f80830be1b4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b441561ae3002799f82cf391c779270"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7b441561ae3002799f82cf391c779270">CSL_CPSW_reset</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga7b441561ae3002799f82cf391c779270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f06eec05393737516dcd8cf4c25193b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga1f06eec05393737516dcd8cf4c25193b">CSL_CPSW_getPortStatsEnableReg</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *pPortStatsCfg)</td></tr>
<tr class="separator:ga1f06eec05393737516dcd8cf4c25193b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3454e75b24e3bad2f85ead36e1698e86"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3454e75b24e3bad2f85ead36e1698e86">CSL_CPSW_setPortStatsEnableReg</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *pPortStatsCfg)</td></tr>
<tr class="separator:ga3454e75b24e3bad2f85ead36e1698e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8980bfc99f6f5bccff43750fbbd639"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaaa8980bfc99f6f5bccff43750fbbd639">CSL_CPSW_getPrioTypeReg</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *pTypeCfg)</td></tr>
<tr class="separator:gaaa8980bfc99f6f5bccff43750fbbd639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7acb225864ffa1f4118c68b8dbae2c23"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7acb225864ffa1f4118c68b8dbae2c23">CSL_CPSW_setPrioTypeReg</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *pTypeCfg)</td></tr>
<tr class="separator:ga7acb225864ffa1f4118c68b8dbae2c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b6f3aafadc9da1e841de67873e30e5"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga98b6f3aafadc9da1e841de67873e30e5">CSL_CPSW_isSoftIdle</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga98b6f3aafadc9da1e841de67873e30e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ae00edb74ed10824ae89f8bd8f03f9"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac4ae00edb74ed10824ae89f8bd8f03f9">CSL_CPSW_getShortGapThreshold</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gac4ae00edb74ed10824ae89f8bd8f03f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14c2384c372ed34448cf2ca4e9b09148"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga14c2384c372ed34448cf2ca4e9b09148">CSL_CPSW_enableSoftIdle</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga14c2384c372ed34448cf2ca4e9b09148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad55fd15834986cfc11d2854f4e7aa6b4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad55fd15834986cfc11d2854f4e7aa6b4">CSL_CPSW_disableSoftIdle</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gad55fd15834986cfc11d2854f4e7aa6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526c2bbee664a9446e754e97abcdf745"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga526c2bbee664a9446e754e97abcdf745">CSL_CPSW_getTxStartWordsReg</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga526c2bbee664a9446e754e97abcdf745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76296aa6eb87a2c3be0bc21df95ca14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae76296aa6eb87a2c3be0bc21df95ca14">CSL_CPSW_setTxStartWordsReg</a> (CSL_cpswHandle hCpswRegs, Uint32 startWordsVal)</td></tr>
<tr class="separator:gae76296aa6eb87a2c3be0bc21df95ca14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga943c22cbedfd86319c4718dcdbdd967a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga943c22cbedfd86319c4718dcdbdd967a">CSL_CPSW_getFlowControlReg</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___f_l_o_w_c_n_t_l.html">CSL_CPSW_FLOWCNTL</a> *pFlowControlCfg)</td></tr>
<tr class="separator:ga943c22cbedfd86319c4718dcdbdd967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a09370721eff2ea8bbae52e1656115"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga57a09370721eff2ea8bbae52e1656115">CSL_CPSW_setFlowControlReg</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___f_l_o_w_c_n_t_l.html">CSL_CPSW_FLOWCNTL</a> *pFlowControlCfg)</td></tr>
<tr class="separator:ga57a09370721eff2ea8bbae52e1656115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504d5c78bb2e3b95c1fc78325cd674c3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga504d5c78bb2e3b95c1fc78325cd674c3">CSL_CPSW_getPort0VlanReg</a> (CSL_cpswHandle hCpswRegs, Uint32 *pPortVID, Uint32 *pPortCFI, Uint32 *pPortPRI)</td></tr>
<tr class="separator:ga504d5c78bb2e3b95c1fc78325cd674c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a71ef6c55c5f20915c13429d537e95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga64a71ef6c55c5f20915c13429d537e95">CSL_CPSW_setPort0VlanReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portVID, Uint32 portCFI, Uint32 portPRI)</td></tr>
<tr class="separator:ga64a71ef6c55c5f20915c13429d537e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0c2b88165a0e2847d6994fcbe7fcb3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2b0c2b88165a0e2847d6994fcbe7fcb3">CSL_CPSW_getPort0TxPriMapReg</a> (CSL_cpswHandle hCpswRegs, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:ga2b0c2b88165a0e2847d6994fcbe7fcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050b2dc7d518b5fc47e190f10f6f3e3d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga050b2dc7d518b5fc47e190f10f6f3e3d">CSL_CPSW_setPort0TxPriMapReg</a> (CSL_cpswHandle hCpswRegs, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:ga050b2dc7d518b5fc47e190f10f6f3e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78bac6f1374b7a54f61ba2c81649a239"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga78bac6f1374b7a54f61ba2c81649a239">CSL_CPSW_getPortMaxBlocksReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 *pRxMaxBlks, Uint32 *pTxMaxBlks)</td></tr>
<tr class="separator:ga78bac6f1374b7a54f61ba2c81649a239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab19617996572ec3771f4f6d8be695d30"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gab19617996572ec3771f4f6d8be695d30">CSL_CPSW_setPortMaxBlocksReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 rxMaxBlks, Uint32 txMaxBlks)</td></tr>
<tr class="separator:gab19617996572ec3771f4f6d8be695d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c26cc30fa421f5703d1fc43c2714a70"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga1c26cc30fa421f5703d1fc43c2714a70">CSL_CPSW_getPortBlockCountReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 *pRxBlkCnt, Uint32 *pTxBlkCnt)</td></tr>
<tr class="separator:ga1c26cc30fa421f5703d1fc43c2714a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27b4b51b34620010ed5366265ec2e74"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae27b4b51b34620010ed5366265ec2e74">CSL_CPSW_getPortRxPriMapReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:gae27b4b51b34620010ed5366265ec2e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd0bce13bd36bd7f4fd2258ac6e9084"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacdd0bce13bd36bd7f4fd2258ac6e9084">CSL_CPSW_setPortTxPriMapReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:gacdd0bce13bd36bd7f4fd2258ac6e9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa33482aa21c5490841be455aaa9be05"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafa33482aa21c5490841be455aaa9be05">CSL_CPSW_getPortRxDscpMap</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 *pRxDscpPriMap)</td></tr>
<tr class="separator:gafa33482aa21c5490841be455aaa9be05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1ee28d71af39c6c4b7e9dbcec47b82"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaaa1ee28d71af39c6c4b7e9dbcec47b82">CSL_CPSW_setPortRxDscpMap</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 *pRxDscpPriMap)</td></tr>
<tr class="separator:gaaa1ee28d71af39c6c4b7e9dbcec47b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07926bcb1c70f614dc7e222b3f0c966d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga07926bcb1c70f614dc7e222b3f0c966d">CSL_CPSW_getPortVlanReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 *pPortVID, Uint32 *pPortCFI, Uint32 *pPortPRI)</td></tr>
<tr class="separator:ga07926bcb1c70f614dc7e222b3f0c966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34074987ab53ecbc87d27a056f31740c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga34074987ab53ecbc87d27a056f31740c">CSL_CPSW_setPortVlanReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 portVID, Uint32 portCFI, Uint32 portPRI)</td></tr>
<tr class="separator:ga34074987ab53ecbc87d27a056f31740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2edf2dbc8b5494235c77954ecdf8fc22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2edf2dbc8b5494235c77954ecdf8fc22">CSL_CPSW_getPortTxPriMapReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint32 *pPortTxPriMap)</td></tr>
<tr class="separator:ga2edf2dbc8b5494235c77954ecdf8fc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga955d6d214961a753ad0dbb70d38f939d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga955d6d214961a753ad0dbb70d38f939d">CSL_CPSW_getPortMACAddress</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint8 *pMacAddress)</td></tr>
<tr class="separator:ga955d6d214961a753ad0dbb70d38f939d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9501acb879fddf69fa40b9878bc518"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9f9501acb879fddf69fa40b9878bc518">CSL_CPSW_setPortMACAddress</a> (CSL_cpswHandle hCpswRegs, Uint32 portNum, Uint8 *pMacAddress)</td></tr>
<tr class="separator:ga9f9501acb879fddf69fa40b9878bc518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5625f0c69ebcd7743ca778c2106f641e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga5625f0c69ebcd7743ca778c2106f641e">CSL_CPSW_getStats</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *pCpswStats)</td></tr>
<tr class="separator:ga5625f0c69ebcd7743ca778c2106f641e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79e189e3ef55ac6b2c3c9b2bc56fbf9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gab79e189e3ef55ac6b2c3c9b2bc56fbf9">CSL_CPSW_getRawStats</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *pCpswStats)</td></tr>
<tr class="separator:gab79e189e3ef55ac6b2c3c9b2bc56fbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b8f9f5a10556ad2385f8c9f340a0da7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9b8f9f5a10556ad2385f8c9f340a0da7">CSL_CPSW_getAleVersionInfo</a> (CSL_cpswHandle hCpswRegs, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_e_r_s_i_o_n.html">CSL_CPSW_ALE_VERSION</a> *pVersionInfo)</td></tr>
<tr class="separator:ga9b8f9f5a10556ad2385f8c9f340a0da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab991d7c3c65324074aa734e15ab999"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4ab991d7c3c65324074aa734e15ab999">CSL_CPSW_isAleRateLimitEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga4ab991d7c3c65324074aa734e15ab999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f080fec3ec6f0afe8246460973631ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6f080fec3ec6f0afe8246460973631ca">CSL_CPSW_enableAleRateLimit</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga6f080fec3ec6f0afe8246460973631ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d20bbf7bddf2959881fdaaec77706c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga40d20bbf7bddf2959881fdaaec77706c">CSL_CPSW_disableAleRateLimit</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga40d20bbf7bddf2959881fdaaec77706c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cab9d77fa1a282666788f7e3dd42324"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2cab9d77fa1a282666788f7e3dd42324">CSL_CPSW_isAleMacAuthModeEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga2cab9d77fa1a282666788f7e3dd42324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7310dfd724d74ee80b7f8864a67b6190"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7310dfd724d74ee80b7f8864a67b6190">CSL_CPSW_enableAleMacAuthMode</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga7310dfd724d74ee80b7f8864a67b6190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54170691ae819e021eafca288174a9ee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga54170691ae819e021eafca288174a9ee">CSL_CPSW_disableAleMacAuthMode</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga54170691ae819e021eafca288174a9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8843c51c67efdc1eb39a7ad0f5a881d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf8843c51c67efdc1eb39a7ad0f5a881d">CSL_CPSW_isAleVlanAwareEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaf8843c51c67efdc1eb39a7ad0f5a881d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a18f8ad933e9d614a186c310397aee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga07a18f8ad933e9d614a186c310397aee">CSL_CPSW_enableAleVlanAware</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga07a18f8ad933e9d614a186c310397aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69f95d66e9957f6f29b544a0ed79c69"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad69f95d66e9957f6f29b544a0ed79c69">CSL_CPSW_disableAleVlanAware</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gad69f95d66e9957f6f29b544a0ed79c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908b2389986abe97cf32bc069d491290"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga908b2389986abe97cf32bc069d491290">CSL_CPSW_isAleTxRateLimitEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga908b2389986abe97cf32bc069d491290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2a21f763db5035fcc07746a025a950"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaac2a21f763db5035fcc07746a025a950">CSL_CPSW_enableAleTxRateLimit</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaac2a21f763db5035fcc07746a025a950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb7e5816163d32a85dc746878350b81f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafb7e5816163d32a85dc746878350b81f">CSL_CPSW_disableAleTxRateLimit</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gafb7e5816163d32a85dc746878350b81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e95e0313df9b44a3186c56cda04f577"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga5e95e0313df9b44a3186c56cda04f577">CSL_CPSW_isAleBypassEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga5e95e0313df9b44a3186c56cda04f577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038f16c1ef6e592ec88dc0ed1d496a62"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga038f16c1ef6e592ec88dc0ed1d496a62">CSL_CPSW_enableAleBypass</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga038f16c1ef6e592ec88dc0ed1d496a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab6ef2d2175b24b1dd7a036c399aae5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gadab6ef2d2175b24b1dd7a036c399aae5">CSL_CPSW_disableAleBypass</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gadab6ef2d2175b24b1dd7a036c399aae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f817d80679fce8ecdff9ec491df2597"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga1f817d80679fce8ecdff9ec491df2597">CSL_CPSW_isAleOUIDenyModeEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga1f817d80679fce8ecdff9ec491df2597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36602485c3e6be8c82178c728198a9b9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga36602485c3e6be8c82178c728198a9b9">CSL_CPSW_enableAleOUIDenyMode</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga36602485c3e6be8c82178c728198a9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9f08f17c5afc20cb07b30a21969121b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa9f08f17c5afc20cb07b30a21969121b">CSL_CPSW_disableAleOUIDenyMode</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaa9f08f17c5afc20cb07b30a21969121b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3de490afaf939fcdd128f26fbad8664"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf3de490afaf939fcdd128f26fbad8664">CSL_CPSW_isAleVID0ModeEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaf3de490afaf939fcdd128f26fbad8664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e3c96eab7360f9bbb113e4ddf870ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga74e3c96eab7360f9bbb113e4ddf870ba">CSL_CPSW_enableAleVID0Mode</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga74e3c96eab7360f9bbb113e4ddf870ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf57e104256825c089cedaf7344bc6438"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf57e104256825c089cedaf7344bc6438">CSL_CPSW_disableAleVID0Mode</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaf57e104256825c089cedaf7344bc6438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00fef84821e309ed3949d181e9bd493"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf00fef84821e309ed3949d181e9bd493">CSL_CPSW_isAleLearnNoVIDEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaf00fef84821e309ed3949d181e9bd493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94202092dceb7373d9121caa1ba47dff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga94202092dceb7373d9121caa1ba47dff">CSL_CPSW_enableAleLearnNoVID</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga94202092dceb7373d9121caa1ba47dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b810c0bb12fa5ae75726a1d5b8f3ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa9b810c0bb12fa5ae75726a1d5b8f3ff">CSL_CPSW_disableAleLearnNoVID</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaa9b810c0bb12fa5ae75726a1d5b8f3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab331805822c688c1098eb422e76ed24b"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gab331805822c688c1098eb422e76ed24b">CSL_CPSW_isAleUUNIToHostEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gab331805822c688c1098eb422e76ed24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3309898ee4fa5f03a32de2c44cded29d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3309898ee4fa5f03a32de2c44cded29d">CSL_CPSW_enableAleUUNIToHost</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga3309898ee4fa5f03a32de2c44cded29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86658b0b55261054ed8c865b92e05be5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga86658b0b55261054ed8c865b92e05be5">CSL_CPSW_disableAleUUNIToHost</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga86658b0b55261054ed8c865b92e05be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a9ba1dbdadc3982c3145b89774a6f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac3a9ba1dbdadc3982c3145b89774a6f8">CSL_CPSW_startAleAgeOutNow</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gac3a9ba1dbdadc3982c3145b89774a6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc38f81cd9fbac78e035d5ec115f3a1"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga0cc38f81cd9fbac78e035d5ec115f3a1">CSL_CPSW_isAleAgeOutDone</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga0cc38f81cd9fbac78e035d5ec115f3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b895d1cc8dbf1cad9f8a0c9d8465f6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaa4b895d1cc8dbf1cad9f8a0c9d8465f6">CSL_CPSW_clearAleTable</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaa4b895d1cc8dbf1cad9f8a0c9d8465f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d5a8ef342469696d53297aa9398544c"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3d5a8ef342469696d53297aa9398544c">CSL_CPSW_isAleEnabled</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga3d5a8ef342469696d53297aa9398544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c88d9be88844f94ec61dc30cb8f226f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7c88d9be88844f94ec61dc30cb8f226f">CSL_CPSW_enableAle</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga7c88d9be88844f94ec61dc30cb8f226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7290a7e7ea6838c1c0e545929ba5e18f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7290a7e7ea6838c1c0e545929ba5e18f">CSL_CPSW_disableAle</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga7290a7e7ea6838c1c0e545929ba5e18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66a6367fe7d72debb43f999cd17cd54"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf66a6367fe7d72debb43f999cd17cd54">CSL_CPSW_getAleControlReg</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:gaf66a6367fe7d72debb43f999cd17cd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1922f63d921905c84fc36a8700cf2e10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga1922f63d921905c84fc36a8700cf2e10">CSL_CPSW_setAleControlReg</a> (CSL_cpswHandle hCpswRegs, Uint32 aleCtrlVal)</td></tr>
<tr class="separator:ga1922f63d921905c84fc36a8700cf2e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860d45da1d6f189badf3d3f629db6572"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga860d45da1d6f189badf3d3f629db6572">CSL_CPSW_getAlePrescaleReg</a> (CSL_cpswHandle hCpswRegs)</td></tr>
<tr class="separator:ga860d45da1d6f189badf3d3f629db6572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6e69be0ffc963e9ce9fa86019b30f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga1b6e69be0ffc963e9ce9fa86019b30f3">CSL_CPSW_setAlePrescaleReg</a> (CSL_cpswHandle hCpswRegs, Uint32 alePrescaleVal)</td></tr>
<tr class="separator:ga1b6e69be0ffc963e9ce9fa86019b30f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eccf6dff9012b321ec2ad2e9fd4c494"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4eccf6dff9012b321ec2ad2e9fd4c494">CSL_CPSW_getAleUnkownVlanReg</a> (CSL_cpswHandle hCpswRegs, Uint32 *pUnVlanMemList, Uint32 *pUnMcastFloodMask, Uint32 *pUnRegMcastFloodMask, Uint32 *pUnForceUntagEgress)</td></tr>
<tr class="separator:ga4eccf6dff9012b321ec2ad2e9fd4c494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga763c5577b1d00023a8412d42dd32cb38"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga763c5577b1d00023a8412d42dd32cb38">CSL_CPSW_setAleUnkownVlanReg</a> (CSL_cpswHandle hCpswRegs, Uint32 unVlanMemList, Uint32 unMcastFloodMask, Uint32 unRegMcastFloodMask, Uint32 unForceUntagEgress)</td></tr>
<tr class="separator:ga763c5577b1d00023a8412d42dd32cb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea0491d1123e54823d7862cca4ff325"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gacea0491d1123e54823d7862cca4ff325">CSL_CPSW_getAleTableEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, Uint32 *pAleInfoWd0, Uint32 *pAleInfoWd1, Uint32 *pAleInfoWd2)</td></tr>
<tr class="separator:gacea0491d1123e54823d7862cca4ff325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32fe555d733bbd7657cf4bcb8e9c398"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gab32fe555d733bbd7657cf4bcb8e9c398">CSL_CPSW_setAleTableEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, Uint32 aleInfoWd0, Uint32 aleInfoWd1, Uint32 aleInfoWd2)</td></tr>
<tr class="separator:gab32fe555d733bbd7657cf4bcb8e9c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0b34f04a182694932b6986f10392546"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga6ea23133eb6b1517c106ca3f1a8b7729">CSL_CPSW_ALE_ENTRYTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad0b34f04a182694932b6986f10392546">CSL_CPSW_getALEEntryType</a> (CSL_cpswHandle hCpswRegs, Uint32 index)</td></tr>
<tr class="separator:gad0b34f04a182694932b6986f10392546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52a9ce02197684319116e8c82802e13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#gac08366dceb5ccaea33ad2555f63471d5">CSL_CPSW_ALE_ADDRTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac52a9ce02197684319116e8c82802e13">CSL_CPSW_getALEAddressType</a> (CSL_cpswHandle hCpswRegs, Uint32 index)</td></tr>
<tr class="separator:gac52a9ce02197684319116e8c82802e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7fc16d53f42d460bffb6e41e653578"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3f7fc16d53f42d460bffb6e41e653578">CSL_CPSW_getAleMcastAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *pMcastAddrCfg)</td></tr>
<tr class="separator:ga3f7fc16d53f42d460bffb6e41e653578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8e42b5febbe3d4bc4238ca42b14e9f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gace8e42b5febbe3d4bc4238ca42b14e9f">CSL_CPSW_setAleMcastAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *pMcastAddrCfg)</td></tr>
<tr class="separator:gace8e42b5febbe3d4bc4238ca42b14e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d677f84db32f0e58952df6139912cac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8d677f84db32f0e58952df6139912cac">CSL_CPSW_getAleVlanMcastAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *pVlanMcastAddrCfg)</td></tr>
<tr class="separator:ga8d677f84db32f0e58952df6139912cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8e763d04272386d7cb2b71d3c8256d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga6d8e763d04272386d7cb2b71d3c8256d">CSL_CPSW_setAleVlanMcastAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *pVlanMcastAddrCfg)</td></tr>
<tr class="separator:ga6d8e763d04272386d7cb2b71d3c8256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130a6d86b911600b79c56292ae91ae1a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga130a6d86b911600b79c56292ae91ae1a">CSL_CPSW_getAleUnicastAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *pUcastAddrCfg)</td></tr>
<tr class="separator:ga130a6d86b911600b79c56292ae91ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7156bf956d80dc1fcb8eb3c991ceed95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7156bf956d80dc1fcb8eb3c991ceed95">CSL_CPSW_setAleUnicastAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *pUcastAddrCfg)</td></tr>
<tr class="separator:ga7156bf956d80dc1fcb8eb3c991ceed95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae030b1f7afab932096107e6491f6a211"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gae030b1f7afab932096107e6491f6a211">CSL_CPSW_getAleOUIAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *pOUIAddrCfg)</td></tr>
<tr class="separator:gae030b1f7afab932096107e6491f6a211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4458ad08823d81716458f7db3cb86c00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4458ad08823d81716458f7db3cb86c00">CSL_CPSW_setAleOUIAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *pOUIAddrCfg)</td></tr>
<tr class="separator:ga4458ad08823d81716458f7db3cb86c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7b93a48d2a9fde6edda55924c91534"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gabb7b93a48d2a9fde6edda55924c91534">CSL_CPSW_getAleVlanUnicastAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *pVlanUcastAddrCfg)</td></tr>
<tr class="separator:gabb7b93a48d2a9fde6edda55924c91534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e63a1711209b0c35e0de14e6f3fecff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7e63a1711209b0c35e0de14e6f3fecff">CSL_CPSW_setAleVlanUnicastAddrEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *pVlanUcastAddrCfg)</td></tr>
<tr class="separator:ga7e63a1711209b0c35e0de14e6f3fecff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a332f3db4e6209c710c56116c6c17aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4a332f3db4e6209c710c56116c6c17aa">CSL_CPSW_getAleVlanEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *pVlanCfg)</td></tr>
<tr class="separator:ga4a332f3db4e6209c710c56116c6c17aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff0952d30e5a54255fd892efd459445e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaff0952d30e5a54255fd892efd459445e">CSL_CPSW_setAleVlanEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *pVlanCfg)</td></tr>
<tr class="separator:gaff0952d30e5a54255fd892efd459445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e6d309810058a00fc32b011c725b81"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf6e6d309810058a00fc32b011c725b81">CSL_CPSW_getAleOutValnEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *pOutValnCfg)</td></tr>
<tr class="separator:gaf6e6d309810058a00fc32b011c725b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9705ca1459395b8502fcf41b9680ba6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac9705ca1459395b8502fcf41b9680ba6">CSL_CPSW_setAleOutValnEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *pOutValnCfg)</td></tr>
<tr class="separator:gac9705ca1459395b8502fcf41b9680ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853a2392b87b584ced02e1c57de3809a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga853a2392b87b584ced02e1c57de3809a">CSL_CPSW_getAleEthertypeEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *pEthertypeCfg)</td></tr>
<tr class="separator:ga853a2392b87b584ced02e1c57de3809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f093b048251f2712c3e0166f90ee50"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga88f093b048251f2712c3e0166f90ee50">CSL_CPSW_setAleEthertypeEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *pEthertypeCfg)</td></tr>
<tr class="separator:ga88f093b048251f2712c3e0166f90ee50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb84a2c44b2bacf2b0d393971771b7a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gabb84a2c44b2bacf2b0d393971771b7a6">CSL_CPSW_getAleIPv4Entry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *pIPv4Cfg)</td></tr>
<tr class="separator:gabb84a2c44b2bacf2b0d393971771b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7ba58f71b039cefb4c0d478a11648da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad7ba58f71b039cefb4c0d478a11648da">CSL_CPSW_setAleIPv4Entry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *pIPv4Cfg)</td></tr>
<tr class="separator:gad7ba58f71b039cefb4c0d478a11648da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac34ff1c919a9a269fd82bab529e0fd71"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac34ff1c919a9a269fd82bab529e0fd71">CSL_CPSW_getAleIPv6Entry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *pIPv6Cfg)</td></tr>
<tr class="separator:gac34ff1c919a9a269fd82bab529e0fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa583dcdb4a94de870d023e507039b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7fa583dcdb4a94de870d023e507039b2">CSL_CPSW_setAleIPv6Entry</a> (CSL_cpswHandle hCpswRegs, Uint32 index, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *pIPv6Cfg)</td></tr>
<tr class="separator:ga7fa583dcdb4a94de870d023e507039b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff707e56df3271f23801dafc0ed2f4a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaff707e56df3271f23801dafc0ed2f4a3">CSL_CPSW_clearAleEntry</a> (CSL_cpswHandle hCpswRegs, Uint32 index)</td></tr>
<tr class="separator:gaff707e56df3271f23801dafc0ed2f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0ad015de0ca4f4f1ea5070f9cf6ff7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4c0ad015de0ca4f4f1ea5070f9cf6ff7">CSL_CPSW_getAlePortControlReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNo, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *pPortControlInfo)</td></tr>
<tr class="separator:ga4c0ad015de0ca4f4f1ea5070f9cf6ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5663f18419cfe84fd818e0a4eb66a06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac5663f18419cfe84fd818e0a4eb66a06">CSL_CPSW_setAlePortControlReg</a> (CSL_cpswHandle hCpswRegs, Uint32 portNo, <a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *pPortControlInfo)</td></tr>
<tr class="separator:gac5663f18419cfe84fd818e0a4eb66a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fecfcaefcef2fb7455886bd78c2a26f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3fecfcaefcef2fb7455886bd78c2a26f">CSL_CPSW_isCpdmaResetDone</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="separator:ga3fecfcaefcef2fb7455886bd78c2a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577b73ac830a4c6aad02030d7ced8392"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga577b73ac830a4c6aad02030d7ced8392">CSL_CPSW_resetCpdma</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="separator:ga577b73ac830a4c6aad02030d7ced8392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844f707dfe4b1e92d960a32c44a17d22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga844f707dfe4b1e92d960a32c44a17d22">CSL_CPSW_enableCpdmaTxInt</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel)</td></tr>
<tr class="memdesc:ga844f707dfe4b1e92d960a32c44a17d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the TXPULSE Interrupt Generation.  <a href="#ga844f707dfe4b1e92d960a32c44a17d22">More...</a><br /></td></tr>
<tr class="separator:ga844f707dfe4b1e92d960a32c44a17d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056b3655f9ec4489d0a4f69220571f14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga056b3655f9ec4489d0a4f69220571f14">CSL_CPSW_enableCpdmaRxInt</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel)</td></tr>
<tr class="memdesc:ga056b3655f9ec4489d0a4f69220571f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the RXPULSE Interrupt Generation.  <a href="#ga056b3655f9ec4489d0a4f69220571f14">More...</a><br /></td></tr>
<tr class="separator:ga056b3655f9ec4489d0a4f69220571f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeaf06ed8cceb86c0525198e709623fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gadeaf06ed8cceb86c0525198e709623fe">CSL_CPSW_disableCpdmaTxInt</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel)</td></tr>
<tr class="memdesc:gadeaf06ed8cceb86c0525198e709623fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the TXPULSE Interrupt Generation.  <a href="#gadeaf06ed8cceb86c0525198e709623fe">More...</a><br /></td></tr>
<tr class="separator:gadeaf06ed8cceb86c0525198e709623fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c255e05667a773c49ba4f38fcc0e0ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga1c255e05667a773c49ba4f38fcc0e0ed">CSL_CPSW_disableCpdmaRxInt</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel)</td></tr>
<tr class="memdesc:ga1c255e05667a773c49ba4f38fcc0e0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the RXPULSE Interrupt Generation.  <a href="#ga1c255e05667a773c49ba4f38fcc0e0ed">More...</a><br /></td></tr>
<tr class="separator:ga1c255e05667a773c49ba4f38fcc0e0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada81933328d77d7c956cc86a1e204b7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gada81933328d77d7c956cc86a1e204b7a">CSL_CPSW_enableCpdmaTx</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:gada81933328d77d7c956cc86a1e204b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to enable the transmit in the TX Control Register. After the transmit is enabled, any write to TXHDP of a channel will start transmission.  <a href="#gada81933328d77d7c956cc86a1e204b7a">More...</a><br /></td></tr>
<tr class="separator:gada81933328d77d7c956cc86a1e204b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067ba5ba98a59478f1fe1e616336a490"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga067ba5ba98a59478f1fe1e616336a490">CSL_CPSW_enableCpdmaRx</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga067ba5ba98a59478f1fe1e616336a490"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to enable the receive in the RX Control Register. After the receive is enabled, and write to RXHDP of a channel, the data can be received in the destination specified by the corresponding RX buffer descriptor.  <a href="#ga067ba5ba98a59478f1fe1e616336a490">More...</a><br /></td></tr>
<tr class="separator:ga067ba5ba98a59478f1fe1e616336a490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4343793ed6dfe949553fbe8ec9e28d1c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4343793ed6dfe949553fbe8ec9e28d1c">CSL_CPSW_setCpdmaTxHdrDescPtr</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 descHdr, Uint32 channel)</td></tr>
<tr class="memdesc:ga4343793ed6dfe949553fbe8ec9e28d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to write the TX HDP register. If transmit is enabled, write to the TX HDP will immediately start transmission. The data will be taken from the buffer pointer of the TX buffer descriptor written to the TX HDP.  <a href="#ga4343793ed6dfe949553fbe8ec9e28d1c">More...</a><br /></td></tr>
<tr class="separator:ga4343793ed6dfe949553fbe8ec9e28d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce55a89822e9c66ecdd66561ca754e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8ce55a89822e9c66ecdd66561ca754e8">CSL_CPSW_setCpdmaRxHdrDescPtr</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 descHdr, Uint32 channel)</td></tr>
<tr class="memdesc:ga8ce55a89822e9c66ecdd66561ca754e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to write the RX HDP register. If receive is enabled, write to the RX HDP will enable data reception to point to the corresponding RX buffer descriptor's buffer pointer.  <a href="#ga8ce55a89822e9c66ecdd66561ca754e8">More...</a><br /></td></tr>
<tr class="separator:ga8ce55a89822e9c66ecdd66561ca754e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc26458252b306edaa3fcf3c50a6f55"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4fc26458252b306edaa3fcf3c50a6f55">CSL_CPSW_setCpdmaTxEndOfIntVector</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga4fc26458252b306edaa3fcf3c50a6f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the DMA End Of Interrupt Vector.  <a href="#ga4fc26458252b306edaa3fcf3c50a6f55">More...</a><br /></td></tr>
<tr class="separator:ga4fc26458252b306edaa3fcf3c50a6f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0b48257289e5a4e4d616dcac23f73f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2e0b48257289e5a4e4d616dcac23f73f">CSL_CPSW_setCpdmaRxEndOfIntVector</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga2e0b48257289e5a4e4d616dcac23f73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the DMA End Of Interrupt Vector.  <a href="#ga2e0b48257289e5a4e4d616dcac23f73f">More...</a><br /></td></tr>
<tr class="separator:ga2e0b48257289e5a4e4d616dcac23f73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ead09ca9132c10f592b34f9a94574bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga5ead09ca9132c10f592b34f9a94574bc">CSL_CPSW_setCpdmaRxThresholdEndOfIntVector</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga5ead09ca9132c10f592b34f9a94574bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the DMA End Of Interrupt Vector.  <a href="#ga5ead09ca9132c10f592b34f9a94574bc">More...</a><br /></td></tr>
<tr class="separator:ga5ead09ca9132c10f592b34f9a94574bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga128e70a4f51ee79896ac6a1cc6524352"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga128e70a4f51ee79896ac6a1cc6524352">CSL_CPSW_setCpdmaMiscEndOfIntVector</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga128e70a4f51ee79896ac6a1cc6524352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the DMA End Of Interrupt Vector.  <a href="#ga128e70a4f51ee79896ac6a1cc6524352">More...</a><br /></td></tr>
<tr class="separator:ga128e70a4f51ee79896ac6a1cc6524352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40cd8c07a98b3de6674ba48ceb8e11af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga40cd8c07a98b3de6674ba48ceb8e11af">CSL_CPSW_setCpdmaTxCp</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel, Uint32 comPtr)</td></tr>
<tr class="memdesc:ga40cd8c07a98b3de6674ba48ceb8e11af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the the TX Completion Pointer for a specific channel.  <a href="#ga40cd8c07a98b3de6674ba48ceb8e11af">More...</a><br /></td></tr>
<tr class="separator:ga40cd8c07a98b3de6674ba48ceb8e11af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga715716f357b05a261adac6fcb99d518e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga715716f357b05a261adac6fcb99d518e">CSL_CPSW_setCpdmaRxCp</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel, Uint32 comPtr)</td></tr>
<tr class="memdesc:ga715716f357b05a261adac6fcb99d518e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the the RX Completion Pointer for a specific channel.  <a href="#ga715716f357b05a261adac6fcb99d518e">More...</a><br /></td></tr>
<tr class="separator:ga715716f357b05a261adac6fcb99d518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga229da5c7671e73349f2eb88f46fa6761"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga229da5c7671e73349f2eb88f46fa6761">CSL_CPSW_getCpdmaTxCp</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel, Uint32 *comPtr)</td></tr>
<tr class="memdesc:ga229da5c7671e73349f2eb88f46fa6761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the the TX Completion Pointer for a specific channel.  <a href="#ga229da5c7671e73349f2eb88f46fa6761">More...</a><br /></td></tr>
<tr class="separator:ga229da5c7671e73349f2eb88f46fa6761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e6318a0129192804fcb18719007d38"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga58e6318a0129192804fcb18719007d38">CSL_CPSW_getCpdmaRxCp</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel, Uint32 *comPtr)</td></tr>
<tr class="memdesc:ga58e6318a0129192804fcb18719007d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the the RX Completion Pointer for a specific channel.  <a href="#ga58e6318a0129192804fcb18719007d38">More...</a><br /></td></tr>
<tr class="separator:ga58e6318a0129192804fcb18719007d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6ca4c0a97640d91bea8c4bf597b375"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3b6ca4c0a97640d91bea8c4bf597b375">CSL_CPSW_setCpdmaNumFreeBuf</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 channel, Uint32 nBuf)</td></tr>
<tr class="memdesc:ga3b6ca4c0a97640d91bea8c4bf597b375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the free buffers for a specific channel.  <a href="#ga3b6ca4c0a97640d91bea8c4bf597b375">More...</a><br /></td></tr>
<tr class="separator:ga3b6ca4c0a97640d91bea8c4bf597b375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c2c89d1b28ebde9cc6a48bd63c38e8"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga80c2c89d1b28ebde9cc6a48bd63c38e8">CSL_CPSW_getCpdmaStatus</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga80c2c89d1b28ebde9cc6a48bd63c38e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CPDMA Status.  <a href="#ga80c2c89d1b28ebde9cc6a48bd63c38e8">More...</a><br /></td></tr>
<tr class="separator:ga80c2c89d1b28ebde9cc6a48bd63c38e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92163b0b57cf7393934166a71c3db4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaf92163b0b57cf7393934166a71c3db4c">CSL_CPSW_configCpdma</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 cfg)</td></tr>
<tr class="memdesc:gaf92163b0b57cf7393934166a71c3db4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the CPDMA module by writing the configuration value to the DMA control register.  <a href="#gaf92163b0b57cf7393934166a71c3db4c">More...</a><br /></td></tr>
<tr class="separator:gaf92163b0b57cf7393934166a71c3db4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb757169e4d9434f3e8af8495c4501f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7cb757169e4d9434f3e8af8495c4501f">CSL_CPSW_enableCpdmaIdle</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga7cb757169e4d9434f3e8af8495c4501f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the command idle mode for CPDMA. When this API is called, the CPSW stops all the reception and transmission. However, if receiving the current frame will be received completely before going to the idle state. Also, while transmitting, the contents in the fifo will be sent fully.  <a href="#ga7cb757169e4d9434f3e8af8495c4501f">More...</a><br /></td></tr>
<tr class="separator:ga7cb757169e4d9434f3e8af8495c4501f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767038452ce8576bfc9ceaa564c636ec"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga767038452ce8576bfc9ceaa564c636ec">CSL_CPSW_isCpdmaIdle</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="separator:ga767038452ce8576bfc9ceaa564c636ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35197be3b285a65cb77410e41d814cd0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga35197be3b285a65cb77410e41d814cd0">CSL_CPSW_disableCpdmaCmdIdle</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga35197be3b285a65cb77410e41d814cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the command idle mode for CPDMA.  <a href="#ga35197be3b285a65cb77410e41d814cd0">More...</a><br /></td></tr>
<tr class="separator:ga35197be3b285a65cb77410e41d814cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f1fdb545d00531e0e14586c0e3aca67"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga0f1fdb545d00531e0e14586c0e3aca67">CSL_CPSW_setCpdmaRxBufOffset</a> (CSL_cpdmaHandle hCpdmaRegs, Uint32 bufOff)</td></tr>
<tr class="memdesc:ga0f1fdb545d00531e0e14586c0e3aca67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RX buffer offset value. The RX buffer offset will be written by the port into each frame SOP buffer descriptor buffer_offset field. The frame data will begin after the rx_buffer_offset value of bytes. This value will be used for all the channels .  <a href="#ga0f1fdb545d00531e0e14586c0e3aca67">More...</a><br /></td></tr>
<tr class="separator:ga0f1fdb545d00531e0e14586c0e3aca67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73376a48ffa8037b09e814c49eaac8f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad73376a48ffa8037b09e814c49eaac8f">CSL_CPSW_getCpdmaTxIntStatRaw</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:gad73376a48ffa8037b09e814c49eaac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw transmit interrupt pending status.  <a href="#gad73376a48ffa8037b09e814c49eaac8f">More...</a><br /></td></tr>
<tr class="separator:gad73376a48ffa8037b09e814c49eaac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5d9dc31fc9251526c2f77d2898fd2c"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4b5d9dc31fc9251526c2f77d2898fd2c">CSL_CPSW_getCpdmaTxIntStatMasked</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga4b5d9dc31fc9251526c2f77d2898fd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the masked transmit interrupt pending status.  <a href="#ga4b5d9dc31fc9251526c2f77d2898fd2c">More...</a><br /></td></tr>
<tr class="separator:ga4b5d9dc31fc9251526c2f77d2898fd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb1b180bf445ee40ce6b5d24a2eae03"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gaffb1b180bf445ee40ce6b5d24a2eae03">CSL_CPSW_getCpdmaRxIntStatRaw</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:gaffb1b180bf445ee40ce6b5d24a2eae03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw receive interrupt pending status.  <a href="#gaffb1b180bf445ee40ce6b5d24a2eae03">More...</a><br /></td></tr>
<tr class="separator:gaffb1b180bf445ee40ce6b5d24a2eae03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38bcfd6760125b600cf89569300a6643"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga38bcfd6760125b600cf89569300a6643">CSL_CPSW_getCpdmaRxIntStatMasked</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga38bcfd6760125b600cf89569300a6643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the masked receive interrupt pending status.  <a href="#ga38bcfd6760125b600cf89569300a6643">More...</a><br /></td></tr>
<tr class="separator:ga38bcfd6760125b600cf89569300a6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8bb2cb71dd6fcf16f80c3905a6a2d4"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga3b8bb2cb71dd6fcf16f80c3905a6a2d4">CSL_CPSW_getCpdmaRxThreshIntStatRaw</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga3b8bb2cb71dd6fcf16f80c3905a6a2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw receive interrupt pending status.  <a href="#ga3b8bb2cb71dd6fcf16f80c3905a6a2d4">More...</a><br /></td></tr>
<tr class="separator:ga3b8bb2cb71dd6fcf16f80c3905a6a2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a246389daddd5a9e36f243f92d5e3a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac4a246389daddd5a9e36f243f92d5e3a">CSL_CPSW_getCpdmaRxThreshIntStatMasked</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:gac4a246389daddd5a9e36f243f92d5e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the masked receive interrupt pending status.  <a href="#gac4a246389daddd5a9e36f243f92d5e3a">More...</a><br /></td></tr>
<tr class="separator:gac4a246389daddd5a9e36f243f92d5e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8838d73f42b0519be843d960ae4adc6f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8838d73f42b0519be843d960ae4adc6f">CSL_CPSW_getCpdmaDmaIntStatRaw</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga8838d73f42b0519be843d960ae4adc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw receive interrupt pending status.  <a href="#ga8838d73f42b0519be843d960ae4adc6f">More...</a><br /></td></tr>
<tr class="separator:ga8838d73f42b0519be843d960ae4adc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c55ba09834fd6a208ddcb236c0a1459"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga1c55ba09834fd6a208ddcb236c0a1459">CSL_CPSW_getCpdmaDmaIntStatMasked</a> (CSL_cpdmaHandle hCpdmaRegs)</td></tr>
<tr class="memdesc:ga1c55ba09834fd6a208ddcb236c0a1459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the masked receive interrupt pending status.  <a href="#ga1c55ba09834fd6a208ddcb236c0a1459">More...</a><br /></td></tr>
<tr class="separator:ga1c55ba09834fd6a208ddcb236c0a1459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ed986b08034826ea21a6660add3e3d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga52ed986b08034826ea21a6660add3e3d">CSL_CPSW_isWrResetDone</a> (CSL_wrHandle hWrRegs)</td></tr>
<tr class="separator:ga52ed986b08034826ea21a6660add3e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84922ba2f35c3c9d58165ad9286af7ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga84922ba2f35c3c9d58165ad9286af7ba">CSL_CPSW_resetWr</a> (CSL_wrHandle hWrRegs)</td></tr>
<tr class="separator:ga84922ba2f35c3c9d58165ad9286af7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcc34b5b0baf38b92266dc437a1e356"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga4bcc34b5b0baf38b92266dc437a1e356">CSL_CPSW_resetWrControlReg</a> (CSL_wrHandle hWrRegs)</td></tr>
<tr class="memdesc:ga4bcc34b5b0baf38b92266dc437a1e356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the Control Register of CPSW Wrapper module.  <a href="#ga4bcc34b5b0baf38b92266dc437a1e356">More...</a><br /></td></tr>
<tr class="separator:ga4bcc34b5b0baf38b92266dc437a1e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6653048159d45580e4077446c771599"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gab6653048159d45580e4077446c771599">CSL_CPSW_enableWrRxThresholdInt</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:gab6653048159d45580e4077446c771599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables an interrupt for the specified core.  <a href="#gab6653048159d45580e4077446c771599">More...</a><br /></td></tr>
<tr class="separator:gab6653048159d45580e4077446c771599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac840dc17e4ee2b11fc34e0054ebf85b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac840dc17e4ee2b11fc34e0054ebf85b7">CSL_CPSW_enableWrRxInt</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:gac840dc17e4ee2b11fc34e0054ebf85b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables an interrupt for the specified core.  <a href="#gac840dc17e4ee2b11fc34e0054ebf85b7">More...</a><br /></td></tr>
<tr class="separator:gac840dc17e4ee2b11fc34e0054ebf85b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2092de58ffcaecab63a2d2c6b511bf86"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga2092de58ffcaecab63a2d2c6b511bf86">CSL_CPSW_enableWrTxInt</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:ga2092de58ffcaecab63a2d2c6b511bf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables an interrupt for the specified core.  <a href="#ga2092de58ffcaecab63a2d2c6b511bf86">More...</a><br /></td></tr>
<tr class="separator:ga2092de58ffcaecab63a2d2c6b511bf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac503399bf5018a544350373e7598ab48"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac503399bf5018a544350373e7598ab48">CSL_CPSW_enableWrMiscInt</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 miscIntrMask)</td></tr>
<tr class="memdesc:gac503399bf5018a544350373e7598ab48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables an interrupt for the specified core.  <a href="#gac503399bf5018a544350373e7598ab48">More...</a><br /></td></tr>
<tr class="separator:gac503399bf5018a544350373e7598ab48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac49002bda188dac5bb86fafb2bba2be5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gac49002bda188dac5bb86fafb2bba2be5">CSL_CPSW_disableWrRxThresholdInt</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:gac49002bda188dac5bb86fafb2bba2be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables an interrupt for the specified core.  <a href="#gac49002bda188dac5bb86fafb2bba2be5">More...</a><br /></td></tr>
<tr class="separator:gac49002bda188dac5bb86fafb2bba2be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb431643b5d0ac4b491f70bb33d75963"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gafb431643b5d0ac4b491f70bb33d75963">CSL_CPSW_disableWrRxInt</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:gafb431643b5d0ac4b491f70bb33d75963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables an interrupt for the specified core.  <a href="#gafb431643b5d0ac4b491f70bb33d75963">More...</a><br /></td></tr>
<tr class="separator:gafb431643b5d0ac4b491f70bb33d75963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e75da1a081767c8f1397d6cabb248bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga9e75da1a081767c8f1397d6cabb248bc">CSL_CPSW_disableWrTxInt</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:ga9e75da1a081767c8f1397d6cabb248bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables an interrupt for the specified core.  <a href="#ga9e75da1a081767c8f1397d6cabb248bc">More...</a><br /></td></tr>
<tr class="separator:ga9e75da1a081767c8f1397d6cabb248bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad713049cc9c8aaecec84e525cc5865c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad713049cc9c8aaecec84e525cc5865c9">CSL_CPSW_disableWrMiscInt</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 miscIntrMask)</td></tr>
<tr class="memdesc:gad713049cc9c8aaecec84e525cc5865c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables an interrupt for the specified core.  <a href="#gad713049cc9c8aaecec84e525cc5865c9">More...</a><br /></td></tr>
<tr class="separator:gad713049cc9c8aaecec84e525cc5865c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c87392e126cac66c4c75a2a5cde236f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga8c87392e126cac66c4c75a2a5cde236f">CSL_CPSW_getWrRxThresholdIntStatus</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:ga8c87392e126cac66c4c75a2a5cde236f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status of the core for the specified channel.  <a href="#ga8c87392e126cac66c4c75a2a5cde236f">More...</a><br /></td></tr>
<tr class="separator:ga8c87392e126cac66c4c75a2a5cde236f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fca10cfc23f1bc475b061e34e4d8a2a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga7fca10cfc23f1bc475b061e34e4d8a2a">CSL_CPSW_getWrRxIntStatus</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:ga7fca10cfc23f1bc475b061e34e4d8a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status of the core for the specified channel.  <a href="#ga7fca10cfc23f1bc475b061e34e4d8a2a">More...</a><br /></td></tr>
<tr class="separator:ga7fca10cfc23f1bc475b061e34e4d8a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a33368d6f670da89a9d8e69eb63acf"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#gad7a33368d6f670da89a9d8e69eb63acf">CSL_CPSW_getWrTxIntStatus</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:gad7a33368d6f670da89a9d8e69eb63acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status of the core for the specified channel.  <a href="#gad7a33368d6f670da89a9d8e69eb63acf">More...</a><br /></td></tr>
<tr class="separator:gad7a33368d6f670da89a9d8e69eb63acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10683649b272ae8356a394ef05d283e7"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga10683649b272ae8356a394ef05d283e7">CSL_CPSW_getWrMiscIntStatus</a> (CSL_wrHandle hWrRegs, Uint32 core, Uint32 channel)</td></tr>
<tr class="memdesc:ga10683649b272ae8356a394ef05d283e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status of the core for the specified channel.  <a href="#ga10683649b272ae8356a394ef05d283e7">More...</a><br /></td></tr>
<tr class="separator:ga10683649b272ae8356a394ef05d283e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941b0a30cc0e9f2c4f05519765d30a09"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_p_s_w___f_u_n_c_t_i_o_n.html#ga941b0a30cc0e9f2c4f05519765d30a09">CSL_CPSW_getWrRgmiiStatus</a> (CSL_wrHandle hWrRegs, Uint32 portNum, <a class="el" href="struct_c_s_l___c_p_s_w___w_r___r_g_m_i_i___s_t_a_t_u_s.html">CSL_CPSW_WR_RGMII_STATUS</a> *rgmiiStatus)</td></tr>
<tr class="memdesc:ga941b0a30cc0e9f2c4f05519765d30a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RGMII status requested.  <a href="#ga941b0a30cc0e9f2c4f05519765d30a09">More...</a><br /></td></tr>
<tr class="separator:ga941b0a30cc0e9f2c4f05519765d30a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf8fbb25b17d4908dba3d1ec3d8844aef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_clearAleEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_clearAleEntry</b> </p>
<p><b>Description</b> <br />
 This function clears the ALE entry corresponding to the index specified</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_5GF_ALE_TABLE_WORD0=0, CPSW_5GF_ALE_TABLE_WORD1=0, CPSW_5GF_ALE_TABLE_WORD2=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;

       index   =   0;

       CSL_CPSW_clearAleEntry (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaff707e56df3271f23801dafc0ed2f4a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_clearAleEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_clearAleEntry</b> </p>
<p><b>Description</b> <br />
 This function clears the ALE entry corresponding to the index specified</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0=0, CPSW_3G_TABLE_WORD1=0, CPSW_3G_TABLE_WORD2=0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;

       index   =   0;

       CSL_CPSW_clearAleEntry (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa4b895d1cc8dbf1cad9f8a0c9d8465f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_clearAleTable </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_clearAleTable</b> </p>
<p><b>Description</b> <br />
 This function initiates a full ALE table cleanup. The ALE hardware clears all table entries.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_CLEAR_TABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_clearAleTable ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5c52548f7197b4d74106c69b70794a5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_clearAleTable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_clearAleTable</b> </p>
<p><b>Description</b> <br />
 This function initiates a full ALE table cleanup. The ALE hardware clears all table entries.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_CLEAR_TABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_clearAleTable ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf92163b0b57cf7393934166a71c3db4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_configCpdma </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the CPDMA module by writing the configuration value to the DMA control register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">cfg</td><td>CPDMA configuration written to control register 'cfg' shall be CPDMA_CFG(tx_rlim, rx_cef, cmd_idle, rx_offlen_blk, rx_own, tx_ptype). <br />
 The parameter 'tx_rlim' to CPDMA_CFG can take one of the below values, showing which all channels are rate-limited. <br />
 CPDMA_CFG_TX_RATE_LIM_CH_7 <br />
 CPDMA_CFG_TX_RATE_LIM_CH_7_TO_6 <br />
 CPDMA_CFG_TX_RATE_LIM_CH_7_TO_5 <br />
 CPDMA_CFG_TX_RATE_LIM_CH_7_TO_4 <br />
 CPDMA_CFG_TX_RATE_LIM_CH_7_TO_3 <br />
 CPDMA_CFG_TX_RATE_LIM_CH_7_TO_2 <br />
 CPDMA_CFG_TX_RATE_LIM_CH_7_TO_1 <br />
 CPDMA_CFG_TX_RATE_LIM_CH_7_TO_0 <br />
 The parameter 'rx_cef' to CPDMA_CFG can take one of the below values <br />
 CPDMA_CFG_COPY_ERR_FRAMES - To copy error frames to memory <br />
 CPDMA_CFG_NO_COPY_ERR_FRAMES - Not to copy error frames <br />
 The parameter 'cmd_idle' to CPDMA_CFG can take one of the below values <br />
 CPDMA_CFG_IDLE_COMMAND - Idle commanded <br />
 CPDMA_CFG_IDLE_COMMAND_NONE - Idle not commanded <br />
 The parameter 'rx_offlen_blk' to CPDMA_CFG can take one of the below values <br />
 CPDMA_CFG_BLOCK_RX_OFF_LEN_WRITE - Block the DMA writes to the offset/length field during packet processing. <br />
 CPDMA_CFG_NOT_BLOCK_RX_OFF_LEN_WRITE - Do not Block the DMA writes to the offset/length field during packet processing. <br />
 The parameter 'rx_own' to CPDMA_CFG can take one of the below values <br />
 CPDMA_CFG_RX_OWN_1 - The CPDMA writes 1 to the ownership bit at the end of packet processing. <br />
 CPDMA_CFG_RX_OWN_0 - The CPDMA writes 0 to the ownership bit at the end of packet processing. <br />
 The parameter 'tx_ptype' to CPDMA_CFG can take one of the below values <br />
 CPDMA_CFG_TX_PRI_ROUND_ROBIN - The next channel for transmit is chosen round-robin. <br />
 CPDMA_CFG_TX_PRI_FIXED - The next channel for transmit is chosen priority based, channel 7 with the highest priority <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gabd4bcbae84ad775d8e7c9af018d110bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAle</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable ALE processing.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_ALE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7290a7e7ea6838c1c0e545929ba5e18f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAle </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAle</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable ALE processing.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_ENABLE_ALE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadab6ef2d2175b24b1dd7a036c399aae5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleBypass </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleBypass</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_BYPASS=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleBypass ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafc7de05be39fbd1ffbeccf5eedb81f22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleBypass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleBypass</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ALE_BYPASS=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleBypass ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa9b810c0bb12fa5ae75726a1d5b8f3ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleLearnNoVID </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleLearnNoVID</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN Id learning.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_LEARN_NO_VID=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleLearnNoVID ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafe696477524e4233aa66a612bdbc1de3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleLearnNoVID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleLearnNoVID</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN Id learning.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_LEARN_NO_VID=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleLearnNoVID ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga54170691ae819e021eafca288174a9ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleMacAuthMode </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleMacAuthMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable MAC authorization mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_ENABLE_AUTH_MODE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleMacAuthMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad4832bb7916d4a28c88963218affb3d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleMacAuthMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleMacAuthMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable MAC authorization mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleMacAuthMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa9f08f17c5afc20cb07b30a21969121b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleOUIDenyMode </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleOUIDenyMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_ENABLE_OUI_DENY=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleOUIDenyMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga051001df426cb6d759f3e03c58884f68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleOUIDenyMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleOUIDenyMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_OUI_DENY=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleOUIDenyMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga40d20bbf7bddf2959881fdaaec77706c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleRateLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable multicast, broadcast rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_ENABLE_RATE_LIMIT=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga71e97f01109f666212665e49b5b0107b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleRateLimit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable multicast, broadcast rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafb7e5816163d32a85dc746878350b81f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleTxRateLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleTxRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to select Rx-port based multicast, broadcast rate limiting</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_RATE_LIMIT_TX=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleTxRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaafb5e19c1052b76158c5a586b3603a9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleTxRateLimit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleTxRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable Tx rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_RATE_LIMIT_TX=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleTxRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga86658b0b55261054ed8c865b92e05be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleUUNIToHost </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleUUNIToHost</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable forwarding unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_EN_P0_UNI_FLOOD=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleUUNIToHost ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga051c41c3d267866406ac3a959a1a45ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleUUNIToHost </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleUUNIToHost</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable forwarding unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_CONTROL_REG_UNI_FLOOD_TO_HOST=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleUUNIToHost ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga05ab39274c6f9ac60c1dbedb52134a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleUVLANNoLearn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleUVLANNoLearn</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable unknown VLAN No Learn mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 ALE_CONTROL_REG_ENABLE = 1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_CONTROL_REG_UVLAN_NO_LEARN=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleUVLANNoLearn ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf57e104256825c089cedaf7344bc6438"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleVID0Mode </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleVID0Mode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable VID0 mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_EN_VID0_MODE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleVID0Mode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafc870e1c5f6dce29e02d30b005313a88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleVID0Mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleVID0Mode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable VID0 mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_EN_VID0_MODE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleVID0Mode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad69f95d66e9957f6f29b544a0ed79c69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleVlanAware </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_VLAN_AWARE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga35874ec9a40687f0659c49745b58b77b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableAleVlanAware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableAleVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to disable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ALE_VLAN_AWARE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableAleVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga35197be3b285a65cb77410e41d814cd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableCpdmaCmdIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable the command idle mode for CPDMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c255e05667a773c49ba4f38fcc0e0ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableCpdmaRxInt </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the RXPULSE Interrupt Generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPDMA Module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt to be disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gadeaf06ed8cceb86c0525198e709623fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableCpdmaTxInt </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the TXPULSE Interrupt Generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPDMA Module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt to be disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gafeb9e8aa48c4ca2f7cc3a4c4bd19d505"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableFIFOLoopback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableFIFOLoopback</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable FIFO loopback mode</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_FIFO_LOOPBACK=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableFIFOLoopback ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6a54fb49e16129911b4ed48b10309b64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableFIFOLoopback </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableFIFOLoopback</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable FIFO loopback mode</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SW_CONTROL_FIFO_LOOPBACK=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableFIFOLoopback ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga78a328d7ebc1a5606c37cecc380ad9b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort0</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P0_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort0 ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf7c25fbb1d5ca58a5944bd6563c6425e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort0PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort0PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort0PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae60b1f8de4e9f2c1aa5160116a2fcc88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort1PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort1PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort1PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5e3919abe57f045f73cce4e5337ae86c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort2PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort2PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 2.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort2PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2995e060055d15eea1a9300ba01223d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort3PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort3PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 3.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P3_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort3PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaeefc0b37afe0170c81c04764610266af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort4PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort4PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 4.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P4_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort0PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga22b64066f7658e18da34c1d9bf4e5f64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort5PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort5PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 5.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P5_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort5PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacfa9c71863840a5ba863c190c9c71785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort6PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort6PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 6.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P6_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort6PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa833f906c500266da80bc10291572e02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort7PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort7PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 7.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P7_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort7PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae1d68badc04b0dfc8e7e7f14a7937c34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disablePort8PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disablePort8PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable the Ingress priority tagging on Port 8.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P8_PASS_PRI_TAGGED=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disablePort8PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad55fd15834986cfc11d2854f4e7aa6b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableSoftIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW Soft Idle register to disable Software Idle mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SOFT_IDLE_SOFT_IDLE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableSoftIdle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga83e951cd8359c7757582fcd555653b6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableSoftIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW Soft Idle register to disable Software Idle mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_SOFT_IDLE_REG_SOFT_IDLE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableSoftIdle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga096dfd36aac3b432f2f0b71ceeee4c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableVlanAware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_VLAN_AWARE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad709c76d7458b4420cc367da18f94081"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableVlanAware </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_disableVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to disable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SW_CONTROL_VLAN_AWARE=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_disableVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad713049cc9c8aaecec84e525cc5865c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableWrMiscInt </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>miscIntrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables an interrupt for the specified core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt to be enabled 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gafb431643b5d0ac4b491f70bb33d75963"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableWrRxInt </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables an interrupt for the specified core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt to be enabled 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac49002bda188dac5bb86fafb2bba2be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableWrRxThresholdInt </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables an interrupt for the specified core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt to be enabled 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e75da1a081767c8f1397d6cabb248bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_disableWrTxInt </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables an interrupt for the specified core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt to be enabled 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga98c8b3ba0258c46a4e1f2e510c50c804"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_EEEPortStatus </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___s_t_a_t_u_s.html">CSL_CPSW_EEE_PORT_STATUS</a> *&#160;</td>
          <td class="paramname"><em>pPortStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEEEPortStatus</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the EEE port-specific Status register corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the EEE status
                               must be retrieved.
       pPortStatus             CSL_CPSW_EEE_PORT_STATUS structure holds the EEE Port Status.                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_EEE_STATUS_REG_WAIT_IDLE2LPI, XGE_CPSW_P0_EEE_STATUS_REG_RX_LPI, XGE_CPSW_P0_EEE_STATUS_REG_TX_LPI, XGE_CPSW_P0_EEE_STATUS_REG_TX_WAKE, XGE_CPSW_P0_EEE_STATUS_REG_TX_FIFO_HOLD, XGE_CPSW_P0_EEE_STATUS_REG_TX_FIFO_EMPTY, XGE_CPSW_P0_EEE_STATUS_REG_RX_FIFO_EMPTY,</p>
<p>XGE_CPSW_PN_EEE_STATUS_REG_WAIT_IDLE2LPI, XGE_CPSW_PN_EEE_STATUS_REG_RX_LPI, XGE_CPSW_PN_EEE_STATUS_REG_TX_LPI, XGE_CPSW_PN_EEE_STATUS_REG_TX_WAKE, XGE_CPSW_PN_EEE_STATUS_REG_TX_FIFO_HOLD, XGE_CPSW_PN_EEE_STATUS_REG_TX_FIFO_EMPTY, XGE_CPSW_PN_EEE_STATUS_REG_RX_FIFO_EMPTY</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32                      portNum;
       CSL_CPSW_EEE_PORT_STATUS    portStatus;

       portNum =   1;            

       CSL_CPSW_getEEEPortStatus (portNum, &amp;portStatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadc0be10dd9b43c5f36fddeddcb2d1724"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAle</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable ALE processing.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_ALE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7c88d9be88844f94ec61dc30cb8f226f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAle </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAle</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable ALE processing.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_ENABLE_ALE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga038f16c1ef6e592ec88dc0ed1d496a62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleBypass </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleBypass</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_BYPASS=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleBypass ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2c06a7bbe9c24604339fc29fa92e2bdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleBypass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleBypass</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ALE_BYPASS=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleBypass ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga94202092dceb7373d9121caa1ba47dff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleLearnNoVID </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleLearnNoVID</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN Id No Learn, i.e., disable VLAN Id learning.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_LEARN_NO_VID=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleLearnNoVID ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9f0b47902ab6fed924c443eb1fe5a4e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleLearnNoVID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleLearnNoVID</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN Id No Learn, i.e., disable VLAN Id learning.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_LEARN_NO_VID=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleLearnNoVID ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7310dfd724d74ee80b7f8864a67b6190"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleMacAuthMode </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleMacAuthMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable MAC authorization mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_ENABLE_AUTH_MODE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleMacAuthMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga18dd684c13a30ee8b5cd1ae5884838f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleMacAuthMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleMacAuthMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable MAC authorization mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleMacAuthMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga36602485c3e6be8c82178c728198a9b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleOUIDenyMode </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleOUIDenyMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_ENABLE_OUI_DENY=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleOUIDenyMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab55db9918f18c719a4853f5d59a22824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleOUIDenyMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleOUIDenyMode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_OUI_DENY=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleOUIDenyMode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6f080fec3ec6f0afe8246460973631ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleRateLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable multicast, broadcast rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_ENABLE_RATE_LIMIT=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga32940fbc01d05b4d420728109fdf8225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleRateLimit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable multicast, broadcast rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaac2a21f763db5035fcc07746a025a950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleTxRateLimit </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleTxRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to select Tx-port based multicast, broadcast rate limiting</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 CPSW_3G_CONTROL_ENABLE_RATE_LIMIT=1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_RATE_LIMIT_TX=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleTxRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3e06196311b238dbd9a32255cd9e24fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleTxRateLimit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleTxRateLimit</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable Tx rate limiting.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_RATE_LIMIT_TX=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleTxRateLimit ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3309898ee4fa5f03a32de2c44cded29d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleUUNIToHost </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleUUNIToHost</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable forwarding unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_EN_P0_UNI_FLOOD=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleUUNIToHost ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaadbda43472b8f81f2cd155f1c81236e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleUUNIToHost </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleUUNIToHost</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable forwarding unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_CONTROL_REG_UNI_FLOOD_TO_HOST=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleUUNIToHost ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaab1791c4ec3fd57ec8156b72c6be1a8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleUVLANNoLearn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleUVLANNoLearn</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable Unknown VLAN No Learn mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 ALE_CONTROL_REG_ENABLE = 1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_CONTROL_REG_UVLAN_NO_LEARN=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleUVLANNoLearn ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga74e3c96eab7360f9bbb113e4ddf870ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleVID0Mode </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleVID0Mode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VID0 mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_EN_VID0_MODE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleVID0Mode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafea1ebd3c767ef2aacf9b9bb526ab80b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleVID0Mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleVID0Mode</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VID0 mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_EN_VID0_MODE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleVID0Mode ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga07a18f8ad933e9d614a186c310397aee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleVlanAware </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_VLAN_AWARE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac384d4446da92c423025538044077895"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableAleVlanAware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableAleVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to enable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ALE_VLAN_AWARE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableAleVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7cb757169e4d9434f3e8af8495c4501f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableCpdmaIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable the command idle mode for CPDMA. When this API is called, the CPSW stops all the reception and transmission. However, if receiving the current frame will be received completely before going to the idle state. Also, while transmitting, the contents in the fifo will be sent fully. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga067ba5ba98a59478f1fe1e616336a490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableCpdmaRx </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>API to enable the receive in the RX Control Register. After the receive is enabled, and write to RXHDP of a channel, the data can be received in the destination specified by the corresponding RX buffer descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga056b3655f9ec4489d0a4f69220571f14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableCpdmaRxInt </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the RXPULSE Interrupt Generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPDMA Module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt to be enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gada81933328d77d7c956cc86a1e204b7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableCpdmaTx </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>API to enable the transmit in the TX Control Register. After the transmit is enabled, any write to TXHDP of a channel will start transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga844f707dfe4b1e92d960a32c44a17d22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableCpdmaTxInt </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the TXPULSE Interrupt Generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPDMA Module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number for which interrupt to be enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaac10f577a2b168b82882c47dce117d93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableFIFOLoopback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableFIFOLoopback</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable FIFO loopback mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_FIFO_LOOPBACK=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableFIFOLoopback ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga660f3391da319b0d311154c24491cc6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableFIFOLoopback </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableFIFOLoopback</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable FIFO loopback mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SW_CONTROL_FIFO_LOOPBACK=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableFIFOLoopback ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa997daa46c3204ba75af8ee2876ef0c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort0</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P0_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort0 ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga190045d2845d98965b0152ff09d9bcce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort0PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort0PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort0PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9906ba44a237c31e4e2ea9d1c26932fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort1PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort1PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort1PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaae934d0bcb4bc8b44f1f6abbd4ed6967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort2PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort2PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 2.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort2PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga861b87dc984fcdde59ec2eb7b22fd20e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort3PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort3PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 3.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P3_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort3PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad3c568f05b03e4aeeebfe5fbe9b2f617"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort4PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort4PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 4.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P4_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort4PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8a9c0fbbcd283d544d787329db1bb955"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort5PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort5PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 5.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P5_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort5PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3ed209704e77f0a320d9a39fb50f3fe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort6PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort6PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 6.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P6_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort6PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae60bd0096abb1d7649f10a1a71cc79fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort7PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort7PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 7.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P7_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort7PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2b56ee3193df1a3fd1645502039906ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enablePort8PassPriTag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enablePort8PassPriTag</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable the Ingress priority tagging on Port 8.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_CONTROL_REG_P8_PASS_PRI_TAGGED=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enablePort8PassPriTag ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga14c2384c372ed34448cf2ca4e9b09148"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableSoftIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW Soft Idle register to enable Software Idle mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SOFT_IDLE_SOFT_IDLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableSoftIdle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga89d5ee0b6c1bdcc49d13ec7e3bb7dc18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableSoftIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW Soft Idle register to enable Software Idle mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_SOFT_IDLE_REG_SOFT_IDLE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableSoftIdle ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga42709039b5b9ff26f35af091e8ad8236"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableVlanAware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_VLAN_AWARE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab55759b5e4e2db97ecf54038f83e36f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableVlanAware </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_enableVlanAware</b> </p>
<p><b>Description</b> <br />
 This function configures the CPSW control register to enable VLAN aware mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SW_CONTROL_VLAN_AWARE=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_enableVlanAware ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac503399bf5018a544350373e7598ab48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableWrMiscInt </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>miscIntrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables an interrupt for the specified core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt to be enabled 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac840dc17e4ee2b11fc34e0054ebf85b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableWrRxInt </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables an interrupt for the specified core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt to be enabled 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gab6653048159d45580e4077446c771599"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableWrRxThresholdInt </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables an interrupt for the specified core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt to be enabled 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga2092de58ffcaecab63a2d2c6b511bf86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_enableWrTxInt </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables an interrupt for the specified core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt to be enabled 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gacbe56e4b3f10fdc7c36a59b8fc9be71a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#gac08366dceb5ccaea33ad2555f63471d5">CSL_CPSW_ALE_ADDRTYPE</a> CSL_CPSW_getALEAddressType </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getALEAddressType</b> </p>
<p><b>Description</b> <br />
 This function returns the address type of an ALE entry.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
*        </pre><p><b> Return Value </b> CSL_CPSW_ALE_ADDRTYPE <br />
 ALE_ADDRTYPE_UCAST Address at this entry is unicast <br />
 ALE_ADDRTYPE_MCAST Address at this entry is multicast <br />
 ALE_ADDRTYPE_OUI Address at this entry is OUI address</p>
<p><b> Pre Condition </b> <br />
 This function must be called only for an ALE address entry, i.e., if <em>CSL_CPSW_getALEEntryType</em> () returns ALE_ENTRYTYPE_ADDRESS or ALE_ENTRYTYPE_VLANADDRESS only.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0_REG, CPSW_5GF_ALE_TABLE_WORD1_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Unicast address
           }
       }
       else
       {
           // Do nothing
       }

       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac52a9ce02197684319116e8c82802e13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#gac08366dceb5ccaea33ad2555f63471d5">CSL_CPSW_ALE_ADDRTYPE</a> CSL_CPSW_getALEAddressType </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getALEAddressType</b> </p>
<p><b>Description</b> <br />
 This function returns the address type of an ALE entry.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
*        </pre><p><b> Return Value </b> CSL_CPSW_ALE_ADDRTYPE <br />
 ALE_ADDRTYPE_UCAST Address at this entry is unicast <br />
 ALE_ADDRTYPE_MCAST Address at this entry is multicast <br />
 ALE_ADDRTYPE_OUI Address at this entry is OUI address</p>
<p><b> Pre Condition </b> <br />
 This function must be called only for an ALE address entry, i.e., if <em>CSL_CPSW_3G_getALEEntryType</em> () returns ALE_ENTRYTYPE_ADDRESS or ALE_ENTRYTYPE_VLANADDRESS only.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Unicast address
           }
       }
       else
       {
           // Do nothing
       }

       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga445958e883475a680420d559ecfcab61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleAgingTimerReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAgingPrescale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAgingPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleAgingTimerReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Aging Timer register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pAgingPrescale          Aging Timer prescale (1, 1000, 1000000)
       pAgingPeriod            Aging period in units of prescale.
                               When non-zero, auto-aging is enabled.  
                               This value (minus 1) times prescale is the number 
                               of clock cycles after which auto-aging will automatically 
                               be initiated.  
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_AGING_TIMER_REG_AGING_TIMER ALE_AGING_TIMER_REG_PRESCALE_1_DISABLE ALE_AGING_TIMER_REG_PRESCALE_2_DISABLE</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      aleAgingPrescale;
       Uint32      aleAgingPeriod

       CSL_CPSW_getAleAgingTimerReg (&amp;aleAgingPrescale,
                                     &amp;aleAgingPeriod);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga04ff4a34944a488f280cd28a7f98faab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getAleControlReg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 ALE control register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      aleCtrlVal;

     aleCtrlVal  =   CSL_CPSW_getAleControlReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf66a6367fe7d72debb43f999cd17cd54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getAleControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 ALE control register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_SW_CONTROL</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      aleCtrlVal;

     aleCtrlVal  =   CSL_CPSW_getAleControlReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6d3123e54dad2e730b70a5a549fef149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga6ea23133eb6b1517c106ca3f1a8b7729">CSL_CPSW_ALE_ENTRYTYPE</a> CSL_CPSW_getALEEntryType </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getALEEntryType</b> </p>
<p><b>Description</b> <br />
 This function returns the ALE entry type for any given ALE table entry index.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
*        </pre><p><b> Return Value </b> CSL_CPSW_ALE_ENTRYTYPE <br />
 ALE_ENTRYTYPE_FREE ALE entry is free. <br />
 ALE_ENTRYTYPE_ADDRESS ALE entry contains a unicast/multicast address. <br />
 ALE_ENTRYTYPE_VLAN VLAN ALE entry. <br />
 ALE_ENTRYTYPE_VLANADDRESS VLAN Address Entry.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD1_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;
       if (CSL_CPSW_getALEEntryType () == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry free
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad0b34f04a182694932b6986f10392546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga6ea23133eb6b1517c106ca3f1a8b7729">CSL_CPSW_ALE_ENTRYTYPE</a> CSL_CPSW_getALEEntryType </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getALEEntryType</b> </p>
<p><b>Description</b> <br />
 This function returns the ALE entry type for any given ALE table entry index.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
*        </pre><p><b> Return Value </b> CSL_CPSW_ALE_ENTRYTYPE <br />
 ALE_ENTRYTYPE_FREE ALE entry is free. <br />
 ALE_ENTRYTYPE_ADDRESS ALE entry contains a unicast/multicast address. <br />
 ALE_ENTRYTYPE_VLAN ALE entry contains a VLAN. <br />
 ALE_ENTRYTYPE_VLANADDRESS ALE entry contains a VLAN and a unicast/multicast address.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD1</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;
       if (CSL_CPSW_getALEEntryType () == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry free
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga853a2392b87b584ced02e1c57de3809a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleEthertypeEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pEthertypeCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleEthertypeEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Ethertype configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pEthertypeCfg           ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_ETHERTYPE_ENTRY            ethertypeCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_ETHERTYPE)
           {
               // Read Ethertype config from hardware
               CSL_CPSW_getAleEthertypeEntry (index, &amp;ethertypeCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8e4253dbbd48a4c81e6c61abe98a4be3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleEthertypeEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pEthertypeCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleEthertypeEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Ethertype configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pEthertypeCfg           ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_ETHERTYPE_ENTRY            ethertypeCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_ETHERTYPE)
           {
               // Read Ethertype config from hardware
               CSL_CPSW_getAleEthertypeEntry (index, &amp;ethertypeCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabb84a2c44b2bacf2b0d393971771b7a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleIPv4Entry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv4Cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv4Entry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with IPv4 configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pIPv4Cfg                ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv4_ENTRY                 ipv4Cfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_IPV4)
           {
               // Read IPv4 config from hardware
               CSL_CPSW_getAleIPv4Entry (index, &amp;ipv4Cfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf526c49f41748487b45bfbddba718ef7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleIPv4Entry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv4Cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv4Entry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with IPv4 configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pIPv4Cfg                ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv4_ENTRY                 ipv4Cfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_IPV4)
           {
               // Read IPv4 config from hardware
               CSL_CPSW_getAleIPv4Entry (index, &amp;ipv4Cfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac34ff1c919a9a269fd82bab529e0fd71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleIPv6Entry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv6Cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv6Entry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Ipv6 configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pIPv6Cfg                ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv6_ENTRY                 ipv6Cfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_IPV6)
           {
               // Read Ipv6 config from hardware
               CSL_CPSW_getAleIPv6Entry (index, &amp;ipv6Cfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga531649f10efcf9e05949e4c2846fb10c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleIPv6Entry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv6Cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleIPv6Entry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Ipv6 configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pIPv6Cfg                ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD0</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv6_ENTRY                 ipv6Cfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_IPV6)
           {
               // Read Ipv6 config from hardware
               CSL_CPSW_getAleIPv6Entry (index, &amp;ipv6Cfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac828b71412cf6b0a6e2a5ed79bf590a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Multicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pMcastAddrCfg           ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;
       CSL_CPSW_ALE_MCASTADDR_ENTRY        mcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
           {
               // Read Multicast address config from hardware
               CSL_CPSW_getAleMcastAddrEntry (index, &amp;mcastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3f7fc16d53f42d460bffb6e41e653578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Multicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pMcastAddrCfg           ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                     index;
       CSL_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
           {
               // Read Multicast address config from hardware
               CSL_CPSW_getAleMcastAddrEntry (index, &amp;mcastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4e4f6bd3bb08bb1086b6937507c83f40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleOUIAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOUIAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleOUIAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with OUI address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pOUIAddrCfg             ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUIADDR_ENTRY          ouiAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read Unicast address config from hardware
               CSL_CPSW_getAleOUIAddrEntry (index, &amp;ouiAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae030b1f7afab932096107e6491f6a211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleOUIAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOUIAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleOUIAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with OUI address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pOUIAddrCfg             ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUIADDR_ENTRY          ouiAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_OUI)
           {
               // Read Unicast address config from hardware
               CSL_CPSW_getAleOUIAddrEntry (index, &amp;ouiAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf6e6d309810058a00fc32b011c725b81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleOutValnEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOutValnCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleOutValnEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Outer VLAN configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pOutValnCfg             ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUTER_VLAN_ENTRY           outVlanCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_OVLAN)
           {
               // Read outer VALN config from hardware
               CSL_CPSW_getAleOutValnEntry (index, &amp;outVlanCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga20c0de43395468d209264dd19061d7a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleOutValnEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOutValnCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleOutValnEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Outer VLAN configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pOutValnCfg             ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD1</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUTER_VLAN_ENTRY           outVlanCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has a plicer entry
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_OVLAN)
           {
               // Read outer VALN config from hardware
               CSL_CPSW_getAleOutValnEntry (index, &amp;outVlanCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2d1269e1a7ab6caf8bdff05ebc544933"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAlePolicerEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___e_n_t_r_y.html">CSL_CPSW_ALE_POLICER_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pPolCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePolicerEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE Policer table entry for the index specified and fills the output parameter structure with Policer configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE Policer table index to be read.
       pPolCfg                 ALE Policer entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_POLICER_TBL_CTL_REG_POL_TBL_INDEX ALE_POLICER_TBL_CTL_REG_WRITE_ENABLE=0 ALE_THREAD_CTL_REG_ENTRY_PTR</p>
<p><b>Reads</b> <br />
 ALE_POLICER_PORT_OUI_REG_PORT_MEN, ALE_POLICER_PORT_OUI_REG_PORT_NUM, ALE_POLICER_PORT_OUI_REG_PRI_MEN, ALE_POLICER_PORT_OUI_REG_PRI_VAL, ALE_POLICER_PORT_OUI_REG_ONU_MEN, ALE_POLICER_PORT_OUI_REG_ONU_INDEX, ALE_POLICER_DA_SA_REG_DST_MEN, ALE_POLICER_DA_SA_REG_DST_INDEX, ALE_POLICER_DA_SA_REG_SRC_MEN, ALE_POLICER_DA_SA_REG_SRC_INDEX, ALE_POLICER_VLAN_REG_OVLAN_MEN, ALE_POLICER_VLAN_REG_OVLAN_INDEX, ALE_POLICER_VLAN_REG_IVLAN_MEN, ALE_POLICER_VLAN_REG_IVLAN_INDEX, ALE_POLICER_ETHERTYPE_IPSA_REG_ETHERTYPE_MEN, ALE_POLICER_ETHERTYPE_IPSA_REG_ETHERTYPE_INDEX, ALE_POLICER_ETHERTYPE_IPSA_REG_IPSRC_MEN, ALE_POLICER_ETHERTYPE_IPSA_REG_IPSRC_INDEX, ALE_POLICER_IPDA_REG_IPDST_MEN, ALE_POLICER_IPDA_REG_IPDST_INDEX, ALE_THREAD_VAL_REG_ENABLE, ALE_THREAD_VAL_REG_VALUE</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_POLICER_ENTRY              polCfg;

       index   =   0;

        // Read Policer Entry config from hardware
        CSL_CPSW_getAlePolicerEntry (index, &amp;polCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6ce8adedb2ce4e6835a5ef554fe12a59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h___d_a_t_a_s_t_r_u_c_t.html#ga13963cf3e07219d0a5b09cfb6c376b27">CSL_CPSW_ALE_POLICER_ENTRYTYPE</a> CSL_CPSW_getALEPolicerEntryType </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getALEPolicerEntryType</b> </p>
<p><b>Description</b> <br />
 This function returns the entry type of an ALE Policer entry.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
*        </pre><p><b> Return Value </b> CSL_CPSW_ALE_POLICER_ENTRYTYPE <br />
 ALE_POLICER_ENTRYTYPE_VLAN (Inner) VLAN Entry <br />
 ALE_POLICER_ENTRYTYPE_OVLAN Outer VLAN entry <br />
 ALE_POLICER_ENTRYTYPE_ETHERTYPEI Ether Type entry <br />
 ALE_POLICER_ENTRYTYPE_IPV4 IPv4 Address entry <br />
 ALE_POLICER_ENTRYTYPE_IPV6 IPv6 Address entry</p>
<p><b> Pre Condition </b> <br />
 This function must be called only for an ALE address entry, i.e., if <em>CSL_XGE_CPSW_getALEEntryType</em> () returns ALE_ENTRYTYPE_POLICER.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 ALE_TABLE_WORD1_REG, ALE_TABLE_WORD2_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_POLICER)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_IPV4)
           {
               // IPv4 address
           }
           
       }
       else
       {
           // Do nothing
       }

       ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae081ad01297c5336fb5ee1ab7681f5d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAlePolicerGlobConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_ALE_POLICER_GLOB_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pGlobConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePolicerGlobConfig</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW ALE Policer/Classifier Global Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pGlobConfig             CSL_CPSW_ALE_POLICER_GLOB_CONFIG structure that needs to 
                               be populated with the contents of the corresponging ALE Policer
                               global control registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_THREAD_DEF_REG_ENABLE, ALE_THREAD_DEF_REG_VALUE</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       CSL_CPSW_ALE_POLICER_GLOB_CONFIG    globConfig;

       CSL_CPSW_getAlePolicerGlobConfig (&amp;globConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga382a664f0f4af7c44ef11af15758a290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAlePortControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *&#160;</td>
          <td class="paramname"><em>pPortControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePortControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of ALE Port control register corresponding to the port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNo                  Port number for which the ALE port control register
                               must be read.
       pPortControlInfo        CSL_CPSW_ALE_PORTCONTROL structure that needs to be 
                               filled with Port control register info read from
                               the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_PORT_CONTROL_REG_PORT_STATE, CPSW_5GF_ALE_PORT_CONTROL_REG_DROP_UNTAGGED, CPSW_5GF_ALE_PORT_CONTROL_REG_VID_INGRESS_CHECK, CPSW_5GF_ALE_PORT_CONTROL_REG_NO_LEARN, CPSW_5GF_ALE_PORT_CONTROL_REG_MCAST_LIMIT, CPSW_5GF_ALE_PORT_CONTROL_REG_BCAST_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                          index;
       CSL_CPSW_ALE_PORTCONTROL    portControlInfo;

       index   =   0;

       CSL_CPSW_getAlePortControlReg (index, &amp;portControlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4c0ad015de0ca4f4f1ea5070f9cf6ff7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAlePortControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *&#160;</td>
          <td class="paramname"><em>pPortControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePortControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of ALE Port control register corresponding to the port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNo                  Port number for which the ALE port control register
                               must be read.
       pPortControlInfo        CSL_CPSW_ALE_PORTCONTROL structure that needs to be
                               filled with Port control register info read from
                               the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_PORT_CONTROL_PORT_STATE, CPSW_3G_PORT_CONTROL_DROP_UNTAGGED, CPSW_3G_PORT_CONTROL_VID_INGRESS_CHECK, CPSW_3G_PORT_CONTROL_NO_LEARN, CPSW_3G_PORT_CONTROL_NO_SA_UPDATE, CPSW_3G_PORT_CONTROL_DISABLE_AUTH_MODE, CPSW_3G_PORT_CONTROL_MCAST_LIMIT, CPSW_3G_PORT_CONTROL_BCAST_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                          index;
       CSL_CPSW_ALE_PORTCONTROL    portControlInfo;

       index   =   0;

       CSL_CPSW_getAlePortControlReg (index, &amp;portControlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga56124a2b5af4c20f57bfab20c71b185e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getAlePrescaleReg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePrescaleReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Prescale register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 ALE prescale register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_PRESCALE_REG_ALE_PRESCALE</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      alePrescaleVal;

     alePrescaleVal  =   CSL_CPSW_getAlePrescaleReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga860d45da1d6f189badf3d3f629db6572"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getAlePrescaleReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAlePrescaleReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Prescale register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 ALE prescale register contents.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_PRESCALE_PRESCALE</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32      alePrescaleVal;

     alePrescaleVal  =   CSL_CPSW_getAlePrescaleReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga65e2c64a99069df58a6b823b5472b095"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleStatusReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pNumPolicers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pNumEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleStatusReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Status register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pNumPolicers            Number of policers the ALE implements (multiple of 8)
       pNumEntries             Number of total table entries supported (multiple of 1024).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_STATUS_REG_ENTRIES_DIV_1024 ALE_STATUS_REG_POLICERS_DIV_8</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      numPolicers, numEntries;

       CSL_CPSW_getAleStatusReg (&amp;numPolicers, 
                                 &amp;numEntries);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6ee41a0be367b8a51b61e2e281721779"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleTableEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleTableEntry</b> </p>
<p><b>Description</b> <br />
 This function retrieves an ALE table entry corresponding to the ALE entry index specified in 'index' input parameter. The ALE entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and ALE_TBLW2 registers are returned in 'pAleInfoWd0', 'pAleInfoWd1', 'pAleInfoWd2' output parameters.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pAleInfoWd0             Contents of ALE Table Word 0 Register (ALE_TBLW0).
       pAleInfoWd1             Contents of ALE Table Word 1 Register (ALE_TBLW1).
       pAleInfoWd2             Contents of ALE Table Word 2 Register (ALE_TBLW2).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0_REG_ENTRY_31_0, CPSW_5GF_ALE_TABLE_WORD1_REG_ENTRY_63_32, CPSW_5GF_ALE_TABLE_WORD2_REG_ENTRY_71_64</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      index, info0, info1, info2;

       index   =   0;

       CSL_CPSW_getAleUnkownVlanReg (index, 
                                         &amp;info0,
                                         &amp;info1,
                                         &amp;info2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacea0491d1123e54823d7862cca4ff325"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleTableEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pAleInfoWd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleTableEntry</b> </p>
<p><b>Description</b> <br />
 This function retrieves an ALE table entry corresponding to the ALE entry index specified in 'index' input parameter. The ALE entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and ALE_TBLW2 registers are returned in 'pAleInfoWd0', 'pAleInfoWd1', 'pAleInfoWd2' output parameters.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pAleInfoWd0             Contents of ALE Table Word 0 Register (ALE_TBLW0).
       pAleInfoWd1             Contents of ALE Table Word 1 Register (ALE_TBLW1).
       pAleInfoWd2             Contents of ALE Table Word 2 Register (ALE_TBLW2).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0_ENTRY_31_0, CPSW_3G_TABLE_WORD1_ENTRY_63_32, CPSW_3G_TABLE_WORD2_ENTRY_71_64</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      index, info0, info1, info2;

       index   =   0;

       CSL_CPSW_getAleTableEntry (index,
                                  &amp;info0,
                                  &amp;info1,
                                  &amp;info2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga04b288e8d3d9c20effc9c8f9ba7ab946"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Unicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pUcastAddrCfg           ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read Unicast address config from hardware
               CSL_CPSW_getAleUnicastAddrEntry (index, &amp;ucastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga130a6d86b911600b79c56292ae91ae1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with Unicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pUcastAddrCfg           ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_ADDRESS)
       {
           // ALE entry has an address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read Unicast address config from hardware
               CSL_CPSW_getAleUnicastAddrEntry (index, &amp;ucastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2e58cb3727a11a46206bc770318882fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleUnkownVlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnVlanMemList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnRegMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnForceUntagEgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleUnkownVlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Unknown VLAN register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pUnVlanMemList          Unknown VLAN member list.
       pUnMcastFloodMask       Unknown VLAN Multicast flood mask.
       pUnRegMcastFloodMask    Unknown VLAN Registered Multicast Flood mask.
       pUnForceUntagEgress     Unknown VLAN Force Untagged Egress.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_VLAN_MEMBER_LIST, CPSW_5GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_MCAST_FLOOD_MASK, CPSW_5GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_REG_MCAST_FLOOD_MASK, CPSW_5GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_FORCE_UNTAGGED_EGRESS</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

       CSL_CPSW_getAleUnkownVlanReg (&amp;unVlanMemList, 
                                         &amp;unMcastFloodMask,
                                         &amp;unRegMcastFloodMask,
                                         &amp;unForceUntagEgress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4eccf6dff9012b321ec2ad2e9fd4c494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleUnkownVlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnVlanMemList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnRegMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pUnForceUntagEgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleUnkownVlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE Unknown VLAN and etc registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pUnVlanMemList          Unknown VLAN member list.
       pUnMcastFloodMask       Unknown VLAN Multicast flood mask.
       pUnRegMcastFloodMask    Unknown VLAN Registered Multicast Flood mask.
       pUnForceUntagEgress     Unknown VLAN Force Untagged Egress.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_UNKNOWN_VLAN_UNKNOWN_VLAN_MEMBER_LIST,</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

       CSL_CPSW_getAleUnkownVlanReg (&amp;unVlanMemList,
                                     &amp;unMcastFloodMask,
                                     &amp;unRegMcastFloodMask,
                                     &amp;unForceUntagEgress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7b4e09c85a3d353535017e22118915bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getAleUpdateBW </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleUpdateBW</b> </p>
<p><b>Description</b> <br />
 This function extracts the ALE Update Bandwidth of the ALE control register</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 aleUpdBW ALE Update Bandwidth</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_CONTROL_REG_UPD_BW_CTL</p>
<p><b>Example</b> </p><pre class="fragment">     Uint32  aleUpdBW;
     
     aleUpdBW = CSL_CPSW_getAleUpdateBW();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9b8f9f5a10556ad2385f8c9f340a0da7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVersionInfo </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_e_r_s_i_o_n.html">CSL_CPSW_ALE_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the ALE submodule identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVersionInfo        CSL_CPSW_ALE_VERSION structure that needs to be populated
                           with the ALE version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_ID_MINOR_VER, CPSW_3G_ID_MAJOR_VER, CPSW_3G_ID_IDENT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_ALE_VERSION    versionInfo;

       CSL_CPSW_getAleVersionInfo (&amp;versionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae236bb905e2e1280b4aadce6a650af32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVersionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_e_r_s_i_o_n.html">CSL_CPSW_ALE_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the ALE submodule identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVersionInfo        CSL_CPSW_ALE_VERSION structure that needs to be populated
                           with the ALE version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_ID_REG_ALE_MINOR_VER, CPSW_5GF_ALE_ID_REG_ALE_MAJOR_VER, CPSW_5GF_ALE_ID_REG_ALE_IDENT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_ALE_VERSION    versionInfo;

       CSL_CPSW_getAleVersionInfo (&amp;versionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga012e77301032c51187442eba2fd15621"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVlanEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanCfg                ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLAN_ENTRY             vlanCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_VLAN)
       {
           // ALE entry has a VLAN configuration
           CSL_CPSW_getAleVlanEntry (index, &amp;vlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4a332f3db4e6209c710c56116c6c17aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVlanEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanCfg                ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLAN_ENTRY             vlanCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_VLAN)
       {
           // ALE entry has a VLAN configuration
           if (CSL_CPSW_getALEPolicerEntryType (index) ==  ALE_POLICER_ENTRYTYPE_VLAN)
           {
               // Read (Inner) VLAN config from hardware
               CSL_CPSW_getAleVlanEntry (index, &amp;vlanCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaa9c64ad4f9c954f38839783053e2500"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVlanMaskMuxReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>vlanMaskMux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanMaskMuxReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the ALE VLAN Mask Mux registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       vlanMaskMux             Array of VLAN Mask Mux which is indexed by
                               the unreg_mcast_flood_index and reg_mcast_flood_
                               index values from the VLAN table entry to determine 
                               the registered and unregistered multicast flood masks                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_VLAN_MASK_MUX_REG_MASK</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      vlanMaskMux[4];

       CSL_CPSW_getAleVlanMaskMuxReg (vlanMaskMux); </pre><h1>: The value of VLAN_Mask_MUX_0 is read only and all ones (all ports are one). </h1>

</div>
</div>
<a class="anchor" id="ga01b71c7bb11e7e7178c43f1861e35fde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVlanMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN Multicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanMcastAddrCfg       ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
       {
           // ALE entry has a VLAN address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
           {
               // Read VLAN Multicast address config from hardware
               CSL_CPSW_getAleVlanMcastAddrEntry (index, &amp;vlanMcastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8d677f84db32f0e58952df6139912cac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVlanMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN Multicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanMcastAddrCfg       ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
       {
           // ALE entry has a VLAN address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_MCAST)
           {
               // Read VLAN Multicast address config from hardware
               CSL_CPSW_getAleVlanMcastAddrEntry (index, &amp;vlanMcastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf1b9a1c3454447108d7ce1c235708081"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVlanUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN Unicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanUcastAddrCfg       ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
       {
           // ALE entry has a VLAN address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read VLAN Unicast address config from hardware
               CSL_CPSW_getAleVlanUnicastAddrEntry (index, &amp;ucvlanUcastAddrCfgastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabb7b93a48d2a9fde6edda55924c91534"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getAleVlanUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getAleVlanUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE table entry for the index specified and fills the output parameter structure with VLAN Unicast address configuration read from the hardware.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be read.
       pVlanUcastAddrCfg       ALE entry contents read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=0</p>
<p><b>Reads</b> <br />
 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

       index   =   0;

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_VLANADDRESS)
       {
           // ALE entry has a VLAN address

           if (CSL_CPSW_getALEAddressType (index) ==  ALE_ADDRTYPE_UCAST)
           {
               // Read VLAN Unicast address config from hardware
               CSL_CPSW_getAleVlanUnicastAddrEntry (index, &amp;ucvlanUcastAddrCfgastAddrCfg);
           }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1c55ba09834fd6a208ddcb236c0a1459"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaDmaIntStatMasked </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the masked receive interrupt pending status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">chanMask</td><td>Channel Mask </td></tr>
    <tr><td class="paramname">intType</td><td>Interrupt type 'chanMask' can be given for one or more channels. <br />
 0x01- for 0th channel, 0x80 for 7th channel, 0x81 for both 0th and 7th channel etc. <br />
 'intType' can take one of the following values. <br />
 CPDMA_RX_INT_THRESH_PEND - RX threshold interrupt pending <br />
 CPDMA_RX_INT_PULSE_PEND - RX pulse interrupt pending <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Masked receive interrupt status <br />
 bits for the 'chanMask' will be set if interrupt is pending <br />
 bits for the 'chanMask' will be cleared if interrupt is not pending <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8838d73f42b0519be843d960ae4adc6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaDmaIntStatRaw </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw receive interrupt pending status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">chanMask</td><td>Channel Mask </td></tr>
    <tr><td class="paramname">intType</td><td>Interrupt type 'chanMask' can be given for one or more channels. <br />
 0x01- for 0th channel, 0x80 for 7th channel, 0x81 for both 0th and 7th channel etc. <br />
 'intType' can take one of the following values. <br />
 CPDMA_RX_INT_THRESH_PEND - RX threshold interrupt pending <br />
 CPDMA_RX_INT_PULSE_PEND - RX pulse interrupt pending <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw receive interrupt status <br />
 bits for the 'chanMask' will be set if interrupt is pending <br />
 bits for the 'chanMask' will be cleared if interrupt is not pending <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga58e6318a0129192804fcb18719007d38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getCpdmaRxCp </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>comPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the the RX Completion Pointer for a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel Number. </td></tr>
    <tr><td class="paramname">comPtr</td><td>Completion Pointer Value to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga38bcfd6760125b600cf89569300a6643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaRxIntStatMasked </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the masked receive interrupt pending status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">chanMask</td><td>Channel Mask </td></tr>
    <tr><td class="paramname">intType</td><td>Interrupt type 'chanMask' can be given for one or more channels. <br />
 0x01- for 0th channel, 0x80 for 7th channel, 0x81 for both 0th and 7th channel etc. <br />
 'intType' can take one of the following values. <br />
 CPDMA_RX_INT_THRESH_PEND - RX threshold interrupt pending <br />
 CPDMA_RX_INT_PULSE_PEND - RX pulse interrupt pending <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Masked receive interrupt status <br />
 bits for the 'chanMask' will be set if interrupt is pending <br />
 bits for the 'chanMask' will be cleared if interrupt is not pending <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaffb1b180bf445ee40ce6b5d24a2eae03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaRxIntStatRaw </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw receive interrupt pending status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">chanMask</td><td>Channel Mask </td></tr>
    <tr><td class="paramname">intType</td><td>Interrupt type 'chanMask' can be given for one or more channels. <br />
 0x01- for 0th channel, 0x80 for 7th channel, 0x81 for both 0th and 7th channel etc. <br />
 'intType' can take one of the following values. <br />
 CPDMA_RX_INT_THRESH_PEND - RX threshold interrupt pending <br />
 CPDMA_RX_INT_PULSE_PEND - RX pulse interrupt pending <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw receive interrupt status <br />
 bits for the 'chanMask' will be set if interrupt is pending <br />
 bits for the 'chanMask' will be cleared if interrupt is not pending <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gac4a246389daddd5a9e36f243f92d5e3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaRxThreshIntStatMasked </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the masked receive interrupt pending status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">chanMask</td><td>Channel Mask </td></tr>
    <tr><td class="paramname">intType</td><td>Interrupt type 'chanMask' can be given for one or more channels. <br />
 0x01- for 0th channel, 0x80 for 7th channel, 0x81 for both 0th and 7th channel etc. <br />
 'intType' can take one of the following values. <br />
 CPDMA_RX_INT_THRESH_PEND - RX threshold interrupt pending <br />
 CPDMA_RX_INT_PULSE_PEND - RX pulse interrupt pending <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Masked receive interrupt status <br />
 bits for the 'chanMask' will be set if interrupt is pending <br />
 bits for the 'chanMask' will be cleared if interrupt is not pending <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3b8bb2cb71dd6fcf16f80c3905a6a2d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaRxThreshIntStatRaw </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw receive interrupt pending status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">chanMask</td><td>Channel Mask </td></tr>
    <tr><td class="paramname">intType</td><td>Interrupt type 'chanMask' can be given for one or more channels. <br />
 0x01- for 0th channel, 0x80 for 7th channel, 0x81 for both 0th and 7th channel etc. <br />
 'intType' can take one of the following values. <br />
 CPDMA_RX_INT_THRESH_PEND - RX threshold interrupt pending <br />
 CPDMA_RX_INT_PULSE_PEND - RX pulse interrupt pending <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw receive interrupt status <br />
 bits for the 'chanMask' will be set if interrupt is pending <br />
 bits for the 'chanMask' will be cleared if interrupt is not pending <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga80c2c89d1b28ebde9cc6a48bd63c38e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the CPDMA Status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">statFlag</td><td>The status flags to be read 'statFlag' can take one of the following values <br />
 CPDMA_STAT_IDLE - to check if CPDMA is idle. <br />
 CPDMA_STAT_TX_HOST_ERR_CODE - TX host error code. <br />
 CPDMA_STAT_TX_HOST_ERR_CHAN - TX host error channel. <br />
 CPDMA_STAT_RX_HOST_ERR_CODE - RX host error code. <br />
 CPDMA_STAT_RX_HOST_ERR_CHAN - RX host error channel. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the DMA status for the status flag passed. The return values for CPDMA_STAT_IDLE are, <br />
 CPDMA_STAT_IDLE - CPDMA is in idle state <br />
 CPDMA_STAT_NOT_IDLE - CPDMA is not in idle state <br />
 The return values for CPDMA_STAT_TX_HOST_ERR_CODE are, <br />
 CPDMA_STAT_TX_NO_ERR - No error <br />
 CPDMA_STAT_TX_SOP_ERR - SOP error <br />
 CPDMA_STAT_TX_OWN_ERR - Ownership bit not set in SOP buffer <br />
 CPDMA_STAT_TX_ZERO_DESC - Zero Next Buffer Descriptor Pointer Without EOP <br />
 CPDMA_STAT_TX_ZERO_BUF_PTR - Zero Buffer Pointer <br />
 CPDMA_STAT_TX_ZERO_BUF_LEN - Zero Buffer Length <br />
 CPDMA_STAT_TX_PKT_LEN_ERR - Packet Length Error <br />
 The return values for CPDMA_STAT_RX_HOST_ERR_CODE are, <br />
 CPDMA_STAT_RXi_NO_ERR - No error <br />
 CPDMA_STAT_RX_OWN_NOT_SET - Ownership bit not set in input buffer <br />
 CPDMA_STAT_RX_ZERO_BUF_PTR - Zero Buffer Pointer<br />
 CPDMA_STAT_RX_ZERO_BUF_LEN - Zero Buffer Length on non-SOP descriptor <br />
 CPDMA_STAT_RX_SOP_BUF_LEN_ERR - SOP buffer length not greater than offset<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga229da5c7671e73349f2eb88f46fa6761"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getCpdmaTxCp </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>comPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the the TX Completion Pointer for a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel Number. </td></tr>
    <tr><td class="paramname">comPtr</td><td>Completion Pointer Value to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b5d9dc31fc9251526c2f77d2898fd2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaTxIntStatMasked </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the masked transmit interrupt pending status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">chanMask</td><td>Channel Mask 'chanMask' can be given for one or more channels. <br />
 0x01- for 0th channel, 0x80 for 7th channel, 0x81 for both 0th and 7th channel etc. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Masked transmit interrupt status <br />
 bits for the 'chanMask' will be set if interrupt is pending <br />
 bits for the 'chanMask' will be cleared if interrupt is not pending <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gad73376a48ffa8037b09e814c49eaac8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getCpdmaTxIntStatRaw </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw transmit interrupt pending status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">chanMask</td><td>Channel Mask 'chanMask' can be given for one or more channels. <br />
 0x01- for 0th channel, 0x80 for 7th channel, 0x81 for both 0th and 7th channel etc. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw receive interrupt status <br />
 bits for the 'chanMask' will be set if interrupt is pending <br />
 bits for the 'chanMask' will be clear if interrupt is not pending <br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2cd2e4e39d25aad0c33304664a02e2e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getCppiSourceIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxASrcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxBSrcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCppiSourceIdReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPPI Source Identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTxASrcId           CPPI Info Word0 Source Id Value on TxA.
       pTxBSrcId           CPPI Info Word0 Source Id Value on TxB.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P0_CPPI_SRC_ID_REG_TXA_SRC_ID, CPSW_5GF_P0_CPPI_SRC_ID_REG_TXB_SRC_ID</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      txASrcId, txBSrcId;

       CSL_CPSW_getCppiSourceIdReg (&amp;txASrcId, &amp;txBSrcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6a70b3ff4d83531fdf6d0a681eb219e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getCppiSourceIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxSrcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCppiSourceIdReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPPI Source Identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTxSrcId[8]         CPPI Info Word0 Source Id Value on Tx Ports respectively.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_SRC_ID_A_REG_PORT1 XGE_CPSW_P0_SRC_ID_A_REG_PORT2 XGE_CPSW_P0_SRC_ID_A_REG_PORT3 XGE_CPSW_P0_SRC_ID_A_REG_PORT4 XGE_CPSW_P0_SRC_ID_B_REG_PORT5 XGE_CPSW_P0_SRC_ID_B_REG_PORT6 XGE_CPSW_P0_SRC_ID_B_REG_PORT7 XGE_CPSW_P0_SRC_ID_B_REG_PORT8</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      txSrcId[8];

       CSL_CPSW_getCppiSourceIdReg (txSrcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga21310e87e4587f4b14dbc40f430f78b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getCpswControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlRegInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCpswControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pControlRegInfo     CSL_CPSW_CONTROL structure that needs to be populated
                           with the control register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_SW_CONTROL_FIFO_LOOPBACK, CPSW_3G_SW_CONTROL_VLAN_AWARE, CPSW_3G_SW_CONTROL_EEE_EN</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       CSL_CPSW_CONTROL    controlRegInfo;

       CSL_CPSW_getCpswControlReg (&amp;controlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3aec269edb62dfc3f16463f7c0554401"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getCpswControlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlRegInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCpswControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pControlRegInfo     CSL_CPSW_CONTROL structure that needs to be populated
                           with the control register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_FIFO_LOOPBACK, CPSW_5GF_CPSW_CONTROL_REG_VLAN_AWARE, CPSW_5GF_CPSW_CONTROL_REG_P0_ENABLE, CPSW_5GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED, CPSW_5GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED, CPSW_5GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_CONTROL    controlRegInfo;

       CSL_CPSW_getCpswControlReg (&amp;controlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa19b06c8ea11eccdbc6b7c8ea14c31e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getCpswVersionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___v_e_r_s_i_o_n.html">CSL_CPSW_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getCpswVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the CPSW identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVersionInfo        CSL_CPSW_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_CPSW_ID_VER_REG_CPSW_5GF_MINOR_VER, CPSW_5GF_CPSW_ID_VER_REG_CPSW_5GF_MAJ_VER, CPSW_5GF_CPSW_ID_VER_REG_CPSW_5GF_RTL_VER, CPSW_5GF_CPSW_ID_VER_REG_CPSW_5GF_IDENT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_VERSION    versionInfo;

       CSL_CPSW_getCpswVersionInfo (&amp;versionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga936efb6cbfbe75548998683bf76b39d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getCpswVersionInfo </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___v_e_r_s_i_o_n.html">CSL_CPSW_VERSION</a> *&#160;</td>
          <td class="paramname"><em>pVersionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_nGF_getCpswVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the CPSW identification and version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pVersionInfo        CSL_CPSW_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_ID_VER_MINOR_VER, CPSW_3G_ID_VER_MAJ_VER, CPSW_3G_ID_VER_IDENT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_VERSION    versionInfo;

       CSL_CPSW_getCpswVersionInfo (&amp;versionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga37aecb54cadfcf0e2e462c2d9f3aaeae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getEEEGlobConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_EEE_GLOB_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pGlobConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEEEGlobConfig</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW EEE Global Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pGlobConfig             CSL_CPSW_EEE_GLOB_CONFIG structure that needs to be populated
                               with the contents of the corresponging EEE global control 
                               registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_EEE_PRESCALE_REG_EEE_PRESCALE XGE_CPSW_CONTROL_REG_EEE_ENABLE</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       CSL_CPSW_EEE_GLOB_CONFIG    globConfig;

       CSL_CPSW_getEEEGlobConfig (&amp;globConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8d31ccf7ee22af955b7e351e87fecf08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getEEEPortConfig </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___c_o_n_f_i_g.html">CSL_CPSW_EEE_PORT_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pPortConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEEEPortConfig</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW EEE Port Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the EEE Port Control 
                               registers must be retrieved.
       pPortConfig             CSL_CPSW_EEE_PORT_CONFIG structure that needs to be populated
                               with the contents of the corresponging EEE port-specific control 
                               registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_IDLE2LPI_REG_COUNT XGE_CPSW_P0_LPI2WAKE_REG_COUNT</p>
<p>XGE_CPSW_PN_IDLE2LPI_REG_COUNT XGE_CPSW_PN_LPI2WAKE_REG_COUNT XGE_CPSW_PN_CONTROL_REG_TX_LPI_CLKSTOP_EN</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                      portNum;
       CSL_CPSW_EEE_PORT_CONFIG    portConfig;

       portNum = 1;
       CSL_CPSW_getEEEPortConfig (portNum, &amp;portConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae29d79ae8023203c435743820ac08380"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getEmulationControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pFree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pSoft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getEmulationControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Emulation Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFree                   Emulation free bit read from the hardware.
       pSoft                   Emulation soft bit read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_EM_CONTROL_REG_FREE, CPSW_5GF_EM_CONTROL_REG_SOFT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  free, soft;

       CSL_CPSW_getEmulationControlReg (&amp;free, &amp;soft);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga943c22cbedfd86319c4718dcdbdd967a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getFlowControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___f_l_o_w_c_n_t_l.html">CSL_CPSW_FLOWCNTL</a> *&#160;</td>
          <td class="paramname"><em>pFlowControlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getFlowControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Flow control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFlowControlCfg     CSL_CPSW_FLOWCNTL structure that needs to be populated
                           with contents of Flow control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_FLOW_CONTROL_P0_FLOW_EN, CPSW_3G_FLOW_CONTROL_P1_FLOW_EN, CPSW_3G_FLOW_CONTROL_P2_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_FLOWCNTL       flowControlCfg;

       CSL_CPSW_getFlowControlReg (&amp;flowControlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3d441d484e63c3fdcfd195899670a7a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getFlowControlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___f_l_o_w_c_n_t_l.html">CSL_CPSW_FLOWCNTL</a> *&#160;</td>
          <td class="paramname"><em>pFlowControlCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getFlowControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Flow control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFlowControlCfg     CSL_CPSW_FLOWCNTL structure that needs to be populated
                           with contents of Flow control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_FLOW_CONTROL_REG_P0_FLOW_EN, CPSW_5GF_FLOW_CONTROL_REG_P1_FLOW_EN, CPSW_5GF_FLOW_CONTROL_REG_P2_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_FLOWCNTL       flowControlCfg;

       CSL_CPSW_getFlowControlReg (&amp;flowControlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8ae212dd26831921161335917420965a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getPort0FlowIdOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0FlowIdOffset</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Flow ID Offset Register, which is added to the thread/Flow_ID in CPPI transmit PSI Info Word 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_FLOW_ID_OFFSET_REG_VALUE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      flowIdOffset;

       flowIdOffset    =   CSL_CPSW_getPort0FlowIdOffset ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaf9ae7aab9a7bf6798e85b47ec0c62f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getPort0RxMaxLen </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0RxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Receive Maximum Length Register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxLen;

       rxMaxLen    =   CSL_CPSW_getPort0RxMaxLen ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga857cad0f0e7167bb491cb1b3cea20ad7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPort0RxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0RxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortRxPriMap           Array of Port 0 Rx priority map priority values 
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortRxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P0_RX_PRI_MAP_REG_PRI0, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI1, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI2, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI3, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI4, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI5, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI6, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      port0RxPriMap [8];

       CSL_CPSW_getPort0RxPriMapReg (port0RxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2b0c2b88165a0e2847d6994fcbe7fcb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPort0TxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0RxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortTxPriMap           Array of Port 0 Rx priority map priority values
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortTxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P0_TX_PRI_MAP_PRI0, CPSW_3G_P0_TX_PRI_MAP_PRI1, CPSW_3G_P0_TX_PRI_MAP_PRI2, CPSW_3G_P0_TX_PRI_MAP_PRI3, CPSW_3G_P0_TX_PRI_MAP_PRI4, CPSW_3G_P0_TX_PRI_MAP_PRI5, CPSW_3G_P0_TX_PRI_MAP_PRI6, CPSW_3G_P0_TX_PRI_MAP_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      port0TxPriMap [8];

       CSL_CPSW_getPort0RxPriMapReg (port0TxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga504d5c78bb2e3b95c1fc78325cd674c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPort0VlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0VlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 VLAN Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortVID                Port VLAN Id
       pPortCFI                Port CFI bit
       pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P0_PORT_VLAN_PORT_VID, CPSW_3G_P0_PORT_VLAN_PORT_CFI, CPSW_3G_P0_PORT_VLAN_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI;

       CSL_CPSW_getPort0VlanReg (&amp;portVID, &amp;portCFI, &amp;portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5c0897b77bf12420ba288d94b996f14a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPort0VlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPort0VlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port 0 VLAN Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortVID                Port VLAN Id
       pPortCFI                Port CFI bit
       pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P0_PORT_VLAN_REG_PORT_VID, CPSW_5GF_P0_PORT_VLAN_REG_PORT_CFI, CPSW_5GF_P0_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI;

       CSL_CPSW_getPort0VlanReg (&amp;portVID, &amp;portCFI, &amp;portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1c26cc30fa421f5703d1fc43c2714a70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortBlockCountReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxBlkCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxBlkCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortBlockCountReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Block Count register corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the block count
                               must be retrieved.
       pRxBlkCnt               Receive block count usage read for this port.
       pTxBlkCnt               Transmit block count usage read for this port.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P_BLK_CNT_P_RX_BLK_CNT, CPSW_3G_P_BLK_CNT_P_TX_BLK_CNT, CPSW_3G_P0_BLK_CNT_P0_RX_BLK_CNT, CPSW_3G_P0_BLK_CNT_P0_TX_BLK_CNT,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxBlkCnt, txBlkCnt, portNum;

       portNum =   1;

       CSL_CPSW_getPortBlockCountReg (portNum, &amp;rxBlkCnt, &amp;txBlkCnt);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadba35a0a62b940cfa3d98c091f79af58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortBlockCountReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxBlkCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxBlkCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortBlockCountReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Block Count register corresponding to the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the block count
                               must be retrieved.
       pRxBlkCnt               Receive block count usage read for this port.                                
       pTxBlkCnt               Transmit block count usage read for this port.                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P_BLK_CNT_REG_RX_BLK_CNT, CPSW_5GF_P_BLK_CNT_REG_TX_BLK_CNT</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxBlkCnt, txBlkCnt, portNum;

       portNum =   1;            

       CSL_CPSW_getPortBlockCountReg (portNum, &amp;rxBlkCnt, &amp;txBlkCnt);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad7f046c4b7269d6f4be9425234b09c59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t___c_o_n_t_r_o_l.html">CSL_CPSW_PORT_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortControlReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Control Register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register contents
                               must be read and returned.
       pControlInfo            CSL_CPSW_PORT_CONTROL structure that needs to be populated
                               with the control register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 none</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_CONTROL_REG_DSCP_IPV4_EN, XGE_CPSW_P0_CONTROL_REG_DSCP_IPV6_EN,</p>
<p>XGE_CPSW_PN_CONTROL_REG_DSCP_IPV4_EN, XGE_CPSW_PN_CONTROL_REG_DSCP_IPV6_EN, XGE_CPSW_PN_CONTROL_REG_TX_LPI_CLKSTOP_EN,</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32                      portNum;
       CSL_CPSW_PORT_CONTROL       controlInfo;

       portNum =   1;

       CSL_CPSW_getPortControlReg (portNum, &amp;controlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1441c77645c1406615421a02d4851109"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortMACAddress </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortMACAddress</b> </p>
<p><b>Description</b> <br />
 This function retreives the source MAC address corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the source MAC address
                               must be read and returned.
       pMacAddress             6 byte Source MAC address read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacAddres' must be large enough the 6 byte MAC address returned by this API.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_SL_SA_LO_REG_MACSRCADDR_7_0, CPSW_5GF_SL_SA_LO_REG_MACSRCADDR_15_8, CPSW_5GF_SL_SA_HI_REG_MACSRCADDR_23_16, CPSW_5GF_SL_SA_HI_REG_MACSRCADDR_31_24, CPSW_5GF_SL_SA_HI_REG_MACSRCADDR_39_32, CPSW_5GF_SL_SA_HI_REG_MACSRCADDR_47_40</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint8   macAddress [6], portNum;

       portNum =   1;

       CSL_CPSW_getPortMACAddress (portNum, macAddress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga955d6d214961a753ad0dbb70d38f939d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortMACAddress </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortMACAddress</b> </p>
<p><b>Description</b> <br />
 This function retreives the source MAC address of the Tx Pause Frame corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the source MAC address
                               must be read and returned. (1-8)
       pMacAddress             6 byte Source MAC address read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacAddres' must be large enough the 6 byte MAC address returned by this API.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P_SA_LO_MACSRCADDR_7_0, CPSW_3G_P_SA_LO_MACSRCADDR_15_8, CPSW_3G_P_SA_HI_MACSRCADDR_23_16, CPSW_3G_P_SA_HI_MACSRCADDR_31_24, CPSW_3G_P_SA_HI_MACSRCADDR_39_32, CPSW_3G_P_SA_HI_MACSRCADDR_47_40</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint8   macAddress [6], portNum;

       portNum =   1;

       CSL_CPSW_getPortMACAddress (portNum, macAddress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6e8cfd91739fb1d3beb50a8376b5b60f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortMaxBlksReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortMaxBlksReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Maxmium Block register corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the max block value
                               must be retrieved.
       pRxMaxBlks              Receive FIFO Maximum Blocks - This value is the 
                               maximum number of 1k memory blocks that may be 
                               allocated to the FIFO's logical receive queue.
                               This value must be greater than or equal to 0x3.  
                               The recommended value of rx_max_blks is 0x9

       pTxMaxBlks              Transmit FIFO Maximum Blocks - This value is the 
                               maximum number of 1k memory blocks that may be 
                               allocated to the FIFO's logical transmit 
                               priority queues.  The recommended value of 
                               tx_max_blks is 0x3.                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_MAX_BLKS_REG_RX_MAX_BLKS, XGE_CPSW_PN_MAX_BLKS_REG_TX_MAX_BLKS,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum =   1;            

       CSL_CPSW_getPortMaxBlksReg (portNum, &amp;rxMaxBlks, &amp;txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga78bac6f1374b7a54f61ba2c81649a239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortMaxBlocksReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortMaxBlocksReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Max Blocks Register corresponding to the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the max block numbers
                               must be retrieved.
       pRxMaxBlks              Receive FIFO Maximum blocks read for this port.
       pTxMaxBlks              Transmit FIFO Maximum blocks read for this port.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P_MAX_BLKS_P_RX_MAX_BLKS, CPSW_3G_P_MAX_BLKS_P_TX_MAX_BLKS, CPSW_3G_P0_MAX_BLKS_P0_RX_MAX_BLKS, CPSW_3G_P0_MAX_BLKS_P0_TX_MAX_BLKS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum =   1;

       CSL_CPSW_getPortMaxBlocksReg (portNum, &amp;rxMaxBlks, &amp;txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga08bc391b94d671a1bff6fe57c91f34c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortMaxBlocksReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortMaxBlocksReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Max Blocks Register corresponding to the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the max block numbers
                               must be retrieved.
       pRxMaxBlks              Receive FIFO Maximum blocks read for this port.                                
       pTxMaxBlks              Transmit FIFO Maximum blocks read for this port.                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P_MAX_BLKS_REG_RX_MAX_BLKS, CPSW_5GF_P_MAX_BLKS_REG_TX_MAX_BLKS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum =   1;            

       CSL_CPSW_getPortMaxBlocksReg (portNum, &amp;rxMaxBlks, &amp;txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafa33482aa21c5490841be455aaa9be05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortRxDscpMap </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxDscpPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortRxDscpMap</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port DSCP to Priority Mapping Registers corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the DSCP mapping
                               registers must be retrieved.
       pRxDscpPriMap           Array of Port Rx DSCP to priority mapping values
                               read from the registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pRxDscpPriMap' must be large enough to hold all the 64 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI0, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI1, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI2, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI3, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI4, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI5, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI6, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI7,</p>
<p>CPSW_3G_P_RX_DSCP_PRI_MAP_PRI0, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI1, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI2, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI3, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI4, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI5, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI6, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI7</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32      rxDscpPriMap [64], portNum;

       portNum = 1;
       CSL_CPSW_getPortRxDscpMap (portNum, rxDscpPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga097caf9f000186ac932fd39dd40191ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortRxDscpMap </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxDscpPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortRxDscpMap</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port DSCP to Priority Mapping Registers corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the DSCP mapping 
                               registers must be retrieved.
       pRxDscpPriMap           Array of Port Rx DSCP to priority mapping values 
                               read from the registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pRxDscpPriMap' must be large enough to hold all the 64 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI0, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI1, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI2, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI3, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI4, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI5, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI6, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI0, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI1, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI2, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI3, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI4, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI5, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI6, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI7</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32      rxDscpPriMap [64], portNum;

       portNum = 1;
       CSL_CPSW_getPortRxDscpMap (portNum, rxDscpPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacbe7f44c7148dc1b52918a3c5a46133a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getPortRxMaxLen </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortRxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Port Receive Maximum Length Register.</p>
<p><b>Arguments</b> portNum CPSW port number for which the Receive Maximum Length must be retrieved.</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_RX_MAXLEN_REG_RX_MAXLEN XGE_CPSW_PN_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum, rxMaxLen;

       portNum = 1;
       rxMaxLen    =   CSL_CPSW_getPortRxMaxLen (portNum);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae27b4b51b34620010ed5366265ec2e74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortRxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortRxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the block count
                               must be retrieved.
       pPortTxPriMap           Array of Port Rx priority map priority values
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortTxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P0_TX_PRI_MAP_PRI0, CPSW_3G_P0_TX_PRI_MAP_PRI1, CPSW_3G_P0_TX_PRI_MAP_PRI2, CPSW_3G_P0_TX_PRI_MAP_PRI3, CPSW_3G_P0_TX_PRI_MAP_PRI4, CPSW_3G_P0_TX_PRI_MAP_PRI5, CPSW_3G_P0_TX_PRI_MAP_PRI6, CPSW_3G_P0_TX_PRI_MAP_PRI7,</p>
<p>CPSW_3G_P_TX_PRI_MAP_PRI0, CPSW_3G_P_TX_PRI_MAP_PRI1, CPSW_3G_P_TX_PRI_MAP_PRI2, CPSW_3G_P_TX_PRI_MAP_PRI3, CPSW_3G_P_TX_PRI_MAP_PRI4, CPSW_3G_P_TX_PRI_MAP_PRI5, CPSW_3G_P_TX_PRI_MAP_PRI6, CPSW_3G_P_TX_PRI_MAP_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum = 1;
*      Uint32      portRxPriMap [8];

       CSL_CPSW_getPortRxPriMapReg (portNum, portRxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0b0cd4a654b3a0b9463e169b9b45385f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortRxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortRxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Port Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the block count
                               must be retrieved.
       pPortRxPriMap           Array of Port Rx priority map priority values
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortRxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_RX_PRI_MAP_REG_PRI0, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI1, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI2, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI3, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI4, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI5, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI6, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_RX_PRI_MAP_REG_PRI0, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI1, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI2, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI3, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI4, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI5, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI6, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum = 1;
*      Uint32      portRxPriMap [8];

       CSL_CPSW_getPortRxPriMapReg (portNum, portRxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1f06eec05393737516dcd8cf4c25193b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortStatsEnableReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *&#160;</td>
          <td class="paramname"><em>pPortStatsCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortStatsEnableReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Port Statistics Enable register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortStatsCfg       CSL_CPSW_PORTSTAT structure that needs to be populated
                           with the port statistics enable register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_STAT_PORT_EN_P0_STAT_EN, CPSW_3G_STAT_PORT_EN_P1_STAT_EN, CPSW_3G_STAT_PORT_EN_P2_STAT_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PORTSTAT       portStatsCfg;

       CSL_CPSW_getPortStatsEnableReg (&amp;portStatsCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7d43e80b94ef9664c6bac27db7e2255f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortStatsEnableReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *&#160;</td>
          <td class="paramname"><em>pPortStatsCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortStatsEnableReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Port Statistics Enable register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortStatsCfg       CSL_CPSW_PORTSTAT structure that needs to be populated
                           with the port statistics enable register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_STAT_PORT_EN_REG_P0A_STAT_EN, CPSW_5GF_STAT_PORT_EN_REG_P0B_STAT_EN, CPSW_5GF_STAT_PORT_EN_REG_P1_STAT_EN, CPSW_5GF_STAT_PORT_EN_REG_P2_STAT_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PORTSTAT       portStatsCfg;

       CSL_CPSW_getPortStatsEnableReg (&amp;portStatsCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6545a150acbe0a63281d46e6cee3c130"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortTimeSyncCntlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_n_t_l.html">CSL_CPSW_TSCNTL</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncCntlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTimeSyncCntlReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time sync control register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be read.
       pTimeSyncCntlCfg        CSL_CPSW_TSCNTL that needs to be populated with 
                               contents of time sync control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P_TS_CTL_REG_TS_RX_EN, CPSW_5GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, CPSW_5GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, CPSW_5GF_P_TS_CTL_REG_TS_TX_EN, CPSW_5GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, CPSW_5GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, CPSW_5GF_P_TS_CTL_REG_TX_MSG_TYPE_EN_15_0</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_TSCNTL     tsCtlCfg;

       portNum =   1;

       CSL_CPSW_getPortTimeSyncCntlReg (portNum, &amp;tsCtlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac6f013d8b53e79a6e9ee6298252db8ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortTimeSyncConfig </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_o_n_f_i_g.html">CSL_CPSW_TSCONFIG</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTimeSyncCntlReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time sync configuration from time sync control registers corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the registers must be read. (1-8)
       pTimeSyncConfig         CSL_CPSW_TSCONFIG that needs to be populated with 
                               contents of time sync control registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_HOST_TS_EN, XGE_CPSW_PN_TS_CTL_REG_TS_MSG_TYPE_EN,</p>
<p>XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_LTYPE1, XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET,</p>
<p>XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2,</p>
<p>XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_LTYPE2, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_107, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_129, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_130, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_131, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_132, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_319, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_330, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_TTL_NONZERO, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_UNI_EN,</p>
<p>XGE_CPSW_PN_TS_CTL2_REG_TS_MCAST_TYPE_EN, XGE_CPSW_PN_TS_CTL2_REG_TS_DOMAIN_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_TSCONFIG   tsConfig;

       portNum =   1;

       CSL_CPSW_getPortTimeSyncCntlReg (portNum, &amp;tsConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga65ad2bc722042b7c92f1bca6563a0fc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortTimeSyncSeqIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsLtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsSeqIdOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTimeSyncSeqIdReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time Sync Sequence Id and LTYPE register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be read.
       pTsLtype                Time sync LTYPE read.
       pTsSeqIdOffset          Time sync sequence Id offset read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P_TS_SEQ_LTYPE_REG_TS_LTYPE, CPSW_5GF_P_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype, tsSeqIdOffset;

       portNum =   1;

       CSL_CPSW_getPortTimeSyncSeqIdReg (portNum, &amp;tsLtype, &amp;tsSeqIdOffset);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga33e98cdf2ccebf62c09f6376f7189048"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortTimeSyncVlanLTypeReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsVlanLtype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTsVlanLtype2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTimeSyncVlanLTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retreives the contents of Time Sync VLAN LTYPE register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be read.
       pTsVlanLtype1           Time sync VLAN LTYPE1 value read.
       pTsVlanLtype2           Time sync VLAN LTYPE2 value read.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, CPSW_5GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype1, tsLtype2;

       portNum =   1;

       CSL_CPSW_getPortTimeSyncVlanLTypeReg (portNum, &amp;tsLtype1, &amp;tsLtype2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga847d06b174b625c1d1d3101ec4352381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortTxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Transmit Header Priority to Switch Priority Mapping Register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register contents
                               must be read and returned.
       pPortTxPriMap           Array of Port Tx priority map priority values 
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortTxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P_TX_PRI_MAP_REG_PRI0, CPSW_5GF_P_TX_PRI_MAP_REG_PRI1, CPSW_5GF_P_TX_PRI_MAP_REG_PRI2, CPSW_5GF_P_TX_PRI_MAP_REG_PRI3, CPSW_5GF_P_TX_PRI_MAP_REG_PRI4, CPSW_5GF_P_TX_PRI_MAP_REG_PRI5, CPSW_5GF_P_TX_PRI_MAP_REG_PRI6, CPSW_5GF_P_TX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portTxPriMap [8], portNum;

       portNum =   1;

       CSL_CPSW_getPortTxPriMapReg (portNum, portTxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2edf2dbc8b5494235c77954ecdf8fc22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortTxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortTxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Transmit Header Priority to Switch Priority Mapping Register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register contents
                               must be read and returned.
       pPortTxPriMap           Array of Port Tx priority map priority values
                               read from the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pPortTxPriMap' must be large enough to hold all the 8 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P_TX_PRI_MAP_PRI0, CPSW_3G_P_TX_PRI_MAP_PRI1, CPSW_3G_P_TX_PRI_MAP_PRI2, CPSW_3G_P_TX_PRI_MAP_PRI3, CPSW_3G_P_TX_PRI_MAP_PRI4, CPSW_3G_P_TX_PRI_MAP_PRI5, CPSW_3G_P_TX_PRI_MAP_PRI6, CPSW_3G_P_TX_PRI_MAP_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portTxPriMap [8], portNum;

       portNum =   1;

       CSL_CPSW_getPortTxPriMapReg (portNum, portTxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga666c77f7148145576d58d5d6192fd5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortVlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortVlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the VLAN Register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the VLAN register 
                               contents must be read
       pPortVID                Port VLAN Id
       pPortCFI                Port CFI bit
       pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_P_PORT_VLAN_REG_PORT_VID, CPSW_5GF_P_PORT_VLAN_REG_PORT_CFI, CPSW_5GF_P_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI, portNum;

       portNum =   2;

       CSL_CPSW_getPortVlanReg (portNum, &amp;portVID, &amp;portCFI, &amp;portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga07926bcb1c70f614dc7e222b3f0c966d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPortVlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPortVlanReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the VLAN Register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the VLAN register
                               contents must be read
       pPortVID                Port VLAN Id
       pPortCFI                Port CFI bit
       pPortPRI                Port VLAN priority (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_P0_PORT_VLAN_PORT_VID, CPSW_3G_P0_PORT_VLAN_PORT_CFI, CPSW_3G_P0_PORT_VLAN_PORT_PRI,</p>
<p>CPSW_3G_P_PORT_VLAN_PORT_VID, CPSW_3G_P_PORT_VLAN_PORT_CFI, CPSW_3G_P_PORT_VLAN_PORT_PRI,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI, portNum;

       portNum =   1;

       CSL_CPSW_getPortVlanReg (portNum, &amp;portVID, &amp;portCFI, &amp;portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaa8980bfc99f6f5bccff43750fbbd639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPrioTypeReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *&#160;</td>
          <td class="paramname"><em>pTypeCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPrioTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Priority Type register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTypeCfg            CSL_CPSW_PTYPE structure that needs to be populated
                           with the priority type register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_PTYPE_ESC_PRI_LD_VAL, CPSW_3G_PTYPE_P0_PTYPE_ESC, CPSW_3G_PTYPE_P1_PTYPE_ESC, CPSW_3G_PTYPE_P2_PTYPE_ESC</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PTYPE       pTypeCfg;

       CSL_CPSW_getPrioTypeReg (&amp;pTypeCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae8a64891e17b258842f6d7666f3b4396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getPrioTypeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *&#160;</td>
          <td class="paramname"><em>pTypeCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getPrioTypeReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Priority Type register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTypeCfg            CSL_CPSW_PTYPE structure that needs to be populated
                           with the priority type register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_PTYPE_REG_ESC_PRI_LD_VAL, CPSW_5GF_PTYPE_REG_P0_PTYPE_ESC, CPSW_5GF_PTYPE_REG_P1_PTYPE_ESC, CPSW_5GF_PTYPE_REG_P2_PTYPE_ESC</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PTYPE       pTypeCfg;

       CSL_CPSW_getPrioTypeReg (&amp;pTypeCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab79e189e3ef55ac6b2c3c9b2bc56fbf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getRawStats </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *&#160;</td>
          <td class="paramname"><em>pCpswStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getRawStats</b> </p>
<p><b>Description</b> <br />
 The CPSW stats are divided into 9 blocks, i.e., Stats for Host port (switch Port 0) and Stats for MAC ports (Port 1-8). This function retreives snapshot of hardware statistics for all the stat blocks. In the case of Linux ARM master use case all CPSW stats is recommended to be accessed from Linux.</p>
<p>Since this function does not clear the stats, its possible to have non-exclusive ownership of the switch and use this function without corrupting other caller's view of the stats.</p>
<p>Additional Note: In order to avoid stats loss due to rollovers, application would need to poll the stats by determining the correct interval. The stat CPSW_NETOCTETS would be first one to roll over The software must poll and accumulate the stats faster than this rate. On a 1 gigabit network, it takes approximately (0x100000000/(1000000000/8)/2)=17 seconds to roll over (the /2 is because this stat contains both tx and rx, both of which run at gigabit). A good rule of thumb is to poll at twice this rate (8-9 seconds).</p>
<p>If it is really necessary for application to have multiple nonexclusive owners of the switch, it is possible for all callers to have a view of the accumulated statistics if they (including Linux) follows the differential accumulation of the stats defiened below: uint64_t accum_CPSW_NETOCTETS; uint32_t old_CPSW_NETOCTETS, new_CPSW_NETOCTETS, diff_CPSW_NETOCTETS;</p>
<p>diff_CPSW_NETOCTETS = new_CPSW_NETOCTETS - old_CPSW_NETOCTETS; // let rollover occur, no "if" required old_CPSW_NETOCTETS = new_CPSW_NETOCTETS; accum_CPSW_NETOCTETS += diff_CPSW_NETOCTETS</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCpswStats              Array of CSL_CPSW_STATS structure that needs to be filled
                               with the stats read from the hardware. This function expects
                               that the array passed to it is big enough to hold the stats
                               for both stat blocks, i.e., size of array passed to this
                               function must be 5 or 9 for 5-port/9-port switch respectively.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_RXGOODFRAMES, CPSW_RXBROADCASTFRAMES, CPSW_RXMULTICASTFRAMES, CPSW_RXPAUSEFRAMES, CPSW_RXCRCERRORS, CPSW_RXALIGNCODEERRORS, CPSW_RXOVERSIZEDFRAMES, CPSW_RXJABBERFRAMES, CPSW_RXUNDERSIZEDFRAMES, CPSW_RXFRAGMENTS, CPSW_ALE_DROP, CPSW_ALE_OVERRUN_DROP, CPSW_RXOCTETS, CPSW_TXGOODFRAMES, CPSW_TXBROADCASTFRAMES, CPSW_TXMULTICASTFRAMES, CPSW_TXPAUSEFRAMES, CPSW_TXDEFERREDFRAMES, CPSW_TXCOLLISIONFRAMES, CPSW_TXSINGLECOLLFRAMES, CPSW_TXMULTCOLLFRAMES, CPSW_TXEXCESSIVECOLLISIONS, CPSW_TXLATECOLLISIONS, CPSW_TXUNDERRUN, CPSW_TXCARRIERSENSEERRORS, CPSW_TXOCTETS, CPSW_OCTETFRAMES64, CPSW_OCTETFRAMES65T127, CPSW_OCTETFRAMES128T255, CPSW_OCTETFRAMES256T511, CPSW_OCTETFRAMES512T1023, CPSW_OCTETFRAMES1024TUP, CPSW_NETOCTETS,</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_STATS     stats [9];

       CSL_CPSW_getRawStats (stats);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf359bd7be6c484ed6c5e36107ec0bec5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getRawStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *&#160;</td>
          <td class="paramname"><em>pCpswStats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getRawStats</b> </p>
<p><b>Description</b> <br />
 The CPSW stats are divided into 2 blocks, i.e., Stats for Host port (switch Port 0) and Stats for MAC ports (Port 1 and Port2). This function retreives snapshot of hardware statistics for both the stat blocks. In the case of Linux ARM master use case all CPSW stats is recommended to be accessed from Linux.</p>
<p>Since this function does not clear the stats, its possible to have non-exclusive ownership of the switch and use this function without corrupting other caller's view of the stats.</p>
<p>Additional Note: In order to avoid stats loss due to rollovers, application would need to poll the stats by determining the correct interval. The stat CPSW_NETOCTETS would be first one to roll over The software must poll and accumulate the stats faster than this rate. On a 1 gigabit network, it takes approximately (0x100000000/(1000000000/8)/2)=17 seconds to roll over (the /2 is because this stat contains both tx and rx, both of which run at gigabit). A good rule of thumb is to poll at twice this rate (8-9 seconds).</p>
<p>If it is really necessary for application to have multiple nonexclusive owners of the switch, it is possible for all callers to have a view of the accumulated statistics if they (including Linux) follows the differential accumulation of the stats defiened below: uint64_t accum_CPSW_NETOCTETS; uint32_t old_CPSW_NETOCTETS, new_CPSW_NETOCTETS, diff_CPSW_NETOCTETS;</p>
<p>diff_CPSW_NETOCTETS = new_CPSW_NETOCTETS - old_CPSW_NETOCTETS; // let rollover occur, no "if" required old_CPSW_NETOCTETS = new_CPSW_NETOCTETS; accum_CPSW_NETOCTETS += diff_CPSW_NETOCTETS</p>
<p><b>Arguments</b> </p><pre class="fragment">       pCpswStats              Array of CSL_CPSW_STATS structure that needs to be filled
                               with the stats read from the hardware. This function expects
                               that the array passed to it is big enough to hold the stats
                               for both stat blocks, i.e., size of array passed to this
                               function must be 2.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_RXGOODFRAMES, CPSW_RXBROADCASTFRAMES, CPSW_RXMULTICASTFRAMES, CPSW_RXPAUSEFRAMES, CPSW_RXCRCERRORS, CPSW_RXALIGNCODEERRORS, CPSW_RXOVERSIZEDFRAMES, CPSW_RXJABBERFRAMES, CPSW_RXUNDERSIZEDFRAMES, CPSW_RXFRAGMENTS, CPSW_RXOCTETS, CPSW_TXGOODFRAMES, CPSW_TXBROADCASTFRAMES, CPSW_TXMULTICASTFRAMES, CPSW_TXPAUSEFRAMES, CPSW_TXDEFERREDFRAMES, CPSW_TXCOLLISIONFRAMES, CPSW_TXSINGLECOLLFRAMES, CPSW_TXMULTCOLLFRAMES, CPSW_TXEXCESSIVECOLLISIONS, CPSW_TXLATECOLLISIONS, CPSW_TXUNDERRUN, CPSW_TXCARRIERSENSEERRORS, CPSW_TXOCTETS, CPSW_OCTETFRAMES64, CPSW_OCTETFRAMES65T127, CPSW_OCTETFRAMES128T255, CPSW_OCTETFRAMES256T511, CPSW_OCTETFRAMES512T1023, CPSW_OCTETFRAMES1024TUP, CPSW_NETOCTETS, CPSW_OVERRUNTYPE1, CPSW_OVERRUNTYPE2, CPSW_OVERRUNTYPE3</p>
<p><b>Affects</b> <br />
 CPSW_RXGOODFRAMES=0, CPSW_RXBROADCASTFRAMES=0, CPSW_RXMULTICASTFRAMES=0, CPSW_RXPAUSEFRAMES=0, CPSW_RXCRCERRORS=0, CPSW_RXALIGNCODEERRORS=0, CPSW_RXOVERSIZEDFRAMES=0, CPSW_RXJABBERFRAMES=0, CPSW_RXUNDERSIZEDFRAMES=0, CPSW_RXFRAGMENTS=0, CPSW_RXOCTETS=0, CPSW_TXGOODFRAMES=0, CPSW_TXBROADCASTFRAMES=0, CPSW_TXMULTICASTFRAMES=0, CPSW_TXPAUSEFRAMES=0, CPSW_TXDEFERREDFRAMES=0, CPSW_TXCOLLISIONFRAMES=0, CPSW_TXSINGLECOLLFRAMES=0, CPSW_TXMULTCOLLFRAMES=0, CPSW_TXEXCESSIVECOLLISIONS=0, CPSW_TXLATECOLLISIONS=0, CPSW_TXUNDERRUN=0, CPSW_TXCARRIERSENSEERRORS=0, CPSW_TXOCTETS=0, CPSW_OCTETFRAMES64=0, CPSW_OCTETFRAMES65T127=0, CPSW_OCTETFRAMES128T255=0, CPSW_OCTETFRAMES256T511=0, CPSW_OCTETFRAMES512T1023=0, CPSW_OCTETFRAMES1024TUP=0, CPSW_NETOCTETS=0, CPSW_OVERRUNTYPE1=0, CPSW_OVERRUNTYPE2=0, CPSW_OVERRUNTYPE3=0</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_STATS     stats [2];

       CSL_CPSW_getStats (stats);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac5c712b06aa5a3383718fddd9f8c1b87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getRxRLimConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___r_x___r_a_t_e___l_i_m_i_t___c_o_n_f_i_g.html">CSL_CPSW_RX_RATE_LIMIT_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pRLimConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getRxRLimConfig</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPPI Rx Rate Limitaion Configuration from the corresponding registers</p>
<p><b>Arguments</b> </p><pre class="fragment">       pRLimConfig             CSL_CPSW_RX_RATE_LIMIT_CONFIG structure that needs to be populated
                               with the rate limitaion register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 none</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_P0_PRI_CTL_REG_RX_RLIM, XGE_CPSW_P0_PRI_SEND_REG_COUNT, XGE_CPSW_P0_PRI_IDLE_REG_COUNT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_RX_RATE_LIMIT_CONFIG       rLimConfig;

       CSL_CPSW_getRxRLimConfig (&amp;rLimConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac4ae00edb74ed10824ae89f8bd8f03f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getShortGapThreshold </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getShortGapThreshold</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW MAC Short Gap Threshold register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 MAC short gap threshold value read from the hardware.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_GAP_THRESH_GAP_THRESH</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          gapThreshVal;

       gapThreshVal    =   CSL_CPSW_getShortGapThreshold ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2017f86eecaa81eb19932559c7036089"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getShortGapThreshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getShortGapThreshold</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW MAC Short Gap Threshold register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 &gt;=0 MAC short gap threshold value read from the hardware.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_GAP_THRESH_CPGMAC_SL_REG_GAP_THRESH</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          gapThreshVal;

       gapThreshVal    =   CSL_CPSW_getShortGapThreshold ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5625f0c69ebcd7743ca778c2106f641e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getStats </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *&#160;</td>
          <td class="paramname"><em>pCpswStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getStats</b> </p>
<p><b>Description</b> <br />
 The CPSW stats are divided into 2 blocks, i.e., Stats for Host port (switch Port 0) and Stats for MAC ports (Port 1 and Port2). This function</p><ul>
<li>retreives hardware statistics for both the stat blocks.</li>
<li>Clear out the stats by the count being returned to application</li>
<li>Accumulates the stats count before returning to Application Function requires appplication to memset the stats (once before first use for accumulator, or once per use without accumulation) In the case of Linux ARM master use case all CPSW stats is recommended to be accessed from Linux. This function unconditionally clears the stats, so it requires the caller have exclusive ownership of the switch. Otherwise, none of the callers (including Linux) will have complete accumulated stats. This function can be used to clear the stats by memesetting pCpswStats to 0 and discarding the returned stats.</li>
</ul>
<pre class="fragment">@b Arguments
</pre> <pre class="fragment">       pCpswStats              Array of CSL_CPSW_STATS structure that needs to be filled
                               with the stats read from the hardware. This function expects
                               that the array passed to it is big enough to hold the stats
                               for both stat blocks, i.e., size of array passed to this
                               function must be 2.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_RXGOODFRAMES, CPSW_RXBROADCASTFRAMES, CPSW_RXMULTICASTFRAMES, CPSW_RXPAUSEFRAMES, CPSW_RXCRCERRORS, CPSW_RXALIGNCODEERRORS, CPSW_RXOVERSIZEDFRAMES, CPSW_RXJABBERFRAMES, CPSW_RXUNDERSIZEDFRAMES, CPSW_RXFRAGMENTS, CPSW_RXOCTETS, CPSW_TXGOODFRAMES, CPSW_TXBROADCASTFRAMES, CPSW_TXMULTICASTFRAMES, CPSW_TXPAUSEFRAMES, CPSW_TXDEFERREDFRAMES, CPSW_TXCOLLISIONFRAMES, CPSW_TXSINGLECOLLFRAMES, CPSW_TXMULTCOLLFRAMES, CPSW_TXEXCESSIVECOLLISIONS, CPSW_TXLATECOLLISIONS, CPSW_TXUNDERRUN, CPSW_TXCARRIERSENSEERRORS, CPSW_TXOCTETS, CPSW_OCTETFRAMES64, CPSW_OCTETFRAMES65T127, CPSW_OCTETFRAMES128T255, CPSW_OCTETFRAMES256T511, CPSW_OCTETFRAMES512T1023, CPSW_OCTETFRAMES1024TUP, CPSW_NETOCTETS, CPSW_RXSOFOVERRUNS, CPSW_RXMOFOVERRUNS, CPSW_RXDMAOVERRUNS</p>
<p><b>Affects</b> <br />
 CPSW_RXGOODFRAMES=0, CPSW_RXBROADCASTFRAMES=0, CPSW_RXMULTICASTFRAMES=0, CPSW_RXPAUSEFRAMES=0, CPSW_RXCRCERRORS=0, CPSW_RXALIGNCODEERRORS=0, CPSW_RXOVERSIZEDFRAMES=0, CPSW_RXJABBERFRAMES=0, CPSW_RXUNDERSIZEDFRAMES=0, CPSW_RXFRAGMENTS=0, CPSW_RXOCTETS=0, CPSW_TXGOODFRAMES=0, CPSW_TXBROADCASTFRAMES=0, CPSW_TXMULTICASTFRAMES=0, CPSW_TXPAUSEFRAMES=0, CPSW_TXDEFERREDFRAMES=0, CPSW_TXCOLLISIONFRAMES=0, CPSW_TXSINGLECOLLFRAMES=0, CPSW_TXMULTCOLLFRAMES=0, CPSW_TXEXCESSIVECOLLISIONS=0, CPSW_TXLATECOLLISIONS=0, CPSW_TXUNDERRUN=0, CPSW_TXCARRIERSENSEERRORS=0, CPSW_TXOCTETS=0, CPSW_OCTETFRAMES64=0, CPSW_OCTETFRAMES65T127=0, CPSW_OCTETFRAMES128T255=0, CPSW_OCTETFRAMES256T511=0, CPSW_OCTETFRAMES512T1023=0, CPSW_OCTETFRAMES1024TUP=0, CPSW_NETOCTETS=0, CPSW_RXSOFOVERRUNS=0, CPSW_RXMOFOVERRUNS=0, CPSW_RXDMAOVERRUNS=0</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_STATS     stats [2];

       CSL_CPSW_getStats (stats);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga658c6291a84782908c8bf3a90d6821d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___s_t_a_t_s.html">CSL_CPSW_STATS</a> *&#160;</td>
          <td class="paramname"><em>pCpswStats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getStats</b> </p>
<p><b>Description</b> <br />
 The CPSW stats are divided into 2 blocks, i.e., Stats for Host port (switch Port 0) and Stats for MAC ports (Port 1 and Port2). This function</p><ul>
<li>retreives hardware statistics for both the stat blocks.</li>
<li>Clear out the stats by the count being returned to application</li>
<li>Accumulates the stats count before returning to Application Function requires appplication to memset the stats (once before first use for accumulator, or once per use without accumulation) In the case of Linux ARM master use case all CPSW stats is recommended to be accessed from Linux. This function unconditionally clears the stats, so it requires the caller have exclusive ownership of the switch. Otherwise, none of the callers (including Linux) will have complete accumulated stats. This function can be used to clear the stats by memesetting pCpswStats to 0 and discarding the returned stats.</li>
</ul>
<pre class="fragment">@b Arguments
</pre> <pre class="fragment">       pCpswStats              Array of CSL_CPSW_STATS structure that needs to be filled
                               with the stats read from the hardware. This function expects
                               that the array passed to it is big enough to hold the stats
                               for both stat blocks, i.e., size of array passed to this 
                               function must be 2.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_RXGOODFRAMES, CPSW_RXBROADCASTFRAMES, CPSW_RXMULTICASTFRAMES, CPSW_RXPAUSEFRAMES, CPSW_RXCRCERRORS, CPSW_RXALIGNCODEERRORS, CPSW_RXOVERSIZEDFRAMES, CPSW_RXJABBERFRAMES, CPSW_RXUNDERSIZEDFRAMES, CPSW_RXFRAGMENTS, CPSW_RXOCTETS, CPSW_TXGOODFRAMES, CPSW_TXBROADCASTFRAMES, CPSW_TXMULTICASTFRAMES, CPSW_TXPAUSEFRAMES, CPSW_TXDEFERREDFRAMES, CPSW_TXCOLLISIONFRAMES, CPSW_TXSINGLECOLLFRAMES, CPSW_TXMULTCOLLFRAMES, CPSW_TXEXCESSIVECOLLISIONS, CPSW_TXLATECOLLISIONS, CPSW_TXUNDERRUN, CPSW_TXCARRIERSENSEERRORS, CPSW_TXOCTETS, CPSW_OCTETFRAMES64, CPSW_OCTETFRAMES65T127, CPSW_OCTETFRAMES128T255, CPSW_OCTETFRAMES256T511, CPSW_OCTETFRAMES512T1023, CPSW_OCTETFRAMES1024TUP, CPSW_NETOCTETS, CPSW_OVERRUNTYPE1, CPSW_OVERRUNTYPE2, CPSW_OVERRUNTYPE3</p>
<p><b>Affects</b> <br />
 CPSW_RXGOODFRAMES=0, CPSW_RXBROADCASTFRAMES=0, CPSW_RXMULTICASTFRAMES=0, CPSW_RXPAUSEFRAMES=0, CPSW_RXCRCERRORS=0, CPSW_RXALIGNCODEERRORS=0, CPSW_RXOVERSIZEDFRAMES=0, CPSW_RXJABBERFRAMES=0, CPSW_RXUNDERSIZEDFRAMES=0, CPSW_RXFRAGMENTS=0, CPSW_RXOCTETS=0, CPSW_TXGOODFRAMES=0, CPSW_TXBROADCASTFRAMES=0, CPSW_TXMULTICASTFRAMES=0, CPSW_TXPAUSEFRAMES=0, CPSW_TXDEFERREDFRAMES=0, CPSW_TXCOLLISIONFRAMES=0, CPSW_TXSINGLECOLLFRAMES=0, CPSW_TXMULTCOLLFRAMES=0, CPSW_TXEXCESSIVECOLLISIONS=0, CPSW_TXLATECOLLISIONS=0, CPSW_TXUNDERRUN=0, CPSW_TXCARRIERSENSEERRORS=0, CPSW_TXOCTETS=0, CPSW_OCTETFRAMES64=0, CPSW_OCTETFRAMES65T127=0, CPSW_OCTETFRAMES128T255=0, CPSW_OCTETFRAMES256T511=0, CPSW_OCTETFRAMES512T1023=0, CPSW_OCTETFRAMES1024TUP=0, CPSW_NETOCTETS=0, CPSW_OVERRUNTYPE1=0, CPSW_OVERRUNTYPE2=0, CPSW_OVERRUNTYPE3=0</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_STATS     stats [2];

       CSL_CPSW_getStats (stats);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga526c2bbee664a9446e754e97abcdf745"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getTxStartWordsReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getTxStartWordsReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Transmit FIFO start words register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_TX_START_WDS_TX_START_WDS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          startWordsVal;

       startWordsVal   =   CSL_CPSW_getTxStartWordsReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaac5629a453313036c762ced0d9b06319"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getTxStartWordsReg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_getTxStartWordsReg</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the Transmit FIFO start words register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_TX_START_WDS_REG_TX_START_WDS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          startWordsVal;

       startWordsVal   =   CSL_CPSW_getTxStartWordsReg ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga10683649b272ae8356a394ef05d283e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getWrMiscIntStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the interrupt status of the core for the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of thei CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt status to be read 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same as intFlag if the status is set '0' if the status is cleared </dd></dl>

</div>
</div>
<a class="anchor" id="ga941b0a30cc0e9f2c4f05519765d30a09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_getWrRgmiiStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___w_r___r_g_m_i_i___s_t_a_t_u_s.html">CSL_CPSW_WR_RGMII_STATUS</a> *&#160;</td>
          <td class="paramname"><em>rgmiiStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the RGMII status requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">statFlag</td><td>Status to be checked 'statFlag' can take a combination of the below values. <br />
 CPSW_RGMII2_DUPLEX - Duplex of RGMII2 <br />
 CPSW_RGMII2_SPEED - Speed of RGMII2 <br />
 CPSW_RGMII2_LINK_STAT - Link Status of RGMII2 <br />
 CPSW_RGMII1_DUPLEX - Duplex of RGMII1 <br />
 CPSW_RGMII1_SPEED - Speed of RGMII1 <br />
 CPSW_RGMII1_LINK_STAT - Link Status of RGMII1 <br />
 The returned value can be compared agains the below values <br />
 CPSW_RGMII2_DUPLEX_FULL - RGMII2 full duplex <br />
 CPSW_RGMII2_DUPLEX_HALF - RGMII2 half duplex <br />
 CPSW_RGMII2_SPEED_10M - Speed is 10 Mbps <br />
 CPSW_RGMII2_SPEED_100M - Speed is 100 Mbps <br />
 CPSW_RGMII2_SPEED_1000M - Speed is 1000 Mbps <br />
 CPSW_RGMII2_LINK_UP - RGMII2 link is up<br />
 CPSW_RGMII2_LINK_DOWN - RGMII2 link is down <br />
 CPSW_RGMII1_DUPLEX_FULL - RGMII1 full duplex <br />
 CPSW_RGMII1_DUPLEX_HALF - RGMII1 half duplex <br />
 CPSW_RGMII1_SPEED_10M - Speed is 10 Mbps <br />
 CPSW_RGMII1_SPEED_100M - Speed is 100 Mbps <br />
 CPSW_RGMII1_SPEED_1000M - Speed is 1000 Mbps <br />
 CPSW_RGMII1_LINK_UP - RGMII1 link is up<br />
 CPSW_RGMII1_LINK_DOWN - RGMII1 link is down <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of RGMII. Return value can be compared agains the same statFlag passed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fca10cfc23f1bc475b061e34e4d8a2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getWrRxIntStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the interrupt status of the core for the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of thei CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt status to be read 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same as intFlag if the status is set '0' if the status is cleared </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c87392e126cac66c4c75a2a5cde236f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getWrRxThresholdIntStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the interrupt status of the core for the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of thei CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt status to be read 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same as intFlag if the status is set '0' if the status is cleared </dd></dl>

</div>
</div>
<a class="anchor" id="gad7a33368d6f670da89a9d8e69eb63acf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_getWrTxIntStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the interrupt status of the core for the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of thei CPSW Wrapper Module </td></tr>
    <tr><td class="paramname">core</td><td>Core number </td></tr>
    <tr><td class="paramname">channel</td><td>Channel number </td></tr>
    <tr><td class="paramname">intFlag</td><td>Interrupt status to be read 'intFlag' can take one of the below values. <br />
 CPSW_CORE_INT_RX_THRESH - RX threshold interrupt <br />
 CPSW_CORE_INT_RX_PULSE - RX pulse interrupt <br />
 CPSW_CORE_INT_TX_PULSE - TX pulse interrupt <br />
 CPSW_CORE_INT_MISC - Miscellaneous interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same as intFlag if the status is set '0' if the status is cleared </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cc38f81cd9fbac78e035d5ec115f3a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleAgeOutDone </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleAgeOutDone</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE control register's AGE_OUT_NOW bit to check if the ALE ageable entry cleanup process is done.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE age out process done. <br />
 FALSE ALE age out process not yet completed.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_AGE_OUT_NOW</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleAgeOutDone ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3179da61fa905e452b84bafee00c7619"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleAgeOutDone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleAgeOutDone</b> </p>
<p><b>Description</b> <br />
 This function reads the ALE control register's AGE_OUT_NOW bit to check if the ALE ageable entry cleanup process is done.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE age out process done. <br />
 FALSE ALE age out process not yet completed.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_AGE_OUT_NOW</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleAgeOutDone ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5e95e0313df9b44a3186c56cda04f577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleBypassEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleBypassEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Bypass mode enabled. <br />
 FALSE ALE Bypass mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_BYPASS</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleBypassEnabled () == TRUE)
     {
         // ALE Bypass mode on
     }
     else
     {
         // ALE Bypass mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga65b52d0952ab1efa933e8a460cfd2cc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleBypassEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleBypassEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in Bypass mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Bypass mode enabled. <br />
 FALSE ALE Bypass mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ALE_BYPASS</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleBypassEnabled () == TRUE)
     {
         // ALE Bypass mode on
     }
     else
     {
         // ALE Bypass mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3d5a8ef342469696d53297aa9398544c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE processing is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE enabled. ALE packet processing will be done. <br />
 FALSE ALE disabled. All packets are dropped by ALE.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_ENABLE_ALE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleEnabled () == TRUE)
     {
         // ALE enabled
     }
     else
     {
         // ALE disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacc328766c13a643871c5c1424bfc65f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE processing is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE enabled. ALE packet processing will be done. <br />
 FALSE ALE disabled. All packets are dropped by ALE.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_ALE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleEnabled () == TRUE)
     {
         // ALE enabled
     }
     else
     {
         // ALE disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf00fef84821e309ed3949d181e9bd493"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleLearnNoVIDEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleLearnNoVIDEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to not learn VLAN Ids.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Learn no VID enabled. VLAN Id is not learned with source address (source address is not tied to VID) <br />
 FALSE ALE VID learning mode enabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_LEARN_NO_VID</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleLearnNoVIDEnabled () == TRUE)
     {
         // ALE VID learning disabled
     }
     else
     {
         // ALE VID learning enabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa514ccd9d94c302fbedf6b8f09f5c674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleLearnNoVIDEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleLearnNoVIDEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to not learn VLAN Ids.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Learn no VID enabled. VLAN Id is not learned with source address (source address is not tied to VID) <br />
 FALSE ALE VID learning mode enabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_LEARN_NO_VID</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleLearnNoVIDEnabled () == TRUE)
     {
         // ALE VID learning disabled
     }
     else
     {
         // ALE VID learning enabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2cab9d77fa1a282666788f7e3dd42324"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleMacAuthModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleMacAuthModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE MAC Authorization mode is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE is in MAC authorization mode. <br />
 FALSE ALE not in MAC authorization mode.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_ENABLE_AUTH_MODE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleMacAuthModeEnabled () == TRUE)
     {
         // ALE  is in MAC authorization mode
     }
     else
     {
         // ALE not in MAC authorization mode
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6a5ade410785f8934e31f5766e5e9c6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleMacAuthModeEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleMacAuthModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE MAC Authorization mode is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE is in MAC authorization mode. <br />
 FALSE ALE not in MAC authorization mode.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_AUTH_MODE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleMacAuthModeEnabled () == TRUE)
     {
         // ALE  is in MAC authorization mode
     }
     else
     {
         // ALE not in MAC authorization mode
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1f817d80679fce8ecdff9ec491df2597"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleOUIDenyModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleOUIDenyModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE OUI deny mode enabled. <br />
 FALSE ALE OUI deny mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_ENABLE_OUI_DENY</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleOUIDenyModeEnabled () == TRUE)
     {
         // ALE OUI deny mode on
     }
     else
     {
         // ALE OUI deny mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga667e1c45c6a5f9664d36504ff4991224"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleOUIDenyModeEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleOUIDenyModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in OUI deny mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE OUI deny mode enabled. <br />
 FALSE ALE OUI deny mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_OUI_DENY</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleOUIDenyModeEnabled () == TRUE)
     {
         // ALE OUI deny mode on
     }
     else
     {
         // ALE OUI deny mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4ab991d7c3c65324074aa734e15ab999"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleRateLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleRateLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE Broadcast and Multicast Rate Limit is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Broadcast and multicast rate limit enabled. Broadcast/multicast packet reception limited to port control register rate limit fields. <br />
 FALSE ALE Broadcast and multicast rate limit disabled. Broadcast/multicast rates not limited.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_SW_CONTROL_ENABLE_RATE_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleRateLimitEnabled () == TRUE)
     {
         // ALE Broadcast/Multicast rate limit enabled
     }
     else
     {
         // ALE Broadcast/Multicast rate limit disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga971b8b779ac906e8e518f1983c8a28bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleRateLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleRateLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE Broadcast and Multicast Rate Limit is enabled.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Broadcast and multicast rate limit enabled. Broadcast/multicast packet reception limited to port control register rate limit fields. <br />
 FALSE ALE Broadcast and multicast rate limit disabled. Broadcast/multicast rates not limited.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ENABLE_RATE_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleRateLimitEnabled () == TRUE)
     {
         // ALE Broadcast/Multicast rate limit enabled
     }
     else
     {
         // ALE Broadcast/Multicast rate limit disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga908b2389986abe97cf32bc069d491290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleTxRateLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleTxRateLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be Tx-port based multicast, broadcast rate limited.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Tx rate limit enabled. Broadcast, multicast rate limit counters are transmit port based. <br />
 FALSE ALE Tx rate limit disabled. Broadcast, multicast rate limit counters are receive port based.</p>
<p><b> Pre Condition </b> <br />
 CPSW_3G_CONTROL_ENABLE_RATE_LIMIT=1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_RATE_LIMIT_TX</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleTxRateLimitEnabled () == TRUE)
     {
         // ALE Tx rate limit on
     }
     else
     {
         // ALE Tx rate limit off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga49a29bf0a7d532d4215cf622c52d07d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleTxRateLimitEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleTxRateLimitEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be Tx rate limited.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE Tx rate limit enabled. Broadcast, multicast rate limit counters are transmit port based. <br />
 FALSE ALE Tx rate limit disabled. Broadcast, multicast rate limit counters are receive port based.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_RATE_LIMIT_TX</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleTxRateLimitEnabled () == TRUE)
     {
         // ALE Tx rate limit on
     }
     else
     {
         // ALE Tx rate limit off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab331805822c688c1098eb422e76ed24b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleUUNIToHostEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleUUNIToHostEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to forward unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Unknown unicast packets flood to host also. <br />
 FALSE Unknown unicast packets are dropped to the host.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_EN_P0_UNI_FLOOD</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleUUNIToHostEnabled () == TRUE)
     {
         // ALE Unknown UNI packets forwarded to host
     }
     else
     {
         // ALE Unknown UNI packets dropped to host
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf128b00e4892f479c0e3036def8cac9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleUUNIToHostEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleUUNIToHostEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to forward unkown unicast packets to host.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Unknown unicast packets flood to host also. <br />
 FALSE Unknown unicast packets are dropped to the host.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_CONTROL_REG_UNI_FLOOD_TO_HOST</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleUUNIToHostEnabled () == TRUE)
     {
         // ALE Unknown UNI packets forwarded to host
     }
     else
     {
         // ALE Unknown UNI packets dropped to host
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0fbf4f970a7ab0da9ef66e247dee9be2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleUVLANNoLearnEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleUVLANNoLearnEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to disable learning of the packets with unknown VLAN.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Unknown VLAN No Learn enabled. Source addresses of unknown VLANIDs are not added into the look up table even if learning is enabled. <br />
 FALSE Unknown VLAN No Learn disabled. Source addresses of unknown VLANIDs are added into the look up table if learning is enabled.</p>
<p><b> Pre Condition </b> <br />
 ALE_CONTROL_REG_ENABLE = 1</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 ALE_CONTROL_REG_UVLAN_NO_LEARN</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleUVLANNoLearnEnabled () == TRUE)
     {
         // Unknown VLAN No Learn disabled
     }
     else
     {
         // Unknown VLAN No Learn enabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf3de490afaf939fcdd128f26fbad8664"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleVID0ModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleVID0ModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in VID0 (VLAN ID=0) mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE VID0 mode enabled. Process the packet with VLAN Id = 0 <br />
 FALSE ALE VID0 mode disabled. Process the packet with VLAN Id =PORT_VLAN[11-0]</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_EN_VID0_MODE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleVID0ModeEnabled () == TRUE)
     {
         // ALE VID0 mode on
     }
     else
     {
         // ALE VID0 mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8e6ddcdf383906b50c6c3d687574be12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleVID0ModeEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleVID0ModeEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be in VID0 (VLAN ID=0) mode.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE VID0 mode enabled. Process the packet with VLAN Id = 0 <br />
 FALSE ALE VID0 mode disabled. Process the packet with VLAN Id =PORT_VLAN[11-0]</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_EN_VID0_MODE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleVID0ModeEnabled () == TRUE)
     {
         // ALE VID0 mode on
     }
     else
     {
         // ALE VID0 mode off
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf8843c51c67efdc1eb39a7ad0f5a881d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleVlanAwareEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleVlanAwareEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be VLAN aware.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE VLAN aware. ALE drops packets if VLAN not found. <br />
 FALSE ALE not VLAN aware. Floods if VLAN not found.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_CONTROL_VLAN_AWARE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleVlanAwareEnabled () == TRUE)
     {
         // ALE VLAN aware
     }
     else
     {
         // ALE not VLAN aware
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad96c1be88aac74cbf4e672e87f7449e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isAleVlanAwareEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isAleVlanAwareEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if ALE is programmed to be VLAN aware.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE ALE VLAN aware. ALE drops packets if VLAN not found. <br />
 FALSE ALE not VLAN aware. Floods if VLAN not found.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_ALE_VLAN_AWARE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isAleVlanAwareEnabled () == TRUE)
     {
         // ALE VLAN aware
     }
     else
     {
         // ALE not VLAN aware
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga767038452ce8576bfc9ceaa564c636ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isCpdmaIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function indicates if the CPSW is at Software Idle mode where no packets will be started to be unloaded from ports.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Software Idle mode enabled. <br />
 FALSE Software Idle mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_SOFT_IDLE_SOFT_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isSoftIdle () == TRUE)
     {
         // Software Idle mode enabled
     }
     else
     {
         // Software Idle mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3fecfcaefcef2fb7455886bd78c2a26f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isCpdmaResetDone </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isCpdmaResetDone</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Softreset register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pSoft                   Soft reset bit read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPDMA_SOFT_RESET_SOFT_RESET</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  softResetStatus;

       softResetStatus = CSL_CPSW_isCpdmaResetDone ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaef81ad7581b330ea24a5e22ec86fe3bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isFIFOLoopbackEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isFIFOLoopbackEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if FIFO loopback mode is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE FIFO loopback mode enabled. Each packet received is turned around and sent out on the same port's transmit path. <br />
 FALSE FIFO loopback mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_FIFO_LOOPBACK</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isFIFOLoopbackEnabled (portNum) == TRUE)
     {
         // FIFO loopback mode enabled
     }
     else
     {
         // FIFO loopback mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9584111f819912b2a66ad6ff2b697469"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isFIFOLoopbackEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isFIFOLoopbackEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if FIFO loopback mode is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE FIFO loopback mode enabled. Each packet received is turned around and sent out on the same port's transmit path. <br />
 FALSE FIFO loopback mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_SW_CONTROL_FIFO_LOOPBACK</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isFIFOLoopbackEnabled (portNum) == TRUE)
     {
         // FIFO loopback mode enabled
     }
     else
     {
         // FIFO loopback mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf41b6d3ff23d63105a48e25c5e1eae20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort0Enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort0Enabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if CPPI Port (Port 0) is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 0 enabled. <br />
 FALSE Port 0 disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P0_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort0Enabled (portNum) == TRUE)
     {
         // Port 0 enabled
     }
     else
     {
         // Port 0 disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga59b3faf27b839e10016e3c0bdab91290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort0PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort0PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 0.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 0 ingress priority tagging enabled. <br />
 FALSE Port 0 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort0PassPriTagEnabled (portNum) == TRUE)
     {
         // Port 0 pass priority tagging enabled
     }
     else
     {
         // Port 0 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga33c67d56975c68a8fcb047cc7c87b0ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort1PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort1PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 1.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 1 ingress priority tagging enabled. <br />
 FALSE Port 1 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort1PassPriTagEnabled (portNum) == TRUE)
     {
         // Port 1 pass priority tagging enabled
     }
     else
     {
         // Port 1 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf00cb40a07dda6fc94f70340d78635d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort2PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort2PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 2.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 2 ingress priority tagging enabled. <br />
 FALSE Port 2 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort2PassPriTagEnabled (portNum) == TRUE)
     {
         // Port 2 pass priority tagging enabled
     }
     else
     {
         // Port 2 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8ed289e4c07b0f8fa1f7482558044da7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort3PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort3PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 3.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 3 ingress priority tagging enabled. <br />
 FALSE Port 3 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P3_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort3PassPriTagEnabled () == TRUE)
     {
         // Port 3 pass priority tagging enabled
     }
     else
     {
         // Port 3 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafbd9de741cfc4d60100ec92f94065cc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort4PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort4PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 4.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 4 ingress priority tagging enabled. <br />
 FALSE Port 4 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P4_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort4PassPriTagEnabled () == TRUE)
     {
         // Port 0 pass priority tagging enabled
     }
     else
     {
         // Port 0 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8694694062539527e3add069759f8b2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort5PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort5PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 5.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 5 ingress priority tagging enabled. <br />
 FALSE Port 5 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P5_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort5PassPriTagEnabled () == TRUE)
     {
         // Port 5 pass priority tagging enabled
     }
     else
     {
         // Port 5 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga76495e877686af8030bed618936009b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort6PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort6PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 6.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 6 ingress priority tagging enabled. <br />
 FALSE Port 6 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P6_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort6PassPriTagEnabled () == TRUE)
     {
         // Port 6 pass priority tagging enabled
     }
     else
     {
         // Port 6 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0476ef563f02e8896d45e270b2f97d57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort7PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort7PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 7.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 7 ingress priority tagging enabled. <br />
 FALSE Port 7 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P7_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort7PassPriTagEnabled () == TRUE)
     {
         // Port 7 pass priority tagging enabled
     }
     else
     {
         // Port 7 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga05660def00de6b505aeacf785a23ff4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isPort8PassPriTagEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isPort8PassPriTagEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if priority tagging is enabled for Port 8.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Port 8 ingress priority tagging enabled. <br />
 FALSE Port 8 ingress priority tagging disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_CONTROL_REG_P8_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isPort8PassPriTagEnabled () == TRUE)
     {
         // Port 8 pass priority tagging enabled
     }
     else
     {
         // Port 8 pass priority tagging disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6d4ebffd268d69391f3f80830be1b4c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isResetDone </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isResetDone</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Softreset register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pSoft                   Soft reset bit read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_SOFT_RESET_SOFT_RESET</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  softResetStatus;

       softResetStatus = CSL_CPSW_isResetDone ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga98b6f3aafadc9da1e841de67873e30e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isSoftIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function indicates if the CPSW is at Software Idle mode where no packets will be started to be unloaded from ports.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Software Idle mode enabled. <br />
 FALSE Software Idle mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_SOFT_IDLE_SOFT_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isSoftIdle () == TRUE)
     {
         // Software Idle mode enabled
     }
     else
     {
         // Software Idle mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9d6c9796c839530be29343e14ffd60c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isSoftIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isSoftIdle</b> </p>
<p><b>Description</b> <br />
 This function indicates if the CPSW is at Software Idle mode where no packets will be started to be unloaded from ports.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE Software Idle mode enabled. <br />
 FALSE Software Idle mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 XGE_CPSW_SOFT_IDLE_REG_SOFT_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isSoftIdle () == TRUE)
     {
         // Software Idle mode enabled
     }
     else
     {
         // Software Idle mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacf6a83239cef87146d70497071c72963"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isVlanAwareEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isVlanAwareEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if VLAN aware mode is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE VLAN aware mode enabled. <br />
 FALSE VLAN aware mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_VLAN_AWARE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isVlanAwareEnabled (portNum) == TRUE)
     {
         // VLAN aware mode enabled
     }
     else
     {
         // VLAN aware mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga77edd6baea97da006c723e9b8c3e72f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isVlanAwareEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isVlanAwareEnabled</b> </p>
<p><b>Description</b> <br />
 This function indicates if VLAN aware mode is enabled in the CPSW control register.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE VLAN aware mode enabled. <br />
 FALSE VLAN aware mode disabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_SW_CONTROL_VLAN_AWARE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_CPSW_isVlanAwareEnabled (portNum) == TRUE)
     {
         // VLAN aware mode enabled
     }
     else
     {
         // VLAN aware mode disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga52ed986b08034826ea21a6660add3e3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_CPSW_isWrResetDone </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_isResetDone</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the CPSW Softreset register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pSoft                   Soft reset bit read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 CPSW_3G_SOFT_RESET_SOFT_RESET</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32  softResetStatus;

       softResetStatus = CSL_CPSW_isResetDone ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7b441561ae3002799f82cf391c779270"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_reset </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_reset</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Soft Reset register.</p>
<p><b> Arguments </b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SOFT_RESET_SOFT_RESET</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_reset ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga577b73ac830a4c6aad02030d7ced8392"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_resetCpdma </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_reset</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Soft Reset register.</p>
<p><b> Arguments </b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SOFT_RESET_SOFT_RESET</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_reset ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga84922ba2f35c3c9d58165ad9286af7ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_resetWr </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_reset</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Soft Reset register.</p>
<p><b> Arguments </b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_SOFT_RESET_SOFT_RESET</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_reset ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4bcc34b5b0baf38b92266dc437a1e356"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_resetWrControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_wrHandle&#160;</td>
          <td class="paramname"><em>hWrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the Control Register of CPSW Wrapper module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base address of the CPSW Wrapper Module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gafb9bb8854b785e82fe0c4db74814daba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleAgingTimerReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>agingPrescale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>agingPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleAgingTimerReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE Aging Timer register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       agingPrescale           Aging Timer prescale (1, 1000, 1000000)
       agingPeriod             Aging period in units of prescale.
                               When non-zero, auto-aging is enabled.  
                               This value (minus 1) times prescale is the number 
                               of clock cycles after which auto-aging will automatically 
                               be initiated.  
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_AGING_TIMER_REG_AGING_TIMER ALE_AGING_TIMER_REG_PRESCALE_1_DISABLE ALE_AGING_TIMER_REG_PRESCALE_2_DISABLE</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      aleAgingPrescale;
       Uint32      aleAgingPeriod;
       
       aleAgingPrescale = (Uint32)ALE_AGT_PRESACLE_1M;
       aleAgingPeriod = 1000; 

       CSL_CPSW_setAleAgingTimerReg (aleAgingPrescale,
                                     aleAgingPeriod);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa8687e7ee5eef346c5a795f466a90b8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleCtrlVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       aleCtrlVal          Value to be configured to the ALE control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          aleCtrlVal = 0;

       aleCtrlVal      =   CSL_CPSW_getAleControlReg ();
       aleCtrlVal      |=  CSL_CPSW_5GF_ALECONTROL_CLRTABLE_EN;

       CSL_CPSW_setAleControlReg (&amp;aleCtrlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1922f63d921905c84fc36a8700cf2e10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleCtrlVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       aleCtrlVal          Value to be configured to the ALE control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_SW_CONTROL</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          aleCtrlVal = 0;

       aleCtrlVal      =   CSL_CPSW_getAleControlReg ();
       aleCtrlVal      |=  CSL_CPSW_3G_ALECONTROL_CLRTABLE_EN;

       CSL_CPSW_setAleControlReg (&amp;aleCtrlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga88f093b048251f2712c3e0166f90ee50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleEthertypeEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pEthertypeCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleEthertypeEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Ethertype configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pEthertypeCfg           ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_ETHERTYPE_ENTRY            ethertypeCfg;

       index   =   0;
       ethertypeCfg.ethertype = 0x0800;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Ethertype entry
           CSL_CPSW_setAleEthertypeEntry (index, &amp;ethertypeCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae7fa3f7e8a48cbabe41faea56721263f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleEthertypeEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___e_t_h_e_r_t_y_p_e___e_n_t_r_y.html">CSL_CPSW_ALE_ETHERTYPE_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pEthertypeCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleEthertypeEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Ethertype configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pEthertypeCfg           ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_ETHERTYPE_ENTRY            ethertypeCfg;

       index   =   0;
       ethertypeCfg.ethertype = 0x0800;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Ethertype entry
           CSL_CPSW_setAleEthertypeEntry (index, &amp;ethertypeCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad7ba58f71b039cefb4c0d478a11648da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleIPv4Entry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv4Cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleIPv4Entry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with IPv4 configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pIPv4Cfg                ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv4_ENTRY                 ipv4Cfg;

       index   =   0;
       ipv4Cfg.ethertype = 0x0800;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add IPv4 entry
           CSL_CPSW_setAleIPv4Entry (index, &amp;ipv4Cfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga80c62f0d4d4a7600d8e5caa0688a122c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleIPv4Entry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv4___e_n_t_r_y.html">CSL_CPSW_ALE_IPv4_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv4Cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleIPv4Entry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with IPv4 configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pIPv4Cfg                ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv4_ENTRY                 ipv4Cfg;

       index   =   0;
       ipv4Cfg.ethertype = 0x0800;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add IPv4 entry
           CSL_CPSW_setAleIPv4Entry (index, &amp;ipv4Cfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7fa583dcdb4a94de870d023e507039b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleIPv6Entry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv6Cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleIPv6Entry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with IPv6 configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pIPv6Cfg                ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv6_ENTRY                 ipv4Cfg;

       index   =   0;
       ipv4Cfg.ethertype = 0x0800;
       ...

       if ((CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE &amp;&amp;
           (CSL_CPSW_getALEEntryType (index+1) == ALE_ENTRYTYPE_FREE))
       {
           // ALE entry is free

           // Add IPv6 entry
           CSL_CPSW_setAleIPv6Entry (index, &amp;ipv4Cfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5b3e4806177d60d16335d1a3ad5d4709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleIPv6Entry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___i_pv6___e_n_t_r_y.html">CSL_CPSW_ALE_IPv6_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pIPv6Cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleIPv6Entry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with IPv6 configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pIPv6Cfg                ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_IPv6_ENTRY                 ipv4Cfg;

       index   =   0;
       ipv4Cfg.ethertype = 0x0800;
       ...

       if ((CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE &amp;&amp;
           (CSL_CPSW_getALEEntryType (index+1) == ALE_ENTRYTYPE_FREE))
       {
           // ALE entry is free

           // Add IPv6 entry
           CSL_CPSW_setAleIPv6Entry (index, &amp;ipv4Cfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga728a2aeef7997963360a9639c150308a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Multicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pMcastAddrCfg           ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;
       CSL_CPSW_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

       index   =   0;
       mcastAddrCfg.macAddress [0] = 0x00;
       mcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Multicast address entry
           CSL_CPSW_setAleMcastAddrEntry (index, &amp;mcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gace8e42b5febbe3d4bc4238ca42b14e9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_MCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Multicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pMcastAddrCfg           ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                              index;
       CSL_CPSW_ALE_MCASTADDR_ENTRY    mcastAddrCfg;

       index   =   0;
       mcastAddrCfg.macAddress [0] = 0x00;
       mcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Multicast address entry
           CSL_CPSW_setAleMcastAddrEntry (index, &amp;mcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga96529608927d1d0f73bb78526055fe18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleOUIAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOUIAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleOUIAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with OUI address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pOUIAddrCfg             ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUIADDR_ENTRY          ouiAddrCfg;

       index   =   0;
       ouiAddrCfg.ouiAddress [0] = 0x00;
       ouiAddrCfg.ouiAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add OUI address entry
           CSL_CPSW_setAleOUIAddrEntry (index, &amp;ouiAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4458ad08823d81716458f7db3cb86c00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleOUIAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_i_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_OUIADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOUIAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleOUIAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with OUI address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pOUIAddrCfg             ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUIADDR_ENTRY          ouiAddrCfg;

       index   =   0;
       ouiAddrCfg.ouiAddress [0] = 0x00;
       ouiAddrCfg.ouiAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add OUI address entry
           CSL_CPSW_setAleOUIAddrEntry (index, &amp;ouiAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac9705ca1459395b8502fcf41b9680ba6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleOutValnEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOutValnCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleOutValnEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Outer VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pOutValnCfg             ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUTER_VLAN_ENTRY           outVlanCfg;

       index   =   0;
       outVlanCfg.vlanId = 0x0123;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Outer VLAN entry
           CSL_CPSW_setAleOutValnEntry (index, &amp;outVlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6da256d0b9a50f76afbec18b788909e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleOutValnEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___o_u_t_e_r___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_OUTER_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pOutValnCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleOutValnEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with Outer VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pOutValnCfg             ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_TABLE_CONTROL_REG_ENTRY_POINTER, ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 ALE_TABLE_WORD0, ALE_TABLE_WORD1, ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_OUTER_VLAN_ENTRY           outVlanCfg;

       index   =   0;
       outVlanCfg.vlanId = 0x0123;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Outer VLAN entry
           CSL_CPSW_setAleOutValnEntry (index, &amp;outVlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga029a45efa6412c54f107ffa6e6628dd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAlePolicerEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___e_n_t_r_y.html">CSL_CPSW_ALE_POLICER_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pPolCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePolicerEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pPolCfg                 ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_POLICER_TBL_CTL_REG_POL_TBL_INDEX ALE_POLICER_TBL_CTL_REG_WRITE_ENABLE=1 ALE_THREAD_CTL_REG_ENTRY_PTR ALE_POLICER_PORT_OUI_REG_PORT_MEN, ALE_POLICER_PORT_OUI_REG_PORT_NUM, ALE_POLICER_PORT_OUI_REG_PRI_MEN, ALE_POLICER_PORT_OUI_REG_PRI_VAL, ALE_POLICER_PORT_OUI_REG_ONU_MEN, ALE_POLICER_PORT_OUI_REG_ONU_INDEX, ALE_POLICER_DA_SA_REG_DST_MEN, ALE_POLICER_DA_SA_REG_DST_INDEX, ALE_POLICER_DA_SA_REG_SRC_MEN, ALE_POLICER_DA_SA_REG_SRC_INDEX, ALE_POLICER_VLAN_REG_OVLAN_MEN, ALE_POLICER_VLAN_REG_OVLAN_INDEX, ALE_POLICER_VLAN_REG_IVLAN_MEN, ALE_POLICER_VLAN_REG_IVLAN_INDEX, ALE_POLICER_ETHERTYPE_IPSA_REG_ETHERTYPE_MEN, ALE_POLICER_ETHERTYPE_IPSA_REG_ETHERTYPE_INDEX, ALE_POLICER_ETHERTYPE_IPSA_REG_IPSRC_MEN, ALE_POLICER_ETHERTYPE_IPSA_REG_IPSRC_INDEX, ALE_POLICER_IPDA_REG_IPDST_MEN, ALE_POLICER_IPDA_REG_IPDST_INDEX, ALE_THREAD_VAL_REG_ENABLE, ALE_THREAD_VAL_REG_VALUE</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_POLICER_ENTRY              polCfg;

       index   =   0;
       polCfg.vlanId  = 0x10;
       ...

       // Add ALE Policer entry
       CSL_CPSW_setAlePolicerEntry (index, &amp;polCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacb0879fe7e0339c8c3c8838039ecfe84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAlePolicerGlobConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_l_i_c_e_r___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_ALE_POLICER_GLOB_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pGlobConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePolicerGlobConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW ALE Policer/Classifier global registers per user-specified ALE Policer Global Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pGlobConfig         CSL_CPSW_ALE_POLICER_GLOB_CONFIG structure that holds the values 
                           that need to be configured to the ALE Policer global control 
                           registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CPSW ALE Policer Global control register modified with values provided.</p>
<p><b>Writes</b> <br />
 ALE_THREAD_DEF_REG_ENABLE, ALE_THREAD_DEF_REG_VALUE</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_ALE_POLICER_GLOB_CONFIG    globConfig;

       globConfig.defThreadEnable  =   1;
       ...

       CSL_CPSW_setAlePolicerGlobConfig (&amp;globConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga371835b4cbd79351e9a83b87a6b55545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAlePortControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *&#160;</td>
          <td class="paramname"><em>pPortControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePortControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of ALE Port control register corresponding to the port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNo                  Port number for which the ALE port control register
                               must be configured.
       pPortControlInfo        CSL_CPSW_ALE_PORTCONTROL structure that contains 
                               port control register settings to be written.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_PORT_CONTROL_REG_PORT_STATE, CPSW_5GF_ALE_PORT_CONTROL_REG_DROP_UNTAGGED, CPSW_5GF_ALE_PORT_CONTROL_REG_VID_INGRESS_CHECK, CPSW_5GF_ALE_PORT_CONTROL_REG_NO_LEARN, CPSW_5GF_ALE_PORT_CONTROL_REG_MCAST_LIMIT, CPSW_5GF_ALE_PORT_CONTROL_REG_BCAST_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                          index;
       CSL_CPSW_ALE_PORTCONTROL    portControlInfo;

       index   =   0;
       portControlInfo.portState   =   ALE_PORTSTATE_FORWARD |
                                       ALE_PORTSTATE_LEARN;

       CSL_CPSW_setAlePortControlReg (index, &amp;portControlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac5663f18419cfe84fd818e0a4eb66a06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAlePortControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___p_o_r_t_c_o_n_t_r_o_l.html">CSL_CPSW_ALE_PORTCONTROL</a> *&#160;</td>
          <td class="paramname"><em>pPortControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePortControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of ALE Port control register corresponding to the port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNo                  Port number for which the ALE port control register
                               must be configured.
       pPortControlInfo        CSL_CPSW_ALE_PORTCONTROL structure that contains
                               port control register settings to be written.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_PORT_CONTROL_PORT_STATE, CPSW_3G_PORT_CONTROL_DROP_UNTAGGED, CPSW_3G_PORT_CONTROL_VID_INGRESS_CHECK, CPSW_3G_PORT_CONTROL_NO_LEARN, CPSW_3G_PORT_CONTROL_NO_SA_UPDATE, CPSW_3G_PORT_CONTROL_DISABLE_AUTH_MODE, CPSW_3G_PORT_CONTROL_MCAST_LIMIT, CPSW_3G_PORT_CONTROL_BCAST_LIMIT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                          index;
       CSL_CPSW_ALE_PORTCONTROL    portControlInfo;

       index   =   0;
       portControlInfo.portState   =   ALE_PORTSTATE_FORWARD |
                                       ALE_PORTSTATE_LEARN;

       CSL_CPSW_setAlePortControlReg (index, &amp;portControlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga176a31b66e28db448bf7de932bc089ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAlePrescaleReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>alePrescaleVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePrescaleReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE prescale register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       alePrescaleVal      Value to be configured to the ALE Prescale register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_PRESCALE_REG_ALE_PRESCALE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          alePrescaleVal = 0;

       alePrescaleVal  =   10;

       CSL_CPSW_setAlePrescaleReg (&amp;aleCtrlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1b6e69be0ffc963e9ce9fa86019b30f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAlePrescaleReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>alePrescaleVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAlePrescaleReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE prescale register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       alePrescaleVal      Value to be configured to the ALE Prescale register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_PRESCALE_PRESCALE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          alePrescaleVal = 0;

       alePrescaleVal  =   10;

       CSL_CPSW_setAlePrescaleReg (&amp;aleCtrlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9d3b77625043068257dcd4d636c7f97e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleTableEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleTableEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up an ALE table entry corresponding to the ALE entry index specified in 'index' input parameter. The ALE entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and ALE_TBLW2 registers msut be specified in 'aleInfoWd0', 'aleInfoWd1', 'aleInfoWd2' input parameters.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be written.
       aleInfoWd0              Value to write to ALE Table Word 0 Register (ALE_TBLW0).
       aleInfoWd1              Value to write to Table Word 1 Register (ALE_TBLW1).
       aleInfoWd2              Value to write to ALE Table Word 2 Register (ALE_TBLW2).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_WORD0_REG_ENTRY_31_0, CPSW_5GF_ALE_TABLE_WORD1_REG_ENTRY_63_32, CPSW_5GF_ALE_TABLE_WORD2_REG_ENTRY_71_64, CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       Uint32      index, info0, info1, info2;

       index   =   0;
       info0   =   ...;
       info1   =   ...;
       info2   =   ...;

       CSL_CPSW_setAleTableEntry (index, 
                                         info0,
                                         info1,
                                         info2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab32fe555d733bbd7657cf4bcb8e9c398"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleTableEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleInfoWd2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleTableEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up an ALE table entry corresponding to the ALE entry index specified in 'index' input parameter. The ALE entry values corresponding to the ALE_TBLW0, ALE_TBLW1 and ALE_TBLW2 registers msut be specified in 'aleInfoWd0', 'aleInfoWd1', 'aleInfoWd2' input parameters.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index to be written.
       aleInfoWd0              Value to write to ALE Table Word 0 Register (ALE_TBLW0).
       aleInfoWd1              Value to write to ALE Table Word 1 Register (ALE_TBLW1).
       aleInfoWd2              Value to write to ALE Table Word 2 Register (ALE_TBLW2).
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_WORD0_ENTRY_31_0, CPSW_3G_TABLE_WORD1_ENTRY_63_32, CPSW_3G_TABLE_WORD2_ENTRY_71_64, CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">       Uint32      index, info0, info1, info2;

       index   =   0;
       info0   =   ...;
       info1   =   ...;
       info2   =   ...;

       CSL_CPSW_setAleTableEntry (index,
                                         info0,
                                         info1,
                                         info2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga49a21c30cb2ef548fd641fba977cd0cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with unicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pUcastAddrCfg           ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

       index   =   0;
       ucastAddrCfg.macAddress [0] = 0x00;
       ucastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Unicast address entry
           CSL_CPSW_setAleUnicastAddrEntry (index, &amp;ucastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7156bf956d80dc1fcb8eb3c991ceed95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_UNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with unicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pUcastAddrCfg           ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_UNICASTADDR_ENTRY      ucastAddrCfg;

       index   =   0;
       ucastAddrCfg.macAddress [0] = 0x00;
       ucastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add Unicast address entry
           CSL_CPSW_setAleUnicastAddrEntry (index, &amp;ucastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga84bf1bbe73f6077eb7724dfefbe0112b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleUnkownVlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unVlanMemList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unRegMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unForceUntagEgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUnkownVlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE Unknown VLAN register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       unVlanMemList           Unknown VLAN member list.
       unMcastFloodMask        Unknown VLAN Multicast flood mask.
       unRegMcastFloodMask     Unknown VLAN Registered Multicast Flood mask.
       unForceUntagEgress      Unknown VLAN Force Untagged Egress.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_VLAN_MEMBER_LIST, CPSW_5GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_MCAST_FLOOD_MASK, CPSW_5GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_REG_MCAST_FLOOD_MASK, CPSW_5GF_ALE_UNKNOWN_VLAN_REG_UNKNOWN_FORCE_UNTAGGED_EGRESS</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

       unVlanMemList           =   0;
       unMcastFloodMask        =   3;
       unRegMcastFloodMask     =   0;
       unForceUntagEgress      =   0;

       CSL_CPSW_setAleUnkownVlanReg (unVlanMemList, 
                                         unMcastFloodMask,
                                         unRegMcastFloodMask,
                                         unForceUntagEgress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga763c5577b1d00023a8412d42dd32cb38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleUnkownVlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unVlanMemList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unRegMcastFloodMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>unForceUntagEgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUnkownVlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE Unknown VLAN and etc. register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       unVlanMemList           Unknown VLAN member list.
       unMcastFloodMask        Unknown VLAN Multicast flood mask.
       unRegMcastFloodMask     Unknown VLAN Registered Multicast Flood mask.
       unForceUntagEgress      Unknown VLAN Force Untagged Egress.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_UNKNOWN_VLAN_UNKNOWN_VLAN_MEMBER_LIST,</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      unVlanMemList, unMcastFloodMask, unRegMcastFloodMask, unForceUntagEgress;

       unVlanMemList           =   0;
       unMcastFloodMask        =   3;
       unRegMcastFloodMask     =   0;
       unForceUntagEgress      =   0;

       CSL_CPSW_setAleUnkownVlanReg (unVlanMemList,
                                     unMcastFloodMask,
                                     unRegMcastFloodMask,
                                     unForceUntagEgress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadafe1eb2be82c731bb317c268a1fff0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleUpdateBW </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>aleUpdBW</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleUpdateBW</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE Update Bandwidth of the ALE control register.</p>
<p><b>Arguments</b> <br />
 aleUpdBW ALE Update Bandwidth</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_CONTROL_REG_UPD_BW_CTL</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_setAleUpdateBW ((Uint32)ALE_UPD_BW_350MHZ_5M);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga111a0c955e21790d81dc931e6e9c2513"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleVlanEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanCfg                ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLAN_ENTRY             vlanCfg;

       index   =   0;
       vlanCfg.vlanId  = 0x10;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN entry
           CSL_CPSW_setAleVlanEntry (index, &amp;vlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaff0952d30e5a54255fd892efd459445e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleVlanEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n___e_n_t_r_y.html">CSL_CPSW_ALE_VLAN_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanCfg                ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLAN_ENTRY             vlanCfg;

       index   =   0;
       vlanCfg.vlanId  = 0x10;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN entry
           CSL_CPSW_setAleVlanEntry (index, &amp;vlanCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab2ce0a286e7dbe4cab8e242678fcbe67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleVlanMaskMuxReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>vlanMaskMux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanMaskMuxReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the ALE VLAN Mask Mux registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">       vlanMaskMux             Array of VLAN Mask Mux which is indexed by
                               the unreg_mcast_flood_index and reg_mcast_flood_
                               index values from the VLAN table entry to determine 
                               the registered and unregistered multicast flood masks                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ALE_VLAN_MASK_MUX_REG_MASK</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32      vlanMaskMux[4];
       
       vlanMaskMux[0] = 0x3;
       vlanMaskMux[1] = 0;
       ...

       CSL_CPSW_setAleVlanMaskMuxReg (vlanMaskMux); </pre> <h1>: The value of VLAN_Mask_MUX_0 is read only and all ones (all ports are one). </h1>

</div>
</div>
<a class="anchor" id="ga8dc20485c91f87261d2678db85aace57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleVlanMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN Multicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanMcastAddrCfg       ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

       index   =   0;
       vlanMcastAddrCfg.macAddress [0] = 0x00;
       vlanMcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN Multicast address entry
           CSL_CPSW_setAleVlanMcastAddrEntry (index, &amp;vlanMcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6d8e763d04272386d7cb2b71d3c8256d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleVlanMcastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_m_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANMCASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanMcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanMcastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN Multicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanMcastAddrCfg       ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANMCASTADDR_ENTRY    vlanMcastAddrCfg;

       index   =   0;
       vlanMcastAddrCfg.macAddress [0] = 0x00;
       vlanMcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN Multicast address entry
           CSL_CPSW_setAleVlanMcastAddrEntry (index, &amp;vlanMcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga524d267027691d56e66050b3cd4d681e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleVlanUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN unicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanUcastAddrCfg       ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_TABLE_CONTROL_REG_ENTRY_POINTER, CPSW_5GF_ALE_TABLE_CONTROL_REG_WRITE_RDZ=1 CPSW_5GF_ALE_TABLE_WORD0, CPSW_5GF_ALE_TABLE_WORD1, CPSW_5GF_ALE_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

       index   =   0;
       vlanUcastAddrCfg.macAddress [0] = 0x00;
       vlanUcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN Unicast address entry
           CSL_CPSW_setAleVlanUnicastAddrEntry (index, &amp;vlanUcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7e63a1711209b0c35e0de14e6f3fecff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setAleVlanUnicastAddrEntry </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___a_l_e___v_l_a_n_u_n_i_c_a_s_t_a_d_d_r___e_n_t_r_y.html">CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>pVlanUcastAddrCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setAleVlanUnicastAddrEntry</b> </p>
<p><b>Description</b> <br />
 This function sets up the ALE table entry for the index specified with VLAN unicast address configuration specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">       index                   ALE table index.
       pVlanUcastAddrCfg       ALE entry contents to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TABLE_CONTROL_ENTRY_POINTER, CPSW_3G_TABLE_CONTROL_WRITE_RDZ=1 CPSW_3G_TABLE_WORD0, CPSW_3G_TABLE_WORD1, CPSW_3G_TABLE_WORD2</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                                  index;
       CSL_CPSW_ALE_VLANUNICASTADDR_ENTRY  vlanUcastAddrCfg;

       index   =   0;
       vlanUcastAddrCfg.macAddress [0] = 0x00;
       vlanUcastAddrCfg.macAddress [1] = 0x01;
       ...

       if (CSL_CPSW_getALEEntryType (index) == ALE_ENTRYTYPE_FREE)
       {
           // ALE entry is free

           // Add VLAN Unicast address entry
           CSL_CPSW_setAleVlanUnicastAddrEntry (index, &amp;vlanUcastAddrCfg);
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga128e70a4f51ee79896ac6a1cc6524352"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaMiscEndOfIntVector </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the DMA End Of Interrupt Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">eoiFlag</td><td>Type of interrupt to acknowledge to the CPDMA 'eoiFlag' can take the following values <br />
 CPSW_EOI_TX_PULSE - TX Pulse Interrupt <br />
 CPSW_EOI_RX_PULSE - RX Pulse Interrupt <br />
 CPSW_EOI_RX_THRESH_PULSE - RX Pulse Threshold Interrupt <br />
 CPSW_EOI_MISC_PULSE - Misc Interrupt <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b6ca4c0a97640d91bea8c4bf597b375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaNumFreeBuf </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>nBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the free buffers for a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel Number. </td></tr>
    <tr><td class="paramname">nBuf</td><td>Number of free buffers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f1fdb545d00531e0e14586c0e3aca67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaRxBufOffset </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>bufOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the RX buffer offset value. The RX buffer offset will be written by the port into each frame SOP buffer descriptor buffer_offset field. The frame data will begin after the rx_buffer_offset value of bytes. This value will be used for all the channels . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers </td></tr>
    <tr><td class="paramname">bufOff</td><td>Buffer offset value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga715716f357b05a261adac6fcb99d518e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaRxCp </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>comPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the the RX Completion Pointer for a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel Number. </td></tr>
    <tr><td class="paramname">comPtr</td><td>Completion Pointer Value to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e0b48257289e5a4e4d616dcac23f73f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaRxEndOfIntVector </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the DMA End Of Interrupt Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">eoiFlag</td><td>Type of interrupt to acknowledge to the CPDMA 'eoiFlag' can take the following values <br />
 CPSW_EOI_TX_PULSE - TX Pulse Interrupt <br />
 CPSW_EOI_RX_PULSE - RX Pulse Interrupt <br />
 CPSW_EOI_RX_THRESH_PULSE - RX Pulse Threshold Interrupt <br />
 CPSW_EOI_MISC_PULSE - Misc Interrupt <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ce55a89822e9c66ecdd66561ca754e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaRxHdrDescPtr </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>descHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>API to write the RX HDP register. If receive is enabled, write to the RX HDP will enable data reception to point to the corresponding RX buffer descriptor's buffer pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">descHdr</td><td>Address of the RX buffer descriptor </td></tr>
    <tr><td class="paramname">channel</td><td>Channel Number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ead09ca9132c10f592b34f9a94574bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaRxThresholdEndOfIntVector </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the DMA End Of Interrupt Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">eoiFlag</td><td>Type of interrupt to acknowledge to the CPDMA 'eoiFlag' can take the following values <br />
 CPSW_EOI_TX_PULSE - TX Pulse Interrupt <br />
 CPSW_EOI_RX_PULSE - RX Pulse Interrupt <br />
 CPSW_EOI_RX_THRESH_PULSE - RX Pulse Threshold Interrupt <br />
 CPSW_EOI_MISC_PULSE - Misc Interrupt <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga40cd8c07a98b3de6674ba48ceb8e11af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaTxCp </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>comPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the the TX Completion Pointer for a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel Number. </td></tr>
    <tr><td class="paramname">comPtr</td><td>Completion Pointer Value to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fc26458252b306edaa3fcf3c50a6f55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaTxEndOfIntVector </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the DMA End Of Interrupt Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">eoiFlag</td><td>Type of interrupt to acknowledge to the CPDMA 'eoiFlag' can take the following values <br />
 CPSW_EOI_TX_PULSE - TX Pulse Interrupt <br />
 CPSW_EOI_RX_PULSE - RX Pulse Interrupt <br />
 CPSW_EOI_RX_THRESH_PULSE - RX Pulse Threshold Interrupt <br />
 CPSW_EOI_MISC_PULSE - Misc Interrupt <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga4343793ed6dfe949553fbe8ec9e28d1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpdmaTxHdrDescPtr </td>
          <td>(</td>
          <td class="paramtype">CSL_cpdmaHandle&#160;</td>
          <td class="paramname"><em>hCpdmaRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>descHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>API to write the TX HDP register. If transmit is enabled, write to the TX HDP will immediately start transmission. The data will be taken from the buffer pointer of the TX buffer descriptor written to the TX HDP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the CPDMA module registers. </td></tr>
    <tr><td class="paramname">descHdr</td><td>Address of the TX buffer descriptor </td></tr>
    <tr><td class="paramname">channel</td><td>Channel Number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaac77c4f25c7b8e5b8e7babd108bf8a07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCppiSourceIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txASrcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txBSrcId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCppiSourceIdReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPPI Source Identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       txASrcId            CPPI Source Id to configure for TxA.
       txBSrcId            CPPI Source Id to configure for TxB.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P0_CPPI_SRC_ID_REG_TXA_SRC_ID, CPSW_5GF_P0_CPPI_SRC_ID_REG_TXB_SRC_ID</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      txASrcId, txBSrcId;

       txASrcId    =   1;
       txBSrcId    =   2;

       CSL_CPSW_setCppiSourceIdReg (txASrcId, txBSrcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa4aa529232f7d81b8f45455d6a71c752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCppiSourceIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pTxSrcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCppiSourceIdReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPPI Source Identification register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTxSrcId[8]         CPPI Info Word0 Source Id Value on Tx Ports respectively.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_SRC_ID_A_REG_PORT1 XGE_CPSW_P0_SRC_ID_A_REG_PORT2 XGE_CPSW_P0_SRC_ID_A_REG_PORT3 XGE_CPSW_P0_SRC_ID_A_REG_PORT4 XGE_CPSW_P0_SRC_ID_B_REG_PORT5 XGE_CPSW_P0_SRC_ID_B_REG_PORT6 XGE_CPSW_P0_SRC_ID_B_REG_PORT7 XGE_CPSW_P0_SRC_ID_B_REG_PORT8</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      txSrcId[8];

       txSrcId[0]    =   1;
       txSrcId[1]    =   2;
       ...

       CSL_CPSW_setCppiSourceIdReg (txSrcId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa8b93090f858706aaa618e8973edbee3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpswControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlRegInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCpswControlReg</b> </p>
<p><b>Description</b> <br />
 This function populates the contents of the CPSW Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pControlRegInfo     CSL_CPSW_CONTROL structure that holds the values
                           that need to be configured to the CPSW control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CPSW control register modified with values provided.</p>
<p><b>Writes</b> <br />
 CPSW_3G_SW_CONTROL_FIFO_LOOPBACK, CPSW_3G_SW_CONTROL_VLAN_AWARE, CPSW_3G_SW_CONTROL_EEE_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_CONTROL    controlRegInfo;

       controlRegInfo.vlanAware    =   0;
       ...

       CSL_CPSW_setCpswControlReg (&amp;controlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga92dcf5fed038e39c2af75ad2727e48e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setCpswControlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___c_o_n_t_r_o_l.html">CSL_CPSW_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlRegInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setCpswControlReg</b> </p>
<p><b>Description</b> <br />
 This function populates the contents of the CPSW Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pControlRegInfo     CSL_CPSW_CONTROL structure that holds the values 
                           that need to be configured to the CPSW control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CPSW control register modified with values provided.</p>
<p><b>Writes</b> <br />
 CPSW_5GF_CPSW_CONTROL_REG_FIFO_LOOPBACK, CPSW_5GF_CPSW_CONTROL_REG_VLAN_AWARE, CPSW_5GF_CPSW_CONTROL_REG_P0_ENABLE, CPSW_5GF_CPSW_CONTROL_REG_P0_PASS_PRI_TAGGED, CPSW_5GF_CPSW_CONTROL_REG_P1_PASS_PRI_TAGGED, CPSW_5GF_CPSW_CONTROL_REG_P2_PASS_PRI_TAGGED</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_CONTROL    controlRegInfo;

       controlRegInfo.fifoLb       =   1;
       controlRegInfo.vlanAware    =   0;
       ...

       CSL_CPSW_setCpswControlReg (&amp;controlRegInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga73a7b8d20eeafb6da83cf8dfd9528308"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setEEEGlobConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___g_l_o_b___c_o_n_f_i_g.html">CSL_CPSW_EEE_GLOB_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pGlobConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setEEEGlobConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW EEE related global registers per user-specified EEE Global Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pGlobConfig         CSL_CPSW_EEE_GLOB_CONFIG structure that holds the values 
                           that need to be configured to the EEE global control 
                           registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CPSW EEE Global control register modified with values provided.</p>
<p><b>Writes</b> <br />
 XGE_CPSW_EEE_PRESCALE_REG_EEE_PRESCALE XGE_CPSW_CONTROL_REG_EEE_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_EEE_GLOB_CONFIG    globConfig;

       globConfig.enable       =   1;
       globalConfig.prescale   =   100;
       ...

       CSL_CPSW_setEEEGlobConfig (&amp;globConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaf479b3f461cfde92ac54c7d1a8bb577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setEEEPortConfig </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___e_e_e___p_o_r_t___c_o_n_f_i_g.html">CSL_CPSW_EEE_PORT_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pPortConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setEEEPortConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW EEE port-specific control registers per user-specified EEE Port Configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the EEE Port Control 
                               registers must be configured.
       pPortConfig             CSL_CPSW_EEE_PORT_CONFIG structure holds the value 
                               that needs to be configured to the EEE port-specific 
                               control registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_IDLE2LPI_REG_COUNT XGE_CPSW_P0_LPI2WAKE_REG_COUNT</p>
<p>XGE_CPSW_PN_IDLE2LPI_REG_COUNT XGE_CPSW_PN_LPI2WAKE_REG_COUNT XGE_CPSW_PN_CONTROL_REG_TX_LPI_CLKSTOP_EN</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32                      portNum;
       CSL_CPSW_EEE_PORT_CONFIG    portConfig;

       portNum = 1;
       portConfig.idle2lpi = 10;
       portConfig.lpi2wake = 10;
       portConfig.txLpiClkstopEnable = 1;
       CSL_CPSW_setEEEPortConfig (portNum, &amp;portConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2fab2fd9ce96ff98f32e28a5a26a6267"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setEmulationControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>soft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setEmulationControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Emulation Control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       free                   Emulation free bit configuration
       soft                   Emulation soft bit configuration
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_EM_CONTROL_REG_FREE, CPSW_5GF_EM_CONTROL_REG_SOFT</p>
<p><b>Example</b> </p><pre class="fragment">       Uint32 free, soft;

       free   =   0;
       soft   =   1;

       CSL_CPSW_setEmulationControlReg (free, soft);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga57a09370721eff2ea8bbae52e1656115"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setFlowControlReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___f_l_o_w_c_n_t_l.html">CSL_CPSW_FLOWCNTL</a> *&#160;</td>
          <td class="paramname"><em>pFlowControlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setFlowControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Flow control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFlowControlCfg     CSL_CPSW_FLOWCNTL structure that contains the values
                           that need to be configured to Flow control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_FLOW_CONTROL_P0_FLOW_EN, CPSW_3G_FLOW_CONTROL_P1_FLOW_EN, CPSW_3G_FLOW_CONTROL_P2_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_FLOWCNTL       flowControlCfg;

       flowControlCfg.p0FlowEnable =   1;
       flowControlCfg.p1FlowEnable =   1;:
       flowControlCfg.p2FlowEnable =   1;

       CSL_CPSW_setFlowControlReg (&amp;flowControlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacaa866233097b1e0ee0c4b053b6e8732"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setFlowControlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___f_l_o_w_c_n_t_l.html">CSL_CPSW_FLOWCNTL</a> *&#160;</td>
          <td class="paramname"><em>pFlowControlCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setFlowControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Flow control register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pFlowControlCfg     CSL_CPSW_FLOWCNTL structure that contains the values
                           that need to be configured to Flow control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_FLOW_CONTROL_REG_P0_FLOW_EN, CPSW_5GF_FLOW_CONTROL_REG_P1_FLOW_EN, CPSW_5GF_FLOW_CONTROL_REG_P2_FLOW_EN</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_CPSW_FLOWCNTL       flowControlCfg;

       flowControlCfg.p0FlowEnable =   1;
       flowControlCfg.p1FlowEnable =   1;:
       flowControlCfg.p2FlowEnable =   1;

       CSL_CPSW_setFlowControlReg (&amp;flowControlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad51c209775ce98b54ab597025ea8c296"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPort0FlowIdOffset </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>flowIdOffset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0FlowIdOffset</b> </p>
<p><b>Description</b> <br />
 This function sets up the Port0 Flow ID Offset register. which is added to the thread/Flow_ID in CPPI transmit PSI Info Word 0.</p>
<p><b>Arguments</b> </p><pre class="fragment">       flowIdOffset            CPPI Flow ID offset to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_FLOW_ID_OFFSET_REG_VALUE</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      flowIdOffset;

       flowIdOffset    =   0;            

       CSL_CPSW_setPort0FlowIdOffset (flowIdOffset);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9f3c995baa9f5f8b4cd91e79ed03f7bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPort0RxMaxLen </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxLen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0RxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function sets up the Port0 Receive Maximum length register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       rxMaxLen            Maximum receive frame length to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxLen;

       rxMaxLen    =   1518;            

       CSL_CPSW_setPort0RxMaxLen (rxMaxLen);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6af0d04508abc33391b5a799ee5500b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPort0RxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0RxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port 0 Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortRxPriMap           Array of Port 0 Rx priority map priority values 
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P0_RX_PRI_MAP_REG_PRI0, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI1, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI2, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI3, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI4, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI5, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI6, CPSW_5GF_P0_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      i, port0RxPriMap [8];

       for (i = 0; i &lt; 8; i ++)
           port0RxPriMap [i] = i;

       CSL_CPSW_setPort0RxPriMapReg (port0RxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga050b2dc7d518b5fc47e190f10f6f3e3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPort0TxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0RxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port 0 Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortTxPriMap           Array of Port 0 Rx priority map priority values
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_P0_TX_PRI_MAP_PRI0, CPSW_3G_P0_TX_PRI_MAP_PRI1, CPSW_3G_P0_TX_PRI_MAP_PRI2, CPSW_3G_P0_TX_PRI_MAP_PRI3, CPSW_3G_P0_TX_PRI_MAP_PRI4, CPSW_3G_P0_TX_PRI_MAP_PRI5, CPSW_3G_P0_TX_PRI_MAP_PRI6, CPSW_3G_P0_TX_PRI_MAP_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      i, port0TxPriMap [8];

       for (i = 0; i &lt; 8; i ++)
           port0TxPriMap [i] = i;

       CSL_CPSW_setPort0RxPriMapReg (port0TxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga64a71ef6c55c5f20915c13429d537e95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPort0VlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0VlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port 0 VLAN Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portVID                 Port VLAN Id to be configured
       portCFI                 Port CFI bit to be configured
       portPRI                 Port VLAN priority to be configured
                               (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_P0_PORT_VLAN_PORT_VID, CPSW_3G_P0_PORT_VLAN_PORT_CFI, CPSW_3G_P0_PORT_VLAN_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI;

       portVID     =   1;
       portCFI     =   0;
       portPRI     =   7;

       CSL_CPSW_setPort0VlanReg (portVID, portCFI, portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7fccd286117a681fb73ec359114ede6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPort0VlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPort0VlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port 0 VLAN Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portVID                 Port VLAN Id to be configured
       portCFI                 Port CFI bit to be configured
       portPRI                 Port VLAN priority to be configured
                               (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P0_PORT_VLAN_REG_PORT_VID, CPSW_5GF_P0_PORT_VLAN_REG_PORT_CFI, CPSW_5GF_P0_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI;

       portVID     =   1;
       portCFI     =   0;
       portPRI     =   7;

       CSL_CPSW_setPort0VlanReg (portVID, portCFI, portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6c4e0c08eb042fb1cea6496d7a468291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortControlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t___c_o_n_t_r_o_l.html">CSL_CPSW_PORT_CONTROL</a> *&#160;</td>
          <td class="paramname"><em>pControlInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortControlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Control Register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the register contents
                               must be read and returned.
       pControlInfo            CSL_CPSW_PORT_CONTROL structure that holds the values 
                               that need to be configured to the CPSW Port 
                               control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 none</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_CONTROL_REG_DSCP_IPV4_EN, XGE_CPSW_P0_CONTROL_REG_DSCP_IPV6_EN,</p>
<p>XGE_CPSW_PN_CONTROL_REG_DSCP_IPV4_EN, XGE_CPSW_PN_CONTROL_REG_DSCP_IPV6_EN, XGE_CPSW_PN_CONTROL_REG_TX_LPI_CLKSTOP_EN,</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32                      portNum;
       CSL_CPSW_PORT_CONTROL       controlInfo;

       portNum =   1;
       
       controlInfo.dscpIpv4Enable = 1;
       controlInfo.dscpIpv6Enable = 1;
       controlInfo.txLpiClkstopEnable = 0;
       

       CSL_CPSW_setPortControlReg (portNum, &amp;controlInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga694e841c56c9532d6915bcfa572549da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortMACAddress </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortMACAddress</b> </p>
<p><b>Description</b> <br />
 This function sets up the source MAC address corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the source MAC address
                               must be setup.
       pMacAddress             6 byte Source MAC address to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacAddres' is expected to be 6 bytes long.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_SL_SA_LO_REG_MACSRCADDR_7_0, CPSW_5GF_SL_SA_LO_REG_MACSRCADDR_15_8, CPSW_5GF_SL_SA_HI_REG_MACSRCADDR_23_16, CPSW_5GF_SL_SA_HI_REG_MACSRCADDR_31_24, CPSW_5GF_SL_SA_HI_REG_MACSRCADDR_39_32, CPSW_5GF_SL_SA_HI_REG_MACSRCADDR_47_40</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint8   macAddress [6], portNum;

       portNum         =   1;
       macAddress [0]  =   0x01;
       macAddress [1]  =   0x02;
       macAddress [2]  =   0x03;
       macAddress [3]  =   0x04;
       macAddress [4]  =   0x05;
       macAddress [5]  =   0x06;

       CSL_CPSW_setPortMACAddress (portNum, macAddress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9f9501acb879fddf69fa40b9878bc518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortMACAddress </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>pMacAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortMACAddress</b> </p>
<p><b>Description</b> <br />
 This function sets up the source MAC address the Tx Pause Frame corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the source MAC address
                               must be setup. (1-8)
       pMacAddress             6 byte Source MAC address to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pMacAddres' is expected to be 6 bytes long.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_P_SA_LO_MACSRCADDR_7_0, CPSW_3G_P_SA_LO_MACSRCADDR_15_8, CPSW_3G_P_SA_HI_MACSRCADDR_23_16, CPSW_3G_P_SA_HI_MACSRCADDR_31_24, CPSW_3G_P_SA_HI_MACSRCADDR_39_32, CPSW_3G_P_SA_HI_MACSRCADDR_47_40</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint8   macAddress [6], portNum;

       portNum         =   1;
       macAddress [0]  =   0x01;
       macAddress [1]  =   0x02;
       macAddress [2]  =   0x03;
       macAddress [3]  =   0x04;
       macAddress [4]  =   0x05;
       macAddress [5]  =   0x06;

       CSL_CPSW_setPortMACAddress (portNum, macAddress);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa24f015c179eea3fb7f4eb86cb29c48f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortMaxBlksReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortMaxBlksReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Maxmium Block register corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the max block value
                               must be retrieved.
       rxMaxBlks               Receive FIFO Maximum Blocks - This value is the 
                               maximum number of 1k memory blocks that may be 
                               allocated to the FIFO's logical receive queue.
                               This value must be greater than or equal to 0x3.  
                               The recommended value of rx_max_blks is 0x9

       txMaxBlks               Transmit FIFO Maximum Blocks - This value is the 
                               maximum number of 1k memory blocks that may be 
                               allocated to the FIFO's logical transmit 
                               priority queues.  The recommended value of 
                               tx_max_blks is 0x3.                                
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_MAX_BLKS_REG_RX_MAX_BLKS, XGE_CPSW_PN_MAX_BLKS_REG_TX_MAX_BLKS,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum =   1;            

       CSL_CPSW_setPortMaxBlksReg (portNum, rxMaxBlks, txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab19617996572ec3771f4f6d8be695d30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortMaxBlocksReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortMaxBlocksReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Max Blocks Register corresponding to the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the max block numbers
                               must be configured.
       rxMaxBlks               Maximum number of 4K memory blocks that must be allocated
                               for the port's FIFO logical receive priority queues.
       txMaxBlks               Maximum number of 4K memory blocks that must be allocated
                               for the port's FIFO logical transmit priority queues.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_P_MAX_BLKS_P_RX_MAX_BLKS, CPSW_3G_P_MAX_BLKS_P_TX_MAX_BLKS, CPSW_3G_P0_MAX_BLKS_P0_RX_MAX_BLKS, CPSW_3G_P0_MAX_BLKS_P0_TX_MAX_BLKS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum     =   1;
       rxMaxBlks   =   3;
       txMaxBlks   =   17;

       CSL_CPSW_getPortMaxBlocksReg (portNum, rxMaxBlks, txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga87715ad84d4f793ff6be8324c0c093e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortMaxBlocksReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxBlks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>txMaxBlks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortMaxBlocksReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Max Blocks Register corresponding to the MAC port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the max block numbers
                               must be configured.
       rxMaxBlks               Maximum number of 4K memory blocks that must be allocated
                               for the port's FIFO logical receive priority queues.
       txMaxBlks               Maximum number of 4K memory blocks that must be allocated
                               for the port's FIFO logical transmit priority queues.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P_MAX_BLKS_REG_RX_MAX_BLKS, CPSW_5GF_P_MAX_BLKS_REG_TX_MAX_BLKS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      rxMaxBlks, txMaxBlks, portNum;

       portNum     =   1;            
       rxMaxBlks   =   3;
       txMaxBlks   =   17;

       CSL_CPSW_getPortMaxBlocksReg (portNum, rxMaxBlks, txMaxBlks);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaa1ee28d71af39c6c4b7e9dbcec47b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortRxDscpMap </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxDscpPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortRxDscpMap</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port DSCP to Priority Mapping Registers corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the DSCP mapping
                               registers must be configured.
       pRxDscpPriMap           Array of Port Rx DSCP to priority mapping values
                               that must be configured to the registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pRxDscpPriMap' must be large enough to hold all the 64 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI0, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI1, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI2, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI3, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI4, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI5, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI6, CPSW_3G_P0_RX_DSCP_PRI_MAP_PRI7,</p>
<p>CPSW_3G_P_RX_DSCP_PRI_MAP_PRI0, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI1, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI2, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI3, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI4, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI5, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI6, CPSW_3G_P_RX_DSCP_PRI_MAP_PRI7</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32      rxDscpPriMap [64], portNum;

       portNum = 1;

       for (i = 0; i &lt; 64; i ++)
           port0TxPriMap [i] = i/8;

       CSL_CPSW_setPortRxDscpMap (portNum, rxDscpPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0a6c16122c7a870de42235103e05cfa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortRxDscpMap </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pRxDscpPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortRxDscpMap</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port DSCP to Priority Mapping Registers corresponding to the CPSW port specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the DSCP mapping 
                               registers must be configured.
       pRxDscpPriMap           Array of Port Rx DSCP to priority mapping values 
                               that must be configured to the registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 The input parameter 'pRxDscpPriMap' must be large enough to hold all the 64 priority values read from the register.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI0, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI1, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI2, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI3, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI4, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI5, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI6, XGE_CPSW_P0_RX_DSCP_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI0, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI1, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI2, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI3, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI4, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI5, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI6, XGE_CPSW_PN_RX_DSCP_MAP_REG_PRI7</p>
<pre class="fragment">@b Example
</pre> <pre class="fragment">*      Uint32      rxDscpPriMap [64], portNum;

       portNum = 1;
       
       for (i = 0; i &lt; 64; i ++)
           port0RxPriMap [i] = i/8;
       
       CSL_CPSW_setPortRxDscpMap (portNum, rxDscpPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga155b64a30cf1bd2a47cc179dccf3d1c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortRxMaxLen </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rxMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortRxMaxLen</b> </p>
<p><b>Description</b> <br />
 This function sets up the Port Receive Maximum length register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum             CPSW port number for which the Receive Maximum Length
                           must be retrieved.
       rxMaxLen            Maximum receive frame length to configure.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_RX_MAXLEN_REG_RX_MAXLEN XGE_CPSW_PN_RX_MAXLEN_REG_RX_MAXLEN</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum, rxMaxLen;

       portNum     =   1;
       rxMaxLen    =   1518;

       CSL_CPSW_setPortRxMaxLen (portNum, rxMaxLen);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac20dd9d4fc9e373dff0c03dcddffce4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortRxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortRxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortRxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the priority mapping
                               registers must be configured.
       pPortRxPriMap           Array of Port Rx priority map priority values
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_RX_PRI_MAP_REG_PRI0, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI1, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI2, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI3, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI4, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI5, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI6, XGE_CPSW_P0_RX_PRI_MAP_REG_PRI7,</p>
<p>XGE_CPSW_PN_RX_PRI_MAP_REG_PRI0, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI1, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI2, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI3, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI4, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI5, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI6, XGE_CPSW_PN_RX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum = 1;
*      Uint32      i, port0RxPriMap [8];

       for (i = 0; i &lt; 8; i ++)
           port0RxPriMap [i] = i;

       CSL_CPSW_setPortRxPriMapReg (port0RxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3454e75b24e3bad2f85ead36e1698e86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortStatsEnableReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *&#160;</td>
          <td class="paramname"><em>pPortStatsCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortStatsEnableReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Port Statistics Enable register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortStatsCfg       CSL_CPSW_PORTSTAT structure that contains the values
                           to be used to setup port statistics enable register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_STAT_PORT_EN_P0_STAT_EN, CPSW_3G_STAT_PORT_EN_P1_STAT_EN, CPSW_3G_STAT_PORT_EN_P2_STAT_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PORTSTAT       portStatsCfg;

       portStatsCfg.p0StatEnable   =   1;
       portStatsCfg.p1StatEnable   =   1;
       portStatsCfg.p2StatEnable   =   1;

       CSL_CPSW_setPortStatsEnableReg (&amp;portStatsCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga09e8bb4a20cde89179f52bdf2a98c80f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortStatsEnableReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_o_r_t_s_t_a_t.html">CSL_CPSW_PORTSTAT</a> *&#160;</td>
          <td class="paramname"><em>pPortStatsCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortStatsEnableReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW Port Statistics Enable register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pPortStatsCfg       CSL_CPSW_PORTSTAT structure that contains the values
                           to be used to setup port statistics enable register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_STAT_PORT_EN_REG_P0A_STAT_EN, CPSW_5GF_STAT_PORT_EN_REG_P0B_STAT_EN, CPSW_5GF_STAT_PORT_EN_REG_P1_STAT_EN, CPSW_5GF_STAT_PORT_EN_REG_P2_STAT_EN</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PORTSTAT       portStatsCfg;

       portStatsCfg.p0AStatEnable  =   1;
       portStatsCfg.p0BStatEnable  =   1;
       portStatsCfg.p1StatEnable   =   1;
       portStatsCfg.p2StatEnable   =   1;

       CSL_CPSW_setPortStatsEnableReg (&amp;portStatsCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga099b9532f5caa1dd049c88bb2117e55b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortTimeSyncCntlReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_n_t_l.html">CSL_CPSW_TSCNTL</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncCntlCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTimeSyncCntlReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time sync control register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be 
                               configured.
       pTimeSyncCntlCfg        CSL_CPSW_TSCNTL containing settings for time
                               sync control register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P_TS_CTL_REG_TS_RX_EN, CPSW_5GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, CPSW_5GF_P_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, CPSW_5GF_P_TS_CTL_REG_TS_TX_EN, CPSW_5GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, CPSW_5GF_P_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, CPSW_5GF_P_TS_CTL_REG_TX_MSG_TYPE_EN_15_0</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_TSCNTL     tsCtlCfg;

       portNum =   1;

       tsCtlCfg.tsRxEnable             =   1;
       tsCtlCfg.tsRxVlanLType1Enable   =   0;
       tsCtlCfg.tsRxVlanLType2Enable   =   0;
       ...

       CSL_CPSW_setPortTimeSyncCntlReg (portNum, &amp;tsCtlCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac7527cc88d372000b84663bc97fc21fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortTimeSyncConfig </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___t_s_c_o_n_f_i_g.html">CSL_CPSW_TSCONFIG</a> *&#160;</td>
          <td class="paramname"><em>pTimeSyncConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTimeSyncConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time sync control registers corresponding to the CPSW port number specified per user configuration.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the registers must be 
                               configured.
       pTimeSyncConfig         CSL_CPSW_TSCONFIG containing settings for time
                               sync control registers.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_F_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE1_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_VLAN_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_D_EN, XGE_CPSW_PN_TS_CTL_REG_TS_LTYPE2_EN, XGE_CPSW_PN_TS_CTL_REG_TS_RX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_ANNEX_E_EN, XGE_CPSW_PN_TS_CTL_REG_TS_TX_HOST_TS_EN, XGE_CPSW_PN_TS_CTL_REG_TS_MSG_TYPE_EN</p>
<p>XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_LTYPE1, XGE_CPSW_PN_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET,</p>
<p>XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, XGE_CPSW_PN_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2,</p>
<p>XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_LTYPE2, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_107, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_129, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_130, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_131, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_132, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_319, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_330, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_TTL_NONZERO, XGE_CPSW_PN_TS_CTL_LTYPE2_REG_TS_UNI_EN,</p>
<p>XGE_CPSW_PN_TS_CTL2_REG_TS_MCAST_TYPE_EN, XGE_CPSW_PN_TS_CTL2_REG_TS_DOMAIN_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum;
       CSL_CPSW_TSCONFIG   tsConfig;

       portNum =   1;

       tsConfig.tsRxVlanLType1Enable   =   0;
       tsConfig.tsRxVlanLType2Enable   =   0;
       ...

       CSL_CPSW_setPortTimeSyncConfig (portNum, &amp;tsConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8149489b2c3d0441e37be1b21bbf7b9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortTimeSyncSeqIdReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsLtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsSeqIdOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTimeSyncSeqIdReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time Sync Sequence Id and LTYPE register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be 
                               configured.
       tsLtype                 Time sync LTYPE to be configured.
       tsSeqIdOffset           Time sync sequence Id offset to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P_TS_SEQ_LTYPE_REG_TS_LTYPE, CPSW_5GF_P_TS_SEQ_LTYPE_REG_TS_SEQ_ID_OFFSET</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype, tsSeqIdOffset;

       portNum         =   1;
       tsLtype         =   0;
       tsSeqIdOffset   =   30;

       CSL_CPSW_getPortTimeSyncSeqIdReg (portNum, tsLtype, tsSeqIdOffset);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga17421dc8d8b8afeb092ee302191946d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortTimeSyncVlanLTypeReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsVlanLtype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>tsVlanLtype2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTimeSyncVlanLTypeReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of Time Sync VLAN LTYPE register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register must be read.
       tsVlanLtype1            Time sync VLAN LTYPE1 value to be configured.
       tsVlanLtype2            Time sync VLAN LTYPE2 value to be configured.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE1, CPSW_5GF_P_TS_VLAN_LTYPE_REG_TS_VLAN_LTYPE2</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32              portNum, tsLtype1, tsLtype2;

       portNum     =   1;
       tsLtype1    =   0x8100;
       tsLtype2    =   0x8100;

       CSL_CPSW_setPortTimeSyncVlanLTypeReg (portNum, &amp;tsLtype1, &amp;tsLtype2);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacdd0bce13bd36bd7f4fd2258ac6e9084"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortTxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Receive Packet Priority to Header Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the priority mapping
                               registers must be configured.
       pPortTxPriMap           Array of Port Rx priority map priority values
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_P0_TX_PRI_MAP_PRI0, CPSW_3G_P0_TX_PRI_MAP_PRI1, CPSW_3G_P0_TX_PRI_MAP_PRI2, CPSW_3G_P0_TX_PRI_MAP_PRI3, CPSW_3G_P0_TX_PRI_MAP_PRI4, CPSW_3G_P0_TX_PRI_MAP_PRI5, CPSW_3G_P0_TX_PRI_MAP_PRI6, CPSW_3G_P0_TX_PRI_MAP_PRI7,</p>
<p>CPSW_3G_P_TX_PRI_MAP_PRI0, CPSW_3G_P_TX_PRI_MAP_PRI1, CPSW_3G_P_TX_PRI_MAP_PRI2, CPSW_3G_P_TX_PRI_MAP_PRI3, CPSW_3G_P_TX_PRI_MAP_PRI4, CPSW_3G_P_TX_PRI_MAP_PRI5, CPSW_3G_P_TX_PRI_MAP_PRI6, CPSW_3G_P_TX_PRI_MAP_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portNum = 1;
*      Uint32      i, port0TxPriMap [8];

       for (i = 0; i &lt; 8; i ++)
           port0TxPriMap [i] = i;

       CSL_CPSW_setPortTxPriMapReg (port0TxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac8efb80f1cfcc76f6fb224f479c0fee7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortTxPriMapReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPortTxPriMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortTxPriMapReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Port Transmit Header Priority to Switch Priority Mapping Register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the register contents
                               must be configured.
       pPortTxPriMap           Array of Port Tx priority map priority values 
                               that must be configured to the register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P_TX_PRI_MAP_REG_PRI0, CPSW_5GF_P_TX_PRI_MAP_REG_PRI1, CPSW_5GF_P_TX_PRI_MAP_REG_PRI2, CPSW_5GF_P_TX_PRI_MAP_REG_PRI3, CPSW_5GF_P_TX_PRI_MAP_REG_PRI4, CPSW_5GF_P_TX_PRI_MAP_REG_PRI5, CPSW_5GF_P_TX_PRI_MAP_REG_PRI6, CPSW_5GF_P_TX_PRI_MAP_REG_PRI7</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      i, portTxPriMap [8], portNum;

       for (i = 0; i &lt; 8; i ++)
           portTxPriMap [i] = i;

       portNum =   1;            

       CSL_CPSW_setPortTxPriMapReg (portNum, portTxPriMap);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga51ce29809fda9cb894170687b4e82327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortVlanReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortVlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the VLAN Register corresponding to the MAC port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 MAC port number for which the VLAN register 
                               must be configured.
       portVID                 Port VLAN Id to be configured
       portCFI                 Port CFI bit to be configured
       portPRI                 Port VLAN priority to be configured
                               (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_P_PORT_VLAN_REG_PORT_VID, CPSW_5GF_P_PORT_VLAN_REG_PORT_CFI, CPSW_5GF_P_PORT_VLAN_REG_PORT_PRI</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI, portNum;
   
       portNum     =   2;
       portVID     =   1;
       portCFI     =   0;
       portPRI     =   7;

       CSL_CPSW_setPortVlanReg (portNum, portVID, portCFI, portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga34074987ab53ecbc87d27a056f31740c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPortVlanReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portVID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portCFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>portPRI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPortVlanReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the VLAN Register corresponding to the CPSW port number specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       portNum                 CPSW port number for which the VLAN register
                               must be configured.
       portVID                 Port VLAN Id to be configured
       portCFI                 Port CFI bit to be configured
       portPRI                 Port VLAN priority to be configured
                               (0-7, 7 is highest priority)
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_P0_PORT_VLAN_PORT_VID, CPSW_3G_P0_PORT_VLAN_PORT_CFI, CPSW_3G_P0_PORT_VLAN_PORT_PRI,</p>
<p>CPSW_3G_P_PORT_VLAN_PORT_VID, CPSW_3G_P_PORT_VLAN_PORT_CFI, CPSW_3G_P_PORT_VLAN_PORT_PRI,</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      portVID, portCFI, portPRI, portNum;

       portNum     =   1;
       portVID     =   1;
       portCFI     =   0;
       portPRI     =   7;

       CSL_CPSW_setPortVlanReg (portNum, portVID, portCFI, portPRI);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7acb225864ffa1f4118c68b8dbae2c23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPrioTypeReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *&#160;</td>
          <td class="paramname"><em>pTypeCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPrioTypeReg</b> </p>
<p><b>Description</b> <br />
 This function modifies the contents of the CPSW Priority Type register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTypeCfg            CSL_CPSW_PTYPE structure that contains the values that
                           need to be populated to Priority type register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_PTYPE_ESC_PRI_LD_VAL, CPSW_3G_PTYPE_P0_PTYPE_ESC, CPSW_3G_PTYPE_P1_PTYPE_ESC, CPSW_3G_PTYPE_P2_PTYPE_ESC</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PTYPE       pTypeCfg;

       pTypeCfg.escPriLdVal    =   1;
       pTypeCfg.p0PtypeEsc     =   1;
       ...

       CSL_CPSW_setPrioTypeReg (&amp;pTypeCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4497889171427a1931f1f47befaf1bd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setPrioTypeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___p_t_y_p_e.html">CSL_CPSW_PTYPE</a> *&#160;</td>
          <td class="paramname"><em>pTypeCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setPrioTypeReg</b> </p>
<p><b>Description</b> <br />
 This function modifies the contents of the CPSW Priority Type register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pTypeCfg            CSL_CPSW_PTYPE structure that contains the values that
                           need to be populated to Priority type register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_PTYPE_REG_ESC_PRI_LD_VAL, CPSW_5GF_PTYPE_REG_P0_PTYPE_ESC, CPSW_5GF_PTYPE_REG_P1_PTYPE_ESC, CPSW_5GF_PTYPE_REG_P2_PTYPE_ESC</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_PTYPE       pTypeCfg;

       pTypeCfg.escPriLdVal    =   1;
       pTypeCfg.p0PtypeEsc     =   1;
       ...

       CSL_CPSW_setPrioTypeReg (&amp;pTypeCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga03f1baa8dfa1c981b63d5a69d8b6a235"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setRxRLimConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___c_p_s_w___r_x___r_a_t_e___l_i_m_i_t___c_o_n_f_i_g.html">CSL_CPSW_RX_RATE_LIMIT_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pRLimConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setRxRLimConfig</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPPI Port Rx Rate Limitaion registers per user-specified Rate Limitation Configuration</p>
<p><b>Arguments</b> </p><pre class="fragment">       pRLimConfig*            CSL_CPSW_RX_RATE_LIMIT_CONFIG structure that needs to 
                               be configured to the rate limitaion register contents.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 none</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 XGE_CPSW_P0_PRI_CTL_REG_RX_RLIM, XGE_CPSW_P0_PRI_SEND_REG_COUNT, XGE_CPSW_P0_PRI_IDLE_REG_COUNT</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_CPSW_RX_RATE_LIMIT_CONFIG       rLimConfig;
       
       rLimConfig.numRLimChans = 2;
       
       rLimConfig.sendStep[7] = 10;
       rLimConfig.sendStep[6] = 10;
       
       rLimConfig.idleStep[7] = 20;
       rLimConfig.idleStep[6] = 20;

       CSL_CPSW_setRxRLimConfig (&amp;rLimConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae5d2b6864e7271448d1a7d8cb4f7a39c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setShortGapThreshold </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>gapThreshVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setShortGapThreshold</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the CPSW MAC Short Gap Threshold register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       gapThreshVal        Gap threshold value to use to configure the MAC Short
                           gap threshold value.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_GAP_THRESH_CPGMAC_SL_REG_GAP_THRESH</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          gapThreshVal;
*
*      gapThreshVal    =   11;

       CSL_CPSW_setShortGapThreshold (gapThreshVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae76296aa6eb87a2c3be0bc21df95ca14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setTxStartWordsReg </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>startWordsVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setTxStartWordsReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Transmit FIFO start words register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pStartWordsVal      Start words value to be set to the Transmit FIFO start
                           words register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_TX_START_WDS_TX_START_WDS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          startWordsVal;
*
*      startWordsVal   =   32;

       CSL_CPSW_setTxStartWordsReg (startWordsVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga591dbfa1c9b824e7155783692ed94410"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_setTxStartWordsReg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>startWordsVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_setTxStartWordsReg</b> </p>
<p><b>Description</b> <br />
 This function sets up the contents of the Transmit FIFO start words register.</p>
<p><b>Arguments</b> </p><pre class="fragment">       pStartWordsVal      Start words value to be set to the Transmit FIFO start
                           words register.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_TX_START_WDS_REG_TX_START_WDS</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32          startWordsVal;
*
*      startWordsVal   =   32;

       CSL_CPSW_setTxStartWordsReg (startWordsVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac3a9ba1dbdadc3982c3145b89774a6f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_startAleAgeOutNow </td>
          <td>(</td>
          <td class="paramtype">CSL_cpswHandle&#160;</td>
          <td class="paramname"><em>hCpswRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_startAleAgeOutNow</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to initiate an ALE ageable entry cleanup. This enables the ALE hardware to remove any ageable table entry that does not have a set touch bit.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_3G_CONTROL_AGE_OUT_NOW=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_startAleAgeOutNow ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga70e3eaea7d750a74cc90cd9f4df9c88f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_CPSW_startAleAgeOutNow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_CPSW_startAleAgeOutNow</b> </p>
<p><b>Description</b> <br />
 This function configures the ALE control register to initiate an ALE ageable entry cleanup. This enables the ALE hardware to remove any ageable table entry that does not have a set touch bit.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 CPSW_5GF_ALE_CONTROL_REG_AGE_OUT_NOW=1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_CPSW_startAleAgeOutNow ();</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
