<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ICFG</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ICFG<div class="ingroups"><a class="el" href="group___c_s_l___a_r_c_h.html">CSL ARCH Module</a> &raquo; <a class="el" href="group___c_s_l___a_r_c_h___c66_x.html">C66x</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:dsp__icfg_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dsp__icfg_8h.html">dsp_icfg.h</a></td></tr>
<tr class="memdesc:dsp__icfg_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains the prototypes of the APIs present in the device abstraction layer file of ICFG in the C66x DSP subsytems. This also include related macro definitions. All APIs should be called with interrupts disabled to ensure coherency. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa5a3d58bcf0e90bc8eb16dfd20557aad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5a3d58bcf0e90bc8eb16dfd20557aad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaa5a3d58bcf0e90bc8eb16dfd20557aad">DSPICFG_L1P_PGSZ</a>&#160;&#160;&#160;(2048U)</td></tr>
<tr class="memdesc:gaa5a3d58bcf0e90bc8eb16dfd20557aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page size for L1P memory protection. <br /></td></tr>
<tr class="separator:gaa5a3d58bcf0e90bc8eb16dfd20557aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af4ab8dba97c9fd6fb970e9530ab290"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7af4ab8dba97c9fd6fb970e9530ab290"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga7af4ab8dba97c9fd6fb970e9530ab290">DSPICFG_L1D_PGSZ</a>&#160;&#160;&#160;(2048U)</td></tr>
<tr class="memdesc:ga7af4ab8dba97c9fd6fb970e9530ab290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page size for L1D memory protection. <br /></td></tr>
<tr class="separator:ga7af4ab8dba97c9fd6fb970e9530ab290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d677e0e343484ea56c7919638fe288a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2d677e0e343484ea56c7919638fe288a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga2d677e0e343484ea56c7919638fe288a">DSPICFG_L2_PGSZ</a>&#160;&#160;&#160;(16U * 1024U)</td></tr>
<tr class="memdesc:ga2d677e0e343484ea56c7919638fe288a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page size for L2 memory protection. <br /></td></tr>
<tr class="separator:ga2d677e0e343484ea56c7919638fe288a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44e9bf3be6c7f647bc0b464e0519052"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae44e9bf3be6c7f647bc0b464e0519052"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae44e9bf3be6c7f647bc0b464e0519052">MAR_SECTION_SZ</a>&#160;&#160;&#160;(16U * 1024U * 1024U)</td></tr>
<tr class="memdesc:gae44e9bf3be6c7f647bc0b464e0519052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page size for MAR registers. <br /></td></tr>
<tr class="separator:gae44e9bf3be6c7f647bc0b464e0519052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160d2a5dac0764f3f4ea2d5e137345da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga160d2a5dac0764f3f4ea2d5e137345da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga160d2a5dac0764f3f4ea2d5e137345da">DSP_MAR_PCX_SHIFT</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:ga160d2a5dac0764f3f4ea2d5e137345da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-Fields missing in <a class="el" href="hw__dsp__icfg_8h.html" title="register-level header file for DSP ">hw_dsp_icfg.h</a>. <br /></td></tr>
<tr class="separator:ga160d2a5dac0764f3f4ea2d5e137345da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5fd474b8fcce98584e847429a4cff4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5fd474b8fcce98584e847429a4cff4b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae5fd474b8fcce98584e847429a4cff4b">DSPICFG_L1P_CACHE_LINE_SIZE</a>&#160;&#160;&#160;(32U)</td></tr>
<tr class="memdesc:gae5fd474b8fcce98584e847429a4cff4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1P Cache Line Size. <br /></td></tr>
<tr class="separator:gae5fd474b8fcce98584e847429a4cff4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb8095e7d059358ac50cd71962c2bee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacdb8095e7d059358ac50cd71962c2bee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gacdb8095e7d059358ac50cd71962c2bee">DSPICFG_L1D_CACHE_LINE_SIZE</a>&#160;&#160;&#160;(64U)</td></tr>
<tr class="memdesc:gacdb8095e7d059358ac50cd71962c2bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1D Cache Line Size. <br /></td></tr>
<tr class="separator:gacdb8095e7d059358ac50cd71962c2bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ed3c65bd46ec09497bc53b83ff8798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8ed3c65bd46ec09497bc53b83ff8798"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gad8ed3c65bd46ec09497bc53b83ff8798">DSPICFG_L2_CACHE_LINE_SIZE</a>&#160;&#160;&#160;(128U)</td></tr>
<tr class="memdesc:gad8ed3c65bd46ec09497bc53b83ff8798"><td class="mdescLeft">&#160;</td><td class="mdescRight">L2 Cache Line Size. <br /></td></tr>
<tr class="separator:gad8ed3c65bd46ec09497bc53b83ff8798"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae6c67e62618ae746be667e49a9f8d1c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6c67e62618ae746be667e49a9f8d1c0"></a>
typedef enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae15fd6129a9303ed2fa3c17ff4f4ba12">dspicfgMARAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae6c67e62618ae746be667e49a9f8d1c0">dspicfgMARAttribute_t</a></td></tr>
<tr class="memdesc:gae6c67e62618ae746be667e49a9f8d1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to create mask for MAR attributes. Refer to device specific documents to check if PCX and WTE are available. <br /></td></tr>
<tr class="separator:gae6c67e62618ae746be667e49a9f8d1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac51b6be3ca4329824738076c71c2b966"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac51b6be3ca4329824738076c71c2b966"></a>
typedef enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga91d9e1f395590f75419b8602b9766e65">dspicfgL2Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gac51b6be3ca4329824738076c71c2b966">dspicfgL2Attribute_t</a></td></tr>
<tr class="memdesc:gac51b6be3ca4329824738076c71c2b966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to create mask for L2MPPA (L2 memory protection attributes) registers for DSP L1P/L1D/L2 Memory . <br /></td></tr>
<tr class="separator:gac51b6be3ca4329824738076c71c2b966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b1ce0cf9f6cf353242848b2c534272"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae0b1ce0cf9f6cf353242848b2c534272"></a>
typedef enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaad2790ee320548d0f8a5e7da60fdddd2">dspicfgMemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae0b1ce0cf9f6cf353242848b2c534272">dspicfgMemType_t</a></td></tr>
<tr class="memdesc:gae0b1ce0cf9f6cf353242848b2c534272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify cache type in cache APIs provided in the file. <br /></td></tr>
<tr class="separator:gae0b1ce0cf9f6cf353242848b2c534272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2609613094e89637de4994b7bc7d02c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2609613094e89637de4994b7bc7d02c0"></a>
typedef enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga4c04a860aefe2d400cac75b413992ea5">dspicfgCacheSizeL1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga2609613094e89637de4994b7bc7d02c0">dspicfgCacheSizeL1_t</a></td></tr>
<tr class="memdesc:ga2609613094e89637de4994b7bc7d02c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify L1 cache size in cache APIs provided in the file. <br /></td></tr>
<tr class="separator:ga2609613094e89637de4994b7bc7d02c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661ba162ff35750fb7172248d89fa967"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga661ba162ff35750fb7172248d89fa967"></a>
typedef enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga26facbf96f9c7770b17085bc0486637b">dspicfgCacheSizeL2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga661ba162ff35750fb7172248d89fa967">dspicfgCacheSizeL2_t</a></td></tr>
<tr class="memdesc:ga661ba162ff35750fb7172248d89fa967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify L2 cache size in cache APIs provided in the file. If the devices L2 memory is less than the specified value, all L2 memory will be used as cache. eg: Using DSPICFG_CACHE_SIZE_L2_1024K in TDA2x will be same as using DSPICFG_CACHE_SIZE_L2_256K or DSPICFG_CACHE_SIZE_L2_512K or DSPICFG_CACHE_SIZE_L2_MAX since total L2 memory is 256kiB. <br /></td></tr>
<tr class="separator:ga661ba162ff35750fb7172248d89fa967"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae15fd6129a9303ed2fa3c17ff4f4ba12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae15fd6129a9303ed2fa3c17ff4f4ba12">dspicfgMARAttribute</a> { <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ggae15fd6129a9303ed2fa3c17ff4f4ba12aadbf5db5a28e2f903950b0f4d5b3694d">DSPICFG_MAR_PC</a> = DSP_MAR_PC_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ggae15fd6129a9303ed2fa3c17ff4f4ba12a24eb6773f2906c265909537bfc644b7f">DSPICFG_MAR_WTE</a> = DSP_MAR_WTE_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ggae15fd6129a9303ed2fa3c17ff4f4ba12a76931c29dc1833a9e5fe9afe9d4c7d0f">DSPICFG_MAR_PCX</a> = DSP_MAR_PCX_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ggae15fd6129a9303ed2fa3c17ff4f4ba12a8a9233fbdd80f35e87a94f65f3b239de">DSPICFG_MAR_PFX</a> = DSP_MAR_PFX_MASK
 }</td></tr>
<tr class="memdesc:gae15fd6129a9303ed2fa3c17ff4f4ba12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to create mask for MAR attributes. Refer to device specific documents to check if PCX and WTE are available.  <a href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae15fd6129a9303ed2fa3c17ff4f4ba12">More...</a><br /></td></tr>
<tr class="separator:gae15fd6129a9303ed2fa3c17ff4f4ba12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d9e1f395590f75419b8602b9766e65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga91d9e1f395590f75419b8602b9766e65">dspicfgL2Attribute</a> { <br />
&#160;&#160;<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a1d00730b56dbe5c5ae430285275aac7f">DSPICFG_L2MPPA_LOCAL</a> = DSP_L2MPPA_LOCAL_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65afef351c4e326f081e4c660386905711b">DSPICFG_L2MPPA_SR</a> = DSP_L2MPPA_SR_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a7af2a95fdba2a223005fafe1f5992f14">DSPICFG_L2MPPA_SW</a> = DSP_L2MPPA_SW_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a1549984c0517b523a6f1fb15028613c0">DSPICFG_L2MPPA_SX</a> = DSP_L2MPPA_SX_MASK, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a27304e32d52cec955f4f26807c1ddffe">DSPICFG_L2MPPA_UR</a> = DSP_L2MPPA_UR_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a81cb955e48b1d4a02c5ae19afb196ee0">DSPICFG_L2MPPA_UW</a> = DSP_L2MPPA_UW_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65adc1582af54340c8fa7ad4d696589d329">DSPICFG_L2MPPA_UX</a> = DSP_L2MPPA_UX_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65abeafcf4e5d1a89298e834cb46a976689">DSPICFG_L2MPPA_AID_0</a> = DSP_L2MPPA_AID0_MASK, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65af29aec4a011748f9c4e0318fe66a2b55">DSPICFG_L2MPPA_AID_1</a> = DSP_L2MPPA_AID1_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a80e076958673e1346c3527f356bef9bc">DSPICFG_L2MPPA_AID_2</a> = DSP_L2MPPA_AID2_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a6d5bad84d499df84b71010a3ab1f1f15">DSPICFG_L2MPPA_AID_3</a> = DSP_L2MPPA_AID3_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65aa13efaeae244e1ff08d72f53aa2e12d7">DSPICFG_L2MPPA_AID_4</a> = DSP_L2MPPA_AID4_MASK, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a25a8bf6f2d20a6ae891ae085f8f1f228">DSPICFG_L2MPPA_AID_5</a> = DSP_L2MPPA_AID5_MASK, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gga91d9e1f395590f75419b8602b9766e65a6fc0f1fcbbe8dec8718b1f266ee637d8">DSPICFG_L2MPPA_AID_X</a> = DSP_L2MPPA_AIDX_MASK
<br />
 }</td></tr>
<tr class="memdesc:ga91d9e1f395590f75419b8602b9766e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to create mask for L2MPPA (L2 memory protection attributes) registers for DSP L1P/L1D/L2 Memory .  <a href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga91d9e1f395590f75419b8602b9766e65">More...</a><br /></td></tr>
<tr class="separator:ga91d9e1f395590f75419b8602b9766e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad2790ee320548d0f8a5e7da60fdddd2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaad2790ee320548d0f8a5e7da60fdddd2">dspicfgMemType</a> { <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ggaad2790ee320548d0f8a5e7da60fdddd2a3a0fca2e257f0271b6e736142562bf25">DSPICFG_MEM_L1D</a>, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ggaad2790ee320548d0f8a5e7da60fdddd2a85a5f2c7a17789205b211550435f3c80">DSPICFG_MEM_L1P</a>, 
<a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ggaad2790ee320548d0f8a5e7da60fdddd2afaf472ea5010cba98032e4c78e06db15">DSPICFG_MEM_L2</a>
 }</td></tr>
<tr class="memdesc:gaad2790ee320548d0f8a5e7da60fdddd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify cache type in cache APIs provided in the file.  <a href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaad2790ee320548d0f8a5e7da60fdddd2">More...</a><br /></td></tr>
<tr class="separator:gaad2790ee320548d0f8a5e7da60fdddd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c04a860aefe2d400cac75b413992ea5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c04a860aefe2d400cac75b413992ea5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga4c04a860aefe2d400cac75b413992ea5">dspicfgCacheSizeL1</a> </td></tr>
<tr class="memdesc:ga4c04a860aefe2d400cac75b413992ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify L1 cache size in cache APIs provided in the file. <br /></td></tr>
<tr class="separator:ga4c04a860aefe2d400cac75b413992ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26facbf96f9c7770b17085bc0486637b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga26facbf96f9c7770b17085bc0486637b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga26facbf96f9c7770b17085bc0486637b">dspicfgCacheSizeL2</a> </td></tr>
<tr class="memdesc:ga26facbf96f9c7770b17085bc0486637b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify L2 cache size in cache APIs provided in the file. If the devices L2 memory is less than the specified value, all L2 memory will be used as cache. eg: Using DSPICFG_CACHE_SIZE_L2_1024K in TDA2x will be same as using DSPICFG_CACHE_SIZE_L2_256K or DSPICFG_CACHE_SIZE_L2_512K or DSPICFG_CACHE_SIZE_L2_MAX since total L2 memory is 256kiB. <br /></td></tr>
<tr class="separator:ga26facbf96f9c7770b17085bc0486637b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9019b6282df39dcfff058b2f547fe4b6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga9019b6282df39dcfff058b2f547fe4b6">DSPICFGSetAttribute</a> (uint32_t baseAddr, uint32_t memType, uint32_t pageAddr, uint32_t attributeMask)</td></tr>
<tr class="memdesc:ga9019b6282df39dcfff058b2f547fe4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set memory protection attributes for specified L1/L2 memory page. Should be called in supervisor mode only.  <a href="#ga9019b6282df39dcfff058b2f547fe4b6">More...</a><br /></td></tr>
<tr class="separator:ga9019b6282df39dcfff058b2f547fe4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1f194e19e1a1c260c6a7564e45f069"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaaf1f194e19e1a1c260c6a7564e45f069">DSPICFGGetAttribute</a> (uint32_t baseAddr, uint32_t memType, uint32_t pageAddr)</td></tr>
<tr class="memdesc:gaaf1f194e19e1a1c260c6a7564e45f069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory protection attributes for specified L1/L2 memory page.  <a href="#gaaf1f194e19e1a1c260c6a7564e45f069">More...</a><br /></td></tr>
<tr class="separator:gaaf1f194e19e1a1c260c6a7564e45f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7138b605c38e399f4f9daf751fab8b24"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga7138b605c38e399f4f9daf751fab8b24">DSPICFGSetMAR</a> (uint32_t baseAddr, uint32_t startAddr, uint32_t attributeMask)</td></tr>
<tr class="memdesc:ga7138b605c38e399f4f9daf751fab8b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the Memory Attribute Register in DSP for the 16MiB page specified by startAddr. Should be called in supervisor mode only.  <a href="#ga7138b605c38e399f4f9daf751fab8b24">More...</a><br /></td></tr>
<tr class="separator:ga7138b605c38e399f4f9daf751fab8b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2eb62fdd3d9771b56cc73873b1b2881"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gab2eb62fdd3d9771b56cc73873b1b2881">DSPICFGGetMAR</a> (uint32_t baseAddr, uint32_t startAddr)</td></tr>
<tr class="memdesc:gab2eb62fdd3d9771b56cc73873b1b2881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Memory Attribute Register in DSP for the 16MiB page specified by startAddr.  <a href="#gab2eb62fdd3d9771b56cc73873b1b2881">More...</a><br /></td></tr>
<tr class="separator:gab2eb62fdd3d9771b56cc73873b1b2881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf880c90eea69c51c76d413eed5b9914"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaaf880c90eea69c51c76d413eed5b9914">DSPICFGCacheEnable</a> (uint32_t baseAddr, uint32_t cacheType, uint32_t size)</td></tr>
<tr class="memdesc:gaaf880c90eea69c51c76d413eed5b9914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable specified cache.  <a href="#gaaf880c90eea69c51c76d413eed5b9914">More...</a><br /></td></tr>
<tr class="separator:gaaf880c90eea69c51c76d413eed5b9914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a9f82f92729c925613bb2f60505462"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga15a9f82f92729c925613bb2f60505462">DSPICFGCacheWriteBackAll</a> (uint32_t baseAddr, uint32_t cacheType)</td></tr>
<tr class="memdesc:ga15a9f82f92729c925613bb2f60505462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-back all cache specified by cacheType.  <a href="#ga15a9f82f92729c925613bb2f60505462">More...</a><br /></td></tr>
<tr class="separator:ga15a9f82f92729c925613bb2f60505462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga226a0a1c50b9181d92150fa6aa974497"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga226a0a1c50b9181d92150fa6aa974497">DSPICFGCacheInvalidateAll</a> (uint32_t baseAddr, uint32_t cacheType)</td></tr>
<tr class="memdesc:ga226a0a1c50b9181d92150fa6aa974497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate all cache specified by cacheType.  <a href="#ga226a0a1c50b9181d92150fa6aa974497">More...</a><br /></td></tr>
<tr class="separator:ga226a0a1c50b9181d92150fa6aa974497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03999b3b0a64c880316c2d32f0c72875"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga03999b3b0a64c880316c2d32f0c72875">DSPICFGCacheWriteBackInvalidateAll</a> (uint32_t baseAddr, uint32_t cacheType)</td></tr>
<tr class="memdesc:ga03999b3b0a64c880316c2d32f0c72875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-back and invalidate all cache specified by cacheType.  <a href="#ga03999b3b0a64c880316c2d32f0c72875">More...</a><br /></td></tr>
<tr class="separator:ga03999b3b0a64c880316c2d32f0c72875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e2306040a7d7ec88db535380322141"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gab8e2306040a7d7ec88db535380322141">DSPICFGCacheWriteBack</a> (uint32_t baseAddr, uint32_t startAddr, uint32_t numBytes)</td></tr>
<tr class="memdesc:gab8e2306040a7d7ec88db535380322141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-back all cache as per input range specified by startAddr and numBytes.  <a href="#gab8e2306040a7d7ec88db535380322141">More...</a><br /></td></tr>
<tr class="separator:gab8e2306040a7d7ec88db535380322141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae7fe91b4f5d9b38c512cda44d32f28"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga1ae7fe91b4f5d9b38c512cda44d32f28">DSPICFGCacheInvalidate</a> (uint32_t baseAddr, uint32_t startAddr, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga1ae7fe91b4f5d9b38c512cda44d32f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate all cache as per input range specified by startAddr and numBytes.  <a href="#ga1ae7fe91b4f5d9b38c512cda44d32f28">More...</a><br /></td></tr>
<tr class="separator:ga1ae7fe91b4f5d9b38c512cda44d32f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37039dcf052ebca440398d6d592a389c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga37039dcf052ebca440398d6d592a389c">DSPICFGCacheWriteBackInvalidate</a> (uint32_t baseAddr, uint32_t startAddr, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga37039dcf052ebca440398d6d592a389c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-back and Invalidate all cache as per input range specified by startAddr and numBytes.  <a href="#ga37039dcf052ebca440398d6d592a389c">More...</a><br /></td></tr>
<tr class="separator:ga37039dcf052ebca440398d6d592a389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8669cac09f64e5427b080fd18a2b81fd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga8669cac09f64e5427b080fd18a2b81fd">DSPICFGMemoryProtectionLock</a> (uint32_t baseAddr, uint32_t key0, uint32_t key1, uint32_t key2, uint32_t key3)</td></tr>
<tr class="memdesc:ga8669cac09f64e5427b080fd18a2b81fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock Memory Protection registers for Memory Protection Unit and XMC.  <a href="#ga8669cac09f64e5427b080fd18a2b81fd">More...</a><br /></td></tr>
<tr class="separator:ga8669cac09f64e5427b080fd18a2b81fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87924bc0d059951ac6d928648cba3ff"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaf87924bc0d059951ac6d928648cba3ff">DSPICFGMemoryProtectionUnlock</a> (uint32_t baseAddr, uint32_t key0, uint32_t key1, uint32_t key2, uint32_t key3)</td></tr>
<tr class="memdesc:gaf87924bc0d059951ac6d928648cba3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock Memory Protection registers for Memory Protection Unit and XMC.  <a href="#gaf87924bc0d059951ac6d928648cba3ff">More...</a><br /></td></tr>
<tr class="separator:gaf87924bc0d059951ac6d928648cba3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf88f9ab828ca5e3f1e94afe542d90201"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaf88f9ab828ca5e3f1e94afe542d90201">DSPICFGClearMdmaErrEvt</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:gaf88f9ab828ca5e3f1e94afe542d90201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the MDMA Error Event register.  <a href="#gaf88f9ab828ca5e3f1e94afe542d90201">More...</a><br /></td></tr>
<tr class="separator:gaf88f9ab828ca5e3f1e94afe542d90201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffca59cf123321c38258fe902c57676b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaffca59cf123321c38258fe902c57676b">DSPICFGGetL2MPUFaultAddr</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:gaffca59cf123321c38258fe902c57676b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fault location as reported by L2 MPU.  <a href="#gaffca59cf123321c38258fe902c57676b">More...</a><br /></td></tr>
<tr class="separator:gaffca59cf123321c38258fe902c57676b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24af1f245e67013db1b0fbc9791ed06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaa24af1f245e67013db1b0fbc9791ed06">DSPICFGGetL2MPUFaultStatus</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:gaa24af1f245e67013db1b0fbc9791ed06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fault status as reported by L2 MPU.  <a href="#gaa24af1f245e67013db1b0fbc9791ed06">More...</a><br /></td></tr>
<tr class="separator:gaa24af1f245e67013db1b0fbc9791ed06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4840587ff6a81fa2473a951137b1ea3d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga4840587ff6a81fa2473a951137b1ea3d">DSPICFGClearL2MPUFaultRegs</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:ga4840587ff6a81fa2473a951137b1ea3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the fault registers for location and status in the L2 MPU.  <a href="#ga4840587ff6a81fa2473a951137b1ea3d">More...</a><br /></td></tr>
<tr class="separator:ga4840587ff6a81fa2473a951137b1ea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7472b715dad9379507238a2ff5db4810"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga7472b715dad9379507238a2ff5db4810">DSPICFGGetL1DMPUFaultAddr</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:ga7472b715dad9379507238a2ff5db4810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fault location as reported by L1D MPU.  <a href="#ga7472b715dad9379507238a2ff5db4810">More...</a><br /></td></tr>
<tr class="separator:ga7472b715dad9379507238a2ff5db4810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad74a33eb45d932bb0ca657075b7aa0eb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gad74a33eb45d932bb0ca657075b7aa0eb">DSPICFGGetL1DMPUFaultStatus</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:gad74a33eb45d932bb0ca657075b7aa0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fault status as reported by L1D MPU.  <a href="#gad74a33eb45d932bb0ca657075b7aa0eb">More...</a><br /></td></tr>
<tr class="separator:gad74a33eb45d932bb0ca657075b7aa0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga730875797a1ea1f642bba7129d267645"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga730875797a1ea1f642bba7129d267645">DSPICFGClearL1DMPUFaultRegs</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:ga730875797a1ea1f642bba7129d267645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the fault registers for location and status in the L1D MPU.  <a href="#ga730875797a1ea1f642bba7129d267645">More...</a><br /></td></tr>
<tr class="separator:ga730875797a1ea1f642bba7129d267645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9821667809c868ebf1a9f90ad0958454"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga9821667809c868ebf1a9f90ad0958454">DSPICFGGetL1PMPUFaultAddr</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:ga9821667809c868ebf1a9f90ad0958454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fault location as reported by L1P MPU.  <a href="#ga9821667809c868ebf1a9f90ad0958454">More...</a><br /></td></tr>
<tr class="separator:ga9821667809c868ebf1a9f90ad0958454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga483de660279c24b2784c7b867d4a2e22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga483de660279c24b2784c7b867d4a2e22">DSPICFGGetL1PMPUFaultStatus</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:ga483de660279c24b2784c7b867d4a2e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fault status as reported by L1P MPU.  <a href="#ga483de660279c24b2784c7b867d4a2e22">More...</a><br /></td></tr>
<tr class="separator:ga483de660279c24b2784c7b867d4a2e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea4a6a02418a97c2b891ae255405a7e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaaea4a6a02418a97c2b891ae255405a7e">DSPICFGClearL1PMPUFaultRegs</a> (uint32_t baseAddress)</td></tr>
<tr class="memdesc:gaaea4a6a02418a97c2b891ae255405a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the fault registers for location and status in the L1P MPU.  <a href="#gaaea4a6a02418a97c2b891ae255405a7e">More...</a><br /></td></tr>
<tr class="separator:gaaea4a6a02418a97c2b891ae255405a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga91d9e1f395590f75419b8602b9766e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga91d9e1f395590f75419b8602b9766e65">dspicfgL2Attribute</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to create mask for L2MPPA (L2 memory protection attributes) registers for DSP L1P/L1D/L2 Memory . </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a1d00730b56dbe5c5ae430285275aac7f"></a>DSPICFG_L2MPPA_LOCAL&#160;</td><td class="fielddoc">
<p>Enable bit for Local DSP access to L1/L2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65afef351c4e326f081e4c660386905711b"></a>DSPICFG_L2MPPA_SR&#160;</td><td class="fielddoc">
<p>Enable bit Supervisor mode Read access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a7af2a95fdba2a223005fafe1f5992f14"></a>DSPICFG_L2MPPA_SW&#160;</td><td class="fielddoc">
<p>Enable bit Supervisor mode Write access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a1549984c0517b523a6f1fb15028613c0"></a>DSPICFG_L2MPPA_SX&#160;</td><td class="fielddoc">
<p>Enable bit Supervisor mode Execute access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a27304e32d52cec955f4f26807c1ddffe"></a>DSPICFG_L2MPPA_UR&#160;</td><td class="fielddoc">
<p>Enable bit User mode Read access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a81cb955e48b1d4a02c5ae19afb196ee0"></a>DSPICFG_L2MPPA_UW&#160;</td><td class="fielddoc">
<p>Enable bit User mode Write access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65adc1582af54340c8fa7ad4d696589d329"></a>DSPICFG_L2MPPA_UX&#160;</td><td class="fielddoc">
<p>Enable bit User mode Execute access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65abeafcf4e5d1a89298e834cb46a976689"></a>DSPICFG_L2MPPA_AID_0&#160;</td><td class="fielddoc">
<p>Enable bit AID = 0 access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65af29aec4a011748f9c4e0318fe66a2b55"></a>DSPICFG_L2MPPA_AID_1&#160;</td><td class="fielddoc">
<p>Enable bit AID = 1 access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a80e076958673e1346c3527f356bef9bc"></a>DSPICFG_L2MPPA_AID_2&#160;</td><td class="fielddoc">
<p>Enable bit AID = 2 access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a6d5bad84d499df84b71010a3ab1f1f15"></a>DSPICFG_L2MPPA_AID_3&#160;</td><td class="fielddoc">
<p>Enable bit AID = 3 access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65aa13efaeae244e1ff08d72f53aa2e12d7"></a>DSPICFG_L2MPPA_AID_4&#160;</td><td class="fielddoc">
<p>Enable bit AID = 4 access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a25a8bf6f2d20a6ae891ae085f8f1f228"></a>DSPICFG_L2MPPA_AID_5&#160;</td><td class="fielddoc">
<p>Enable bit AID = 5 access </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91d9e1f395590f75419b8602b9766e65a6fc0f1fcbbe8dec8718b1f266ee637d8"></a>DSPICFG_L2MPPA_AID_X&#160;</td><td class="fielddoc">
<p>Enable bit AID &gt;= 6 access </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae15fd6129a9303ed2fa3c17ff4f4ba12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae15fd6129a9303ed2fa3c17ff4f4ba12">dspicfgMARAttribute</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to create mask for MAR attributes. Refer to device specific documents to check if PCX and WTE are available. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae15fd6129a9303ed2fa3c17ff4f4ba12aadbf5db5a28e2f903950b0f4d5b3694d"></a>DSPICFG_MAR_PC&#160;</td><td class="fielddoc">
<p>Specify if region is cacheable </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae15fd6129a9303ed2fa3c17ff4f4ba12a24eb6773f2906c265909537bfc644b7f"></a>DSPICFG_MAR_WTE&#160;</td><td class="fielddoc">
<p>Specify if region is write-through cacheable </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae15fd6129a9303ed2fa3c17ff4f4ba12a76931c29dc1833a9e5fe9afe9d4c7d0f"></a>DSPICFG_MAR_PCX&#160;</td><td class="fielddoc">
<p>Specify if region is cacheable in external cache like MSMC </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae15fd6129a9303ed2fa3c17ff4f4ba12a8a9233fbdd80f35e87a94f65f3b239de"></a>DSPICFG_MAR_PFX&#160;</td><td class="fielddoc">
<p>Specify if region is pre-fetchable. Used by XMC/L2-Memory controller </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaad2790ee320548d0f8a5e7da60fdddd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gaad2790ee320548d0f8a5e7da60fdddd2">dspicfgMemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to specify cache type in cache APIs provided in the file. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaad2790ee320548d0f8a5e7da60fdddd2a3a0fca2e257f0271b6e736142562bf25"></a>DSPICFG_MEM_L1D&#160;</td><td class="fielddoc">
<p>L1 Data memory </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaad2790ee320548d0f8a5e7da60fdddd2a85a5f2c7a17789205b211550435f3c80"></a>DSPICFG_MEM_L1P&#160;</td><td class="fielddoc">
<p>L1 Program memory </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaad2790ee320548d0f8a5e7da60fdddd2afaf472ea5010cba98032e4c78e06db15"></a>DSPICFG_MEM_L2&#160;</td><td class="fielddoc">
<p>L2 memory </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaaf880c90eea69c51c76d413eed5b9914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGCacheEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cacheType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable specified cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">cacheType</td><td>Use enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae0b1ce0cf9f6cf353242848b2c534272" title="Enum to specify cache type in cache APIs provided in the file. ">dspicfgMemType_t</a> to specify the cache.</td></tr>
    <tr><td class="paramname">size</td><td>Specify cache size. Remaining memory will be available as RAM. Argument ignored if enable is 0. Use <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga2609613094e89637de4994b7bc7d02c0" title="Enum to specify L1 cache size in cache APIs provided in the file. ">dspicfgCacheSizeL1_t</a> or <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#ga661ba162ff35750fb7172248d89fa967" title="Enum to specify L2 cache size in cache APIs provided in the file. If the devices L2 memory is less th...">dspicfgCacheSizeL2_t</a> enums for L1 and L2 caches respectively. Use DSPICFG_CACHE_SIZEL1_DISABLE or DSPICFG_CACHE_SIZEL2_DISABLE to disable cache.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status STW_SOK/STW_EFAIL for success/fail </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ae7fe91b4f5d9b38c512cda44d32f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGCacheInvalidate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate all cache as per input range specified by startAddr and numBytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">startAddr</td><td>Starting address on which the cache-operation occurs.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Specify the range in number of bytes on which cache operation occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Always STW_SOK for success </dd></dl>

</div>
</div>
<a class="anchor" id="ga226a0a1c50b9181d92150fa6aa974497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGCacheInvalidateAll </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cacheType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate all cache specified by cacheType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">cacheType</td><td>Use enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae0b1ce0cf9f6cf353242848b2c534272" title="Enum to specify cache type in cache APIs provided in the file. ">dspicfgMemType_t</a> Using argument DSPICFG_MEM_L2 causes, same operation on L1D cache as well.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status STW_SOK/STW_EFAIL for success/fail </dd></dl>

</div>
</div>
<a class="anchor" id="gab8e2306040a7d7ec88db535380322141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGCacheWriteBack </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write-back all cache as per input range specified by startAddr and numBytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">startAddr</td><td>Starting address on which the cache-operation occurs.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Specify the range in number of bytes on which cache operation occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Always STW_SOK for success </dd></dl>

</div>
</div>
<a class="anchor" id="ga15a9f82f92729c925613bb2f60505462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGCacheWriteBackAll </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cacheType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write-back all cache specified by cacheType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">cacheType</td><td>Use enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae0b1ce0cf9f6cf353242848b2c534272" title="Enum to specify cache type in cache APIs provided in the file. ">dspicfgMemType_t</a> Using argument DSPICFG_MEM_L2 causes, same operation on L1D cache as well.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status STW_SOK/STW_EFAIL for success/fail </dd></dl>

</div>
</div>
<a class="anchor" id="ga37039dcf052ebca440398d6d592a389c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGCacheWriteBackInvalidate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write-back and Invalidate all cache as per input range specified by startAddr and numBytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">startAddr</td><td>Starting address on which the` cache-operation occurs.</td></tr>
    <tr><td class="paramname">numBytes</td><td>Specify the range in number of bytes on which cache operation occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Always STW_SOK for success </dd></dl>

</div>
</div>
<a class="anchor" id="ga03999b3b0a64c880316c2d32f0c72875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGCacheWriteBackInvalidateAll </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cacheType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write-back and invalidate all cache specified by cacheType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">cacheType</td><td>Use enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae0b1ce0cf9f6cf353242848b2c534272" title="Enum to specify cache type in cache APIs provided in the file. ">dspicfgMemType_t</a> Using argument DSPICFG_MEM_L2 causes, same operation on L1D cache as well.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status STW_SOK/STW_EFAIL for success/fail </dd></dl>

</div>
</div>
<a class="anchor" id="ga730875797a1ea1f642bba7129d267645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGClearL1DMPUFaultRegs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the fault registers for location and status in the L1D MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Always returns STW_SOK </dd></dl>

</div>
</div>
<a class="anchor" id="gaaea4a6a02418a97c2b891ae255405a7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGClearL1PMPUFaultRegs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the fault registers for location and status in the L1P MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Always returns STW_SOK </dd></dl>

</div>
</div>
<a class="anchor" id="ga4840587ff6a81fa2473a951137b1ea3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGClearL2MPUFaultRegs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the fault registers for location and status in the L2 MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Always returns STW_SOK </dd></dl>

</div>
</div>
<a class="anchor" id="gaf88f9ab828ca5e3f1e94afe542d90201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGClearMdmaErrEvt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the MDMA Error Event register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the XMC instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Always returns STW_SOK </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf1f194e19e1a1c260c6a7564e45f069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DSPICFGGetAttribute </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get memory protection attributes for specified L1/L2 memory page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">pageAddr</td><td>Starting address of the page in L1/L2 Memory which needs to be protected. Base of L1P Memory address is assumed to be SOC_DSP_L1P_BASE. Base of L1D Memory address is assumed to be SOC_DSP_L1D_BASE. Base of L2 Memory address is assumed to be SOC_DSP_L2_BASE. Therefore, pageAddr == SOC_DSP_L2_BASE will configure 0th page of L2, i.e, (SOC_DSP_L2_BASE to (SOC_DSP_L2_BASE + L2_PAGE_SIZE)). Similar convention applies for L1P/L1D. All addresses will be assumed to be aligned as per DSPICFG_L2_PGSZ, DSPICFG_L1P_PGSZ or DSPICFG_L1D_PGSZ</td></tr>
    <tr><td class="paramname">memType</td><td>Use enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae0b1ce0cf9f6cf353242848b2c534272" title="Enum to specify cache type in cache APIs provided in the file. ">dspicfgMemType_t</a> to specify memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>attributeMask Permission masks created by bit-wise "OR"ing of <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gac51b6be3ca4329824738076c71c2b966" title="Enum to create mask for L2MPPA (L2 memory protection attributes) registers for DSP L1P/L1D/L2 Memory ...">dspicfgL2Attribute_t</a> enums. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7472b715dad9379507238a2ff5db4810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DSPICFGGetL1DMPUFaultAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fault location as reported by L1D MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>faultAddr Address where the first fault was generated </dd></dl>

</div>
</div>
<a class="anchor" id="gad74a33eb45d932bb0ca657075b7aa0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DSPICFGGetL1DMPUFaultStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fault status as reported by L1D MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>faultStatus Masks created by bit-wise "OR"ing of <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gac51b6be3ca4329824738076c71c2b966" title="Enum to create mask for L2MPPA (L2 memory protection attributes) registers for DSP L1P/L1D/L2 Memory ...">dspicfgL2Attribute_t</a> enums. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9821667809c868ebf1a9f90ad0958454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DSPICFGGetL1PMPUFaultAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fault location as reported by L1P MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>faultAddr Address where the first fault was generated </dd></dl>

</div>
</div>
<a class="anchor" id="ga483de660279c24b2784c7b867d4a2e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DSPICFGGetL1PMPUFaultStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fault status as reported by L1P MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>faultStatus Masks created by bit-wise "OR"ing of <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gac51b6be3ca4329824738076c71c2b966" title="Enum to create mask for L2MPPA (L2 memory protection attributes) registers for DSP L1P/L1D/L2 Memory ...">dspicfgL2Attribute_t</a> enums. </dd></dl>

</div>
</div>
<a class="anchor" id="gaffca59cf123321c38258fe902c57676b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DSPICFGGetL2MPUFaultAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fault location as reported by L2 MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>faultAddr Address where the first fault was generated </dd></dl>

</div>
</div>
<a class="anchor" id="gaa24af1f245e67013db1b0fbc9791ed06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DSPICFGGetL2MPUFaultStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fault status as reported by L2 MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>Base Address of the DSP_ICFG instance (SOC_DSP_ICFG_BASE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>faultStatus Masks created by bit-wise "OR"ing of <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gac51b6be3ca4329824738076c71c2b966" title="Enum to create mask for L2MPPA (L2 memory protection attributes) registers for DSP L1P/L1D/L2 Memory ...">dspicfgL2Attribute_t</a> enums. </dd></dl>

</div>
</div>
<a class="anchor" id="gab2eb62fdd3d9771b56cc73873b1b2881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t DSPICFGGetMAR </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Memory Attribute Register in DSP for the 16MiB page specified by startAddr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">startAddr</td><td>Specify the 16MiB aligned start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>attributeMask MAR attribute created by bit-wise "OR"ing of <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae6c67e62618ae746be667e49a9f8d1c0" title="Enum to create mask for MAR attributes. Refer to device specific documents to check if PCX and WTE ar...">dspicfgMARAttribute_t</a> enums. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8669cac09f64e5427b080fd18a2b81fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGMemoryProtectionLock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock Memory Protection registers for Memory Protection Unit and XMC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">key0</td><td>First Key </td></tr>
    <tr><td class="paramname">key1</td><td>Second Key </td></tr>
    <tr><td class="paramname">key2</td><td>Third Key </td></tr>
    <tr><td class="paramname">key3</td><td>Fourth Key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Returns STW_SOK if the Memory Protection Lock status is LOCKed </dd></dl>

</div>
</div>
<a class="anchor" id="gaf87924bc0d059951ac6d928648cba3ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGMemoryProtectionUnlock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock Memory Protection registers for Memory Protection Unit and XMC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">key0</td><td>First Key </td></tr>
    <tr><td class="paramname">key1</td><td>Second Key </td></tr>
    <tr><td class="paramname">key2</td><td>Third Key </td></tr>
    <tr><td class="paramname">key3</td><td>Fourth Key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Returns STW_SOK if the Memory Protection Lock status is UNLOCKed </dd></dl>

</div>
</div>
<a class="anchor" id="ga9019b6282df39dcfff058b2f547fe4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGSetAttribute </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set memory protection attributes for specified L1/L2 memory page. Should be called in supervisor mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">pageAddr</td><td>Starting address of the page in L1/L2 Memory which needs to be protected. Base of L1P Memory address is assumed to be SOC_DSP_L1P_BASE. Base of L1D Memory address is assumed to be SOC_DSP_L1D_BASE. Base of L2 Memory address is assumed to be SOC_DSP_L2_BASE. Therefore, pageAddr == SOC_DSP_L2_BASE will configure 0th page of L2, i.e, (SOC_DSP_L2_BASE to (SOC_DSP_L2_BASE + L2_PAGE_SIZE)). Similar convention applies for L1P/L1D. All addresses will be assumed to be aligned as per DSPICFG_L2_PGSZ, DSPICFG_L1P_PGSZ or DSPICFG_L1D_PGSZ</td></tr>
    <tr><td class="paramname">memType</td><td>Use enum <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae0b1ce0cf9f6cf353242848b2c534272" title="Enum to specify cache type in cache APIs provided in the file. ">dspicfgMemType_t</a> to specify memory.</td></tr>
    <tr><td class="paramname">attributeMask</td><td>Permission masks created by bit-wise "OR"ing of <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gac51b6be3ca4329824738076c71c2b966" title="Enum to create mask for L2MPPA (L2 memory protection attributes) registers for DSP L1P/L1D/L2 Memory ...">dspicfgL2Attribute_t</a> enums.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Returns STW_SOK indicating success Returns STW_EFAIL for invalid arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ga7138b605c38e399f4f9daf751fab8b24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DSPICFGSetMAR </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the Memory Attribute Register in DSP for the 16MiB page specified by startAddr. Should be called in supervisor mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the DSP_ICFG instance. (SOC_DSP_ICFG_BASE)</td></tr>
    <tr><td class="paramname">startAddr</td><td>Specify the 16MiB aligned start address.</td></tr>
    <tr><td class="paramname">attributeMask</td><td>MAR attribute created by bit-wise "OR"ing of <a class="el" href="group___c_s_l___a_r_c_h___c66_x___i_c_f_g.html#gae6c67e62618ae746be667e49a9f8d1c0" title="Enum to create mask for MAR attributes. Refer to device specific documents to check if PCX and WTE ar...">dspicfgMARAttribute_t</a> enums. For range 0x0C00_0000 to 0x0FFF_FFFF, only PFX can be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Return -1 in case of invalid startAddress. 0 indicating success in all other cases. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
