<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ocmc_ecc_l1.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_5c9827f39abcc28a92e5a02429a0e390.html">ip</a></li><li class="navelem"><a class="el" href="dir_06f3626d03f4c047ee01e49df5a07240.html">ocmc</a></li><li class="navelem"><a class="el" href="dir_cc0560a4a76f1b8c13fe6335ca5f51d6.html">V0</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ocmc_ecc_l1.h File Reference<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a> &raquo; <a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e___o_c_m_c.html">OCMC</a> &raquo; <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html">ECC L1</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This module defines the OCMC HAL. This file contains the OCMC Hardware Abstraction Layer API used for low-level programming of the OCMC IP.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;stdint.h&quot;</code><br />
<code>#include &quot;<a class="el" href="soc_8h.html">ti/csl/soc.h</a>&quot;</code><br />
<code>#include &quot;ti/csl/cslr_ocmc_ecc.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf27130e8d96cf8ed6270df83a3960d03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf27130e8d96cf8ed6270df83a3960d03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#gaf27130e8d96cf8ed6270df83a3960d03">OCMC_BUF_ENABLE</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:gaf27130e8d96cf8ed6270df83a3960d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_BUF_ENABLE Enable OCMC buffer. <br /></td></tr>
<tr class="separator:gaf27130e8d96cf8ed6270df83a3960d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c994782fae73a0c00258fe49346d25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga64c994782fae73a0c00258fe49346d25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga64c994782fae73a0c00258fe49346d25">OCMC_BUF_DISABLE</a>&#160;&#160;&#160;((uint32_t) 0U)</td></tr>
<tr class="memdesc:ga64c994782fae73a0c00258fe49346d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_BUF_DISABLE Disable OCMC buffer. <br /></td></tr>
<tr class="separator:ga64c994782fae73a0c00258fe49346d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeb3cd3a00dea033547bb4536829a18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeeb3cd3a00dea033547bb4536829a18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aaeeb3cd3a00dea033547bb4536829a18">OCMC_ECC_SEC_ERROR_FOUND</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_SEC_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:aaeeb3cd3a00dea033547bb4536829a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_ECC_SEC_ERROR_FOUND SEC error interrupt. <br /></td></tr>
<tr class="separator:aaeeb3cd3a00dea033547bb4536829a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9073556261888cb3e7a4186be9ba334"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9073556261888cb3e7a4186be9ba334"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ab9073556261888cb3e7a4186be9ba334">OCMC_ECC_DED_ERROR_FOUND</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_DED_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:ab9073556261888cb3e7a4186be9ba334"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_ECC_DED_ERROR_FOUND DED error interrupt. <br /></td></tr>
<tr class="separator:ab9073556261888cb3e7a4186be9ba334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7c79629574030e995d925107428be9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a7c79629574030e995d925107428be9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a0a7c79629574030e995d925107428be9">OCMC_ECC_ADDR_ERROR_FOUND</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_ADDR_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a0a7c79629574030e995d925107428be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_ECC_ADDR_ERROR_FOUND Address error interrupt. <br /></td></tr>
<tr class="separator:a0a7c79629574030e995d925107428be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c65a5eb1ff5243c13ff841775273c11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c65a5eb1ff5243c13ff841775273c11"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a8c65a5eb1ff5243c13ff841775273c11">OCMC_ADDR_OUT_OF_RANGE</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_OUT_OF_RANGE_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a8c65a5eb1ff5243c13ff841775273c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_ADDR_OUT_OF_RANGE Address out of range error interrupt. <br /></td></tr>
<tr class="separator:a8c65a5eb1ff5243c13ff841775273c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393fadefb7a96b07a4176f738e9c88a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a393fadefb7a96b07a4176f738e9c88a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a393fadefb7a96b07a4176f738e9c88a8">OCMC_CBUF_VIRT_ADDR_ERROR</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_VIRTUAL_ADDR_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a393fadefb7a96b07a4176f738e9c88a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_VIRT_ADDR_ERROR CBUFF virtual address error interrupt. <br /></td></tr>
<tr class="separator:a393fadefb7a96b07a4176f738e9c88a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4ad393c48ab8a704c87323bf972ce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d4ad393c48ab8a704c87323bf972ce7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a6d4ad393c48ab8a704c87323bf972ce7">OCMC_CBUF_WR_OUT_OF_RANGE</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_WR_OUT_OF_RANGE_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a6d4ad393c48ab8a704c87323bf972ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_WR_OUT_OF_RANGE CBUF write out of range error interrupt. <br /></td></tr>
<tr class="separator:a6d4ad393c48ab8a704c87323bf972ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f27c2e5dbfaae0e4097f036adda37e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98f27c2e5dbfaae0e4097f036adda37e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a98f27c2e5dbfaae0e4097f036adda37e">OCMC_CBUF_WR_VBUF_START_ERR</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_VBUF_WRITE_START_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a98f27c2e5dbfaae0e4097f036adda37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_WR_VBUF_START_ERR VBUF write start error interrupt. <br /></td></tr>
<tr class="separator:a98f27c2e5dbfaae0e4097f036adda37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce0bdc7567cfcd71eedbc73242e354a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adce0bdc7567cfcd71eedbc73242e354a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#adce0bdc7567cfcd71eedbc73242e354a">OCMC_CBUF_WR_ADDR_SEQ_ERR</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_WRITE_SEQUENCE_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:adce0bdc7567cfcd71eedbc73242e354a"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_WR_ADDR_SEQ_ERR CBUFF write sequence error interrupt. <br /></td></tr>
<tr class="separator:adce0bdc7567cfcd71eedbc73242e354a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd5e933f3f09a6f53492f2c1cc48399"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dd5e933f3f09a6f53492f2c1cc48399"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a5dd5e933f3f09a6f53492f2c1cc48399">OCMC_CBUF_RD_OUT_OF_RANGE</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_READ_OUT_OF_RANGE_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a5dd5e933f3f09a6f53492f2c1cc48399"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_RD_OUT_OF_RANGE CBUFF read out of range error interrupt. <br /></td></tr>
<tr class="separator:a5dd5e933f3f09a6f53492f2c1cc48399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0467893752b6704b4360849609a77b4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0467893752b6704b4360849609a77b4a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a0467893752b6704b4360849609a77b4a">OCMC_CBUF_RD_VBUF_START_ERR</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_VBUF_READ_START_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a0467893752b6704b4360849609a77b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_RD_VBUF_START_ERR VBUF read start error interrupt. <br /></td></tr>
<tr class="separator:a0467893752b6704b4360849609a77b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3875537a35b89e175809fea9dc2937e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3875537a35b89e175809fea9dc2937e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a3875537a35b89e175809fea9dc2937e1">OCMC_CBUF_RD_ADDR_SEQ_ERR</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_READ_SEQUENCE_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a3875537a35b89e175809fea9dc2937e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_RD_ADDR_SEQ_ERR CBUF read sequence error interrupt. <br /></td></tr>
<tr class="separator:a3875537a35b89e175809fea9dc2937e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dae976d6807448ab0d61a84e6e4490"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97dae976d6807448ab0d61a84e6e4490"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a97dae976d6807448ab0d61a84e6e4490">OCMC_CBUF_OVERFLOW_MID_FOUND</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_OVERFLOW_MID_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:a97dae976d6807448ab0d61a84e6e4490"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_OVERFLOW_MID_FOUND CBUF overflow mid error interrupt. <br /></td></tr>
<tr class="separator:a97dae976d6807448ab0d61a84e6e4490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43af9c6e6b4dce49b65e1f1d565aeb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad43af9c6e6b4dce49b65e1f1d565aeb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ad43af9c6e6b4dce49b65e1f1d565aeb3">OCMC_CBUF_OVER_FLOW_WRAP_FOUND</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_OVERFLOW_WRAP_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:ad43af9c6e6b4dce49b65e1f1d565aeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_OVER_FLOW_WRAP_FOUND CBUFF overflow wrap error interrupt. <br /></td></tr>
<tr class="separator:ad43af9c6e6b4dce49b65e1f1d565aeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2927318e283560b1ef3fced7a1469a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2927318e283560b1ef3fced7a1469a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aa2927318e283560b1ef3fced7a1469a4">OCMC_CBUF_UNDERFLOW</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_UNDERFLOW_ERR_FOUND_MASK)</td></tr>
<tr class="memdesc:aa2927318e283560b1ef3fced7a1469a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_UNDERFLOW CBUF underflow error interrupt. <br /></td></tr>
<tr class="separator:aa2927318e283560b1ef3fced7a1469a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b81577c7f4ff58587bc09a52dba15f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3b81577c7f4ff58587bc09a52dba15f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ae3b81577c7f4ff58587bc09a52dba15f">OCMC_CBUF_SHORT_FRAME_DETECT</a>&#160;&#160;&#160;(OCMC_RAM_INTR0_STATUS_RAW_SET_CBUF_SHORT_FRAME_DETECT_FOUND_MASK)</td></tr>
<tr class="memdesc:ae3b81577c7f4ff58587bc09a52dba15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CBUF_SHORT_FRAME_DETECT CBUFF short frame detect interrupt. <br /></td></tr>
<tr class="separator:ae3b81577c7f4ff58587bc09a52dba15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545100d39c198eee4edb9b98998503a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a545100d39c198eee4edb9b98998503a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a545100d39c198eee4edb9b98998503a2">OCMC_INTERRUPT_ALL</a>&#160;&#160;&#160;(0x7FFFU)</td></tr>
<tr class="memdesc:a545100d39c198eee4edb9b98998503a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_INTERRUPT_ALL All interrupt status. <br /></td></tr>
<tr class="separator:a545100d39c198eee4edb9b98998503a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90c05dd491a777cd86add528c3b264e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af90c05dd491a777cd86add528c3b264e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#af90c05dd491a777cd86add528c3b264e">OCMC_CLEAR_SEC_ERROR_HIST</a>&#160;&#160;&#160;(OCMC_RAM_CFG_OCMC_ECC_CLEAR_HIST_CLEAR_SEC_ERR_CNT_MASK)</td></tr>
<tr class="memdesc:af90c05dd491a777cd86add528c3b264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CLEAR_SEC_ERROR_HIST Clear stored SEC error history. <br /></td></tr>
<tr class="separator:af90c05dd491a777cd86add528c3b264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792113f910aac9ed763bad7275f21fd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a792113f910aac9ed763bad7275f21fd9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a792113f910aac9ed763bad7275f21fd9">OCMC_CLEAR_DED_ERROR_HIST</a>&#160;&#160;&#160;(OCMC_RAM_CFG_OCMC_ECC_CLEAR_HIST_CLEAR_DED_ERR_CNT_MASK)</td></tr>
<tr class="memdesc:a792113f910aac9ed763bad7275f21fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CLEAR_DED_ERROR_HIST Clear stored DED error history. <br /></td></tr>
<tr class="separator:a792113f910aac9ed763bad7275f21fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352b320add25aa8db02c231e2deb2354"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a352b320add25aa8db02c231e2deb2354"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a352b320add25aa8db02c231e2deb2354">OCMC_CLEAR_ADDR_ERROR_HIST</a>&#160;&#160;&#160;(OCMC_RAM_CFG_OCMC_ECC_CLEAR_HIST_CLEAR_ADDR_ERR_CNT_MASK)</td></tr>
<tr class="memdesc:a352b320add25aa8db02c231e2deb2354"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CLEAR_ADDR_ERROR_HIST Clear stored ADDR error history. <br /></td></tr>
<tr class="separator:a352b320add25aa8db02c231e2deb2354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bfd0199a532dfba3dbfe22ab2ff642"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8bfd0199a532dfba3dbfe22ab2ff642"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ab8bfd0199a532dfba3dbfe22ab2ff642">OCMC_CLEAR_SEC_BIT_DIST_HIST</a>&#160;&#160;&#160;(OCMC_RAM_CFG_OCMC_ECC_CLEAR_HIST_CLEAR_SEC_BIT_DISTR_MASK)</td></tr>
<tr class="memdesc:ab8bfd0199a532dfba3dbfe22ab2ff642"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CLEAR_SEC_BIT_DIST_HIST Clear stored SEC bit distribution history. <br /></td></tr>
<tr class="separator:ab8bfd0199a532dfba3dbfe22ab2ff642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542de559eb44a1a1931d6c0fb2e5b51c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a542de559eb44a1a1931d6c0fb2e5b51c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a542de559eb44a1a1931d6c0fb2e5b51c">OCMC_CLEAR_ALL_HIST</a>&#160;&#160;&#160;(0x0FU)</td></tr>
<tr class="memdesc:a542de559eb44a1a1931d6c0fb2e5b51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">OCMC_CLEAR_ALL_HIST CLears all history. <br /></td></tr>
<tr class="separator:a542de559eb44a1a1931d6c0fb2e5b51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2bda956bb280aa28a0eb3c18788e72c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2bda956bb280aa28a0eb3c18788e72c5"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga2bda956bb280aa28a0eb3c18788e72c5">ocmc_addr_t</a></td></tr>
<tr class="memdesc:ga2bda956bb280aa28a0eb3c18788e72c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ocmc_addr_t datatype definition <br /></td></tr>
<tr class="separator:ga2bda956bb280aa28a0eb3c18788e72c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d474b24274a293377242f16445a870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43d474b24274a293377242f16445a870"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a></td></tr>
<tr class="memdesc:ga43d474b24274a293377242f16445a870"><td class="mdescLeft">&#160;</td><td class="mdescRight">ocmc_buf_id_t datatype definition <br /></td></tr>
<tr class="separator:ga43d474b24274a293377242f16445a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3bc2f748d3250a6d19798c1ce2926006"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bc2f748d3250a6d19798c1ce2926006"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a3bc2f748d3250a6d19798c1ce2926006">ocmc_sysconfig_mode</a> </td></tr>
<tr class="memdesc:a3bc2f748d3250a6d19798c1ce2926006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that specifies possible OCMC system configuration modes. <br /></td></tr>
<tr class="separator:a3bc2f748d3250a6d19798c1ce2926006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb9760a63e55a0a49206c65fe8da6c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bb9760a63e55a0a49206c65fe8da6c0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a4bb9760a63e55a0a49206c65fe8da6c0">ocmc_cfg_ecc_mode</a> </td></tr>
<tr class="memdesc:a4bb9760a63e55a0a49206c65fe8da6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that specifies possible OCMC ECC configuration modes. <br /></td></tr>
<tr class="separator:a4bb9760a63e55a0a49206c65fe8da6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38604649c1d8fe60befe815efbadab56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38604649c1d8fe60befe815efbadab56"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a38604649c1d8fe60befe815efbadab56">ocmc_err_cnt_type</a> </td></tr>
<tr class="memdesc:a38604649c1d8fe60befe815efbadab56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration listing possible ECC error types used by OCMCErrCntStatusGet. <br /></td></tr>
<tr class="separator:a38604649c1d8fe60befe815efbadab56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37af214a62592feb13477ffd6362ca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37af214a62592feb13477ffd6362ca2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ae37af214a62592feb13477ffd6362ca2">ocmc_wr_overflow_handler_t</a> </td></tr>
<tr class="memdesc:ae37af214a62592feb13477ffd6362ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that specifies possible write overflow handling options. <br /></td></tr>
<tr class="separator:ae37af214a62592feb13477ffd6362ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f8129cd63e3ef518ef364f3e476ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab94f8129cd63e3ef518ef364f3e476ce"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ab94f8129cd63e3ef518ef364f3e476ce">ocmc_wr_overflow_reenable_t</a> </td></tr>
<tr class="memdesc:ab94f8129cd63e3ef518ef364f3e476ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that specifies possible write overflow check re-enable options. <br /></td></tr>
<tr class="separator:ab94f8129cd63e3ef518ef364f3e476ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79189417d3255559ed66a1636b02a7cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79189417d3255559ed66a1636b02a7cb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a79189417d3255559ed66a1636b02a7cb">ocmc_cbuf_err_t</a> </td></tr>
<tr class="memdesc:a79189417d3255559ed66a1636b02a7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that specifies possible CBUF errors. <br /></td></tr>
<tr class="separator:a79189417d3255559ed66a1636b02a7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc322c5ddc151a139059ba9740259ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a2bc322c5ddc151a139059ba9740259ad">ocmc_ecc_err_t</a> { <a class="el" href="ocmc__ecc__l1_8h.html#a2bc322c5ddc151a139059ba9740259ada97a5ffee72c8be5557acc8495597be17">OCMC_ECC_SEC_ERR</a>, 
<a class="el" href="ocmc__ecc__l1_8h.html#a2bc322c5ddc151a139059ba9740259ada455ca760076631660bab068335919f54">OCMC_ECC_DED_ERR</a>, 
<a class="el" href="ocmc__ecc__l1_8h.html#a2bc322c5ddc151a139059ba9740259ada3ba6dbc748f4a52b31dba9f368eb2803">OCMC_ECC_ADDR_ERR</a>
 }</td></tr>
<tr class="memdesc:a2bc322c5ddc151a139059ba9740259ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that specifies possible ECC errors.  <a href="ocmc__ecc__l1_8h.html#a2bc322c5ddc151a139059ba9740259ad">More...</a><br /></td></tr>
<tr class="separator:a2bc322c5ddc151a139059ba9740259ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff13784353d41e5ac76c0073dabebd8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff13784353d41e5ac76c0073dabebd8b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aff13784353d41e5ac76c0073dabebd8b">ocmc_sec_ecc_err_dist_t</a> </td></tr>
<tr class="memdesc:aff13784353d41e5ac76c0073dabebd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that specifies possible SEC ECC error Distribution Type. <br /></td></tr>
<tr class="separator:aff13784353d41e5ac76c0073dabebd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abd696b93ad769a9a48e6fe762cc482ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#abd696b93ad769a9a48e6fe762cc482ea">OCMCModeSet</a> (uint32_t baseAddr, <a class="el" href="ocmc__ecc__l1_8h.html#a3bc2f748d3250a6d19798c1ce2926006">ocmc_sysconfig_mode</a> mode)</td></tr>
<tr class="memdesc:abd696b93ad769a9a48e6fe762cc482ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure OCMC Mode.  <a href="#abd696b93ad769a9a48e6fe762cc482ea">More...</a><br /></td></tr>
<tr class="separator:abd696b93ad769a9a48e6fe762cc482ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae0220aacac57c59a803322326930bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a7ae0220aacac57c59a803322326930bc">OCMCSoftReset</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a7ae0220aacac57c59a803322326930bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to soft-reset entire OCMC.  <a href="#a7ae0220aacac57c59a803322326930bc">More...</a><br /></td></tr>
<tr class="separator:a7ae0220aacac57c59a803322326930bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62169617974b8fdf216a52aecbe0568f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a62169617974b8fdf216a52aecbe0568f">OCMCGetRAMSize</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a62169617974b8fdf216a52aecbe0568f"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to return the size of the OCMC memory in bytes.  <a href="#a62169617974b8fdf216a52aecbe0568f">More...</a><br /></td></tr>
<tr class="separator:a62169617974b8fdf216a52aecbe0568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ad17d9b1df69828e0247a0c55ff0a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ae4ad17d9b1df69828e0247a0c55ff0a9">OCMCCbufCapabilityGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ae4ad17d9b1df69828e0247a0c55ff0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get the Circular buffer capability for the OCMC instance passed.  <a href="#ae4ad17d9b1df69828e0247a0c55ff0a9">More...</a><br /></td></tr>
<tr class="separator:ae4ad17d9b1df69828e0247a0c55ff0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bfd30e900b07867fc090b25ecc75c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ac8bfd30e900b07867fc090b25ecc75c5">OCMCEccCapabilityGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ac8bfd30e900b07867fc090b25ecc75c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get the ECC capability for the OCMC instance passed.  <a href="#ac8bfd30e900b07867fc090b25ecc75c5">More...</a><br /></td></tr>
<tr class="separator:ac8bfd30e900b07867fc090b25ecc75c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d3943523648628f46c161ebeb9e6be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a70d3943523648628f46c161ebeb9e6be">OCMCIntStatusRawGet</a> (uint32_t baseAddr, uint8_t intr_group, uint32_t intFlag)</td></tr>
<tr class="memdesc:a70d3943523648628f46c161ebeb9e6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get raw interrupt status for the interrupt flag passed.  <a href="#a70d3943523648628f46c161ebeb9e6be">More...</a><br /></td></tr>
<tr class="separator:a70d3943523648628f46c161ebeb9e6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a41f60b5b7aca12d32528bc2a2752e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a9a41f60b5b7aca12d32528bc2a2752e4">OCMCIntStatusRawSet</a> (uint32_t baseAddr, uint8_t intr_group, uint32_t intFlag)</td></tr>
<tr class="memdesc:a9a41f60b5b7aca12d32528bc2a2752e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to set raw interrupt status for the interrupt flag passed.  <a href="#a9a41f60b5b7aca12d32528bc2a2752e4">More...</a><br /></td></tr>
<tr class="separator:a9a41f60b5b7aca12d32528bc2a2752e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde11f374acd89f033f2c4719b3e3fbe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#adde11f374acd89f033f2c4719b3e3fbe">OCMCIntStatusEnableGet</a> (uint32_t baseAddr, uint8_t intr_group, uint32_t intFlag)</td></tr>
<tr class="memdesc:adde11f374acd89f033f2c4719b3e3fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get status of generated interrupt for the interrupt flag passed.  <a href="#adde11f374acd89f033f2c4719b3e3fbe">More...</a><br /></td></tr>
<tr class="separator:adde11f374acd89f033f2c4719b3e3fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194bbb19860653efdcfd15e17c326462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a194bbb19860653efdcfd15e17c326462">OCMCIntStatusEnableClear</a> (uint32_t baseAddr, uint8_t intr_group, uint32_t intFlag)</td></tr>
<tr class="memdesc:a194bbb19860653efdcfd15e17c326462"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to clear the status of generated interrupt for the interrupt flag passed.  <a href="#a194bbb19860653efdcfd15e17c326462">More...</a><br /></td></tr>
<tr class="separator:a194bbb19860653efdcfd15e17c326462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0e8a6495db8ce8939f90b7a0ba7c36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a0d0e8a6495db8ce8939f90b7a0ba7c36">OCMCIntEnable</a> (uint32_t baseAddr, uint8_t intr_group, uint32_t intFlag)</td></tr>
<tr class="memdesc:a0d0e8a6495db8ce8939f90b7a0ba7c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to enable interrupt for the interrupt flag passed.  <a href="#a0d0e8a6495db8ce8939f90b7a0ba7c36">More...</a><br /></td></tr>
<tr class="separator:a0d0e8a6495db8ce8939f90b7a0ba7c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5710bf01fb7d723385c29931926161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a7c5710bf01fb7d723385c29931926161">OCMCIntDisable</a> (uint32_t baseAddr, uint8_t intr_group, uint32_t intFlag)</td></tr>
<tr class="memdesc:a7c5710bf01fb7d723385c29931926161"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to disable interrupt for the interrupt flag passed.  <a href="#a7c5710bf01fb7d723385c29931926161">More...</a><br /></td></tr>
<tr class="separator:a7c5710bf01fb7d723385c29931926161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fe7363debcba7412c0c060d441edc4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ab6fe7363debcba7412c0c060d441edc4">OCMCIntEnableGet</a> (uint32_t baseAddr, uint8_t intr_group, uint32_t intFlag)</td></tr>
<tr class="memdesc:ab6fe7363debcba7412c0c060d441edc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get enabled interrupt status for the interrupt flag passed.  <a href="#ab6fe7363debcba7412c0c060d441edc4">More...</a><br /></td></tr>
<tr class="separator:ab6fe7363debcba7412c0c060d441edc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cdcaf9da9f4f018fd4a8720cb16538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#af9cdcaf9da9f4f018fd4a8720cb16538">OCMCEccConfig</a> (uint32_t baseAddr, <a class="el" href="ocmc__ecc__l1_8h.html#a4bb9760a63e55a0a49206c65fe8da6c0">ocmc_cfg_ecc_mode</a> ocmc_ecc_mode_cfg, uint32_t cfgEccSecAutoCorrectEn, uint32_t cfgEccErrSrespEn, uint32_t cfgEccOptNonEccReadEn)</td></tr>
<tr class="memdesc:af9cdcaf9da9f4f018fd4a8720cb16538"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure OCMC ECC.  <a href="#af9cdcaf9da9f4f018fd4a8720cb16538">More...</a><br /></td></tr>
<tr class="separator:af9cdcaf9da9f4f018fd4a8720cb16538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674170b8cc7b96d404ea583724859276"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a674170b8cc7b96d404ea583724859276">OCMCRAMBlockEnableStatusGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a674170b8cc7b96d404ea583724859276"><td class="mdescLeft">&#160;</td><td class="mdescRight">API gets status of enable ECC blocks.  <a href="#a674170b8cc7b96d404ea583724859276">More...</a><br /></td></tr>
<tr class="separator:a674170b8cc7b96d404ea583724859276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea0d380c2126b648853cc300ee11a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a9ea0d380c2126b648853cc300ee11a46">OCMCRAMBlockEnableCtrl</a> (uint32_t baseAddr, uint32_t enable, uint32_t blockNum)</td></tr>
<tr class="memdesc:a9ea0d380c2126b648853cc300ee11a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">API enables or disables ECC for the block number passed.  <a href="#a9ea0d380c2126b648853cc300ee11a46">More...</a><br /></td></tr>
<tr class="separator:a9ea0d380c2126b648853cc300ee11a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b87a54226e3008d79fb3b1a038f398b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a0b87a54226e3008d79fb3b1a038f398b">OCMCEccErrTraceConfig</a> (uint32_t baseAddr, uint32_t secErrCnt, uint32_t dedErrCnt, uint32_t addrErrCnt, uint32_t discardDupErrAddr)</td></tr>
<tr class="memdesc:a0b87a54226e3008d79fb3b1a038f398b"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure OCMC ECC Err trace.  <a href="#a0b87a54226e3008d79fb3b1a038f398b">More...</a><br /></td></tr>
<tr class="separator:a0b87a54226e3008d79fb3b1a038f398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec4aa052eff651bbb3092ceb5e04fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#adec4aa052eff651bbb3092ceb5e04fb3">OCMCEccErrClearTraceHist</a> (uint32_t baseAddr, uint32_t errFlag)</td></tr>
<tr class="memdesc:adec4aa052eff651bbb3092ceb5e04fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to clear OCMC ECC Err trace history.  <a href="#adec4aa052eff651bbb3092ceb5e04fb3">More...</a><br /></td></tr>
<tr class="separator:adec4aa052eff651bbb3092ceb5e04fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa062bfc5ec874c43cdbc4dc8740a1406"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aa062bfc5ec874c43cdbc4dc8740a1406">OCMCErrCntStatusGet</a> (uint32_t baseAddr, <a class="el" href="ocmc__ecc__l1_8h.html#a38604649c1d8fe60befe815efbadab56">ocmc_err_cnt_type</a> errType)</td></tr>
<tr class="memdesc:aa062bfc5ec874c43cdbc4dc8740a1406"><td class="mdescLeft">&#160;</td><td class="mdescRight">API Returns Error Count for the error type passed.  <a href="#aa062bfc5ec874c43cdbc4dc8740a1406">More...</a><br /></td></tr>
<tr class="separator:aa062bfc5ec874c43cdbc4dc8740a1406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a895493698a0c62ce0a0c4900babee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ac3a895493698a0c62ce0a0c4900babee">OCMCVBufStartAddrSet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga2bda956bb280aa28a0eb3c18788e72c5">ocmc_addr_t</a> vbuf_start)</td></tr>
<tr class="memdesc:ac3a895493698a0c62ce0a0c4900babee"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to set virtual buffer start address for the buffer id passed.  <a href="#ac3a895493698a0c62ce0a0c4900babee">More...</a><br /></td></tr>
<tr class="separator:ac3a895493698a0c62ce0a0c4900babee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652df5a50171f9f4f481bab100431382"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a652df5a50171f9f4f481bab100431382">OCMCVBufStartAddrGet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id)</td></tr>
<tr class="memdesc:a652df5a50171f9f4f481bab100431382"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get virtual buffer start address for the buffer id passed.  <a href="#a652df5a50171f9f4f481bab100431382">More...</a><br /></td></tr>
<tr class="separator:a652df5a50171f9f4f481bab100431382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21436758b0a7ac09191d9de1a21e7f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aa21436758b0a7ac09191d9de1a21e7f3">OCMCVBufEndAddrSet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga2bda956bb280aa28a0eb3c18788e72c5">ocmc_addr_t</a> vbuf_end)</td></tr>
<tr class="memdesc:aa21436758b0a7ac09191d9de1a21e7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to set virtual buffer end address for the buffer id passed.  <a href="#aa21436758b0a7ac09191d9de1a21e7f3">More...</a><br /></td></tr>
<tr class="separator:aa21436758b0a7ac09191d9de1a21e7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8748363e4a4f4601cb50571331245cce"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a8748363e4a4f4601cb50571331245cce">OCMCVBufEndAddrGet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id)</td></tr>
<tr class="memdesc:a8748363e4a4f4601cb50571331245cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get virtual buffer end address for the buffer id passed.  <a href="#a8748363e4a4f4601cb50571331245cce">More...</a><br /></td></tr>
<tr class="separator:a8748363e4a4f4601cb50571331245cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8eec65b1f9fa239f4f2d6d515e07f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a9b8eec65b1f9fa239f4f2d6d515e07f4">OCMCCBufStartAddrSet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga2bda956bb280aa28a0eb3c18788e72c5">ocmc_addr_t</a> cbuf_start)</td></tr>
<tr class="memdesc:a9b8eec65b1f9fa239f4f2d6d515e07f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to set OCMC circular buffer start address for the buffer id passed.  <a href="#a9b8eec65b1f9fa239f4f2d6d515e07f4">More...</a><br /></td></tr>
<tr class="separator:a9b8eec65b1f9fa239f4f2d6d515e07f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bc41c225dcb9a2c3dbfba7d96f57cb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a03bc41c225dcb9a2c3dbfba7d96f57cb">OCMCCBufStartAddrGet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id)</td></tr>
<tr class="memdesc:a03bc41c225dcb9a2c3dbfba7d96f57cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get OCMC circular buffer start address for the buffer id passed.  <a href="#a03bc41c225dcb9a2c3dbfba7d96f57cb">More...</a><br /></td></tr>
<tr class="separator:a03bc41c225dcb9a2c3dbfba7d96f57cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ceb79602f5da1e35b1f8778565a1ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a22ceb79602f5da1e35b1f8778565a1ed">OCMCCBufSizeSet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id, uint32_t cbuf_size)</td></tr>
<tr class="memdesc:a22ceb79602f5da1e35b1f8778565a1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to set OCMC circular buffer size for the buffer id passed.  <a href="#a22ceb79602f5da1e35b1f8778565a1ed">More...</a><br /></td></tr>
<tr class="separator:a22ceb79602f5da1e35b1f8778565a1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d764adb366fefca915a70e305eda40"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aa2d764adb366fefca915a70e305eda40">OCMCCBufSizeGet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id)</td></tr>
<tr class="memdesc:aa2d764adb366fefca915a70e305eda40"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get OCMC circular buffer size for the buffer id passed.  <a href="#aa2d764adb366fefca915a70e305eda40">More...</a><br /></td></tr>
<tr class="separator:aa2d764adb366fefca915a70e305eda40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad932e64de37ea8d639df31e61bdab297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ad932e64de37ea8d639df31e61bdab297">OCMCCbufEnableCtrl</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id, uint8_t buf_enable)</td></tr>
<tr class="memdesc:ad932e64de37ea8d639df31e61bdab297"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to enable/disable a specified VBUF.  <a href="#ad932e64de37ea8d639df31e61bdab297">More...</a><br /></td></tr>
<tr class="separator:ad932e64de37ea8d639df31e61bdab297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d15fcf8d20c0ed9184c6f4307d7346"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a67d15fcf8d20c0ed9184c6f4307d7346">OCMCCbufEnableStatusGet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id)</td></tr>
<tr class="memdesc:a67d15fcf8d20c0ed9184c6f4307d7346"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to Get state of the cbuf(enabled or disabled)  <a href="#a67d15fcf8d20c0ed9184c6f4307d7346">More...</a><br /></td></tr>
<tr class="separator:a67d15fcf8d20c0ed9184c6f4307d7346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b896a56c8ea90d994fa5505dfe5975a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a0b896a56c8ea90d994fa5505dfe5975a">OCMCCbufModeEnableCtrl</a> (uint32_t baseAddr, uint8_t cbuf_enable)</td></tr>
<tr class="memdesc:a0b896a56c8ea90d994fa5505dfe5975a"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to enable/disable global circular buffer mode of operations.  <a href="#a0b896a56c8ea90d994fa5505dfe5975a">More...</a><br /></td></tr>
<tr class="separator:a0b896a56c8ea90d994fa5505dfe5975a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa725bf5f5cacccf37cbfb0b74aa6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a9faa725bf5f5cacccf37cbfb0b74aa6c">OCMCCBufReset</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id)</td></tr>
<tr class="memdesc:a9faa725bf5f5cacccf37cbfb0b74aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to reset a specified CBUF.  <a href="#a9faa725bf5f5cacccf37cbfb0b74aa6c">More...</a><br /></td></tr>
<tr class="separator:a9faa725bf5f5cacccf37cbfb0b74aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6e8758d2fa18e173452bdc2d6bef7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a8d6e8758d2fa18e173452bdc2d6bef7e">OCMCShortFrameDetectEnableCtrl</a> (uint32_t baseAddr, uint8_t short_frame_detect, uint8_t prev_eof_sel)</td></tr>
<tr class="memdesc:a8d6e8758d2fa18e173452bdc2d6bef7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to enable/disable int16_t frame detect, and also specify prev_eof selection.  <a href="#a8d6e8758d2fa18e173452bdc2d6bef7e">More...</a><br /></td></tr>
<tr class="separator:a8d6e8758d2fa18e173452bdc2d6bef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb032812cbbb49c8c81d4f321aeb3f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aafb032812cbbb49c8c81d4f321aeb3f6">OCMCOverflowConfigure</a> (uint32_t baseAddr, uint8_t overflow_detect, <a class="el" href="ocmc__ecc__l1_8h.html#ae37af214a62592feb13477ffd6362ca2">ocmc_wr_overflow_handler_t</a> overflow_handler, <a class="el" href="ocmc__ecc__l1_8h.html#ab94f8129cd63e3ef518ef364f3e476ce">ocmc_wr_overflow_reenable_t</a> overflow_check_reenable)</td></tr>
<tr class="memdesc:aafb032812cbbb49c8c81d4f321aeb3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure overflow handling.  <a href="#aafb032812cbbb49c8c81d4f321aeb3f6">More...</a><br /></td></tr>
<tr class="separator:aafb032812cbbb49c8c81d4f321aeb3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d2087e7d631f259c384e9621a0eb5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ae0d2087e7d631f259c384e9621a0eb5a">OCMCUnderflowConfigure</a> (uint32_t baseAddr, uint8_t underflow_detect, uint8_t underflow_last_cbuf_slice_disable)</td></tr>
<tr class="memdesc:ae0d2087e7d631f259c384e9621a0eb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure underflow handling.  <a href="#ae0d2087e7d631f259c384e9621a0eb5a">More...</a><br /></td></tr>
<tr class="separator:ae0d2087e7d631f259c384e9621a0eb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8b3d356a8aa77ea58746e76e100b8f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aad8b3d356a8aa77ea58746e76e100b8f">OCMCCbufErrorStatusGet</a> (uint32_t baseAddr, <a class="el" href="ocmc__ecc__l1_8h.html#a79189417d3255559ed66a1636b02a7cb">ocmc_cbuf_err_t</a> cbuf_err_type, uint32_t cBufId)</td></tr>
<tr class="memdesc:aad8b3d356a8aa77ea58746e76e100b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get cbuf error status for the buffer id passed.  <a href="#aad8b3d356a8aa77ea58746e76e100b8f">More...</a><br /></td></tr>
<tr class="separator:aad8b3d356a8aa77ea58746e76e100b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae140c412bb1976b67ab42f6492c324f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ae140c412bb1976b67ab42f6492c324f3">OCMCCbufErrorStatusClear</a> (uint32_t baseAddr, <a class="el" href="ocmc__ecc__l1_8h.html#a79189417d3255559ed66a1636b02a7cb">ocmc_cbuf_err_t</a> cbuf_err_type, uint32_t cBufId)</td></tr>
<tr class="memdesc:ae140c412bb1976b67ab42f6492c324f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to clear cbuf error status for the buffer id passed.  <a href="#ae140c412bb1976b67ab42f6492c324f3">More...</a><br /></td></tr>
<tr class="separator:ae140c412bb1976b67ab42f6492c324f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aad0018460c0e50c27d6f9d2bf0cf3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ac6aad0018460c0e50c27d6f9d2bf0cf3">OCMCCBufLastRdAddrGet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id)</td></tr>
<tr class="memdesc:ac6aad0018460c0e50c27d6f9d2bf0cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to read a CBUF's "last read address".  <a href="#ac6aad0018460c0e50c27d6f9d2bf0cf3">More...</a><br /></td></tr>
<tr class="separator:ac6aad0018460c0e50c27d6f9d2bf0cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab60b1057cb48735abe8664f1d03350f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#aab60b1057cb48735abe8664f1d03350f">OCMCCBufLastWrAddrGet</a> (uint32_t baseAddr, <a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a> buf_id)</td></tr>
<tr class="memdesc:aab60b1057cb48735abe8664f1d03350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to read a CBUF's "last write address".  <a href="#aab60b1057cb48735abe8664f1d03350f">More...</a><br /></td></tr>
<tr class="separator:aab60b1057cb48735abe8664f1d03350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed5e0ebc927008ae4338479debb093b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a7ed5e0ebc927008ae4338479debb093b">OCMCBaseAddrGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a7ed5e0ebc927008ae4338479debb093b"><td class="mdescLeft">&#160;</td><td class="mdescRight">API returns the OCMC physical memory base address.  <a href="#a7ed5e0ebc927008ae4338479debb093b">More...</a><br /></td></tr>
<tr class="separator:a7ed5e0ebc927008ae4338479debb093b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d6013fb2b9ab68dfadbcc881e1c8b2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a88d6013fb2b9ab68dfadbcc881e1c8b2">OCMCCBUFBaseAddrGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a88d6013fb2b9ab68dfadbcc881e1c8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">API returns the OCMC cbuf base address.  <a href="#a88d6013fb2b9ab68dfadbcc881e1c8b2">More...</a><br /></td></tr>
<tr class="separator:a88d6013fb2b9ab68dfadbcc881e1c8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2ac01d4f2739f90f806f9569d8a2b6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a4b2ac01d4f2739f90f806f9569d8a2b6">OCMCCBUFSizeGet</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:a4b2ac01d4f2739f90f806f9569d8a2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">API returns OCMC cbuf size.  <a href="#a4b2ac01d4f2739f90f806f9569d8a2b6">More...</a><br /></td></tr>
<tr class="separator:a4b2ac01d4f2739f90f806f9569d8a2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b51c3c82ad64f384607c30e179db38"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#a46b51c3c82ad64f384607c30e179db38">OCMCEccErrTraceAddrGet</a> (uint32_t baseAddr, <a class="el" href="ocmc__ecc__l1_8h.html#a2bc322c5ddc151a139059ba9740259ad">ocmc_ecc_err_t</a> errType)</td></tr>
<tr class="memdesc:a46b51c3c82ad64f384607c30e179db38"><td class="mdescLeft">&#160;</td><td class="mdescRight">API Returns OCMC offset address of ECC error for the error type passed.  <a href="#a46b51c3c82ad64f384607c30e179db38">More...</a><br /></td></tr>
<tr class="separator:a46b51c3c82ad64f384607c30e179db38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d8429017946c9e5b2c999d1699cb07"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ocmc__ecc__l1_8h.html#ac5d8429017946c9e5b2c999d1699cb07">OCMCSecEccErrDistributionStatusGet</a> (uint32_t baseAddr, <a class="el" href="ocmc__ecc__l1_8h.html#aff13784353d41e5ac76c0073dabebd8b">ocmc_sec_ecc_err_dist_t</a> errType)</td></tr>
<tr class="memdesc:ac5d8429017946c9e5b2c999d1699cb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">API Returns OCMC SEC data error bit distribution status for the SEC ECC error Distribution Type passed.  <a href="#ac5d8429017946c9e5b2c999d1699cb07">More...</a><br /></td></tr>
<tr class="separator:ac5d8429017946c9e5b2c999d1699cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module defines the OCMC HAL. This file contains the OCMC Hardware Abstraction Layer API used for low-level programming of the OCMC IP. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a2bc322c5ddc151a139059ba9740259ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ocmc__ecc__l1_8h.html#a2bc322c5ddc151a139059ba9740259ad">ocmc_ecc_err_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration that specifies possible ECC errors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2bc322c5ddc151a139059ba9740259ada97a5ffee72c8be5557acc8495597be17"></a>OCMC_ECC_SEC_ERR&#160;</td><td class="fielddoc">
<p>SEC - Single Error Correction </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2bc322c5ddc151a139059ba9740259ada455ca760076631660bab068335919f54"></a>OCMC_ECC_DED_ERR&#160;</td><td class="fielddoc">
<p>DED - Double Error detection </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2bc322c5ddc151a139059ba9740259ada3ba6dbc748f4a52b31dba9f368eb2803"></a>OCMC_ECC_ADDR_ERR&#160;</td><td class="fielddoc">
<p>Address Error You can induce an address error by corrupting the stored the CODE word[8* :1] by applying XOR with a value (137..154) so that the error_bit_code(code_saved[8:1] ^ code_gen[8:1]) ends up in the (137..154) range. Error_bit_code=137 indicates addr[0] error. 138 indicates addr[1]. And so on. Note that info on which addr bit had an error is not available. Note that an addr error supercedes SEC/DED. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7ed5e0ebc927008ae4338479debb093b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCBaseAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API returns the OCMC physical memory base address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OCMC physical memory base address. </dd></dl>

</div>
</div>
<a class="anchor" id="a88d6013fb2b9ab68dfadbcc881e1c8b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCBUFBaseAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API returns the OCMC cbuf base address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OCMC cbuf base address </dd></dl>

</div>
</div>
<a class="anchor" id="ae4ad17d9b1df69828e0247a0c55ff0a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCbufCapabilityGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get the Circular buffer capability for the OCMC instance passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if supports circular buffer 0 if not supported </dd></dl>

</div>
</div>
<a class="anchor" id="ad932e64de37ea8d639df31e61bdab297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCCbufEnableCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buf_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to enable/disable a specified VBUF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_enable</td><td>Buffer enable / disable flag - use OCMC_BUF_DISABLE to disable, OCMC_BUF_ENABLE to enable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a67d15fcf8d20c0ed9184c6f4307d7346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCbufEnableStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to Get state of the cbuf(enabled or disabled) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non zero value if circular buffer is enabled. zero if disabled </dd></dl>

</div>
</div>
<a class="anchor" id="ae140c412bb1976b67ab42f6492c324f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCCbufErrorStatusClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#a79189417d3255559ed66a1636b02a7cb">ocmc_cbuf_err_t</a>&#160;</td>
          <td class="paramname"><em>cbuf_err_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cBufId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to clear cbuf error status for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbuf_err_type</td><td>Cbuf error type defined by enum ocmc_cbuf_err_t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cBufId</td><td>circular buffer id (cBufId = 0 to 11 for circular buffers 1 to 12)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aad8b3d356a8aa77ea58746e76e100b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCbufErrorStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#a79189417d3255559ed66a1636b02a7cb">ocmc_cbuf_err_t</a>&#160;</td>
          <td class="paramname"><em>cbuf_err_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cBufId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get cbuf error status for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbuf_err_type</td><td>Cbuf error type defined by enum ocmc_cbuf_err_t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cBufId</td><td>circular buffer id (cBufId = 0 to 11 for circular buffers 1 to 12)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cbuf error status for the buffer id passed </dd></dl>

</div>
</div>
<a class="anchor" id="ac6aad0018460c0e50c27d6f9d2bf0cf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCBufLastRdAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to read a CBUF's "last read address". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id whose "last read address" is to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the last read on this CBUF </dd></dl>

</div>
</div>
<a class="anchor" id="aab60b1057cb48735abe8664f1d03350f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCBufLastWrAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to read a CBUF's "last write address". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id whose "last write address" is to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the last write on this CBUF </dd></dl>

</div>
</div>
<a class="anchor" id="a0b896a56c8ea90d994fa5505dfe5975a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCCbufModeEnableCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cbuf_enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to enable/disable global circular buffer mode of operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbuf_enable</td><td>Circular buffering mode enable / disable flag - use OCMC_BUF_DISABLE to disable, OCMC_BUF_ENABLE to enable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a9faa725bf5f5cacccf37cbfb0b74aa6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCCBufReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to reset a specified CBUF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id to be reset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aa2d764adb366fefca915a70e305eda40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCBufSizeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get OCMC circular buffer size for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OCMC circular buffer size for the buffer id passed </dd></dl>

</div>
</div>
<a class="anchor" id="a4b2ac01d4f2739f90f806f9569d8a2b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCBUFSizeGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API returns OCMC cbuf size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OCMC cbuf size </dd></dl>

</div>
</div>
<a class="anchor" id="a22ceb79602f5da1e35b1f8778565a1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCCBufSizeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cbuf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to set OCMC circular buffer size for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbuf_size</td><td>OCMC circular buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a03bc41c225dcb9a2c3dbfba7d96f57cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCCBufStartAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get OCMC circular buffer start address for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OCMC circular buffer start address for the buffer id passed </dd></dl>

</div>
</div>
<a class="anchor" id="a9b8eec65b1f9fa239f4f2d6d515e07f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCCBufStartAddrSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga2bda956bb280aa28a0eb3c18788e72c5">ocmc_addr_t</a>&#160;</td>
          <td class="paramname"><em>cbuf_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to set OCMC circular buffer start address for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cbuf_start</td><td>OCMC circular buffer start address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ac8bfd30e900b07867fc090b25ecc75c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCEccCapabilityGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get the ECC capability for the OCMC instance passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non zero value if supports ECC 0 if not supported </dd></dl>

</div>
</div>
<a class="anchor" id="af9cdcaf9da9f4f018fd4a8720cb16538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCEccConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#a4bb9760a63e55a0a49206c65fe8da6c0">ocmc_cfg_ecc_mode</a>&#160;</td>
          <td class="paramname"><em>ocmc_ecc_mode_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cfgEccSecAutoCorrectEn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cfgEccErrSrespEn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cfgEccOptNonEccReadEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to configure OCMC ECC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ocmc_ecc_mode_cfg</td><td>OCMC_ECC module memory access modes 000 : non-ECC mode (data access) 001 : non-ECC mode (code access) 010 : full ECC enabled mode 011 : block ECC enabled mode 1xx : reserved</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfgEccSecAutoCorrectEn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfgEccErrSrespEn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfgEccOptNonEccReadEn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="adec4aa052eff651bbb3092ceb5e04fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCEccErrClearTraceHist </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>errFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to clear OCMC ECC Err trace history. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errFlag</td><td>flag to indicate the err history to be cleared. errFlag can take the possible values OCMC_CLEAR_SEC_ERROR_HIST OCMC_CLEAR_DED_ERROR_HIST OCMC_CLEAR_ADDR_ERROR_HIST OCMC_CLEAR_SEC_BIT_DIST_HIST OCMC_ALL_HIST</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a46b51c3c82ad64f384607c30e179db38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCEccErrTraceAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#a2bc322c5ddc151a139059ba9740259ad">ocmc_ecc_err_t</a>&#160;</td>
          <td class="paramname"><em>errType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API Returns OCMC offset address of ECC error for the error type passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errType</td><td>errtype as define in enum ocmc_ecc_err_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OCMC offset address of ECC error for the error type passed </dd></dl>

</div>
</div>
<a class="anchor" id="a0b87a54226e3008d79fb3b1a038f398b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCEccErrTraceConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>secErrCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dedErrCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addrErrCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>discardDupErrAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to configure OCMC ECC Err trace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secErrCnt</td><td>Number of SEC error to trigger an interrupt (Must be &gt; 0 to generate an interrupt) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dedErrCnt</td><td>Number of DED errors to trigger an interrupt (Must be &gt; 0 to generate an interrupt) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrErrCnt</td><td>Number of ADDR errors to trigger an interrupt (Must be &gt; 0 to generate an interrupt) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discardDupErrAddr</td><td>0 : Save even the duplicated addresses 1 : Save only the unique addresses </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aa062bfc5ec874c43cdbc4dc8740a1406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCErrCntStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#a38604649c1d8fe60befe815efbadab56">ocmc_err_cnt_type</a>&#160;</td>
          <td class="paramname"><em>errType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API Returns Error Count for the error type passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errType</td><td>errtype as define in enum ocmc_err_cnt_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error count for the error type passed </dd></dl>

</div>
</div>
<a class="anchor" id="a62169617974b8fdf216a52aecbe0568f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCGetRAMSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to return the size of the OCMC memory in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of OCMC RAM in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a7c5710bf01fb7d723385c29931926161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to disable interrupt for the interrupt flag passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr_group</td><td>Argument to select interrupt group (0 or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>OCMC/ECC interrupt types. These macro can be ORed and passed to disable multiple interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>OCMC_ECC_SEC_ERROR_FOUND OCMC_ECC_DED_ERROR_FOUND OCMC_ECC_ADDR_ERROR_FOUND OCMC_ADDR_OUT_OF_RANGE OCMC_CBUF_VIRT_ADDR_ERROR OCMC_CBUF_WR_OUT_OF_RANGE OCMC_CBUF_WR_VBUF_START_ERR OCMC_CBUF_WR_ADDR_SEQ_ERR OCMC_CBUF_RD_OUT_OF_RANGE OCMC_CBUF_RD_VBUF_START_ERR OCMC_CBUF_RD_ADDR_SEQ_ERR OCMC_CBUF_OVERFLOW_MID_FOUND OCMC_CBUF_OVER_FLOW_WRAP_FOUND OCMC_CBUF_UNDERFLOW OCMC_CBUF_SHORT_FRAME_DETECT OCMC_INTERRUPT_ALL</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a0d0e8a6495db8ce8939f90b7a0ba7c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to enable interrupt for the interrupt flag passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr_group</td><td>Argument to select interrupt group (0 or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>OCMC/ECC interrupt types. These macro can be ORed and passed to enable multiple interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>OCMC_ECC_SEC_ERROR_FOUND OCMC_ECC_DED_ERROR_FOUND OCMC_ECC_ADDR_ERROR_FOUND OCMC_ADDR_OUT_OF_RANGE OCMC_CBUF_VIRT_ADDR_ERROR OCMC_CBUF_WR_OUT_OF_RANGE OCMC_CBUF_WR_VBUF_START_ERR OCMC_CBUF_WR_ADDR_SEQ_ERR OCMC_CBUF_RD_OUT_OF_RANGE OCMC_CBUF_RD_VBUF_START_ERR OCMC_CBUF_RD_ADDR_SEQ_ERR OCMC_CBUF_OVERFLOW_MID_FOUND OCMC_CBUF_OVER_FLOW_WRAP_FOUND OCMC_CBUF_UNDERFLOW OCMC_CBUF_SHORT_FRAME_DETECT OCMC_INTERRUPT_ALL</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ab6fe7363debcba7412c0c060d441edc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCIntEnableGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get enabled interrupt status for the interrupt flag passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr_group</td><td>Argument to select interrupt group (0 or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>OCMC/ECC interrupt types. These macro can be ORed and passed to get multiple interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>OCMC_ECC_SEC_ERROR_FOUND OCMC_ECC_DED_ERROR_FOUND OCMC_ECC_ADDR_ERROR_FOUND OCMC_ADDR_OUT_OF_RANGE OCMC_CBUF_VIRT_ADDR_ERROR OCMC_CBUF_WR_OUT_OF_RANGE OCMC_CBUF_WR_VBUF_START_ERR OCMC_CBUF_WR_ADDR_SEQ_ERR OCMC_CBUF_RD_OUT_OF_RANGE OCMC_CBUF_RD_VBUF_START_ERR OCMC_CBUF_RD_ADDR_SEQ_ERR OCMC_CBUF_OVERFLOW_MID_FOUND OCMC_CBUF_OVER_FLOW_WRAP_FOUND OCMC_CBUF_UNDERFLOW OCMC_CBUF_SHORT_FRAME_DETECT OCMC_INTERRUPT_ALL</p>
<dl class="section return"><dt>Returns</dt><dd>Enabled interrupt status for the intFlag passed </dd></dl>

</div>
</div>
<a class="anchor" id="a194bbb19860653efdcfd15e17c326462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCIntStatusEnableClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to clear the status of generated interrupt for the interrupt flag passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr_group</td><td>Argument to select interrupt group (0 or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>OCMC/ECC interrupt types. These macro can be ORed and passed to clear multiple interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>OCMC_ECC_SEC_ERROR_FOUND OCMC_ECC_DED_ERROR_FOUND OCMC_ECC_ADDR_ERROR_FOUND OCMC_ADDR_OUT_OF_RANGE OCMC_CBUF_VIRT_ADDR_ERROR OCMC_CBUF_WR_OUT_OF_RANGE OCMC_CBUF_WR_VBUF_START_ERR OCMC_CBUF_WR_ADDR_SEQ_ERR OCMC_CBUF_RD_OUT_OF_RANGE OCMC_CBUF_RD_VBUF_START_ERR OCMC_CBUF_RD_ADDR_SEQ_ERR OCMC_CBUF_OVERFLOW_MID_FOUND OCMC_CBUF_OVER_FLOW_WRAP_FOUND OCMC_CBUF_UNDERFLOW OCMC_CBUF_SHORT_FRAME_DETECT OCMC_INTERRUPT_ALL</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="adde11f374acd89f033f2c4719b3e3fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCIntStatusEnableGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get status of generated interrupt for the interrupt flag passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr_group</td><td>Argument to select interrupt group (0 or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>OCMC/ECC interrupt types. These macro can be ORed and passed to get multiple interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>OCMC_ECC_SEC_ERROR_FOUND OCMC_ECC_DED_ERROR_FOUND OCMC_ECC_ADDR_ERROR_FOUND OCMC_ADDR_OUT_OF_RANGE OCMC_CBUF_VIRT_ADDR_ERROR OCMC_CBUF_WR_OUT_OF_RANGE OCMC_CBUF_WR_VBUF_START_ERR OCMC_CBUF_WR_ADDR_SEQ_ERR OCMC_CBUF_RD_OUT_OF_RANGE OCMC_CBUF_RD_VBUF_START_ERR OCMC_CBUF_RD_ADDR_SEQ_ERR OCMC_CBUF_OVERFLOW_MID_FOUND OCMC_CBUF_OVER_FLOW_WRAP_FOUND OCMC_CBUF_UNDERFLOW OCMC_CBUF_SHORT_FRAME_DETECT OCMC_INTERRUPT_ALL</p>
<dl class="section return"><dt>Returns</dt><dd>Interrupt status for the intFlag passed </dd></dl>

</div>
</div>
<a class="anchor" id="a70d3943523648628f46c161ebeb9e6be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCIntStatusRawGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get raw interrupt status for the interrupt flag passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr_group</td><td>Argument to select interrupt group (0 or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>OCMC/ECC interrupt types. These macro can be ORed and passed to get multiple interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>OCMC_ECC_SEC_ERROR_FOUND OCMC_ECC_DED_ERROR_FOUND OCMC_ECC_ADDR_ERROR_FOUND OCMC_ADDR_OUT_OF_RANGE OCMC_CBUF_VIRT_ADDR_ERROR OCMC_CBUF_WR_OUT_OF_RANGE OCMC_CBUF_WR_VBUF_START_ERR OCMC_CBUF_WR_ADDR_SEQ_ERR OCMC_CBUF_RD_OUT_OF_RANGE OCMC_CBUF_RD_VBUF_START_ERR OCMC_CBUF_RD_ADDR_SEQ_ERR OCMC_CBUF_OVERFLOW_MID_FOUND OCMC_CBUF_OVER_FLOW_WRAP_FOUND OCMC_CBUF_UNDERFLOW OCMC_CBUF_SHORT_FRAME_DETECT OCMC_INTERRUPT_ALL</p>
<dl class="section return"><dt>Returns</dt><dd>Interrupt status for the intFlag passed </dd></dl>

</div>
</div>
<a class="anchor" id="a9a41f60b5b7aca12d32528bc2a2752e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCIntStatusRawSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to set raw interrupt status for the interrupt flag passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intr_group</td><td>Argument to select interrupt group (0 or 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>OCMC/ECC interrupt types. These macro can be ORed and passed to set multiple interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>OCMC_ECC_SEC_ERROR_FOUND OCMC_ECC_DED_ERROR_FOUND OCMC_ECC_ADDR_ERROR_FOUND OCMC_ADDR_OUT_OF_RANGE OCMC_CBUF_VIRT_ADDR_ERROR OCMC_CBUF_WR_OUT_OF_RANGE OCMC_CBUF_WR_VBUF_START_ERR OCMC_CBUF_WR_ADDR_SEQ_ERR OCMC_CBUF_RD_OUT_OF_RANGE OCMC_CBUF_RD_VBUF_START_ERR OCMC_CBUF_RD_ADDR_SEQ_ERR OCMC_CBUF_OVERFLOW_MID_FOUND OCMC_CBUF_OVER_FLOW_WRAP_FOUND OCMC_CBUF_UNDERFLOW OCMC_CBUF_SHORT_FRAME_DETECT OCMC_INTERRUPT_ALL</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="abd696b93ad769a9a48e6fe762cc482ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCModeSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#a3bc2f748d3250a6d19798c1ce2926006">ocmc_sysconfig_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to configure OCMC Mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Modes as defined in enum ocmc_sysconfig_mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aafb032812cbbb49c8c81d4f321aeb3f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCOverflowConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>overflow_detect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#ae37af214a62592feb13477ffd6362ca2">ocmc_wr_overflow_handler_t</a>&#160;</td>
          <td class="paramname"><em>overflow_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#ab94f8129cd63e3ef518ef364f3e476ce">ocmc_wr_overflow_reenable_t</a>&#160;</td>
          <td class="paramname"><em>overflow_check_reenable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to configure overflow handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">overflow_detect</td><td>Boolean flag to enable/disable overflow detection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">overflow_handler</td><td>Specify write overflow handler type once an overflow has occurred </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">overflow_check_reenable</td><td>Specify when the write overflow check is to be re-enabled following an overflow</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a9ea0d380c2126b648853cc300ee11a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCRAMBlockEnableCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API enables or disables ECC for the block number passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>enable = 1 enable block enable = 0 disable block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockNum</td><td>block number to be enabled or disabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a674170b8cc7b96d404ea583724859276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCRAMBlockEnableStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API gets status of enable ECC blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Word containing enabled cbuf status </dd></dl>

</div>
</div>
<a class="anchor" id="ac5d8429017946c9e5b2c999d1699cb07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCSecEccErrDistributionStatusGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ocmc__ecc__l1_8h.html#aff13784353d41e5ac76c0073dabebd8b">ocmc_sec_ecc_err_dist_t</a>&#160;</td>
          <td class="paramname"><em>errType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API Returns OCMC SEC data error bit distribution status for the SEC ECC error Distribution Type passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errType</td><td>errtype as define in enum ocmc_ecc_err_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OCMC SEC data error bit distribution status for the SEC ECC error Distribution Type passed </dd></dl>

</div>
</div>
<a class="anchor" id="a8d6e8758d2fa18e173452bdc2d6bef7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCShortFrameDetectEnableCtrl </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>short_frame_detect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prev_eof_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to enable/disable int16_t frame detect, and also specify prev_eof selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">short_frame_detect</td><td>Boolean flag to enable/disable int16_t frame detection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prev_eof_sel</td><td>Boolean flag to specify prev_eof history</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a7ae0220aacac57c59a803322326930bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCSoftReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to soft-reset entire OCMC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ae0d2087e7d631f259c384e9621a0eb5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCUnderflowConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>underflow_detect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>underflow_last_cbuf_slice_disable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to configure underflow handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">underflow_detect</td><td>Boolean flag to enable/disable underflow detection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">underflow_last_cbuf_slice_disable</td><td>Specify if underflow check is on at last cbuf slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a8748363e4a4f4601cb50571331245cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCVBufEndAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get virtual buffer end address for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Virtual buffer end address for the buffer id passed </dd></dl>

</div>
</div>
<a class="anchor" id="aa21436758b0a7ac09191d9de1a21e7f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCVBufEndAddrSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga2bda956bb280aa28a0eb3c18788e72c5">ocmc_addr_t</a>&#160;</td>
          <td class="paramname"><em>vbuf_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to set virtual buffer end address for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vbuf_end</td><td>virtual buffer end address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a652df5a50171f9f4f481bab100431382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t OCMCVBufStartAddrGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get virtual buffer start address for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Virtual buffer start address for the buffer id passed </dd></dl>

</div>
</div>
<a class="anchor" id="ac3a895493698a0c62ce0a0c4900babee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OCMCVBufStartAddrSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga43d474b24274a293377242f16445a870">ocmc_buf_id_t</a>&#160;</td>
          <td class="paramname"><em>buf_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___o_c_m_c___e_c_c___l1.html#ga2bda956bb280aa28a0eb3c18788e72c5">ocmc_addr_t</a>&#160;</td>
          <td class="paramname"><em>vbuf_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to set virtual buffer start address for the buffer id passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseAddr</td><td>OCMC Instance baseAddr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_id</td><td>Buffer Id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vbuf_start</td><td>virtual buffer start address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
