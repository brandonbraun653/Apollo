<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EPWM</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EPWM<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_timebase_cfg.html">CSL_EpwmTimebaseCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the TimeBase sub-module configuration parameters.  <a href="struct_c_s_l___epwm_timebase_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_counter_cmp_cfg.html">CSL_EpwmCounterCmpCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Counter Comparator values.  <a href="struct_c_s_l___epwm_counter_cmp_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_aq_action_cfg.html">CSL_EpwmAqActionCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Action Qualifier actions to be taken on the PWM output at the specific events.  <a href="struct_c_s_l___epwm_aq_action_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_deadband_cfg.html">CSL_EpwmDeadbandCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the dead band generation sub-module configuration parameters.  <a href="struct_c_s_l___epwm_deadband_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_chopper_cfg.html">CSL_EpwmChopperCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the configuration parameters of Chopper sub-module.  <a href="struct_c_s_l___epwm_chopper_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_tripzone_cfg.html">CSL_EpwmTripzoneCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the trip-zone sub-module configuration parameters.  <a href="struct_c_s_l___epwm_tripzone_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_et_cfg.html">CSL_EpwmEtCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Event Trigger Sub-Module configuration parameters.  <a href="struct_c_s_l___epwm_et_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_high_resolution_cfg.html">CSL_EpwmHighResolutionCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the configuration parameters of high resolution pwm pulse generation sub module.  <a href="struct_c_s_l___epwm_high_resolution_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadf4da9ae0133524b06dcbc6332a1efdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf4da9ae0133524b06dcbc6332a1efdf"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_timebase_cfg.html">CSL_EpwmTimebaseCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gadf4da9ae0133524b06dcbc6332a1efdf">CSL_EpwmTimebaseCfg_t</a></td></tr>
<tr class="memdesc:gadf4da9ae0133524b06dcbc6332a1efdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the TimeBase sub-module configuration parameters. <br /></td></tr>
<tr class="separator:gadf4da9ae0133524b06dcbc6332a1efdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949100d20e14bbdb72a0e905855385d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga949100d20e14bbdb72a0e905855385d1"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_counter_cmp_cfg.html">CSL_EpwmCounterCmpCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga949100d20e14bbdb72a0e905855385d1">CSL_EpwmCounterCmpCfg_t</a></td></tr>
<tr class="memdesc:ga949100d20e14bbdb72a0e905855385d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Counter Comparator values. <br /></td></tr>
<tr class="separator:ga949100d20e14bbdb72a0e905855385d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3bc020da4d3d9c9c13d5259e44e2ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa3bc020da4d3d9c9c13d5259e44e2ad"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_aq_action_cfg.html">CSL_EpwmAqActionCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaaa3bc020da4d3d9c9c13d5259e44e2ad">CSL_EpwmAqActionCfg_t</a></td></tr>
<tr class="memdesc:gaaa3bc020da4d3d9c9c13d5259e44e2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Action Qualifier actions to be taken on the PWM output at the specific events. <br /></td></tr>
<tr class="separator:gaaa3bc020da4d3d9c9c13d5259e44e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4201245ce28a464ac9e1493d06f19f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4201245ce28a464ac9e1493d06f19f9"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_deadband_cfg.html">CSL_EpwmDeadbandCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad4201245ce28a464ac9e1493d06f19f9">CSL_EpwmDeadbandCfg_t</a></td></tr>
<tr class="memdesc:gad4201245ce28a464ac9e1493d06f19f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the dead band generation sub-module configuration parameters. <br /></td></tr>
<tr class="separator:gad4201245ce28a464ac9e1493d06f19f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494e3bbf20e23cebda4ffb422961c7ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga494e3bbf20e23cebda4ffb422961c7ba"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_chopper_cfg.html">CSL_EpwmChopperCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga494e3bbf20e23cebda4ffb422961c7ba">CSL_EpwmChopperCfg_t</a></td></tr>
<tr class="memdesc:ga494e3bbf20e23cebda4ffb422961c7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the configuration parameters of Chopper sub-module. <br /></td></tr>
<tr class="separator:ga494e3bbf20e23cebda4ffb422961c7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb7ffc02fe32205386e610e8997665e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb7ffc02fe32205386e610e8997665e8"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_tripzone_cfg.html">CSL_EpwmTripzoneCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaeb7ffc02fe32205386e610e8997665e8">CSL_EpwmTripzoneCfg_t</a></td></tr>
<tr class="memdesc:gaeb7ffc02fe32205386e610e8997665e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the trip-zone sub-module configuration parameters. <br /></td></tr>
<tr class="separator:gaeb7ffc02fe32205386e610e8997665e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ef90980865a22194ee0995c165b834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89ef90980865a22194ee0995c165b834"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_et_cfg.html">CSL_EpwmEtCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga89ef90980865a22194ee0995c165b834">CSL_EpwmEtCfg_t</a></td></tr>
<tr class="memdesc:ga89ef90980865a22194ee0995c165b834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Event Trigger Sub-Module configuration parameters. <br /></td></tr>
<tr class="separator:ga89ef90980865a22194ee0995c165b834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00bea47184b64be843a9a1f427b8579"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa00bea47184b64be843a9a1f427b8579"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_high_resolution_cfg.html">CSL_EpwmHighResolutionCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa00bea47184b64be843a9a1f427b8579">CSL_EpwmHighResolutionCfg_t</a></td></tr>
<tr class="memdesc:gaa00bea47184b64be843a9a1f427b8579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the configuration parameters of high resolution pwm pulse generation sub module. <br /></td></tr>
<tr class="separator:gaa00bea47184b64be843a9a1f427b8579"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaccc86de57b0138e374b106003c07fdf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaccc86de57b0138e374b106003c07fdf6">CSL_epwmTbTimebaseClkCfg</a> (uint32_t baseAddr, uint32_t tbClk, uint32_t moduleClk)</td></tr>
<tr class="memdesc:gaccc86de57b0138e374b106003c07fdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the clock divider of the Time base module.  <a href="#gaccc86de57b0138e374b106003c07fdf6">More...</a><br /></td></tr>
<tr class="separator:gaccc86de57b0138e374b106003c07fdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa6c5056eb541841419c7e6a3160717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1fa6c5056eb541841419c7e6a3160717">CSL_epwmTbPwmFreqCfg</a> (uint32_t baseAddr, uint32_t tbClk, uint32_t pwmFreq, uint32_t counterDir, uint32_t enableShadowWrite)</td></tr>
<tr class="memdesc:ga1fa6c5056eb541841419c7e6a3160717"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the PWM Time base counter Frequency/Period.  <a href="#ga1fa6c5056eb541841419c7e6a3160717">More...</a><br /></td></tr>
<tr class="separator:ga1fa6c5056eb541841419c7e6a3160717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a7f77c01cb831a7935fdfd6e766091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga94a7f77c01cb831a7935fdfd6e766091">CSL_epwmTbSyncEnable</a> (uint32_t baseAddr, uint32_t tbPhsValue, uint32_t counterDir)</td></tr>
<tr class="memdesc:ga94a7f77c01cb831a7935fdfd6e766091"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the synchronization of time base sub-module and also configures the phase count value to be loaded after sync event, counter direction after sync event.  <a href="#ga94a7f77c01cb831a7935fdfd6e766091">More...</a><br /></td></tr>
<tr class="separator:ga94a7f77c01cb831a7935fdfd6e766091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f4c56932cad3819d7cc735c4695fd28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga8f4c56932cad3819d7cc735c4695fd28">CSL_epwmTbSyncDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga8f4c56932cad3819d7cc735c4695fd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the synchronization. Even if sync-in event occurs the count value will not be reloaded.  <a href="#ga8f4c56932cad3819d7cc735c4695fd28">More...</a><br /></td></tr>
<tr class="separator:ga8f4c56932cad3819d7cc735c4695fd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1783f1d4e175c768ed350467659065ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1783f1d4e175c768ed350467659065ca">CSL_epwmTbSetSyncOutMode</a> (uint32_t baseAddr, uint32_t syncOutMode)</td></tr>
<tr class="memdesc:ga1783f1d4e175c768ed350467659065ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API selects the source of the synchronization output signal. It determines on which of the supported events sync-out has to be generated.  <a href="#ga1783f1d4e175c768ed350467659065ca">More...</a><br /></td></tr>
<tr class="separator:ga1783f1d4e175c768ed350467659065ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b88fd8c50ffc905cea62f8bf9dc1598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga9b88fd8c50ffc905cea62f8bf9dc1598">CSL_epwmTbTriggerSwSync</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga9b88fd8c50ffc905cea62f8bf9dc1598"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API generates software triggered sync pulse.  <a href="#ga9b88fd8c50ffc905cea62f8bf9dc1598">More...</a><br /></td></tr>
<tr class="separator:ga9b88fd8c50ffc905cea62f8bf9dc1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3602d386ffb1b55d7cb6660e5b878d8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga3602d386ffb1b55d7cb6660e5b878d8c">CSL_epwmTbWriteTbCount</a> (uint32_t baseAddr, uint32_t tbCount)</td></tr>
<tr class="memdesc:ga3602d386ffb1b55d7cb6660e5b878d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API loads the Time base counter. The new value is taken immediately.  <a href="#ga3602d386ffb1b55d7cb6660e5b878d8c">More...</a><br /></td></tr>
<tr class="separator:ga3602d386ffb1b55d7cb6660e5b878d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3debb795a5a3c567ff4a5f6f2fb3a564"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga3debb795a5a3c567ff4a5f6f2fb3a564">CSL_epwmTbReadTbCount</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga3debb795a5a3c567ff4a5f6f2fb3a564"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the Time base counter current value. The count operation is not affected by the read.  <a href="#ga3debb795a5a3c567ff4a5f6f2fb3a564">More...</a><br /></td></tr>
<tr class="separator:ga3debb795a5a3c567ff4a5f6f2fb3a564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7071efede364ce48b46fcc63ed44c325"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7071efede364ce48b46fcc63ed44c325">CSL_epwmTbGetStatus</a> (uint32_t baseAddr, uint32_t tbStatusMask)</td></tr>
<tr class="memdesc:ga7071efede364ce48b46fcc63ed44c325"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the Time Base status as indicated by the tbStatusMask parameter.  <a href="#ga7071efede364ce48b46fcc63ed44c325">More...</a><br /></td></tr>
<tr class="separator:ga7071efede364ce48b46fcc63ed44c325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00629ad2136740cb2fc5a5ac3db12d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga00629ad2136740cb2fc5a5ac3db12d1b">CSL_epwmTbStatusClear</a> (uint32_t baseAddr, uint32_t tbStatusClrMask)</td></tr>
<tr class="memdesc:ga00629ad2136740cb2fc5a5ac3db12d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the Time base status bits indicated by the tbStatusClrMask parameter.  <a href="#ga00629ad2136740cb2fc5a5ac3db12d1b">More...</a><br /></td></tr>
<tr class="separator:ga00629ad2136740cb2fc5a5ac3db12d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe04ef2e88a21414b917aa167c68407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaefe04ef2e88a21414b917aa167c68407">CSL_epwmTbSetEmulationMode</a> (uint32_t baseAddr, uint32_t mode)</td></tr>
<tr class="memdesc:gaefe04ef2e88a21414b917aa167c68407"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures emulation mode. This setting determines the behaviour of Timebase counter during emulation (debugging).  <a href="#gaefe04ef2e88a21414b917aa167c68407">More...</a><br /></td></tr>
<tr class="separator:gaefe04ef2e88a21414b917aa167c68407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbfb18a2d74589338daee3a6a134755c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabbfb18a2d74589338daee3a6a134755c">CSL_epwmCounterComparatorCfg</a> (uint32_t baseAddr, uint32_t cmpType, uint32_t cmpVal, uint32_t enableShadowWrite, uint32_t shadowToActiveLoadTrigger, uint32_t overwriteShadow)</td></tr>
<tr class="memdesc:gabbfb18a2d74589338daee3a6a134755c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the counter comparator and loads the comparator value. When Counter comparator value equals the counter value, then an event is generated both in the up direction and down direction.  <a href="#gabbfb18a2d74589338daee3a6a134755c">More...</a><br /></td></tr>
<tr class="separator:gabbfb18a2d74589338daee3a6a134755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc5067aa5e5a90ee10b896dd912a7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1fc5067aa5e5a90ee10b896dd912a7d2">CSL_epwmAqActionOnOutputCfg</a> (uint32_t baseAddr, uint32_t pwmOutputCh, const <a class="el" href="group___c_s_l___e_p_w_m.html#gaaa3bc020da4d3d9c9c13d5259e44e2ad">CSL_EpwmAqActionCfg_t</a> *pCfg)</td></tr>
<tr class="memdesc:ga1fc5067aa5e5a90ee10b896dd912a7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the action to be taken on output by the Action qualifier module upon receiving the events. This will determine the output waveform.  <a href="#ga1fc5067aa5e5a90ee10b896dd912a7d2">More...</a><br /></td></tr>
<tr class="separator:ga1fc5067aa5e5a90ee10b896dd912a7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94dcc6812f81713d1de771192f25996f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga94dcc6812f81713d1de771192f25996f">CSL_epwmAqSwTriggerOneTimeAction</a> (uint32_t baseAddr, uint32_t pwmOutputCh, uint32_t swTrigAction)</td></tr>
<tr class="memdesc:ga94dcc6812f81713d1de771192f25996f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API triggers the SW forced single event on the PWM output.  <a href="#ga94dcc6812f81713d1de771192f25996f">More...</a><br /></td></tr>
<tr class="separator:ga94dcc6812f81713d1de771192f25996f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab659bf7153e07a716955b1041a83b7e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab659bf7153e07a716955b1041a83b7e0">CSL_epwmAqSwTriggerContAction</a> (uint32_t baseAddr, uint32_t pwmOutputCh, uint32_t swTrigAction, uint32_t activeRegReloadMode)</td></tr>
<tr class="memdesc:gab659bf7153e07a716955b1041a83b7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API forces output value continuously on PWM output channel. The output can be forced to low or high.  <a href="#gab659bf7153e07a716955b1041a83b7e0">More...</a><br /></td></tr>
<tr class="separator:gab659bf7153e07a716955b1041a83b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c5cc1dc58a505405457936ad6f39042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0c5cc1dc58a505405457936ad6f39042">CSL_epwmDeadbandCfg</a> (uint32_t baseAddr, const <a class="el" href="group___c_s_l___e_p_w_m.html#gad4201245ce28a464ac9e1493d06f19f9">CSL_EpwmDeadbandCfg_t</a> *pCfg)</td></tr>
<tr class="memdesc:ga0c5cc1dc58a505405457936ad6f39042"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API performs the configuration of the dead band sub-module. This API configures the input source, output mode, polarity, rising and falling edge delays.  <a href="#ga0c5cc1dc58a505405457936ad6f39042">More...</a><br /></td></tr>
<tr class="separator:ga0c5cc1dc58a505405457936ad6f39042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab645593e6d1a96dfabe0abe10123c067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab645593e6d1a96dfabe0abe10123c067">CSL_epwmDeadbandBypass</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gab645593e6d1a96dfabe0abe10123c067"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API bypasses the Dead-band sub-module.  <a href="#gab645593e6d1a96dfabe0abe10123c067">More...</a><br /></td></tr>
<tr class="separator:gab645593e6d1a96dfabe0abe10123c067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12f7f88391a3459181789d911f8184b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae12f7f88391a3459181789d911f8184b">CSL_epwmChopperCfg</a> (uint32_t baseAddr, const <a class="el" href="group___c_s_l___e_p_w_m.html#ga494e3bbf20e23cebda4ffb422961c7ba">CSL_EpwmChopperCfg_t</a> *pCfg)</td></tr>
<tr class="memdesc:gae12f7f88391a3459181789d911f8184b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API performs the configuration of the chopper sub-module. This API configures chopping clock duty cycle, chopping clock frequency and pulse width of first pulse of chopping clock.  <a href="#gae12f7f88391a3459181789d911f8184b">More...</a><br /></td></tr>
<tr class="separator:gae12f7f88391a3459181789d911f8184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04dd41f4f5a88637ec8927237ee5b14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga04dd41f4f5a88637ec8927237ee5b14c">CSL_epwmChopperEnable</a> (uint32_t baseAddr, uint32_t enableChopper)</td></tr>
<tr class="memdesc:ga04dd41f4f5a88637ec8927237ee5b14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls the enabling or disabling of chopper sub-module.  <a href="#ga04dd41f4f5a88637ec8927237ee5b14c">More...</a><br /></td></tr>
<tr class="separator:ga04dd41f4f5a88637ec8927237ee5b14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65025ed62bdb842f6a520c83a7cfac19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga65025ed62bdb842f6a520c83a7cfac19">CSL_epwmTzTriggerTripAction</a> (uint32_t baseAddr, uint32_t tripAction, uint32_t pwmOutputCh)</td></tr>
<tr class="memdesc:ga65025ed62bdb842f6a520c83a7cfac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the o/p on PWM channel when a trip event is recognized. The output can be set to high or low or high impedance.  <a href="#ga65025ed62bdb842f6a520c83a7cfac19">More...</a><br /></td></tr>
<tr class="separator:ga65025ed62bdb842f6a520c83a7cfac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a425c0124749de1ab5e877f2f529491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7a425c0124749de1ab5e877f2f529491">CSL_epwmTzTripEventEnable</a> (uint32_t baseAddr, uint32_t tzEventType, uint32_t pinNum)</td></tr>
<tr class="memdesc:ga7a425c0124749de1ab5e877f2f529491"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the trip event.  <a href="#ga7a425c0124749de1ab5e877f2f529491">More...</a><br /></td></tr>
<tr class="separator:ga7a425c0124749de1ab5e877f2f529491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2360ef51b088052085727d89752bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0b2360ef51b088052085727d89752bb9">CSL_epwmTzTripEventDisable</a> (uint32_t baseAddr, uint32_t tzEventType, uint32_t pinNum)</td></tr>
<tr class="memdesc:ga0b2360ef51b088052085727d89752bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disable the trip event. The disabled trip events will be ignored.  <a href="#ga0b2360ef51b088052085727d89752bb9">More...</a><br /></td></tr>
<tr class="separator:ga0b2360ef51b088052085727d89752bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174736f224abc925a0474a5ee48c5552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga174736f224abc925a0474a5ee48c5552">CSL_epwmTzIntrEnable</a> (uint32_t baseAddr, uint32_t tzEventType)</td></tr>
<tr class="memdesc:ga174736f224abc925a0474a5ee48c5552"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the trip interrupt. When trip event occurs the sub-module can be configured to interrupt CPU.  <a href="#ga174736f224abc925a0474a5ee48c5552">More...</a><br /></td></tr>
<tr class="separator:ga174736f224abc925a0474a5ee48c5552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8cead002b55aad5f7346e1a192cbba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaea8cead002b55aad5f7346e1a192cbba">CSL_epwmTzIntrDisable</a> (uint32_t baseAddr, uint32_t tzEventType)</td></tr>
<tr class="memdesc:gaea8cead002b55aad5f7346e1a192cbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the trip interrupt.  <a href="#gaea8cead002b55aad5f7346e1a192cbba">More...</a><br /></td></tr>
<tr class="separator:gaea8cead002b55aad5f7346e1a192cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33ecda8dfa28260ef573327fd1e0822"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae33ecda8dfa28260ef573327fd1e0822">CSL_epwmTzEventStatus</a> (uint32_t baseAddr, uint32_t eventMask)</td></tr>
<tr class="memdesc:gae33ecda8dfa28260ef573327fd1e0822"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the selected trip zone event status.  <a href="#gae33ecda8dfa28260ef573327fd1e0822">More...</a><br /></td></tr>
<tr class="separator:gae33ecda8dfa28260ef573327fd1e0822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76cff74a105d8bbd78350d8f1367dc86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga76cff74a105d8bbd78350d8f1367dc86">CSL_epwmTzEventStatusClear</a> (uint32_t baseAddr, uint32_t eventMask)</td></tr>
<tr class="memdesc:ga76cff74a105d8bbd78350d8f1367dc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the selected trip zone event status.  <a href="#ga76cff74a105d8bbd78350d8f1367dc86">More...</a><br /></td></tr>
<tr class="separator:ga76cff74a105d8bbd78350d8f1367dc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad424481c3b6ba56fd734c942efd81075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad424481c3b6ba56fd734c942efd81075">CSL_epwmTzTriggerSwEvent</a> (uint32_t baseAddr, uint32_t tzEventType)</td></tr>
<tr class="memdesc:gad424481c3b6ba56fd734c942efd81075"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables to generate Software forced trip condition.  <a href="#gad424481c3b6ba56fd734c942efd81075">More...</a><br /></td></tr>
<tr class="separator:gad424481c3b6ba56fd734c942efd81075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74eb5ae3c209861ea82d0ed0fdc7f470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga74eb5ae3c209861ea82d0ed0fdc7f470">CSL_epwmEtIntrCfg</a> (uint32_t baseAddr, uint32_t intrEvtSrc, uint32_t intrPrd)</td></tr>
<tr class="memdesc:ga74eb5ae3c209861ea82d0ed0fdc7f470"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the Event Trigger sub-module. This API configures the interrupt source and interrupt period.  <a href="#ga74eb5ae3c209861ea82d0ed0fdc7f470">More...</a><br /></td></tr>
<tr class="separator:ga74eb5ae3c209861ea82d0ed0fdc7f470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae500d137bbc0d0fdfc2586081f68f24d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae500d137bbc0d0fdfc2586081f68f24d">CSL_epwmEtIntrEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gae500d137bbc0d0fdfc2586081f68f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the ePWM Event interrupt.  <a href="#gae500d137bbc0d0fdfc2586081f68f24d">More...</a><br /></td></tr>
<tr class="separator:gae500d137bbc0d0fdfc2586081f68f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e5ad7cd49e5b96face61a0a9258f27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga13e5ad7cd49e5b96face61a0a9258f27">CSL_epwmEtIntrDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga13e5ad7cd49e5b96face61a0a9258f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the ePWM Event interrupt.  <a href="#ga13e5ad7cd49e5b96face61a0a9258f27">More...</a><br /></td></tr>
<tr class="separator:ga13e5ad7cd49e5b96face61a0a9258f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3da844c980fb123495fa49b1b0657c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga5c3da844c980fb123495fa49b1b0657c">CSL_epwmEtIntrStatus</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga5c3da844c980fb123495fa49b1b0657c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the ePWM event interrupt status.  <a href="#ga5c3da844c980fb123495fa49b1b0657c">More...</a><br /></td></tr>
<tr class="separator:ga5c3da844c980fb123495fa49b1b0657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24fe4e9590ee1541fcba7291c4d723e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac24fe4e9590ee1541fcba7291c4d723e">CSL_epwmEtIntrClear</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gac24fe4e9590ee1541fcba7291c4d723e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the interrupt. This will clear the interrupt flag bit and enable further interrupts pulses to be generated.  <a href="#gac24fe4e9590ee1541fcba7291c4d723e">More...</a><br /></td></tr>
<tr class="separator:gac24fe4e9590ee1541fcba7291c4d723e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17259d0151ecfee6757522aab0b4495"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae17259d0151ecfee6757522aab0b4495">CSL_epwmEtIntrTrigger</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gae17259d0151ecfee6757522aab0b4495"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API forces interrupt to be generated. This API is used for testing purpose.  <a href="#gae17259d0151ecfee6757522aab0b4495">More...</a><br /></td></tr>
<tr class="separator:gae17259d0151ecfee6757522aab0b4495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2bd0a2f385993fb695645bd6c3d25e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga4c2bd0a2f385993fb695645bd6c3d25e">CSL_epwmEtGetEventCount</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga4c2bd0a2f385993fb695645bd6c3d25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the number of events occurred.  <a href="#ga4c2bd0a2f385993fb695645bd6c3d25e">More...</a><br /></td></tr>
<tr class="separator:ga4c2bd0a2f385993fb695645bd6c3d25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5e58e92df08aa7ae5b9377e6e11850"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga5a5e58e92df08aa7ae5b9377e6e11850">CSL_epwmHighResolutionCfg</a> (uint32_t baseAddr, uint32_t ctrlMode, uint32_t mepCtrlEdge)</td></tr>
<tr class="memdesc:ga5a5e58e92df08aa7ae5b9377e6e11850"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures control mode and edge mode of high resolution sub-module. In also enables the HR sub-module.  <a href="#ga5a5e58e92df08aa7ae5b9377e6e11850">More...</a><br /></td></tr>
<tr class="separator:ga5a5e58e92df08aa7ae5b9377e6e11850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b6c9b6b308290a2b0f47b437d447f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga2b6c9b6b308290a2b0f47b437d447f9a">CSL_epwmHrLoadTbPhaseHrValue</a> (uint32_t baseAddr, uint32_t tbPhsHighResVal)</td></tr>
<tr class="memdesc:ga2b6c9b6b308290a2b0f47b437d447f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API loads the Timebase Phase high resolution register value.  <a href="#ga2b6c9b6b308290a2b0f47b437d447f9a">More...</a><br /></td></tr>
<tr class="separator:ga2b6c9b6b308290a2b0f47b437d447f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36291f05e628fb8b89523dc1e8dfff7d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga36291f05e628fb8b89523dc1e8dfff7d">CSL_epwmHrLoadCmpAHrValue</a> (uint32_t baseAddr, uint32_t compAHighResVal, uint32_t ShadowToActiveLoadTrigger)</td></tr>
<tr class="memdesc:ga36291f05e628fb8b89523dc1e8dfff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API loads Counter-Comparator A high resolution value and also configure the pulse select bits, that select which pulse to use for timing events in the HRPWM module.  <a href="#ga36291f05e628fb8b89523dc1e8dfff7d">More...</a><br /></td></tr>
<tr class="separator:ga36291f05e628fb8b89523dc1e8dfff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06b989c821cddc4ff43926f769614ed"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa06b989c821cddc4ff43926f769614ed">CSL_epwmHighResolutionDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaa06b989c821cddc4ff43926f769614ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the high-resolution feature of ePWM.  <a href="#gaa06b989c821cddc4ff43926f769614ed">More...</a><br /></td></tr>
<tr class="separator:gaa06b989c821cddc4ff43926f769614ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83fac9bc328de6de99dc2154f0f895d6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga83fac9bc328de6de99dc2154f0f895d6">CSL_epwmClockEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga83fac9bc328de6de99dc2154f0f895d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions enables clock for EPWM module in PWM subsystem.  <a href="#ga83fac9bc328de6de99dc2154f0f895d6">More...</a><br /></td></tr>
<tr class="separator:ga83fac9bc328de6de99dc2154f0f895d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a03b4b23292be66294e87e374e640a9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6a03b4b23292be66294e87e374e640a9">CSL_epwmClockDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga6a03b4b23292be66294e87e374e640a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions disables clock for EPWM sub-module in the PWM subsystem.  <a href="#ga6a03b4b23292be66294e87e374e640a9">More...</a><br /></td></tr>
<tr class="separator:ga6a03b4b23292be66294e87e374e640a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Output Channel</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfc8e65809f5a4d57229d8246a319ab21"></a><a class="anchor" id="CSL_EpwmOutputCh_t"></a></p>
</td></tr>
<tr class="memitem:ga67c6393a7b0407c0b00d9cf76845a983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67c6393a7b0407c0b00d9cf76845a983"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga67c6393a7b0407c0b00d9cf76845a983">CSL_EpwmOutputCh_t</a></td></tr>
<tr class="memdesc:ga67c6393a7b0407c0b00d9cf76845a983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported EPWM outputs in a single epwm channel. <br /></td></tr>
<tr class="separator:ga67c6393a7b0407c0b00d9cf76845a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec672943ec79f8fb3a0342bec99ab7fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaec672943ec79f8fb3a0342bec99ab7fc">CSL_EPWM_OUTPUT_CH_MIN</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:gaec672943ec79f8fb3a0342bec99ab7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2326cce479b910b21928e58080cb4869"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga2326cce479b910b21928e58080cb4869">CSL_EPWM_OUTPUT_CH_A</a>&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#gaec672943ec79f8fb3a0342bec99ab7fc">CSL_EPWM_OUTPUT_CH_MIN</a>)</td></tr>
<tr class="separator:ga2326cce479b910b21928e58080cb4869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e15752c66632890e97d3b0c2b0627a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga15e15752c66632890e97d3b0c2b0627a">CSL_EPWM_OUTPUT_CH_B</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ga15e15752c66632890e97d3b0c2b0627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389cc04f50ac2e37ac4229d4f1ba8960"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga389cc04f50ac2e37ac4229d4f1ba8960">CSL_EPWM_OUTPUT_CH_MAX</a>&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga15e15752c66632890e97d3b0c2b0627a">CSL_EPWM_OUTPUT_CH_B</a>)</td></tr>
<tr class="separator:ga389cc04f50ac2e37ac4229d4f1ba8960"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Tb Counter Direction</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb1bb055cf10ab5cfcef1807891607886"></a><a class="anchor" id="CSL_EpwmTbCounterDir_t"></a></p>
</td></tr>
<tr class="memitem:ga6d860cbfc585fd38ec5dc313a57b2bd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d860cbfc585fd38ec5dc313a57b2bd7"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6d860cbfc585fd38ec5dc313a57b2bd7">CSL_EpwmTbCounterDir_t</a></td></tr>
<tr class="memdesc:ga6d860cbfc585fd38ec5dc313a57b2bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Time base counter direction modes. <br /></td></tr>
<tr class="separator:ga6d860cbfc585fd38ec5dc313a57b2bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f7570f593be6c1b9d7d0e165f0c9b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad9f7570f593be6c1b9d7d0e165f0c9b2">CSL_EPWM_TB_COUNTER_DIR_UP</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_CTRMODE_UP_COUNT)</td></tr>
<tr class="separator:gad9f7570f593be6c1b9d7d0e165f0c9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea3897fdd5d4b52b992040fdb41f034"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gadea3897fdd5d4b52b992040fdb41f034">CSL_EPWM_TB_COUNTER_DIR_DOWN</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_CTRMODE_DOWN_COUNT)</td></tr>
<tr class="separator:gadea3897fdd5d4b52b992040fdb41f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8fb19e09f24903c5e002a7731b2ccfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa8fb19e09f24903c5e002a7731b2ccfb">CSL_EPWM_TB_COUNTER_DIR_UP_DOWN</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_CTRMODE_UP_DOWN_COUNT)</td></tr>
<tr class="separator:gaa8fb19e09f24903c5e002a7731b2ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6898fb3b5a8668eff093d6fb9c5d6159"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6898fb3b5a8668eff093d6fb9c5d6159">CSL_EPWM_TB_COUNTER_DIR_STOP</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_CTRMODE_STOP_FREEZE)</td></tr>
<tr class="separator:ga6898fb3b5a8668eff093d6fb9c5d6159"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Shadow register Control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc39b8963189b1824973b765629d1edba"></a><a class="anchor" id="CSL_EpwmShadowRegCtrl_t"></a></p>
</td></tr>
<tr class="memitem:ga4af92ad6f2f6690f974917168ba10c6d"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga4af92ad6f2f6690f974917168ba10c6d">CSL_EpwmShadowRegCtrl_t</a></td></tr>
<tr class="memdesc:ga4af92ad6f2f6690f974917168ba10c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow register enable or disable control.  <a href="#ga4af92ad6f2f6690f974917168ba10c6d">More...</a><br /></td></tr>
<tr class="separator:ga4af92ad6f2f6690f974917168ba10c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d943145882309b498a8accac1e26cfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga3d943145882309b498a8accac1e26cfb">CSL_EPWM_SHADOW_REG_CTRL_ENABLE</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_PRDLD_LOAD_FROM_SHADOW)</td></tr>
<tr class="separator:ga3d943145882309b498a8accac1e26cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcded6c044417a0c604f64725d2e21e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gafcded6c044417a0c604f64725d2e21e5">CSL_EPWM_SHADOW_REG_CTRL_DISABLE</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_PRDLD_LOAD_IMMEDIATELY)</td></tr>
<tr class="separator:gafcded6c044417a0c604f64725d2e21e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Counter directions after sync event</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1b7d75a12e121f927c2f320c14c326c7"></a><a class="anchor" id="CSL_EpwmTbCntDirAftSync_t"></a></p>
</td></tr>
<tr class="memitem:ga17612511be7a1866a543c264d036b0a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga17612511be7a1866a543c264d036b0a8"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga17612511be7a1866a543c264d036b0a8">CSL_EpwmTbCntDirAftSync_t</a></td></tr>
<tr class="memdesc:ga17612511be7a1866a543c264d036b0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter directions after sync event. <br /></td></tr>
<tr class="separator:ga17612511be7a1866a543c264d036b0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46718c7834d835d2787923fe2c843cb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga46718c7834d835d2787923fe2c843cb3">CSL_EPWM_TB_CNT_DIR_AFT_SYNC_DOWN</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_PHSDIR_COUNT_DOWN)</td></tr>
<tr class="separator:ga46718c7834d835d2787923fe2c843cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8e13599754bd2bca03cd2918d8104e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gadc8e13599754bd2bca03cd2918d8104e">CSL_EPWM_TB_CNT_DIR_AFT_SYNC_UP</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_PHSDIR_COUNT_UP)</td></tr>
<tr class="separator:gadc8e13599754bd2bca03cd2918d8104e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Source of Synchronization output signal</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2bd3ba666b3791925a8da48538e704ed"></a><a class="anchor" id="CSL_EpwmTbSyncOutEvt_t"></a></p>
</td></tr>
<tr class="memitem:ga0da2edc68dac48190d3c1e8521897e22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0da2edc68dac48190d3c1e8521897e22"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0da2edc68dac48190d3c1e8521897e22">CSL_EpwmTbSyncOutEvt_t</a></td></tr>
<tr class="memdesc:ga0da2edc68dac48190d3c1e8521897e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source of Synchronization output signal. <br /></td></tr>
<tr class="separator:ga0da2edc68dac48190d3c1e8521897e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1724908c9552f6e7ebd31454791d9c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae1724908c9552f6e7ebd31454791d9c1">CSL_EPWM_TB_SYNC_OUT_EVT_SYNCIN</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_SYNCOSEL_EPWMXSYNC)</td></tr>
<tr class="separator:gae1724908c9552f6e7ebd31454791d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3229782686f3e1b6d823317d5227a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0c3229782686f3e1b6d823317d5227a4">CSL_EPWM_TB_SYNC_OUT_EVT_CNT_EQ_ZERO</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_SYNCOSEL_CTR_0)</td></tr>
<tr class="separator:ga0c3229782686f3e1b6d823317d5227a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga507266728005582735b491d7efab89ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga507266728005582735b491d7efab89ef">CSL_EPWM_TB_SYNC_OUT_EVT_CNT_EQ_CMP_B</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_SYNCOSEL_CTR_CPMB)</td></tr>
<tr class="separator:ga507266728005582735b491d7efab89ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2770de6ef4dbdb8839e2043c5d7791"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga5c2770de6ef4dbdb8839e2043c5d7791">CSL_EPWM_TB_SYNC_OUT_EVT_DISABLE</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_SYNCOSEL_DISABLE_EPWMXSYNCO)</td></tr>
<tr class="separator:ga5c2770de6ef4dbdb8839e2043c5d7791"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Flags to get the different types of time base status</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp465f2f632db5e934ffafc773d5a33338"></a><a class="anchor" id="CSL_EpwmTbSts_t"></a></p>
</td></tr>
<tr class="memitem:ga723c0cd8460ee8ce21a79f1c7997ecee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga723c0cd8460ee8ce21a79f1c7997ecee"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga723c0cd8460ee8ce21a79f1c7997ecee">CSL_EpwmTbSts_t</a></td></tr>
<tr class="memdesc:ga723c0cd8460ee8ce21a79f1c7997ecee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to get the different types of time base status. <br /></td></tr>
<tr class="separator:ga723c0cd8460ee8ce21a79f1c7997ecee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b99bd82535f931391d564aac925352c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0b99bd82535f931391d564aac925352c">EPWM_TB_STS_CTR_MAX</a>&#160;&#160;&#160;(PWMSS_EPWM_TBSTS_CTRMAX_MASK)</td></tr>
<tr class="separator:ga0b99bd82535f931391d564aac925352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c14239a94d052ef9a7d4a69b2d1a240"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6c14239a94d052ef9a7d4a69b2d1a240">EPWM_TB_STS_SYNCI</a>&#160;&#160;&#160;(PWMSS_EPWM_TBSTS_SYNCI_MASK)</td></tr>
<tr class="separator:ga6c14239a94d052ef9a7d4a69b2d1a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a2682a21e9ee70a8a6d53eb9959560"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga91a2682a21e9ee70a8a6d53eb9959560">EPWM_TB_STS_CTR_DIR</a>&#160;&#160;&#160;(PWMSS_EPWM_TBSTS_CTRDIR_MASK)</td></tr>
<tr class="separator:ga91a2682a21e9ee70a8a6d53eb9959560"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Emulation Mode</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf40a57c34f9491d12b25a4ab4be5a85d"></a><a class="anchor" id="CSL_EpwmTbEmuMode_t"></a></p>
</td></tr>
<tr class="memitem:ga1e915bd82628e6c88e3066a52f70da86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e915bd82628e6c88e3066a52f70da86"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1e915bd82628e6c88e3066a52f70da86">CSL_EpwmTbEmuMode_t</a></td></tr>
<tr class="memdesc:ga1e915bd82628e6c88e3066a52f70da86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulation Mode. This selects the behaviour of the ePWM time-base counter during emulation events. <br /></td></tr>
<tr class="separator:ga1e915bd82628e6c88e3066a52f70da86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75fc2d257901bc79117c6fd2c6be1168"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga75fc2d257901bc79117c6fd2c6be1168">CSL_EPWM_TB_EMU_MODE_STP_AFT_NEXT_CYCLE</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_FREE_SOFT_STOP_AFTER_NEXT_CTR)</td></tr>
<tr class="separator:ga75fc2d257901bc79117c6fd2c6be1168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc6c093ae6a7eaf3b174e35b3896d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gafbc6c093ae6a7eaf3b174e35b3896d84">CSL_EPWM_TB_EMU_MODE_STP_AFT_COMPLETE_CYCLE</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_FREE_SOFT_STOP_AFTER_CYCLE)</td></tr>
<tr class="separator:gafbc6c093ae6a7eaf3b174e35b3896d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9889496c285364e9669859164d4fecf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad9889496c285364e9669859164d4fecf">EPWM_TB_EMU_MODE_FREE_RUN</a>&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_FREE_SOFT_RUN2)</td></tr>
<tr class="separator:gad9889496c285364e9669859164d4fecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Comparator type</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2a336ba6e7c91750599c8e0da31d5bce"></a><a class="anchor" id="CSL_EpwmCcCmp_t"></a></p>
</td></tr>
<tr class="memitem:gabaaf6d257f978e30f2aeead3ab8ff83e"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabaaf6d257f978e30f2aeead3ab8ff83e">CSL_EpwmCcCmp_t</a></td></tr>
<tr class="separator:gabaaf6d257f978e30f2aeead3ab8ff83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838d8d8d0bba6547ebcbb70cc0574b05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga838d8d8d0bba6547ebcbb70cc0574b05">CSL_EPWM_CC_CMP_MIN</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:ga838d8d8d0bba6547ebcbb70cc0574b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa35f07d4b9f249aea860c314e42bab7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gafa35f07d4b9f249aea860c314e42bab7">CSL_EPWM_CC_CMP_A</a>&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga838d8d8d0bba6547ebcbb70cc0574b05">CSL_EPWM_CC_CMP_MIN</a>)</td></tr>
<tr class="separator:gafa35f07d4b9f249aea860c314e42bab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240fd702fd04a054d74573302bd29187"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga240fd702fd04a054d74573302bd29187">CSL_EPWM_CC_CMP_B</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ga240fd702fd04a054d74573302bd29187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc665fc7e98c0e40600e5e8ecec204f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0cc665fc7e98c0e40600e5e8ecec204f">CSL_EPWM_CC_CMP_MAX</a>&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga240fd702fd04a054d74573302bd29187">CSL_EPWM_CC_CMP_B</a>)</td></tr>
<tr class="separator:ga0cc665fc7e98c0e40600e5e8ecec204f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Counter-Comparator registers(A and B) load mode</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1be072a7f3d0546ab0ce0bc014a71279"></a><a class="anchor" id="CSL_EpwmCcCmpLoadMode_t"></a></p>
</td></tr>
<tr class="memitem:gaa9fa681cfe0d40be47575a99f8c30026"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa9fa681cfe0d40be47575a99f8c30026">CSL_EpwmCcCmpLoadMode_t</a></td></tr>
<tr class="memdesc:gaa9fa681cfe0d40be47575a99f8c30026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter-Comparator registers(A and B) load mode flags from shadow register.  <a href="#gaa9fa681cfe0d40be47575a99f8c30026">More...</a><br /></td></tr>
<tr class="separator:gaa9fa681cfe0d40be47575a99f8c30026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae07c3f4f1779cc827b04d48cefea56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacae07c3f4f1779cc827b04d48cefea56">CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_ZERO</a>&#160;&#160;&#160;(PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0)</td></tr>
<tr class="separator:gacae07c3f4f1779cc827b04d48cefea56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c62025f5e6dc378556d1a03ec5aff00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga5c62025f5e6dc378556d1a03ec5aff00">CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_PRD</a>&#160;&#160;&#160;(PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_PRD)</td></tr>
<tr class="separator:ga5c62025f5e6dc378556d1a03ec5aff00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e6209d518aa186db5f6b6e6475e032"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga04e6209d518aa186db5f6b6e6475e032">CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_ZERO_OR_PRD</a>&#160;&#160;&#160;(PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0_OR_PRD)</td></tr>
<tr class="separator:ga04e6209d518aa186db5f6b6e6475e032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca52f34e904f5ccf09fbb0398da8d27a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaca52f34e904f5ccf09fbb0398da8d27a">CSL_EPWM_CC_CMP_LOAD_MODE_NO_LOAD</a>&#160;&#160;&#160;(PWMSS_EPWM_CMPCTL_LOADAMODE_FREEZE)</td></tr>
<tr class="separator:gaca52f34e904f5ccf09fbb0398da8d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Actions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpdebd3ead927ad969d3a41d374163fa75"></a><a class="anchor" id="CSL_EpwmAqAction_t"></a></p>
</td></tr>
<tr class="memitem:ga247be6082138b847e1b839ef6b8830e0"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga247be6082138b847e1b839ef6b8830e0">CSL_EpwmAqAction_t</a></td></tr>
<tr class="memdesc:ga247be6082138b847e1b839ef6b8830e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Actions that Action Qualifier can take on the Output when the supported counter compare event occurs.  <a href="#ga247be6082138b847e1b839ef6b8830e0">More...</a><br /></td></tr>
<tr class="separator:ga247be6082138b847e1b839ef6b8830e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac7f7617737c68047d7351ea1162021b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaac7f7617737c68047d7351ea1162021b">CSL_EPWM_AQ_ACTION_DONOTHING</a>&#160;&#160;&#160;(PWMSS_EPWM_AQCTLA_ZRO_DISABLED)</td></tr>
<tr class="separator:gaac7f7617737c68047d7351ea1162021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3da9d904d15793312c7cb7fa9ef095a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae3da9d904d15793312c7cb7fa9ef095a">CSL_EPWM_AQ_ACTION_LOW</a>&#160;&#160;&#160;(PWMSS_EPWM_AQCTLA_ZRO_CLEAR)</td></tr>
<tr class="separator:gae3da9d904d15793312c7cb7fa9ef095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21295de17d4264be8d542c57b71f31ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga21295de17d4264be8d542c57b71f31ec">CSL_EPWM_AQ_ACTION_HIGH</a>&#160;&#160;&#160;(PWMSS_EPWM_AQCTLA_ZRO_SET)</td></tr>
<tr class="separator:ga21295de17d4264be8d542c57b71f31ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga053bf82daf27e7dce599edb8b11622a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga053bf82daf27e7dce599edb8b11622a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSL_EPQM_AQ_ACTION_TOLLGE</b>&#160;&#160;&#160;(PWMSS_EPWM_AQCTLA_ZRO_TOGGLE)</td></tr>
<tr class="separator:ga053bf82daf27e7dce599edb8b11622a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a5a1d743513b25a7dbb94f4edb90c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac6a5a1d743513b25a7dbb94f4edb90c2">CSL_EPWM_AQ_ACTION_TOLLGE</a>&#160;&#160;&#160;(CSL_EPQM_AQ_ACTION_TOLLGE)</td></tr>
<tr class="separator:gac6a5a1d743513b25a7dbb94f4edb90c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM output actions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp217bc59eefe991243ce50a148a6a288f"></a><a class="anchor" id="CSL_EpwmAqSwTrigOtAction_t"></a></p>
</td></tr>
<tr class="memitem:ga04f5a1d05aa074e82a78fa0487699942"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga04f5a1d05aa074e82a78fa0487699942">CSL_EpwmAqSwTrigOtAction_t</a></td></tr>
<tr class="memdesc:ga04f5a1d05aa074e82a78fa0487699942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions to be taken on the output, when Software triggered one time events will occur.  <a href="#ga04f5a1d05aa074e82a78fa0487699942">More...</a><br /></td></tr>
<tr class="separator:ga04f5a1d05aa074e82a78fa0487699942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cab589b53f00bf881cf378035b606bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga3cab589b53f00bf881cf378035b606bc">CSL_EPWM_AQ_SW_TRIG_OT_ACTION_DONOTHING</a>&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_ACTSFA_DISABLED)</td></tr>
<tr class="separator:ga3cab589b53f00bf881cf378035b606bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb445c38f875b24ecf8059c57925a791"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacb445c38f875b24ecf8059c57925a791">CSL_EPWM_AQ_SW_TRIG_OT_ACTION_LOW</a>&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_ACTSFA_CLEAR)</td></tr>
<tr class="separator:gacb445c38f875b24ecf8059c57925a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc14b1f270afafc863b2c723dc8de0a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gadc14b1f270afafc863b2c723dc8de0a5">CSL_EPWM_AQ_SW_TRIG_OT_ACTION_HIGH</a>&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_ACTSFA_SET)</td></tr>
<tr class="separator:gadc14b1f270afafc863b2c723dc8de0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f87c8328d7786877ccda13d2f062de6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1f87c8328d7786877ccda13d2f062de6">CSL_EPWM_AQ_SW_TRIG_OT_ACTION_TOGGLE</a>&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_ACTSFA_TOGGLE)</td></tr>
<tr class="separator:ga1f87c8328d7786877ccda13d2f062de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Continuous software forced actions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf5fd0102114f280f69c1912021e3e107"></a><a class="anchor" id="CSL_EpwmAqSwTrigContAction_t"></a></p>
</td></tr>
<tr class="memitem:gadd0542055b2b9e8a67cada3734768970"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gadd0542055b2b9e8a67cada3734768970">CSL_EpwmAqSwTrigContAction_t</a></td></tr>
<tr class="memdesc:gadd0542055b2b9e8a67cada3734768970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Continuous software forced actions on output.  <a href="#gadd0542055b2b9e8a67cada3734768970">More...</a><br /></td></tr>
<tr class="separator:gadd0542055b2b9e8a67cada3734768970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55811355adbd92b71743e8e9a8fa7ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaf55811355adbd92b71743e8e9a8fa7ce">CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_NOEFFECT</a>&#160;&#160;&#160;(PWMSS_EPWM_AQCSFRC_CSFA_DISABLED)</td></tr>
<tr class="separator:gaf55811355adbd92b71743e8e9a8fa7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c5e6788fc8c295d5be9ec95c97c09fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga5c5e6788fc8c295d5be9ec95c97c09fa">CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_LOW</a>&#160;&#160;&#160;(PWMSS_EPWM_AQCSFRC_CSFA_LOW_OUTPUT)</td></tr>
<tr class="separator:ga5c5e6788fc8c295d5be9ec95c97c09fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee90202e7cb04a27ea6bf149094d455"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacee90202e7cb04a27ea6bf149094d455">CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_HIGH</a>&#160;&#160;&#160;(PWMSS_EPWM_AQCSFRC_CSFA_HIGH_OUTPUT)</td></tr>
<tr class="separator:gacee90202e7cb04a27ea6bf149094d455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b3853721b4894b61900ba3b141d595"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga77b3853721b4894b61900ba3b141d595">CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_SW_DISBALED</a>&#160;&#160;&#160;(PWMSS_EPWM_AQCSFRC_CSFA_NO_EFFECT)</td></tr>
<tr class="separator:ga77b3853721b4894b61900ba3b141d595"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Software Force Active Register Reload</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe753af951fd58aa5401fad0eddebf6f0"></a><a class="anchor" id="CSL_EpwmAqCsfrcRegReload_t"></a></p>
</td></tr>
<tr class="memitem:ga15408044a1b06cbf59eadef7f30dfb9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15408044a1b06cbf59eadef7f30dfb9f"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga15408044a1b06cbf59eadef7f30dfb9f">CSL_EpwmAqCsfrcRegReload_t</a></td></tr>
<tr class="memdesc:ga15408044a1b06cbf59eadef7f30dfb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action Qualifier Software Force Active Register Reload From Shadow Options. <br /></td></tr>
<tr class="separator:ga15408044a1b06cbf59eadef7f30dfb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02619d51fa8417b775d9c637761b154"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac02619d51fa8417b775d9c637761b154">CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_ZRO</a>&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_RLDCSF_CTR_0)</td></tr>
<tr class="separator:gac02619d51fa8417b775d9c637761b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0104dce46379280ca5739154641c0f3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0104dce46379280ca5739154641c0f3b">CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_PRD</a>&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_RLDCSF_CTR_PERIOD)</td></tr>
<tr class="separator:ga0104dce46379280ca5739154641c0f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806ab8d498ce37d2708d93371b735f8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga806ab8d498ce37d2708d93371b735f8d">CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_ZRO_OR_PRD</a>&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_RLDCSF_CTR_0_OR_PERIOD)</td></tr>
<tr class="separator:ga806ab8d498ce37d2708d93371b735f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92ace7c47be5777174c80be846cb632"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad92ace7c47be5777174c80be846cb632">CSL_EPWM_AQ_CSFRC_REG_RELOAD_IMMEDIATE</a>&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_RLDCSF_IMMEDIATE)</td></tr>
<tr class="separator:gad92ace7c47be5777174c80be846cb632"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Dead Band Input Mode Control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb94f12dd8e5ef2b23253b599ff6fb7e5"></a><a class="anchor" id="CSL_EpwmDbInMode_t"></a></p>
</td></tr>
<tr class="memitem:ga5c2678810c1c957a8a4ab284f01cd8aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5c2678810c1c957a8a4ab284f01cd8aa"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga5c2678810c1c957a8a4ab284f01cd8aa">CSL_EpwmDbInMode_t</a></td></tr>
<tr class="memdesc:ga5c2678810c1c957a8a4ab284f01cd8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead Band Input Mode Control. This allows you to select the input source to the falling-edge and rising-edge delay. <br /></td></tr>
<tr class="separator:ga5c2678810c1c957a8a4ab284f01cd8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa975aa421d31ee9c5cded73378567140"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa975aa421d31ee9c5cded73378567140">CSL_EPWM_DB_IN_MODE_A_RED_A_FED</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_IN_MODE_SRC_ARED_AFED)</td></tr>
<tr class="separator:gaa975aa421d31ee9c5cded73378567140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74ab10dea4be7428b721ca5468b53ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaf74ab10dea4be7428b721ca5468b53ff">CSL_EPWM_DB_IN_MODE_B_RED_A_FED</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_IN_MODE_SRC_BRED_AFED)</td></tr>
<tr class="separator:gaf74ab10dea4be7428b721ca5468b53ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf34c24dad7551404f856099848c9ccb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaaf34c24dad7551404f856099848c9ccb">CSL_EPWM_DB_IN_MODE_A_RED_B_FED</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_IN_MODE_SRC_ARED_BFED)</td></tr>
<tr class="separator:gaaf34c24dad7551404f856099848c9ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812cc413bba2011102fd609b4bcbd5eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga812cc413bba2011102fd609b4bcbd5eb">CSL_EPWM_DB_IN_MODE_B_RED_B_FED</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_IN_MODE_SRC_BRED_BFED)</td></tr>
<tr class="separator:ga812cc413bba2011102fd609b4bcbd5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Polarity Select Control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2527c0511ca7f7deeb34b71c44a3d707"></a><a class="anchor" id="CSL_EpwmDbPolSel_t"></a></p>
</td></tr>
<tr class="memitem:ga6f373c41cc690c429622259878074b55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f373c41cc690c429622259878074b55"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6f373c41cc690c429622259878074b55">CSL_EpwmDbPolSel_t</a></td></tr>
<tr class="memdesc:ga6f373c41cc690c429622259878074b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polarity Select Control. This allows you to selectively invert one of the delayed signals before it is sent out of the dead-band sub-module. <br /></td></tr>
<tr class="separator:ga6f373c41cc690c429622259878074b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db3d52db6e30318847920f84d46017a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0db3d52db6e30318847920f84d46017a">CSL_EPWM_DB_POL_SEL_ACTV_HIGH</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_POLSEL_ACTIVE_HIGH)</td></tr>
<tr class="separator:ga0db3d52db6e30318847920f84d46017a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143a69cdc9e96e27b70b5b6d591ff628"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga143a69cdc9e96e27b70b5b6d591ff628">CSL_EPWM_DB_POL_SEL_ACTV_LOW_COMPLEMENTARY</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_POLSEL_ACTIVE_LOW_COMPLEMENTARY)</td></tr>
<tr class="separator:ga143a69cdc9e96e27b70b5b6d591ff628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec1713dc02aa5890535cbad82a996a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga9ec1713dc02aa5890535cbad82a996a2">CSL_EPWM_DB_POL_SEL_ACTV_HIGH_COMPLEMENTARY</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_POLSEL_ACTIVE_HIGH_COMPLEMENTARY)</td></tr>
<tr class="separator:ga9ec1713dc02aa5890535cbad82a996a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c3add499208256c56ed4cd044dd01e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga76c3add499208256c56ed4cd044dd01e">CSL_EPWM_DB_POL_SEL_ACTV_LOW</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_POLSEL_ACTIVE_LOW)</td></tr>
<tr class="separator:ga76c3add499208256c56ed4cd044dd01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Dead-band Output Mode Control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd2121b49f611e0ebccba603d842b2ae4"></a><a class="anchor" id="CSL_EpwmDbOutMode_t"></a></p>
</td></tr>
<tr class="memitem:gaf1e5e8325a89b9f8425e0f952e3c0fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1e5e8325a89b9f8425e0f952e3c0fc6"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaf1e5e8325a89b9f8425e0f952e3c0fc6">CSL_EpwmDbOutMode_t</a></td></tr>
<tr class="memdesc:gaf1e5e8325a89b9f8425e0f952e3c0fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead-band Output Mode Control. This allows you to selectively enable or bypass the dead-band generation for the falling-edge and rising-edge delay. <br /></td></tr>
<tr class="separator:gaf1e5e8325a89b9f8425e0f952e3c0fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab68e3c2b80c627431192c5aea2dcec4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab68e3c2b80c627431192c5aea2dcec4d">CSL_EPWM_DB_OUT_MODE_BYPASS</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_OUT_MODE_DISABLED)</td></tr>
<tr class="separator:gab68e3c2b80c627431192c5aea2dcec4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3731088ee696538c63146afc8d064a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacc3731088ee696538c63146afc8d064a">CSL_EPWM_DB_OUT_MODE_NO_RED_B_FED</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_OUT_MODE_DISABLE_RISING_EDGE)</td></tr>
<tr class="separator:gacc3731088ee696538c63146afc8d064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44752d64cd3deda1fb28ba841772464d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga44752d64cd3deda1fb28ba841772464d">CSL_EPWM_DB_OUT_MODE_A_RED_NO_FED</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_OUT_MODE_DISABLE_FALLING_EDGE)</td></tr>
<tr class="separator:ga44752d64cd3deda1fb28ba841772464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8812146ebdd8df9e363eee4e327ef3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga2d8812146ebdd8df9e363eee4e327ef3">CSL_EPWM_DB_OUT_MODE_A_RED_B_FED</a>&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_OUT_MODE_ENABLED)</td></tr>
<tr class="separator:ga2d8812146ebdd8df9e363eee4e327ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Chopping Clock Duty Cycle</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpef3adfc5302a2850d6cb9b385d19408c"></a><a class="anchor" id="CSL_EpwmChpDutyCycle_t"></a></p>
</td></tr>
<tr class="memitem:gadaab104733da4ef6422fad7dd7abac40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadaab104733da4ef6422fad7dd7abac40"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gadaab104733da4ef6422fad7dd7abac40">CSL_EpwmChpDutyCycle_t</a></td></tr>
<tr class="memdesc:gadaab104733da4ef6422fad7dd7abac40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chopping Clock Duty Cycle values. <br /></td></tr>
<tr class="separator:gadaab104733da4ef6422fad7dd7abac40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48cc2b49d51301e48b665cbf813d958c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga48cc2b49d51301e48b665cbf813d958c">CSL_EPWM_CHP_DUTY_CYCLE_PERC_12PNT5</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_12_5)</td></tr>
<tr class="separator:ga48cc2b49d51301e48b665cbf813d958c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb029e91cc10ce06940efc77c6d0615d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacb029e91cc10ce06940efc77c6d0615d">CSL_EPWM_CHP_DUTY_CYCLE_PERC_25</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_25)</td></tr>
<tr class="separator:gacb029e91cc10ce06940efc77c6d0615d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db9640f0d048ccac9f8a856a46b3305"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0db9640f0d048ccac9f8a856a46b3305">CSL_EPWM_CHP_DUTY_CYCLE_PERC_37PNT5</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_37_5)</td></tr>
<tr class="separator:ga0db9640f0d048ccac9f8a856a46b3305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab62124d78b25d0bd314b8fe66694f297"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab62124d78b25d0bd314b8fe66694f297">CSL_EPWM_CHP_DUTY_CYCLE_PERC_50_PER</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_50)</td></tr>
<tr class="separator:gab62124d78b25d0bd314b8fe66694f297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bf01f6d9dbb064b61872d2f5ad569b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga11bf01f6d9dbb064b61872d2f5ad569b">CSL_EPWM_CHP_DUTY_CYCLE_PERC_62PNT5</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_62_5)</td></tr>
<tr class="separator:ga11bf01f6d9dbb064b61872d2f5ad569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72689d1c54bd0f6943ff04f3103d6cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaf72689d1c54bd0f6943ff04f3103d6cc">CSL_EPWM_CHP_DUTY_CYCLE_PERC_75</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_75)</td></tr>
<tr class="separator:gaf72689d1c54bd0f6943ff04f3103d6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8bc48049e6dc0796df102dfdeb91455"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaf8bc48049e6dc0796df102dfdeb91455">CSL_EPWM_CHP_DUTY_CYCLE_PERC_87PNT5</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_87_5)</td></tr>
<tr class="separator:gaf8bc48049e6dc0796df102dfdeb91455"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Chopping Clock Frequency</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpae3529c084210f2f13f4f9350a9ff017"></a><a class="anchor" id="CSL_EpwmChpClkFreq_t"></a></p>
</td></tr>
<tr class="memitem:ga85519f2dab3cef9876887eafaec2156c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85519f2dab3cef9876887eafaec2156c"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga85519f2dab3cef9876887eafaec2156c">CSL_EpwmChpClkFreq_t</a></td></tr>
<tr class="memdesc:ga85519f2dab3cef9876887eafaec2156c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chopping Clock Frequency values . <br /></td></tr>
<tr class="separator:ga85519f2dab3cef9876887eafaec2156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561d12603c957579c01532ebfe8a0c10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga561d12603c957579c01532ebfe8a0c10">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_1</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_1)</td></tr>
<tr class="separator:ga561d12603c957579c01532ebfe8a0c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a9b38ae81824fa22ce8d4d7fc2b51b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa3a9b38ae81824fa22ce8d4d7fc2b51b">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_2</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_2)</td></tr>
<tr class="separator:gaa3a9b38ae81824fa22ce8d4d7fc2b51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7587fecd9b1eee18064ce7699af3396d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7587fecd9b1eee18064ce7699af3396d">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_3</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_3)</td></tr>
<tr class="separator:ga7587fecd9b1eee18064ce7699af3396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeacb6bb536bb7c3341731763e8bece2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaeacb6bb536bb7c3341731763e8bece2f">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_4</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_4)</td></tr>
<tr class="separator:gaeacb6bb536bb7c3341731763e8bece2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga641672133a43b413424de503d571744e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga641672133a43b413424de503d571744e">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_5</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_5)</td></tr>
<tr class="separator:ga641672133a43b413424de503d571744e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc88d2e0e05bc30a540d848a468c7d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7dc88d2e0e05bc30a540d848a468c7d7">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_6</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_6)</td></tr>
<tr class="separator:ga7dc88d2e0e05bc30a540d848a468c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b531ae313bc539a552f8b154895a338"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7b531ae313bc539a552f8b154895a338">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_7</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_7)</td></tr>
<tr class="separator:ga7b531ae313bc539a552f8b154895a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d81e0f575c3077b70102507fe2f05c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga97d81e0f575c3077b70102507fe2f05c">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_8</a>&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_8)</td></tr>
<tr class="separator:ga97d81e0f575c3077b70102507fe2f05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM One-Shot Pulse Width</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe9cce8b04c676aebe59345d5d609b504"></a><a class="anchor" id="CSL_EpwmChpOshtWidth_t"></a></p>
</td></tr>
<tr class="memitem:ga4a64a467c94ceb16d5e3dd429e588563"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a64a467c94ceb16d5e3dd429e588563"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga4a64a467c94ceb16d5e3dd429e588563">CSL_EpwmChpOshtWidth_t</a></td></tr>
<tr class="memdesc:ga4a64a467c94ceb16d5e3dd429e588563"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-Shot Pulse Width values. <br /></td></tr>
<tr class="separator:ga4a64a467c94ceb16d5e3dd429e588563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1280117993aa611fa0d107458eed12c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1280117993aa611fa0d107458eed12c1">CSL_EPWM_CHP_OSHT_WIDTH_MIN</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:ga1280117993aa611fa0d107458eed12c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a1330a246edf8b2aaf74750ed581f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga21a1330a246edf8b2aaf74750ed581f7">CSL_EPWM_CHP_OSHT_WIDTH_1XSYSOUT_BY_8</a>&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga1280117993aa611fa0d107458eed12c1">CSL_EPWM_CHP_OSHT_WIDTH_MIN</a>)</td></tr>
<tr class="separator:ga21a1330a246edf8b2aaf74750ed581f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceaf8e1ec3812636bbc8ad6ec4276271"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaceaf8e1ec3812636bbc8ad6ec4276271">CSL_EPWM_CHP_OSHT_WIDTH_2XSYSOUT_BY_8</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:gaceaf8e1ec3812636bbc8ad6ec4276271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f95e72ad356bfe961dbc724ba20511"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae1f95e72ad356bfe961dbc724ba20511">CSL_EPWM_CHP_OSHT_WIDTH_3XSYSOUT_BY_8</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:gae1f95e72ad356bfe961dbc724ba20511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c167c56e425cb6df148be858e0e42a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga9c167c56e425cb6df148be858e0e42a8">CSL_EPWM_CHP_OSHT_WIDTH_4XSYSOUT_BY_8</a>&#160;&#160;&#160;(3U)</td></tr>
<tr class="separator:ga9c167c56e425cb6df148be858e0e42a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1cad396375c37d0fa038fd169eb0318"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac1cad396375c37d0fa038fd169eb0318">CSL_EPWM_CHP_OSHT_WIDTH_5XSYSOUT_BY_8</a>&#160;&#160;&#160;(4U)</td></tr>
<tr class="separator:gac1cad396375c37d0fa038fd169eb0318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba436ec9115a352b9324c0dfe2e31b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga2ba436ec9115a352b9324c0dfe2e31b5">CSL_EPWM_CHP_OSHT_WIDTH_6XSYSOUT_BY_8</a>&#160;&#160;&#160;(5U)</td></tr>
<tr class="separator:ga2ba436ec9115a352b9324c0dfe2e31b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13ad6b9d1f87a2026dc1c42a15cb531"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab13ad6b9d1f87a2026dc1c42a15cb531">CSL_EPWM_CHP_OSHT_WIDTH_7XSYSOUT_BY_8</a>&#160;&#160;&#160;(6U)</td></tr>
<tr class="separator:gab13ad6b9d1f87a2026dc1c42a15cb531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2ea42faa1d207b28d405474ec101d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaee2ea42faa1d207b28d405474ec101d5">CSL_EPWM_CHP_OSHT_WIDTH_8XSYSOUT_BY_8</a>&#160;&#160;&#160;(7U)</td></tr>
<tr class="separator:gaee2ea42faa1d207b28d405474ec101d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda46ccb87a947903f0d7b03dc1f4d64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacda46ccb87a947903f0d7b03dc1f4d64">CSL_EPWM_CHP_OSHT_WIDTH_9XSYSOUT_BY_8</a>&#160;&#160;&#160;(8U)</td></tr>
<tr class="separator:gacda46ccb87a947903f0d7b03dc1f4d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a06750c1261b29f2f563cf77228c03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga45a06750c1261b29f2f563cf77228c03">CSL_EPWM_CHP_OSHT_WIDTH_10XSYSOUT_BY_8</a>&#160;&#160;&#160;(9U)</td></tr>
<tr class="separator:ga45a06750c1261b29f2f563cf77228c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga653442a660e90ed70dc16ebaeb9a5761"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga653442a660e90ed70dc16ebaeb9a5761">CSL_EPWM_CHP_OSHT_WIDTH_11XSYSOUT_BY_8</a>&#160;&#160;&#160;(10U)</td></tr>
<tr class="separator:ga653442a660e90ed70dc16ebaeb9a5761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e337d2dbd6efb9c2d2399c8fed5298"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab2e337d2dbd6efb9c2d2399c8fed5298">CSL_EPWM_CHP_OSHT_WIDTH_12XSYSOUT_BY_8</a>&#160;&#160;&#160;(11U)</td></tr>
<tr class="separator:gab2e337d2dbd6efb9c2d2399c8fed5298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9607955ceb8ae3de370f21709b3bd4da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga9607955ceb8ae3de370f21709b3bd4da">CSL_EPWM_CHP_OSHT_WIDTH_13XSYSOUT_BY_8</a>&#160;&#160;&#160;(12U)</td></tr>
<tr class="separator:ga9607955ceb8ae3de370f21709b3bd4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb31881a83a805b98183d5d990f0782"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabeb31881a83a805b98183d5d990f0782">CSL_EPWM_CHP_OSHT_WIDTH_14XSYSOUT_BY_8</a>&#160;&#160;&#160;(13U)</td></tr>
<tr class="separator:gabeb31881a83a805b98183d5d990f0782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea12f8e03e0a77adb4d5c0062217afad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaea12f8e03e0a77adb4d5c0062217afad">CSL_EPWM_CHP_OSHT_WIDTH_15XSYSOUT_BY_8</a>&#160;&#160;&#160;(14U)</td></tr>
<tr class="separator:gaea12f8e03e0a77adb4d5c0062217afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a304316f1ef72888af25035a7442dde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1a304316f1ef72888af25035a7442dde">CSL_EPWM_CHP_OSHT_WIDTH_16XSYSOUT_BY_8</a>&#160;&#160;&#160;(15U)</td></tr>
<tr class="separator:ga1a304316f1ef72888af25035a7442dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d4fe83df29f6f326db0172d97b6eb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab0d4fe83df29f6f326db0172d97b6eb2">CSL_EPWM_CHP_OSHT_WIDTH_MAX</a>&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga1a304316f1ef72888af25035a7442dde">CSL_EPWM_CHP_OSHT_WIDTH_16XSYSOUT_BY_8</a>)</td></tr>
<tr class="separator:gab0d4fe83df29f6f326db0172d97b6eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM output action when a trip event occurs</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3a4bde995765177427b42476138f27d2"></a><a class="anchor" id="CSL_EpwmTzTripAction_t"></a></p>
</td></tr>
<tr class="memitem:ga338b02aaed675499de7696e0cb0a7e8d"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga338b02aaed675499de7696e0cb0a7e8d">CSL_EpwmTzTripAction_t</a></td></tr>
<tr class="memdesc:ga338b02aaed675499de7696e0cb0a7e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action to be taken on PWM output When a trip event occurs.  <a href="#ga338b02aaed675499de7696e0cb0a7e8d">More...</a><br /></td></tr>
<tr class="separator:ga338b02aaed675499de7696e0cb0a7e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d3d7bb8a70569e3750cd4b66256b2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga39d3d7bb8a70569e3750cd4b66256b2f">CSL_EPWM_TZ_TRIP_ACTION_TRI_STATE</a>&#160;&#160;&#160;(PWMSS_EPWM_TZCTL_TZA_HIGH_IMPEDANCE)</td></tr>
<tr class="separator:ga39d3d7bb8a70569e3750cd4b66256b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217b576287f68033af8725522ca43986"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga217b576287f68033af8725522ca43986">CSL_EPWM_TZ_TRIP_ACTION_HIGH</a>&#160;&#160;&#160;(PWMSS_EPWM_TZCTL_TZA_HIGH_STATE)</td></tr>
<tr class="separator:ga217b576287f68033af8725522ca43986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16635db394cd7ac86b1276bf30c6676f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga16635db394cd7ac86b1276bf30c6676f">CSL_EPWM_TZ_TRIP_ACTION_LOW</a>&#160;&#160;&#160;(PWMSS_EPWM_TZCTL_TZA_LOW_STATE)</td></tr>
<tr class="separator:ga16635db394cd7ac86b1276bf30c6676f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab062d137039917526333ede6a3853a95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab062d137039917526333ede6a3853a95">CSL_EPWM_TZ_TRIP_ACTION_DO_NOTHING</a>&#160;&#160;&#160;(PWMSS_EPWM_TZCTL_TZA_DO_NOTHING)</td></tr>
<tr class="separator:gab062d137039917526333ede6a3853a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM trip zone events</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpecfc0a93540746f2823cbb491d2b1afc"></a><a class="anchor" id="CSL_EpwmTzEvent_t"></a></p>
</td></tr>
<tr class="memitem:ga3b21dd002850676ee0ca6b9e9e4fc79c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b21dd002850676ee0ca6b9e9e4fc79c"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga3b21dd002850676ee0ca6b9e9e4fc79c">CSL_EpwmTzEvent_t</a></td></tr>
<tr class="memdesc:ga3b21dd002850676ee0ca6b9e9e4fc79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of trip zone events. <br /></td></tr>
<tr class="separator:ga3b21dd002850676ee0ca6b9e9e4fc79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa530beeef3837b64ffb5a15bb69dc8eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa530beeef3837b64ffb5a15bb69dc8eb">CSL_EPWM_TZ_EVENT_MIN</a>&#160;&#160;&#160;(0x0U)</td></tr>
<tr class="separator:gaa530beeef3837b64ffb5a15bb69dc8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga985219a76b3986497b8c5d12b9091d4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga985219a76b3986497b8c5d12b9091d4b">CSL_EPWM_TZ_EVENT_ONE_SHOT</a>&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#gaa530beeef3837b64ffb5a15bb69dc8eb">CSL_EPWM_TZ_EVENT_MIN</a>)</td></tr>
<tr class="separator:ga985219a76b3986497b8c5d12b9091d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae15a910346642ffdf4212ef5fbe79557"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae15a910346642ffdf4212ef5fbe79557">CSL_EPWM_TZ_EVENT_CYCLE_BY_CYCLE</a>&#160;&#160;&#160;(0x1U)</td></tr>
<tr class="separator:gae15a910346642ffdf4212ef5fbe79557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038d6344fa139f888e77f84dd44273cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga038d6344fa139f888e77f84dd44273cc">CSL_EPWM_TZ_EVENT_MAX</a>&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#gae15a910346642ffdf4212ef5fbe79557">CSL_EPWM_TZ_EVENT_CYCLE_BY_CYCLE</a>)</td></tr>
<tr class="separator:ga038d6344fa139f888e77f84dd44273cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Trip zone status flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb7a830b6d0c9bf21b58c693683b91411"></a><a class="anchor" id="CSL_EpwmTzStsFlg_t"></a></p>
</td></tr>
<tr class="memitem:ga388f004caf9970a16637804a1dba4670"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga388f004caf9970a16637804a1dba4670"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga388f004caf9970a16637804a1dba4670">CSL_EpwmTzStsFlg_t</a></td></tr>
<tr class="memdesc:ga388f004caf9970a16637804a1dba4670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trip zone status flags. <br /></td></tr>
<tr class="separator:ga388f004caf9970a16637804a1dba4670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4b4207f2b2c88d58004f0f346849fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gafe4b4207f2b2c88d58004f0f346849fb">CSL_EPWM_TZ_STS_FLG_OST</a>&#160;&#160;&#160;(PWMSS_EPWM_TZFLG_OST_MASK)</td></tr>
<tr class="separator:gafe4b4207f2b2c88d58004f0f346849fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e0444f465228b6fc555c2dedd2949c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab5e0444f465228b6fc555c2dedd2949c">CSL_EPWM_TZ_STS_FLG_CBC</a>&#160;&#160;&#160;(PWMSS_EPWM_TZFLG_CBC_MASK)</td></tr>
<tr class="separator:gab5e0444f465228b6fc555c2dedd2949c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb52a12d4069f3c25f8b7397c2e2fb35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacb52a12d4069f3c25f8b7397c2e2fb35">CSL_EPWM_TZ_STS_FLG_INT</a>&#160;&#160;&#160;(PWMSS_EPWM_TZFLG_INT_MASK)</td></tr>
<tr class="separator:gacb52a12d4069f3c25f8b7397c2e2fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Interrupt (EPWMx_INT) Selection Options</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp210211da3a4e14fb3cec0152be7903b9"></a><a class="anchor" id="CSL_EpwmEtIntrEvt_t"></a></p>
</td></tr>
<tr class="memitem:gae650de33bc61ad8b5390a11e69c3e79b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae650de33bc61ad8b5390a11e69c3e79b"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae650de33bc61ad8b5390a11e69c3e79b">CSL_EpwmEtIntrEvt_t</a></td></tr>
<tr class="memdesc:gae650de33bc61ad8b5390a11e69c3e79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ePWM Interrupt (EPWMx_INT) Selection Options. <br /></td></tr>
<tr class="separator:gae650de33bc61ad8b5390a11e69c3e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga968e05343b35765cc80e6ce095b72cd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga968e05343b35765cc80e6ce095b72cd2">CSL_EPWM_ET_INTR_EVT_CNT_EQ_ZRO</a>&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_0)</td></tr>
<tr class="separator:ga968e05343b35765cc80e6ce095b72cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba787df44595e607b87c6ce44fb1534"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaeba787df44595e607b87c6ce44fb1534">CSL_EPWM_ET_INTR_EVT_CNT_EQ_PRD</a>&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_PERIOD)</td></tr>
<tr class="separator:gaeba787df44595e607b87c6ce44fb1534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954997096a2fdc274953bf72832e046f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga954997096a2fdc274953bf72832e046f">CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPA_INC</a>&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_CMPA_INCR)</td></tr>
<tr class="separator:ga954997096a2fdc274953bf72832e046f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e54033a28b056b3cb5319aabb2dca4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga97e54033a28b056b3cb5319aabb2dca4">CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPA_DEC</a>&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_CMPA_DECR)</td></tr>
<tr class="separator:ga97e54033a28b056b3cb5319aabb2dca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0ba070a2fd8d9f6d9a01f4220b081a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac0ba070a2fd8d9f6d9a01f4220b081a1">CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPB_INC</a>&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_CMPB_INCR)</td></tr>
<tr class="separator:gac0ba070a2fd8d9f6d9a01f4220b081a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a9212b9f65a50c500a00991a894066"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga39a9212b9f65a50c500a00991a894066">CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPB_DEC</a>&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_CMPB_DECR)</td></tr>
<tr class="separator:ga39a9212b9f65a50c500a00991a894066"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Interrupt (EPWMx_INT) Period Select</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpff21b35344780c82033e2cccdcbe7eca"></a><a class="anchor" id="CSL_EpwmEtIntrPeriod_t"></a></p>
</td></tr>
<tr class="memitem:ga35e90e6dcd7e7a8078e49407a6a4f502"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35e90e6dcd7e7a8078e49407a6a4f502"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga35e90e6dcd7e7a8078e49407a6a4f502">CSL_EpwmEtIntrPeriod_t</a></td></tr>
<tr class="memdesc:ga35e90e6dcd7e7a8078e49407a6a4f502"><td class="mdescLeft">&#160;</td><td class="mdescRight">ePWM Interrupt (EPWMx_INT) Period Select. These values determine how many selected events need to occur before an interrupt is generated. <br /></td></tr>
<tr class="separator:ga35e90e6dcd7e7a8078e49407a6a4f502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5f552a9b5e79ec1b80cef8c1d5a8b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabe5f552a9b5e79ec1b80cef8c1d5a8b7">CSL_EPWM_ET_INTR_PERIOD_DIS_INTR</a>&#160;&#160;&#160;(PWMSS_EPWM_ETPS_INTPRD_DISABLE)</td></tr>
<tr class="separator:gabe5f552a9b5e79ec1b80cef8c1d5a8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e230ac038ce07cc125f8ccf2583f771"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga2e230ac038ce07cc125f8ccf2583f771">CSL_EPWM_ET_INTR_PERIOD_FIRST_EVT</a>&#160;&#160;&#160;(PWMSS_EPWM_ETPS_INTPRD_GEN_FIRST_EVT)</td></tr>
<tr class="separator:ga2e230ac038ce07cc125f8ccf2583f771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab888d03bd6b6f5f444bef06b12c2dcb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab888d03bd6b6f5f444bef06b12c2dcb8">CSL_EPWM_ET_INTR_PERIOD_SECOND_EVT</a>&#160;&#160;&#160;(PWMSS_EPWM_ETPS_INTPRD_GEN_SECOND_EVT)</td></tr>
<tr class="separator:gab888d03bd6b6f5f444bef06b12c2dcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b53d675f0790cac472cfcf979993d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga59b53d675f0790cac472cfcf979993d6">CSL_EPWM_ET_INTR_PERIOD_THIRD_EVT</a>&#160;&#160;&#160;(PWMSS_EPWM_ETPS_INTPRD_GEN_THIRD_EVT)</td></tr>
<tr class="separator:ga59b53d675f0790cac472cfcf979993d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Delay Bus Selection</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6696e9c6b5daf316217a7e9870d13fca"></a><a class="anchor" id="CSL_EpwmHrDelayBusSelMode_t"></a></p>
</td></tr>
<tr class="memitem:ga463a8ac6841aea34bdc324e937fcde3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga463a8ac6841aea34bdc324e937fcde3a"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga463a8ac6841aea34bdc324e937fcde3a">CSL_EpwmHrDelayBusSelMode_t</a></td></tr>
<tr class="memdesc:ga463a8ac6841aea34bdc324e937fcde3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay Bus Selection, that selects which bus is used to select the delay for the PWM pulse. <br /></td></tr>
<tr class="separator:ga463a8ac6841aea34bdc324e937fcde3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae75e4332c0d510105391724ebd15a88a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae75e4332c0d510105391724ebd15a88a">CSL_EPWM_HR_DELAY_BUS_SEL_CMPAHR</a>&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELBUSSEL_SEL_CMPAHR)</td></tr>
<tr class="separator:gae75e4332c0d510105391724ebd15a88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga825b458b471652b404a0f5dc74a50935"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga825b458b471652b404a0f5dc74a50935">CSL_EPWM_HR_DELAY_BUS_SEL_TBPHSHR</a>&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELBUSSEL_SEL_TBPHSHR)</td></tr>
<tr class="separator:ga825b458b471652b404a0f5dc74a50935"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Delay Mode Configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp467763720d8281ff8c2c1f41541fb068"></a><a class="anchor" id="CSL_EpwmHrDelayEdgeCtrl_t"></a></p>
</td></tr>
<tr class="memitem:ga129fa03b277087c3052a1a9bfde1d6c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga129fa03b277087c3052a1a9bfde1d6c7"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga129fa03b277087c3052a1a9bfde1d6c7">CSL_EpwmHrDelayEdgeCtrl_t</a></td></tr>
<tr class="memdesc:ga129fa03b277087c3052a1a9bfde1d6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay Mode Configuration, that selects which edge of the PWM pulse the delay is inserted. <br /></td></tr>
<tr class="separator:ga129fa03b277087c3052a1a9bfde1d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24260a8f1d868403c5ca27cb03fb3be1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga24260a8f1d868403c5ca27cb03fb3be1">CSL_EPWM_HR_DELAY_EDGE_CTRL_NO_DELAY</a>&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELMODE_NO_DELAY)</td></tr>
<tr class="separator:ga24260a8f1d868403c5ca27cb03fb3be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bafac8e96d26c6bfb7bb947d18de384"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga5bafac8e96d26c6bfb7bb947d18de384">CSL_EPWM_HR_DELAY_EDGE_CTRL_RISING</a>&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELMODE_DELAY_RISING_EDGE)</td></tr>
<tr class="separator:ga5bafac8e96d26c6bfb7bb947d18de384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae303eb0a572420dc8633d91b35a82da7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae303eb0a572420dc8633d91b35a82da7">CSL_EPWM_HR_DELAY_EDGE_CTRL_FALLING</a>&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELMODE_DELAY_FALLING_EDGE)</td></tr>
<tr class="separator:gae303eb0a572420dc8633d91b35a82da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac21027736d9b138ac44ccff6a795dc18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac21027736d9b138ac44ccff6a795dc18">CSL_EPWM_HR_DELAY_EDGE_CTRL_BOTH</a>&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELMODE_DELAY_ON_BOTH_EDGES)</td></tr>
<tr class="separator:gac21027736d9b138ac44ccff6a795dc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
EPWM Pulse selection</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc2bfd6274b8aa9c361fb73e3dcb378d7"></a><a class="anchor" id="CSL_EpwmHrRegActLoad_t"></a></p>
</td></tr>
<tr class="memitem:ga7e9fa03f67d3250d913cb7cf9feeafa1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7e9fa03f67d3250d913cb7cf9feeafa1"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7e9fa03f67d3250d913cb7cf9feeafa1">CSL_EpwmHrRegActLoad_t</a></td></tr>
<tr class="memdesc:ga7e9fa03f67d3250d913cb7cf9feeafa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulse selection, that selects which pulse to use for timing events in the HRPWM module. <br /></td></tr>
<tr class="separator:ga7e9fa03f67d3250d913cb7cf9feeafa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c7ad1103bb3d8a7978dc3656d7d7c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac7c7ad1103bb3d8a7978dc3656d7d7c7">CSL_EPWM_HR_REG_ACT_LOAD_CNT_ZRO_PULSE</a>&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_PULSESEL_SEL_CNT_ZERO_PULSE)</td></tr>
<tr class="separator:gac7c7ad1103bb3d8a7978dc3656d7d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d8959e8f38129c118dac77477f6e4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga05d8959e8f38129c118dac77477f6e4c">CSL_EPWM_HR_REG_ACT_LOAD_PRD_EQ_PULSE</a>&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_PULSESEL_SEL_PRD_EQ_PULSE)</td></tr>
<tr class="separator:ga05d8959e8f38129c118dac77477f6e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaac7f7617737c68047d7351ea1162021b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_ACTION_DONOTHING&#160;&#160;&#160;(PWMSS_EPWM_AQCTLA_ZRO_DISABLED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do nothing (Action disabled). </p>

</div>
</div>
<a class="anchor" id="ga21295de17d4264be8d542c57b71f31ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_ACTION_HIGH&#160;&#160;&#160;(PWMSS_EPWM_AQCTLA_ZRO_SET)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set: Force EPWMx output high. </p>

</div>
</div>
<a class="anchor" id="gae3da9d904d15793312c7cb7fa9ef095a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_ACTION_LOW&#160;&#160;&#160;(PWMSS_EPWM_AQCTLA_ZRO_CLEAR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear: Force EPWMx output low. </p>

</div>
</div>
<a class="anchor" id="gac6a5a1d743513b25a7dbb94f4edb90c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_ACTION_TOLLGE&#160;&#160;&#160;(CSL_EPQM_AQ_ACTION_TOLLGE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Toggle EPWMx output: low output signal will be forced high, and a high signal will be forced low. </p>

</div>
</div>
<a class="anchor" id="ga0104dce46379280ca5739154641c0f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_PRD&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_RLDCSF_CTR_PERIOD)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load on event counter equals period. </p>

</div>
</div>
<a class="anchor" id="gac02619d51fa8417b775d9c637761b154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_ZRO&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_RLDCSF_CTR_0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load on event counter equals zero. </p>

</div>
</div>
<a class="anchor" id="ga806ab8d498ce37d2708d93371b735f8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_ZRO_OR_PRD&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_RLDCSF_CTR_0_OR_PERIOD)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load on event counter equals zero or counter equals period. </p>

</div>
</div>
<a class="anchor" id="gad92ace7c47be5777174c80be846cb632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_CSFRC_REG_RELOAD_IMMEDIATE&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_RLDCSF_IMMEDIATE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load immediately. </p>

</div>
</div>
<a class="anchor" id="gacee90202e7cb04a27ea6bf149094d455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_HIGH&#160;&#160;&#160;(PWMSS_EPWM_AQCSFRC_CSFA_HIGH_OUTPUT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces a continuous high on output A. </p>

</div>
</div>
<a class="anchor" id="ga5c5e6788fc8c295d5be9ec95c97c09fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_LOW&#160;&#160;&#160;(PWMSS_EPWM_AQCSFRC_CSFA_LOW_OUTPUT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces a continuous low on output A. </p>

</div>
</div>
<a class="anchor" id="gaf55811355adbd92b71743e8e9a8fa7ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_NOEFFECT&#160;&#160;&#160;(PWMSS_EPWM_AQCSFRC_CSFA_DISABLED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forcing disabled, that is, has no effect. </p>

</div>
</div>
<a class="anchor" id="ga77b3853721b4894b61900ba3b141d595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_SW_DISBALED&#160;&#160;&#160;(PWMSS_EPWM_AQCSFRC_CSFA_NO_EFFECT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Software forcing is disabled and has no effect. </p>

</div>
</div>
<a class="anchor" id="ga3cab589b53f00bf881cf378035b606bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_SW_TRIG_OT_ACTION_DONOTHING&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_ACTSFA_DISABLED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do nothing (Action disabled). </p>

</div>
</div>
<a class="anchor" id="gadc14b1f270afafc863b2c723dc8de0a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_SW_TRIG_OT_ACTION_HIGH&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_ACTSFA_SET)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set: Output high. </p>

</div>
</div>
<a class="anchor" id="gacb445c38f875b24ecf8059c57925a791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_SW_TRIG_OT_ACTION_LOW&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_ACTSFA_CLEAR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear: Output Low. </p>

</div>
</div>
<a class="anchor" id="ga1f87c8328d7786877ccda13d2f062de6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_AQ_SW_TRIG_OT_ACTION_TOGGLE&#160;&#160;&#160;(PWMSS_EPWM_AQSFRC_ACTSFA_TOGGLE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Toggle output. </p>

</div>
</div>
<a class="anchor" id="gafa35f07d4b9f249aea860c314e42bab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CC_CMP_A&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga838d8d8d0bba6547ebcbb70cc0574b05">CSL_EPWM_CC_CMP_MIN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter Comparator A. </p>

</div>
</div>
<a class="anchor" id="ga240fd702fd04a054d74573302bd29187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CC_CMP_B&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter Comparator B. </p>

</div>
</div>
<a class="anchor" id="ga5c62025f5e6dc378556d1a03ec5aff00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_PRD&#160;&#160;&#160;(PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_PRD)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load on CTR = PRD: Time-base counter equal to period. </p>

</div>
</div>
<a class="anchor" id="gacae07c3f4f1779cc827b04d48cefea56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_ZERO&#160;&#160;&#160;(PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load on CTR = 0: Time-base counter equal to zero. </p>

</div>
</div>
<a class="anchor" id="ga04e6209d518aa186db5f6b6e6475e032"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_ZERO_OR_PRD&#160;&#160;&#160;(PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0_OR_PRD)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load on either CTR = 0 or CTR = PRD. </p>

</div>
</div>
<a class="anchor" id="gaca52f34e904f5ccf09fbb0398da8d27a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CC_CMP_LOAD_MODE_NO_LOAD&#160;&#160;&#160;(PWMSS_EPWM_CMPCTL_LOADAMODE_FREEZE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Freeze (no loads possible). </p>

</div>
</div>
<a class="anchor" id="ga0cc665fc7e98c0e40600e5e8ecec204f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CC_CMP_MAX&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga240fd702fd04a054d74573302bd29187">CSL_EPWM_CC_CMP_B</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum value of enumeration. Used for input validation. </p>

</div>
</div>
<a class="anchor" id="ga838d8d8d0bba6547ebcbb70cc0574b05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CC_CMP_MIN&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minimum value of enumeration. Used for input validation. </p>

</div>
</div>
<a class="anchor" id="ga561d12603c957579c01532ebfe8a0c10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_CLK_FREQ_DIV_BY_1&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide by 1 (no prescale). </p>

</div>
</div>
<a class="anchor" id="gaa3a9b38ae81824fa22ce8d4d7fc2b51b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_CLK_FREQ_DIV_BY_2&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide by 2. </p>

</div>
</div>
<a class="anchor" id="ga7587fecd9b1eee18064ce7699af3396d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_CLK_FREQ_DIV_BY_3&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide by 3. </p>

</div>
</div>
<a class="anchor" id="gaeacb6bb536bb7c3341731763e8bece2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_CLK_FREQ_DIV_BY_4&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide by 4. </p>

</div>
</div>
<a class="anchor" id="ga641672133a43b413424de503d571744e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_CLK_FREQ_DIV_BY_5&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide by 5. </p>

</div>
</div>
<a class="anchor" id="ga7dc88d2e0e05bc30a540d848a468c7d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_CLK_FREQ_DIV_BY_6&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide by 6. </p>

</div>
</div>
<a class="anchor" id="ga7b531ae313bc539a552f8b154895a338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_CLK_FREQ_DIV_BY_7&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide by 7. </p>

</div>
</div>
<a class="anchor" id="ga97d81e0f575c3077b70102507fe2f05c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_CLK_FREQ_DIV_BY_8&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPFREQ_DIV_8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide by 8. </p>

</div>
</div>
<a class="anchor" id="ga48cc2b49d51301e48b665cbf813d958c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_DUTY_CYCLE_PERC_12PNT5&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_12_5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duty cycle 1/8 (12.5%). </p>

</div>
</div>
<a class="anchor" id="gacb029e91cc10ce06940efc77c6d0615d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_DUTY_CYCLE_PERC_25&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_25)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duty cycle 2/8 (25%). </p>

</div>
</div>
<a class="anchor" id="ga0db9640f0d048ccac9f8a856a46b3305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_DUTY_CYCLE_PERC_37PNT5&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_37_5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duty cycle 3/8 (37.5%). </p>

</div>
</div>
<a class="anchor" id="gab62124d78b25d0bd314b8fe66694f297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_DUTY_CYCLE_PERC_50_PER&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_50)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duty cycle 4/8 (50%). </p>

</div>
</div>
<a class="anchor" id="ga11bf01f6d9dbb064b61872d2f5ad569b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_DUTY_CYCLE_PERC_62PNT5&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_62_5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duty cycle 5/8 (62.5%). </p>

</div>
</div>
<a class="anchor" id="gaf72689d1c54bd0f6943ff04f3103d6cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_DUTY_CYCLE_PERC_75&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_75)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duty cycle 6/8 (75%). </p>

</div>
</div>
<a class="anchor" id="gaf8bc48049e6dc0796df102dfdeb91455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_DUTY_CYCLE_PERC_87PNT5&#160;&#160;&#160;(PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_87_5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duty cycle 7/8 (87.5%). </p>

</div>
</div>
<a class="anchor" id="ga45a06750c1261b29f2f563cf77228c03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_10XSYSOUT_BY_8&#160;&#160;&#160;(9U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>10 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="ga653442a660e90ed70dc16ebaeb9a5761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_11XSYSOUT_BY_8&#160;&#160;&#160;(10U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>11 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gab2e337d2dbd6efb9c2d2399c8fed5298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_12XSYSOUT_BY_8&#160;&#160;&#160;(11U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>12 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="ga9607955ceb8ae3de370f21709b3bd4da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_13XSYSOUT_BY_8&#160;&#160;&#160;(12U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>13 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gabeb31881a83a805b98183d5d990f0782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_14XSYSOUT_BY_8&#160;&#160;&#160;(13U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>14 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gaea12f8e03e0a77adb4d5c0062217afad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_15XSYSOUT_BY_8&#160;&#160;&#160;(14U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>15 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="ga1a304316f1ef72888af25035a7442dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_16XSYSOUT_BY_8&#160;&#160;&#160;(15U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>16 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="ga21a1330a246edf8b2aaf74750ed581f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_1XSYSOUT_BY_8&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga1280117993aa611fa0d107458eed12c1">CSL_EPWM_CHP_OSHT_WIDTH_MIN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>1 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gaceaf8e1ec3812636bbc8ad6ec4276271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_2XSYSOUT_BY_8&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>2 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gae1f95e72ad356bfe961dbc724ba20511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_3XSYSOUT_BY_8&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>3 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="ga9c167c56e425cb6df148be858e0e42a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_4XSYSOUT_BY_8&#160;&#160;&#160;(3U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>4 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gac1cad396375c37d0fa038fd169eb0318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_5XSYSOUT_BY_8&#160;&#160;&#160;(4U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>5 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="ga2ba436ec9115a352b9324c0dfe2e31b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_6XSYSOUT_BY_8&#160;&#160;&#160;(5U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>6 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gab13ad6b9d1f87a2026dc1c42a15cb531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_7XSYSOUT_BY_8&#160;&#160;&#160;(6U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>7 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gaee2ea42faa1d207b28d405474ec101d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_8XSYSOUT_BY_8&#160;&#160;&#160;(7U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>8 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gacda46ccb87a947903f0d7b03dc1f4d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_9XSYSOUT_BY_8&#160;&#160;&#160;(8U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>9 x SYSCLKOUT/8 wide. </p>

</div>
</div>
<a class="anchor" id="gab0d4fe83df29f6f326db0172d97b6eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_MAX&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga1a304316f1ef72888af25035a7442dde">CSL_EPWM_CHP_OSHT_WIDTH_16XSYSOUT_BY_8</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum value of enumeration. Used for input validation. </p>

</div>
</div>
<a class="anchor" id="ga1280117993aa611fa0d107458eed12c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_CHP_OSHT_WIDTH_MIN&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minimum value of enumeration. Used for input validation. </p>

</div>
</div>
<a class="anchor" id="gaa975aa421d31ee9c5cded73378567140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_IN_MODE_A_RED_A_FED&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_IN_MODE_SRC_ARED_AFED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EPWMxA In (from the action-qualifier) is the source for both falling-edge and rising-edge delay. </p>

</div>
</div>
<a class="anchor" id="gaaf34c24dad7551404f856099848c9ccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_IN_MODE_A_RED_B_FED&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_IN_MODE_SRC_ARED_BFED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EPWMxA In (from the action-qualifier) is the source for rising-edge delayed signal. EPWMxB In (from the action-qualifier) is the source for falling-edge delayed signal. </p>

</div>
</div>
<a class="anchor" id="gaf74ab10dea4be7428b721ca5468b53ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_IN_MODE_B_RED_A_FED&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_IN_MODE_SRC_BRED_AFED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EPWMxB In (from the action-qualifier) is the source for rising-edge delayed signal. EPWMxA In (from the action-qualifier) is the source for falling-edge delayed signal. </p>

</div>
</div>
<a class="anchor" id="ga812cc413bba2011102fd609b4bcbd5eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_IN_MODE_B_RED_B_FED&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_IN_MODE_SRC_BRED_BFED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EPWMxB In (from the action-qualifier) is the source for both rising-edge delay and falling-edge delayed signal. </p>

</div>
</div>
<a class="anchor" id="ga2d8812146ebdd8df9e363eee4e327ef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_OUT_MODE_A_RED_B_FED&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_OUT_MODE_ENABLED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dead-band is fully enabled for both rising-edge delay on output EPWMxA and falling-edge delay on output EPWMxB. </p>

</div>
</div>
<a class="anchor" id="ga44752d64cd3deda1fb28ba841772464d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_OUT_MODE_A_RED_NO_FED&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_OUT_MODE_DISABLE_FALLING_EDGE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable falling-edge delay. The EPWMxB signal from the action-qualifier is passed straight through to the EPWMxB input of the PWM-chopper sub-module. The rising-edge delayed signal is seen on output EPWMxA. </p>

</div>
</div>
<a class="anchor" id="gab68e3c2b80c627431192c5aea2dcec4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_OUT_MODE_BYPASS&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_OUT_MODE_DISABLED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dead-band generation is bypassed for both output signals. In this mode, both the EPWMxA and EPWMxB output signals from the action-qualifier are passed directly to the PWM-chopper sub-module. </p>

</div>
</div>
<a class="anchor" id="gacc3731088ee696538c63146afc8d064a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_OUT_MODE_NO_RED_B_FED&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_OUT_MODE_DISABLE_RISING_EDGE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable rising-edge delay. The EPWMxA signal from the action-qualifier is passed straight through to the EPWMxA input of the PWM-chopper sub-module. The falling-edge delayed signal is seen on output EPWMxB </p>

</div>
</div>
<a class="anchor" id="ga0db3d52db6e30318847920f84d46017a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_POL_SEL_ACTV_HIGH&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_POLSEL_ACTIVE_HIGH)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Neither EPWMxA nor EPWMxB is inverted (default). </p>

</div>
</div>
<a class="anchor" id="ga9ec1713dc02aa5890535cbad82a996a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_POL_SEL_ACTV_HIGH_COMPLEMENTARY&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_POLSEL_ACTIVE_HIGH_COMPLEMENTARY)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EPWMxB is inverted. </p>

</div>
</div>
<a class="anchor" id="ga76c3add499208256c56ed4cd044dd01e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_POL_SEL_ACTV_LOW&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_POLSEL_ACTIVE_LOW)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Both EPWMxA and EPWMxB are inverted. </p>

</div>
</div>
<a class="anchor" id="ga143a69cdc9e96e27b70b5b6d591ff628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_DB_POL_SEL_ACTV_LOW_COMPLEMENTARY&#160;&#160;&#160;(PWMSS_EPWM_DBCTL_POLSEL_ACTIVE_LOW_COMPLEMENTARY)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EPWMxA is inverted. </p>

</div>
</div>
<a class="anchor" id="ga97e54033a28b056b3cb5319aabb2dca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPA_DEC&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_CMPA_DECR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable event time-base counter equal to CMPA when the timer is decrementing. </p>

</div>
</div>
<a class="anchor" id="ga954997096a2fdc274953bf72832e046f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPA_INC&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_CMPA_INCR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable event time-base counter equal to CMPA when the timer is incrementing. </p>

</div>
</div>
<a class="anchor" id="ga39a9212b9f65a50c500a00991a894066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPB_DEC&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_CMPB_DECR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable event: time-base counter equal to CMPB when the timer is decrementing. </p>

</div>
</div>
<a class="anchor" id="gac0ba070a2fd8d9f6d9a01f4220b081a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPB_INC&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_CMPB_INCR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable event: time-base counter equal to CMPB when the timer is incrementing. </p>

</div>
</div>
<a class="anchor" id="gaeba787df44595e607b87c6ce44fb1534"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_EVT_CNT_EQ_PRD&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_PERIOD)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable event time-base counter equal to period (TBCNT = TBPRD). </p>

</div>
</div>
<a class="anchor" id="ga968e05343b35765cc80e6ce095b72cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_EVT_CNT_EQ_ZRO&#160;&#160;&#160;(PWMSS_EPWM_ETSEL_INTSEL_CTR_0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable event time-base counter equal to zero. (TBCNT = 0000h). </p>

</div>
</div>
<a class="anchor" id="gabe5f552a9b5e79ec1b80cef8c1d5a8b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_PERIOD_DIS_INTR&#160;&#160;&#160;(PWMSS_EPWM_ETPS_INTPRD_DISABLE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the interrupt event counter. No interrupt will be generated. </p>

</div>
</div>
<a class="anchor" id="ga2e230ac038ce07cc125f8ccf2583f771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_PERIOD_FIRST_EVT&#160;&#160;&#160;(PWMSS_EPWM_ETPS_INTPRD_GEN_FIRST_EVT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an interrupt on the first event. </p>

</div>
</div>
<a class="anchor" id="gab888d03bd6b6f5f444bef06b12c2dcb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_PERIOD_SECOND_EVT&#160;&#160;&#160;(PWMSS_EPWM_ETPS_INTPRD_GEN_SECOND_EVT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an interrupt on the second event. </p>

</div>
</div>
<a class="anchor" id="ga59b53d675f0790cac472cfcf979993d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_ET_INTR_PERIOD_THIRD_EVT&#160;&#160;&#160;(PWMSS_EPWM_ETPS_INTPRD_GEN_THIRD_EVT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an interrupt on the third event. </p>

</div>
</div>
<a class="anchor" id="gae75e4332c0d510105391724ebd15a88a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_HR_DELAY_BUS_SEL_CMPAHR&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELBUSSEL_SEL_CMPAHR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select CMPAHR(8) bus from compare module of EPWM (default on reset). </p>

</div>
</div>
<a class="anchor" id="ga825b458b471652b404a0f5dc74a50935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_HR_DELAY_BUS_SEL_TBPHSHR&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELBUSSEL_SEL_TBPHSHR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select TBPHSHR(8) bus from time base module. </p>

</div>
</div>
<a class="anchor" id="gac21027736d9b138ac44ccff6a795dc18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_HR_DELAY_EDGE_CTRL_BOTH&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELMODE_DELAY_ON_BOTH_EDGES)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay inserted on both edges. </p>

</div>
</div>
<a class="anchor" id="gae303eb0a572420dc8633d91b35a82da7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_HR_DELAY_EDGE_CTRL_FALLING&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELMODE_DELAY_FALLING_EDGE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay inserted falling edge. </p>

</div>
</div>
<a class="anchor" id="ga24260a8f1d868403c5ca27cb03fb3be1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_HR_DELAY_EDGE_CTRL_NO_DELAY&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELMODE_NO_DELAY)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No delay inserted (default on reset). </p>

</div>
</div>
<a class="anchor" id="ga5bafac8e96d26c6bfb7bb947d18de384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_HR_DELAY_EDGE_CTRL_RISING&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_DELMODE_DELAY_RISING_EDGE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay inserted rising edge. </p>

</div>
</div>
<a class="anchor" id="gac7c7ad1103bb3d8a7978dc3656d7d7c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_HR_REG_ACT_LOAD_CNT_ZRO_PULSE&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_PULSESEL_SEL_CNT_ZERO_PULSE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select CNT_zero pulse. </p>

</div>
</div>
<a class="anchor" id="ga05d8959e8f38129c118dac77477f6e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_HR_REG_ACT_LOAD_PRD_EQ_PULSE&#160;&#160;&#160;(PWMSS_EPWM_HRCTL_PULSESEL_SEL_PRD_EQ_PULSE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select CNT_zero pulse. </p>

</div>
</div>
<a class="anchor" id="ga2326cce479b910b21928e58080cb4869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_OUTPUT_CH_A&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#gaec672943ec79f8fb3a0342bec99ab7fc">CSL_EPWM_OUTPUT_CH_MIN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output channel A. </p>

</div>
</div>
<a class="anchor" id="ga15e15752c66632890e97d3b0c2b0627a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_OUTPUT_CH_B&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output channel B. </p>

</div>
</div>
<a class="anchor" id="ga389cc04f50ac2e37ac4229d4f1ba8960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_OUTPUT_CH_MAX&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#ga15e15752c66632890e97d3b0c2b0627a">CSL_EPWM_OUTPUT_CH_B</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum value of enumeration. Used for input validation. </p>

</div>
</div>
<a class="anchor" id="gaec672943ec79f8fb3a0342bec99ab7fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_OUTPUT_CH_MIN&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minimum value of enumeration. Used for input validation. </p>

</div>
</div>
<a class="anchor" id="gafcded6c044417a0c604f64725d2e21e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_SHADOW_REG_CTRL_DISABLE&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_PRDLD_LOAD_IMMEDIATELY)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shadow register is disabled and active register value will be used. </p>

</div>
</div>
<a class="anchor" id="ga3d943145882309b498a8accac1e26cfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_SHADOW_REG_CTRL_ENABLE&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_PRDLD_LOAD_FROM_SHADOW)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shadow register value will be used. </p>

</div>
</div>
<a class="anchor" id="ga46718c7834d835d2787923fe2c843cb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_CNT_DIR_AFT_SYNC_DOWN&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_PHSDIR_COUNT_DOWN)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count down after the synchronization event. </p>

</div>
</div>
<a class="anchor" id="gadc8e13599754bd2bca03cd2918d8104e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_CNT_DIR_AFT_SYNC_UP&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_PHSDIR_COUNT_UP)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count up after the synchronization event. </p>

</div>
</div>
<a class="anchor" id="gadea3897fdd5d4b52b992040fdb41f034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_COUNTER_DIR_DOWN&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_CTRMODE_DOWN_COUNT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Down count mode. </p>

</div>
</div>
<a class="anchor" id="ga6898fb3b5a8668eff093d6fb9c5d6159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_COUNTER_DIR_STOP&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_CTRMODE_STOP_FREEZE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>stop-freeze counter operation (default on reset). </p>

</div>
</div>
<a class="anchor" id="gad9f7570f593be6c1b9d7d0e165f0c9b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_COUNTER_DIR_UP&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_CTRMODE_UP_COUNT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Up Count mode. </p>

</div>
</div>
<a class="anchor" id="gaa8fb19e09f24903c5e002a7731b2ccfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_COUNTER_DIR_UP_DOWN&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_CTRMODE_UP_DOWN_COUNT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Up down count mode. </p>

</div>
</div>
<a class="anchor" id="gafbc6c093ae6a7eaf3b174e35b3896d84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_EMU_MODE_STP_AFT_COMPLETE_CYCLE&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_FREE_SOFT_STOP_AFTER_CYCLE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop after the next time-base counter increment or decrement. Up-count mode: stop when the time-base counter = period. Down-count mode: stop when the time-base counter = 0000. Up-down-count mode: stop when the time-base counter = 0000. </p>

</div>
</div>
<a class="anchor" id="ga75fc2d257901bc79117c6fd2c6be1168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_EMU_MODE_STP_AFT_NEXT_CYCLE&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_FREE_SOFT_STOP_AFTER_NEXT_CTR)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop after the next time-base counter increment or decrement. </p>

</div>
</div>
<a class="anchor" id="ga507266728005582735b491d7efab89ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_SYNC_OUT_EVT_CNT_EQ_CMP_B&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_SYNCOSEL_CTR_CPMB)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time-base counter equal to counter-compare B (TBCNT = CMPB). </p>

</div>
</div>
<a class="anchor" id="ga0c3229782686f3e1b6d823317d5227a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_SYNC_OUT_EVT_CNT_EQ_ZERO&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_SYNCOSEL_CTR_0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time-base counter equal to zero. </p>

</div>
</div>
<a class="anchor" id="ga5c2770de6ef4dbdb8839e2043c5d7791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_SYNC_OUT_EVT_DISABLE&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_SYNCOSEL_DISABLE_EPWMXSYNCO)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable EPWMxSYNCO(Sync Output) signal. </p>

</div>
</div>
<a class="anchor" id="gae1724908c9552f6e7ebd31454791d9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TB_SYNC_OUT_EVT_SYNCIN&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_SYNCOSEL_EPWMXSYNC)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sync Input signal. </p>

</div>
</div>
<a class="anchor" id="gae15a910346642ffdf4212ef5fbe79557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_EVENT_CYCLE_BY_CYCLE&#160;&#160;&#160;(0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cycle by cycle trip zone event. </p>

</div>
</div>
<a class="anchor" id="ga038d6344fa139f888e77f84dd44273cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_EVENT_MAX&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#gae15a910346642ffdf4212ef5fbe79557">CSL_EPWM_TZ_EVENT_CYCLE_BY_CYCLE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum value of enumeration. Used for input validation. </p>

</div>
</div>
<a class="anchor" id="gaa530beeef3837b64ffb5a15bb69dc8eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_EVENT_MIN&#160;&#160;&#160;(0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minimum value of enumeration. Used for input validation. </p>

</div>
</div>
<a class="anchor" id="ga985219a76b3986497b8c5d12b9091d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_EVENT_ONE_SHOT&#160;&#160;&#160;(<a class="el" href="group___c_s_l___e_p_w_m.html#gaa530beeef3837b64ffb5a15bb69dc8eb">CSL_EPWM_TZ_EVENT_MIN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One shot trip zone event. </p>

</div>
</div>
<a class="anchor" id="gab5e0444f465228b6fc555c2dedd2949c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_STS_FLG_CBC&#160;&#160;&#160;(PWMSS_EPWM_TZFLG_CBC_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Latched Status Flag for Cycle-By-Cycle Trip Event. </p>

</div>
</div>
<a class="anchor" id="gacb52a12d4069f3c25f8b7397c2e2fb35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_STS_FLG_INT&#160;&#160;&#160;(PWMSS_EPWM_TZFLG_INT_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Latched status for Trip Interrupt . </p>

</div>
</div>
<a class="anchor" id="gafe4b4207f2b2c88d58004f0f346849fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_STS_FLG_OST&#160;&#160;&#160;(PWMSS_EPWM_TZFLG_OST_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Latched Status Flag for A One-Shot Trip Event. </p>

</div>
</div>
<a class="anchor" id="gab062d137039917526333ede6a3853a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_TRIP_ACTION_DO_NOTHING&#160;&#160;&#160;(PWMSS_EPWM_TZCTL_TZA_DO_NOTHING)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do nothing, no action is taken on EPWMxA. </p>

</div>
</div>
<a class="anchor" id="ga217b576287f68033af8725522ca43986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_TRIP_ACTION_HIGH&#160;&#160;&#160;(PWMSS_EPWM_TZCTL_TZA_HIGH_STATE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force EPWMxA to a high state. </p>

</div>
</div>
<a class="anchor" id="ga16635db394cd7ac86b1276bf30c6676f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_TRIP_ACTION_LOW&#160;&#160;&#160;(PWMSS_EPWM_TZCTL_TZA_LOW_STATE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force EPWMxA to a low state. </p>

</div>
</div>
<a class="anchor" id="ga39d3d7bb8a70569e3750cd4b66256b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_EPWM_TZ_TRIP_ACTION_TRI_STATE&#160;&#160;&#160;(PWMSS_EPWM_TZCTL_TZA_HIGH_IMPEDANCE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>High impedance (EPWMxA = High-impedance state). </p>

</div>
</div>
<a class="anchor" id="gad9889496c285364e9669859164d4fecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPWM_TB_EMU_MODE_FREE_RUN&#160;&#160;&#160;(PWMSS_EPWM_TBCTL_FREE_SOFT_RUN2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter is in Free run. </p>

</div>
</div>
<a class="anchor" id="ga91a2682a21e9ee70a8a6d53eb9959560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPWM_TB_STS_CTR_DIR&#160;&#160;&#160;(PWMSS_EPWM_TBSTS_CTRDIR_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time-Base Counter Direction Status. </p>

</div>
</div>
<a class="anchor" id="ga0b99bd82535f931391d564aac925352c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPWM_TB_STS_CTR_MAX&#160;&#160;&#160;(PWMSS_EPWM_TBSTS_CTRMAX_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time-Base Counter Max Latched Status. </p>

</div>
</div>
<a class="anchor" id="ga6c14239a94d052ef9a7d4a69b2d1a240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPWM_TB_STS_SYNCI&#160;&#160;&#160;(PWMSS_EPWM_TBSTS_SYNCI_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input Synchronization Latched Status. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga247be6082138b847e1b839ef6b8830e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___c_s_l___e_p_w_m.html#ga247be6082138b847e1b839ef6b8830e0">CSL_EpwmAqAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of Actions that Action Qualifier can take on the Output when the supported counter compare event occurs. </p>
<p>Same actions will be applicable for all the supported events and same actions are applicable for both A and B channel PWM outputs.</p>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for all the events and for both A and B because their field values are same.<ul>
<li>Action Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_PRD_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CAU_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CAD_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CBU_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CBD_DISABLED</li>
</ul>
</li>
<li>Action high macros with value 0x1<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_PRD_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CAU_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CAD_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CBU_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CBD_CLEAR</li>
</ul>
</li>
<li>Action low macros with value 0x2<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_SET</li>
<li>PWMSS_EPWM_AQCTLx_PRD_SET</li>
<li>PWMSS_EPWM_AQCTLx_CAU_SET</li>
<li>PWMSS_EPWM_AQCTLx_CAD_SET</li>
<li>PWMSS_EPWM_AQCTLx_CBU_SET</li>
<li>PWMSS_EPWM_AQCTLx_CBD_SET</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_PRD_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CAU_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CAD_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CBU_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CBD_TOGGLE </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gadd0542055b2b9e8a67cada3734768970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___c_s_l___e_p_w_m.html#gadd0542055b2b9e8a67cada3734768970">CSL_EpwmAqSwTrigContAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of Continuous software forced actions on output. </p>
<p>Same macros will be used for configuration of both A and B PWM outputs, because bit field values for both A and B are same.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros,<ul>
<li>Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_DISABLED</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_DISABLED</li>
</ul>
</li>
<li>Action low macros with value 0x1<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_LOW_OUTPUT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_LOW_OUTPUT</li>
</ul>
</li>
<li>Action high macros with value 0x2<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_HIGH_OUTPUT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_HIGH_OUTPUT</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_NO_EFFECT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_NO_EFFECT </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga04f5a1d05aa074e82a78fa0487699942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___c_s_l___e_p_w_m.html#ga04f5a1d05aa074e82a78fa0487699942">CSL_EpwmAqSwTrigOtAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actions to be taken on the output, when Software triggered one time events will occur. </p>
<p>Same macros will be used for both A and B channel outputs because the bit field values are same.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros,<ul>
<li>Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_DISABLED</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_DISABLED</li>
</ul>
</li>
<li>Action low macros with value 0x1<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_CLEAR</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_CLEAR</li>
</ul>
</li>
<li>Action high macros with value 0x2<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_SET</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_SET</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_TOGGLE</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_TOGGLE </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabaaf6d257f978e30f2aeead3ab8ff83e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___c_s_l___e_p_w_m.html#gabaaf6d257f978e30f2aeead3ab8ff83e">CSL_EpwmCcCmp_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\ Counter Comparator type either A or B. </p>

</div>
</div>
<a class="anchor" id="gaa9fa681cfe0d40be47575a99f8c30026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___c_s_l___e_p_w_m.html#gaa9fa681cfe0d40be47575a99f8c30026">CSL_EpwmCcCmpLoadMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter-Comparator registers(A and B) load mode flags from shadow register. </p>
<p>Same macros will be used to control the following registers</p><ul>
<li>Counter Comparator A register</li>
<li>Counter Comparator B register</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for controlling all the three registers because the field values are same for all these cases.<ul>
<li>load when counter equals zero = 0x0</li>
<li>load when counter equals period = 0x1</li>
<li>load when counter equals zero or period = 0x2</li>
<li>Do not load = 0x3 In any case if these values changes across the above mentioned registers, then separate macros need to be used.</li>
<li>Load when counter equals zero macros with value 0x0<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0,</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_0,</li>
</ul>
</li>
<li>Load when counter equals period macros with value 0x1<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_PRD</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_PRD</li>
</ul>
</li>
<li>Load when counter equals zero or period macros with value 0x2<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0_OR_PRD</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_0_OR_PRD</li>
</ul>
</li>
<li>Do not load macros with value 0x3<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_FREEZE</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_FREEZE </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4af92ad6f2f6690f974917168ba10c6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___c_s_l___e_p_w_m.html#ga4af92ad6f2f6690f974917168ba10c6d">CSL_EpwmShadowRegCtrl_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow register enable or disable control. </p>
<p>Same macros will be used to control the following shadow registers</p><ul>
<li>Time Base period register</li>
<li>Counter Comparator A register</li>
<li>Counter Comparator B register</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for controlling all the three registers because the field values are same for all these cases.<ul>
<li>Shadow enable = 0x0</li>
<li>Shadow disable = 0x1 In any case if these values changes across the above mentioned registers then separate macros need to be used.</li>
<li>Shadow enable macros with value 0x0<ul>
<li>PWMSS_EPWM_TBCTL_PRDLD_LOAD_FROM_SHADOW,</li>
<li>PWMSS_EPWM_CMPCTL_SHDWAMODE_SHADOW,</li>
<li>PWMSS_EPWM_CMPCTL_SHDWBMODE_SHADOW</li>
</ul>
</li>
<li>Shadow disable macros with value 0x1<ul>
<li>PWMSS_EPWM_TBCTL_PRDLD_LOAD_IMMEDIATELY</li>
<li>PWMSS_EPWM_CMPCTL_SHDWAMODE_IMMEDIATE</li>
<li>PWMSS_EPWM_CMPCTL_SHDWBMODE_IMMEDIATE </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga338b02aaed675499de7696e0cb0a7e8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___c_s_l___e_p_w_m.html#ga338b02aaed675499de7696e0cb0a7e8d">CSL_EpwmTzTripAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Action to be taken on PWM output When a trip event occurs. </p>
<p>Same macros will be used to control both A and B outputs because the bit field values are same for A and B channels.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros<ul>
<li>Tri state action macro with value 0x0<ul>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_IMPEDANCE</li>
<li>PWMSS_EPWM_TZCTL_TZB_HIGH_IMPEDANCE</li>
</ul>
</li>
<li>High action macro with value 0x1<ul>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_STATE</li>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_STATE</li>
</ul>
</li>
<li>Low action macro with value 0x2<ul>
<li>PWMSS_EPWM_TZCTL_TZA_LOW_STATE</li>
<li>PWMSS_EPWM_TZCTL_TZB_LOW_STATE</li>
</ul>
</li>
<li>Do nothing action macro with value 0x3<ul>
<li>PWMSS_EPWM_TZCTL_TZA_DO_NOTHING</li>
<li>PWMSS_EPWM_TZCTL_TZB_DO_NOTHING </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1fc5067aa5e5a90ee10b896dd912a7d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmAqActionOnOutputCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmOutputCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_p_w_m.html#gaaa3bc020da4d3d9c9c13d5259e44e2ad">CSL_EpwmAqActionCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the action to be taken on output by the Action qualifier module upon receiving the events. This will determine the output waveform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pwmOutputCh</td><td>PWM Output channel type either A or B 'pwmOutputCh' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga67c6393a7b0407c0b00d9cf76845a983" title="Number of supported EPWM outputs in a single epwm channel. ">CSL_EpwmOutputCh_t</a>.</li>
</ul>
</td></tr>
    <tr><td class="paramname">pCfg</td><td>Pointer to the following structure which contains the action configuration variables for different events<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gaaa3bc020da4d3d9c9c13d5259e44e2ad" title="Structure holding the Action Qualifier actions to be taken on the PWM output at the specific events...">CSL_EpwmAqActionCfg_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Each event can be configured to one of the following enum values.<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga247be6082138b847e1b839ef6b8830e0" title="Types of Actions that Action Qualifier can take on the Output when the supported counter compare even...">CSL_EpwmAqAction_t</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab659bf7153e07a716955b1041a83b7e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmAqSwTriggerContAction </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmOutputCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swTrigAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>activeRegReloadMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API forces output value continuously on PWM output channel. The output can be forced to low or high. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pwmOutputCh</td><td>PWM Output channel type either A or B 'pwmOutputCh' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga67c6393a7b0407c0b00d9cf76845a983" title="Number of supported EPWM outputs in a single epwm channel. ">CSL_EpwmOutputCh_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">swTrigAction</td><td>Value to be forced on the output This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gadd0542055b2b9e8a67cada3734768970" title="Types of Continuous software forced actions on output. ">CSL_EpwmAqSwTrigContAction_t</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">activeRegReloadMode</td><td>Shadow to active reg load trigger. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga15408044a1b06cbf59eadef7f30dfb9f" title="Action Qualifier Software Force Active Register Reload From Shadow Options. ">CSL_EpwmAqCsfrcRegReload_t</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94dcc6812f81713d1de771192f25996f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmAqSwTriggerOneTimeAction </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmOutputCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swTrigAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API triggers the SW forced single event on the PWM output. </p>
<p>This can be used for testing the AQ sub-module. Every call to this API will trigger a single event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pwmOutputCh</td><td>PWM Output channel type either A or B 'pwmOutputCh' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga67c6393a7b0407c0b00d9cf76845a983" title="Number of supported EPWM outputs in a single epwm channel. ">CSL_EpwmOutputCh_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">swTrigAction</td><td>Action that needs to be taken on the PWM output. 'swTrigAction' can take one of the following enum values<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga04f5a1d05aa074e82a78fa0487699942" title="Actions to be taken on the output, when Software triggered one time events will occur. ">CSL_EpwmAqSwTrigOtAction_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae12f7f88391a3459181789d911f8184b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmChopperCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_p_w_m.html#ga494e3bbf20e23cebda4ffb422961c7ba">CSL_EpwmChopperCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API performs the configuration of the chopper sub-module. This API configures chopping clock duty cycle, chopping clock frequency and pulse width of first pulse of chopping clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pCfg</td><td>Pointer to the structure <a class="el" href="group___c_s_l___e_p_w_m.html#ga494e3bbf20e23cebda4ffb422961c7ba" title="Structure holding the configuration parameters of Chopper sub-module. ">CSL_EpwmChopperCfg_t</a> containing the chopper configuration parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04dd41f4f5a88637ec8927237ee5b14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmChopperEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enableChopper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls the enabling or disabling of chopper sub-module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">enableChopper</td><td>Flag controlling the enabling or disabling 'enableChopper' can take one of the following values<ul>
<li>TRUE - Enable chopper</li>
<li>FALSE - Disable chopper </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a03b4b23292be66294e87e374e640a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_epwmClockDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions disables clock for EPWM sub-module in the PWM subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>for success </td></tr>
    <tr><td class="paramname">CSL_EUNSUPPORTED_CMD</td><td>for unsupported API on this SOC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API disables the clock for the EPWM module which is present inside the PWM subsystem. The clocks for the PWM Sub system will be disabled inside the PRCM module. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83fac9bc328de6de99dc2154f0f895d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_epwmClockEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions enables clock for EPWM module in PWM subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>for success </td></tr>
    <tr><td class="paramname">CSL_EUNSUPPORTED_CMD</td><td>for unsupported API on this SOC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API enables the clock for the EPWM module which is present inside the PWM subsystem. The clocks for the PWM Sub system will be enabled inside the PRCM module. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbfb18a2d74589338daee3a6a134755c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_epwmCounterComparatorCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmpType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enableShadowWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shadowToActiveLoadTrigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>overwriteShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the counter comparator and loads the comparator value. When Counter comparator value equals the counter value, then an event is generated both in the up direction and down direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">cmpType</td><td>Comparator Type A or B. 'cmpType' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabaaf6d257f978e30f2aeead3ab8ff83e">CSL_EpwmCcCmp_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">cmpVal</td><td>Comparator value that needs to be loaded. </td></tr>
    <tr><td class="paramname">enableShadowWrite</td><td>Enable write to shadow register. 'enableShadowWrite' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga4af92ad6f2f6690f974917168ba10c6d" title="Shadow register enable or disable control. ">CSL_EpwmShadowRegCtrl_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">shadowToActiveLoadTrigger</td><td>Shadow to active register load mode. 'shadowToActiveLoadTrigger' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gaa9fa681cfe0d40be47575a99f8c30026" title="Counter-Comparator registers(A and B) load mode flags from shadow register. ">CSL_EpwmCcCmpLoadMode_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">overwriteShadow</td><td>Overwrite even if previous value is not loaded to active register. 'overwriteShadow' can take following values<ul>
<li>TRUE</li>
<li>FALSE</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Comparator value is written successfully. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Comparator value write is failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab645593e6d1a96dfabe0abe10123c067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmDeadbandBypass </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API bypasses the Dead-band sub-module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0c5cc1dc58a505405457936ad6f39042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmDeadbandCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_p_w_m.html#gad4201245ce28a464ac9e1493d06f19f9">CSL_EpwmDeadbandCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API performs the configuration of the dead band sub-module. This API configures the input source, output mode, polarity, rising and falling edge delays. </p>
<p>The Dead band generator has two sub-modules, one for raising edge delay and the other for falling edge delay. This can be configured when a delay is need between two signals during signal change. The dead band generator is useful in full-inverters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pCfg</td><td>Pointer to the structure <a class="el" href="group___c_s_l___e_p_w_m.html#gad4201245ce28a464ac9e1493d06f19f9" title="Structure holding the dead band generation sub-module configuration parameters. ">CSL_EpwmDeadbandCfg_t</a> containing the dead band configuration parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c2bd0a2f385993fb695645bd6c3d25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmEtGetEventCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the number of events occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">eventCount</td><td>number of events occurred. This will have values in the range 0 to 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga74eb5ae3c209861ea82d0ed0fdc7f470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrEvtSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrPrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the Event Trigger sub-module. This API configures the interrupt source and interrupt period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">intrEvtSrc</td><td>Event source which triggers interrupt. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gae650de33bc61ad8b5390a11e69c3e79b" title="ePWM Interrupt (EPWMx_INT) Selection Options. ">CSL_EpwmEtIntrEvt_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">intrPrd</td><td>prescalar value(This determines how may selected events need to occur before an interrupt is generated). This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga35e90e6dcd7e7a8078e49407a6a4f502" title="ePWM Interrupt (EPWMx_INT) Period Select. These values determine how many selected events need to occ...">CSL_EpwmEtIntrPeriod_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac24fe4e9590ee1541fcba7291c4d723e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the interrupt. This will clear the interrupt flag bit and enable further interrupts pulses to be generated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga13e5ad7cd49e5b96face61a0a9258f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the ePWM Event interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae500d137bbc0d0fdfc2586081f68f24d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the ePWM Event interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c3da844c980fb123495fa49b1b0657c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmEtIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the ePWM event interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Interrupt is not generated. </td></tr>
    <tr><td class="paramname">1</td><td>Interrupt is generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae17259d0151ecfee6757522aab0b4495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API forces interrupt to be generated. This API is used for testing purpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a5e58e92df08aa7ae5b9377e6e11850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_epwmHighResolutionCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mepCtrlEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures control mode and edge mode of high resolution sub-module. In also enables the HR sub-module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance or EHRPWM instance used. </td></tr>
    <tr><td class="paramname">ctrlMode</td><td>phase control or duty control. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga463a8ac6841aea34bdc324e937fcde3a" title="Delay Bus Selection, that selects which bus is used to select the delay for the PWM pulse...">CSL_EpwmHrDelayBusSelMode_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">mepCtrlEdge</td><td>Edge on which MEP to be applied.(rising,falling,both) This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga129fa03b277087c3052a1a9bfde1d6c7" title="Delay Mode Configuration, that selects which edge of the PWM pulse the delay is inserted. ">CSL_EpwmHrDelayEdgeCtrl_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>for success </td></tr>
    <tr><td class="paramname">CSL_EUNSUPPORTED_CMD</td><td>for unsupported API on this SOC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>High-resolution feature is supported only on PWM-A channel output. For SOCs such as AM65xx, J7200, J721e EHRPWM baseAddr is passed. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa06b989c821cddc4ff43926f769614ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_epwmHighResolutionDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the high-resolution feature of ePWM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>for success </td></tr>
    <tr><td class="paramname">CSL_EUNSUPPORTED_CMD</td><td>for unsupported API on this SOC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36291f05e628fb8b89523dc1e8dfff7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_epwmHrLoadCmpAHrValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compAHighResVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ShadowToActiveLoadTrigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API loads Counter-Comparator A high resolution value and also configure the pulse select bits, that select which pulse to use for timing events in the HRPWM module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">compAHighResVal</td><td>Counter-comparator A high resolution value </td></tr>
    <tr><td class="paramname">ShadowToActiveLoadTrigger</td><td>Condition when the active reg to be loaded. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga7e9fa03f67d3250d913cb7cf9feeafa1" title="Pulse selection, that selects which pulse to use for timing events in the HRPWM module. ">CSL_EpwmHrRegActLoad_t</a>;</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>for success </td></tr>
    <tr><td class="paramname">CSL_EUNSUPPORTED_CMD</td><td>for unsupported API on this SOC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b6c9b6b308290a2b0f47b437d447f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmHrLoadTbPhaseHrValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbPhsHighResVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API loads the Timebase Phase high resolution register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbPhsHighResVal</td><td>Time-base phase high resolution value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7071efede364ce48b46fcc63ed44c325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmTbGetStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbStatusMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the Time Base status as indicated by the tbStatusMask parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbStatusMask</td><td>Flag indicating the type of status needed. 'tbStatusMask' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga723c0cd8460ee8ce21a79f1c7997ecee" title="Flags to get the different types of time base status. ">CSL_EpwmTbSts_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">tbStatus</td><td>Requested status is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The returned status will depend on the status mask passed.<ul>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#ga0b99bd82535f931391d564aac925352c">EPWM_TB_STS_CTR_MAX</a><ol type="1">
<li>Zero indicates the time-base counter never reached its max value.</li>
<li>NonZero indicates that the time-base counter reached max value 0xFFFF</li>
</ol>
</li>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#ga6c14239a94d052ef9a7d4a69b2d1a240">EPWM_TB_STS_SYNCI</a><ol type="1">
<li>Zero indicates that no external synchronization event has occurred.</li>
<li>NonZero indicates that an external synchronization event has occurred.</li>
</ol>
</li>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#ga91a2682a21e9ee70a8a6d53eb9959560">EPWM_TB_STS_CTR_DIR</a><ol type="1">
<li>Zero indicates that Time-Base Counter is currently counting down.</li>
<li>NonZero indicates that Time-Base Counter is currently counting up. </li>
</ol>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1fa6c5056eb541841419c7e6a3160717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbPwmFreqCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counterDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enableShadowWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the PWM Time base counter Frequency/Period. </p>
<p>The period count determines the period of the final output waveform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbClk</td><td>Timebase clock in Hz. </td></tr>
    <tr><td class="paramname">pwmFreq</td><td>Frequency of the PWM Output in Hz. </td></tr>
    <tr><td class="paramname">counterDir</td><td>Direction of the counter(up, down, up-down). 'counterDir' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga6d860cbfc585fd38ec5dc313a57b2bd7" title="Types of Time base counter direction modes. ">CSL_EpwmTbCounterDir_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">enableShadowWrite</td><td>Flag controlling Whether write to Period register is to be shadowed or not. 'enableShadowWrite' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga4af92ad6f2f6690f974917168ba10c6d" title="Shadow register enable or disable control. ">CSL_EpwmShadowRegCtrl_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the counter direction is configured as <a class="el" href="group___c_s_l___e_p_w_m.html#gaa8fb19e09f24903c5e002a7731b2ccfb">CSL_EPWM_TB_COUNTER_DIR_UP_DOWN</a>, then output frequency will be half the value of required pwm frequency. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3debb795a5a3c567ff4a5f6f2fb3a564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmTbReadTbCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the Time base counter current value. The count operation is not affected by the read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">tbCount</td><td>Current Timebase count value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaefe04ef2e88a21414b917aa167c68407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbSetEmulationMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures emulation mode. This setting determines the behaviour of Timebase counter during emulation (debugging). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">mode</td><td>Emulation mode. 'mode' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga1e915bd82628e6c88e3066a52f70da86" title="Emulation Mode. This selects the behaviour of the ePWM time-base counter during emulation events...">CSL_EpwmTbEmuMode_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1783f1d4e175c768ed350467659065ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbSetSyncOutMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>syncOutMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API selects the source of the synchronization output signal. It determines on which of the supported events sync-out has to be generated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">syncOutMode</td><td>Sync out mode. 'syncOutMode' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga0da2edc68dac48190d3c1e8521897e22" title="Source of Synchronization output signal. ">CSL_EpwmTbSyncOutEvt_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00629ad2136740cb2fc5a5ac3db12d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbStatusClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbStatusClrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the Time base status bits indicated by the tbStatusClrMask parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbStatusClrMask</td><td>Mask indicating which status bit need to be cleared 'tbStatusClrMask' can take following values<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga0b99bd82535f931391d564aac925352c">EPWM_TB_STS_CTR_MAX</a></li>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga6c14239a94d052ef9a7d4a69b2d1a240">EPWM_TB_STS_SYNCI</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f4c56932cad3819d7cc735c4695fd28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbSyncDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the synchronization. Even if sync-in event occurs the count value will not be reloaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94a7f77c01cb831a7935fdfd6e766091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbSyncEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbPhsValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counterDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the synchronization of time base sub-module and also configures the phase count value to be loaded after sync event, counter direction after sync event. </p>
<p>When a sync-in event is generated the the time base counter is reloaded with the new value. After sync the counter will use the new value and direction as specified after sync event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbPhsValue</td><td>Phase value to be reloaded after sync </td></tr>
    <tr><td class="paramname">counterDir</td><td>Count direction after sync. 'counterDir' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga17612511be7a1866a543c264d036b0a8" title="Counter directions after sync event. ">CSL_EpwmTbCntDirAftSync_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaccc86de57b0138e374b106003c07fdf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbTimebaseClkCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the clock divider of the Time base module. </p>
<p>The clock divider can be calculated using the equation TBCLK = SYSCLKOUT/(HSPCLKDIV  CLKDIV)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbClk</td><td>Timebase clock to be generated in Hz. </td></tr>
    <tr><td class="paramname">moduleClk</td><td>Input clock of the PWM module (sysclk2) in Hz. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9b88fd8c50ffc905cea62f8bf9dc1598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbTriggerSwSync </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API generates software triggered sync pulse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API can be used for testing. When this API is called sync-in event will be generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3602d386ffb1b55d7cb6660e5b878d8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbWriteTbCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API loads the Time base counter. The new value is taken immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbCount</td><td>Time base count value to be loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae33ecda8dfa28260ef573327fd1e0822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmTzEventStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the selected trip zone event status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">eventMask</td><td>Type of status which has to be read. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga388f004caf9970a16637804a1dba4670" title="Trip zone status flags. ">CSL_EpwmTzStsFlg_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Status</td><td>Status of the required status flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The return status depends on the type of status flag passed.<ol type="1">
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gafe4b4207f2b2c88d58004f0f346849fb">CSL_EPWM_TZ_STS_FLG_OST</a><ol type="a">
<li>Zero - No one-shot trip event has occurred.</li>
<li>NonZero - Indicates a trip event has occurred on a pin selected as a one-shot trip source.</li>
</ol>
</li>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gab5e0444f465228b6fc555c2dedd2949c">CSL_EPWM_TZ_STS_FLG_CBC</a><ol type="a">
<li>Zero - No cycle-by-cycle trip event has occurred.</li>
<li>NonZero - Indicates a trip event has occurred on a pin selected as a cycle-by-cycle trip source.</li>
</ol>
</li>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gacb52a12d4069f3c25f8b7397c2e2fb35">CSL_EPWM_TZ_STS_FLG_INT</a><ol type="a">
<li>Zero - Indicates no interrupt has been generated.</li>
<li>NonZero - Indicates an EPWMxTZINT interrupt was generated because of a trip condition. </li>
</ol>
</li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga76cff74a105d8bbd78350d8f1367dc86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzEventStatusClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the selected trip zone event status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">eventMask</td><td>Type of status which has to be read. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga388f004caf9970a16637804a1dba4670" title="Trip zone status flags. ">CSL_EpwmTzStsFlg_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea8cead002b55aad5f7346e1a192cbba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzIntrDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the trip interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Trip zone event for which interrupt has to be enabled. This parameter can take values form the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga3b21dd002850676ee0ca6b9e9e4fc79c" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga174736f224abc925a0474a5ee48c5552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzIntrEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the trip interrupt. When trip event occurs the sub-module can be configured to interrupt CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Trip zone event for which interrupt has to be enabled. This parameter can take values form the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga3b21dd002850676ee0ca6b9e9e4fc79c" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad424481c3b6ba56fd734c942efd81075"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzTriggerSwEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables to generate Software forced trip condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Type of trip condition which has to be generated. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga3b21dd002850676ee0ca6b9e9e4fc79c" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65025ed62bdb842f6a520c83a7cfac19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzTriggerTripAction </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tripAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmOutputCh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the o/p on PWM channel when a trip event is recognized. The output can be set to high or low or high impedance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tripAction</td><td>Action to be taken on the PWM output. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga338b02aaed675499de7696e0cb0a7e8d" title="Action to be taken on PWM output When a trip event occurs. ">CSL_EpwmTzTripAction_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pwmOutputCh</td><td>PWM Output channel type either A or B 'pwmOutputCh' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga67c6393a7b0407c0b00d9cf76845a983" title="Number of supported EPWM outputs in a single epwm channel. ">CSL_EpwmOutputCh_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0b2360ef51b088052085727d89752bb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzTripEventDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disable the trip event. The disabled trip events will be ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Disable OST or CBC trip zone event This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga3b21dd002850676ee0ca6b9e9e4fc79c" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pinNum</td><td>Pin number on which trip zone event has to be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a425c0124749de1ab5e877f2f529491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzTripEventEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the trip event. </p>
<p>The trip signals indicates external fault, and the ePWM outputs can be programmed to respond accordingly when faults occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Enable OST or CBC trip zone event This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga3b21dd002850676ee0ca6b9e9e4fc79c" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pinNum</td><td>Pin number on which trip zone event has to be enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
