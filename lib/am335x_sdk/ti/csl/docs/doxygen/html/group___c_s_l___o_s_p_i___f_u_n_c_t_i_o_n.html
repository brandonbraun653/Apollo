<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OSPI Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OSPI Functions<div class="ingroups"><a class="el" href="group___c_s_l___o_s_p_i___a_p_i.html">Octal SPI (OSPI) API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0ca29f9065be052e3d4621b5326f2496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga0ca29f9065be052e3d4621b5326f2496">CSL_ospiEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:ga0ca29f9065be052e3d4621b5326f2496"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI By definition, target can handle read/write transaction as long as it is enabled.  <a href="#ga0ca29f9065be052e3d4621b5326f2496">More...</a><br /></td></tr>
<tr class="separator:ga0ca29f9065be052e3d4621b5326f2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf34bfba7f2dd973ea3468b368e4402c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gaf34bfba7f2dd973ea3468b368e4402c1">CSL_ospiDacEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:gaf34bfba7f2dd973ea3468b368e4402c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI Direct Access Controller.  <a href="#gaf34bfba7f2dd973ea3468b368e4402c1">More...</a><br /></td></tr>
<tr class="separator:gaf34bfba7f2dd973ea3468b368e4402c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eee95f2222f1d401c3cde516e39b416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga9eee95f2222f1d401c3cde516e39b416">CSL_ospiXipEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:ga9eee95f2222f1d401c3cde516e39b416"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI XIP Controller.  <a href="#ga9eee95f2222f1d401c3cde516e39b416">More...</a><br /></td></tr>
<tr class="separator:ga9eee95f2222f1d401c3cde516e39b416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a375d1f28314f083690676d96632527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga0a375d1f28314f083690676d96632527">CSL_ospiSetModeBits</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t flashModeVal)</td></tr>
<tr class="memdesc:ga0a375d1f28314f083690676d96632527"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Mode bits which are sent to the device following address.  <a href="#ga0a375d1f28314f083690676d96632527">More...</a><br /></td></tr>
<tr class="separator:ga0a375d1f28314f083690676d96632527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac08ebdeec5cabc3cc1554ac5d5d5e35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gaac08ebdeec5cabc3cc1554ac5d5d5e35">CSL_ospiPhyEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:gaac08ebdeec5cabc3cc1554ac5d5d5e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI PHY mode.  <a href="#gaac08ebdeec5cabc3cc1554ac5d5d5e35">More...</a><br /></td></tr>
<tr class="separator:gaac08ebdeec5cabc3cc1554ac5d5d5e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f685360ebe54c6d25dcea95f6e2c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gad8f685360ebe54c6d25dcea95f6e2c2b">CSL_ospiPipelinePhyEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:gad8f685360ebe54c6d25dcea95f6e2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI pipeline PHY mode.  <a href="#gad8f685360ebe54c6d25dcea95f6e2c2b">More...</a><br /></td></tr>
<tr class="separator:gad8f685360ebe54c6d25dcea95f6e2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b2f979833c68008e8275359a7c5696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gad7b2f979833c68008e8275359a7c5696">CSL_ospiDtrEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:gad7b2f979833c68008e8275359a7c5696"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables the OSPI DTR protocol.  <a href="#gad7b2f979833c68008e8275359a7c5696">More...</a><br /></td></tr>
<tr class="separator:gad7b2f979833c68008e8275359a7c5696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98118c36736e83d50035ac4c26303bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga98118c36736e83d50035ac4c26303bc0">CSL_ospiSetPreScaler</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t clkDividerVal)</td></tr>
<tr class="memdesc:ga98118c36736e83d50035ac4c26303bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the OSPI clock register divider value.  <a href="#ga98118c36736e83d50035ac4c26303bc0">More...</a><br /></td></tr>
<tr class="separator:ga98118c36736e83d50035ac4c26303bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d28ce8d5131efb20a3c321211339db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga98d28ce8d5131efb20a3c321211339db">CSL_ospiSetClkMode</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t clkMode)</td></tr>
<tr class="memdesc:ga98d28ce8d5131efb20a3c321211339db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the OSPI to work in different clock modes.  <a href="#ga98d28ce8d5131efb20a3c321211339db">More...</a><br /></td></tr>
<tr class="separator:ga98d28ce8d5131efb20a3c321211339db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga589aeb7f02f905f6697f6a7dbce13b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga589aeb7f02f905f6697f6a7dbce13b8b">CSL_ospiSetChipSelect</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t chipSelect, uint32_t decSelect)</td></tr>
<tr class="memdesc:ga589aeb7f02f905f6697f6a7dbce13b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the chip select polarity for a selected chip select. This can only be done if OSPI module is not busy.  <a href="#ga589aeb7f02f905f6697f6a7dbce13b8b">More...</a><br /></td></tr>
<tr class="separator:ga589aeb7f02f905f6697f6a7dbce13b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe08c94de5bd08d0f793f37577d2e48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga1fe08c94de5bd08d0f793f37577d2e48">CSL_ospiSetDevDelay</a> (const CSL_ospi_flash_cfgRegs *pRegs, const uint32_t *delays)</td></tr>
<tr class="memdesc:ga1fe08c94de5bd08d0f793f37577d2e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the device delays This can only be done if OSPI controller is idle.  <a href="#ga1fe08c94de5bd08d0f793f37577d2e48">More...</a><br /></td></tr>
<tr class="separator:ga1fe08c94de5bd08d0f793f37577d2e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae599049affdf8d90ef2d184c888bab06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gae599049affdf8d90ef2d184c888bab06">CSL_ospiSetDevSize</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t numAddrBytes, uint32_t pageSize, uint32_t blkSize)</td></tr>
<tr class="memdesc:gae599049affdf8d90ef2d184c888bab06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set device size configrations.  <a href="#gae599049affdf8d90ef2d184c888bab06">More...</a><br /></td></tr>
<tr class="separator:gae599049affdf8d90ef2d184c888bab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8c6666c8fec4398c9095db6302566c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga1d8c6666c8fec4398c9095db6302566c">CSL_ospiSetIndTrigAddr</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t indTrigAddr)</td></tr>
<tr class="memdesc:ga1d8c6666c8fec4398c9095db6302566c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Indirect Trigger Address.  <a href="#ga1d8c6666c8fec4398c9095db6302566c">More...</a><br /></td></tr>
<tr class="separator:ga1d8c6666c8fec4398c9095db6302566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2857f30dcc253ce15e3df2ea51895235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga2857f30dcc253ce15e3df2ea51895235">CSL_ospiSetWrCompAutoPolling</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t pollingState)</td></tr>
<tr class="memdesc:ga2857f30dcc253ce15e3df2ea51895235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set write completion auto polling configuration.  <a href="#ga2857f30dcc253ce15e3df2ea51895235">More...</a><br /></td></tr>
<tr class="separator:ga2857f30dcc253ce15e3df2ea51895235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf747a3b701c1bc77706bf02c1df9fa17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gaf747a3b701c1bc77706bf02c1df9fa17">CSL_ospiSetSramPartition</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t partition)</td></tr>
<tr class="memdesc:gaf747a3b701c1bc77706bf02c1df9fa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SRAM partition configuration.  <a href="#gaf747a3b701c1bc77706bf02c1df9fa17">More...</a><br /></td></tr>
<tr class="separator:gaf747a3b701c1bc77706bf02c1df9fa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5923f3cd1c4defd291e543c829422e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gabf5923f3cd1c4defd291e543c829422e">CSL_ospiIntrEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t intrFlag, uint32_t enable)</td></tr>
<tr class="memdesc:gabf5923f3cd1c4defd291e543c829422e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Function enables/diables only specified OSPI interrupts.  <a href="#gabf5923f3cd1c4defd291e543c829422e">More...</a><br /></td></tr>
<tr class="separator:gabf5923f3cd1c4defd291e543c829422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632be9b0cc0676c8fbde7b8f69db4c28"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga632be9b0cc0676c8fbde7b8f69db4c28">CSL_ospiIntrStatus</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga632be9b0cc0676c8fbde7b8f69db4c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the status of interrupts. It specifies whether an interrupt is active or inactive. After an interrupt is serviced, the software must set to 0 the corresponding flag in the interrupt status register.  <a href="#ga632be9b0cc0676c8fbde7b8f69db4c28">More...</a><br /></td></tr>
<tr class="separator:ga632be9b0cc0676c8fbde7b8f69db4c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262e95f450ff6d9b9a95556535e1fdca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga262e95f450ff6d9b9a95556535e1fdca">CSL_ospiIntrClear</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t intrFlag)</td></tr>
<tr class="memdesc:ga262e95f450ff6d9b9a95556535e1fdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Function clears the status of specified interrupts.  <a href="#ga262e95f450ff6d9b9a95556535e1fdca">More...</a><br /></td></tr>
<tr class="separator:ga262e95f450ff6d9b9a95556535e1fdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga754389cfe8f87f2d5876946b901a1365"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga754389cfe8f87f2d5876946b901a1365">CSL_ospiGetSramLvl</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t read)</td></tr>
<tr class="memdesc:ga754389cfe8f87f2d5876946b901a1365"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Function gets the OSPI SRAM FIFO fill level bytes.  <a href="#ga754389cfe8f87f2d5876946b901a1365">More...</a><br /></td></tr>
<tr class="separator:ga754389cfe8f87f2d5876946b901a1365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374e7d32091bbb266a63bc1daeefcb0e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga374e7d32091bbb266a63bc1daeefcb0e">CSL_ospiCmdRead</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t cmd, uint32_t rxLen)</td></tr>
<tr class="memdesc:ga374e7d32091bbb266a63bc1daeefcb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read operation in config mode.  <a href="#ga374e7d32091bbb266a63bc1daeefcb0e">More...</a><br /></td></tr>
<tr class="separator:ga374e7d32091bbb266a63bc1daeefcb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242b8cf08a3c7df1b70747d7dc889074"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga242b8cf08a3c7df1b70747d7dc889074">CSL_ospiCmdWrite</a> (const CSL_ospi_flash_cfgRegs *pRegs, const uint8_t *cmdBuf, uint32_t cmdLen, const uint8_t *txBuf, uint32_t txLen)</td></tr>
<tr class="memdesc:ga242b8cf08a3c7df1b70747d7dc889074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write operation in config mode.  <a href="#ga242b8cf08a3c7df1b70747d7dc889074">More...</a><br /></td></tr>
<tr class="separator:ga242b8cf08a3c7df1b70747d7dc889074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9a1d8db873f6053a03f49ec800e243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga6c9a1d8db873f6053a03f49ec800e243">CSL_ospiConfigRead</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t cmd, uint32_t mode, uint32_t dummyClk)</td></tr>
<tr class="memdesc:ga6c9a1d8db873f6053a03f49ec800e243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup read operation transfer mode.  <a href="#ga6c9a1d8db873f6053a03f49ec800e243">More...</a><br /></td></tr>
<tr class="separator:ga6c9a1d8db873f6053a03f49ec800e243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf786362643a4215db7f13bd389d4050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gadf786362643a4215db7f13bd389d4050">CSL_ospiIndReadExecute</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t rxLen)</td></tr>
<tr class="memdesc:gadf786362643a4215db7f13bd389d4050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute read operation in indirect transfer mode.  <a href="#gadf786362643a4215db7f13bd389d4050">More...</a><br /></td></tr>
<tr class="separator:gadf786362643a4215db7f13bd389d4050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d76207f28a007888acf3e820ed332ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga5d76207f28a007888acf3e820ed332ad">CSL_ospiClrIndReadComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga5d76207f28a007888acf3e820ed332ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear indirect read operation done status.  <a href="#ga5d76207f28a007888acf3e820ed332ad">More...</a><br /></td></tr>
<tr class="separator:ga5d76207f28a007888acf3e820ed332ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b039af1efe8f8d1c8283c546c6546cf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga1b039af1efe8f8d1c8283c546c6546cf">CSL_ospiIndReadComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga1b039af1efe8f8d1c8283c546c6546cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indirect read operation is done.  <a href="#ga1b039af1efe8f8d1c8283c546c6546cf">More...</a><br /></td></tr>
<tr class="separator:ga1b039af1efe8f8d1c8283c546c6546cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f2bf2c3d39baf80176d8342c249963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gaa1f2bf2c3d39baf80176d8342c249963">CSL_ospiReadFifoData</a> (uintptr_t indAddr, uint8_t *dest, uint32_t rdLen)</td></tr>
<tr class="memdesc:gaa1f2bf2c3d39baf80176d8342c249963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the SRAM FIFO.  <a href="#gaa1f2bf2c3d39baf80176d8342c249963">More...</a><br /></td></tr>
<tr class="separator:gaa1f2bf2c3d39baf80176d8342c249963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22aa9309cf92d103b0a1f9dd6711f152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga22aa9309cf92d103b0a1f9dd6711f152">CSL_ospiWriteSetup</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t cmd, uint32_t mode)</td></tr>
<tr class="memdesc:ga22aa9309cf92d103b0a1f9dd6711f152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup write operation transfer mode.  <a href="#ga22aa9309cf92d103b0a1f9dd6711f152">More...</a><br /></td></tr>
<tr class="separator:ga22aa9309cf92d103b0a1f9dd6711f152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842c89c830fce446210a8f28fad8b709"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga842c89c830fce446210a8f28fad8b709">CSL_ospiIsIndWriteComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga842c89c830fce446210a8f28fad8b709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indirect write operation is done.  <a href="#ga842c89c830fce446210a8f28fad8b709">More...</a><br /></td></tr>
<tr class="separator:ga842c89c830fce446210a8f28fad8b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1505f040be3c3a65fb105556ec346490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga1505f040be3c3a65fb105556ec346490">CSL_ospiClrIndWriteComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga1505f040be3c3a65fb105556ec346490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear indirect write operation done status.  <a href="#ga1505f040be3c3a65fb105556ec346490">More...</a><br /></td></tr>
<tr class="separator:ga1505f040be3c3a65fb105556ec346490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9e15223a027d32ac41208cacb09f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gaaa9e15223a027d32ac41208cacb09f0d">CSL_ospiIndWriteExecute</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t txLen)</td></tr>
<tr class="memdesc:gaaa9e15223a027d32ac41208cacb09f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute write operation in indirect transfer mode.  <a href="#gaaa9e15223a027d32ac41208cacb09f0d">More...</a><br /></td></tr>
<tr class="separator:gaaa9e15223a027d32ac41208cacb09f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea41411aa63bc90dd1d968c3e1a79c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gaaea41411aa63bc90dd1d968c3e1a79c0">CSL_ospiIndWriteCancel</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:gaaea41411aa63bc90dd1d968c3e1a79c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel write operation in indirect transfer mode.  <a href="#gaaea41411aa63bc90dd1d968c3e1a79c0">More...</a><br /></td></tr>
<tr class="separator:gaaea41411aa63bc90dd1d968c3e1a79c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3f08ca441621893a208a72bfad0b3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gaed3f08ca441621893a208a72bfad0b3e">CSL_ospiWriteFifoData</a> (uintptr_t indAddr, const uint8_t *src, uint32_t wrLen)</td></tr>
<tr class="memdesc:gaed3f08ca441621893a208a72bfad0b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the SRAM FIFO.  <a href="#gaed3f08ca441621893a208a72bfad0b3e">More...</a><br /></td></tr>
<tr class="separator:gaed3f08ca441621893a208a72bfad0b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815beb57187a9f4ac3ebde81ae00cfa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga815beb57187a9f4ac3ebde81ae00cfa4">CSL_ospiLoopbackClkEnable</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t enable)</td></tr>
<tr class="memdesc:ga815beb57187a9f4ac3ebde81ae00cfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the adapted loopback clock circuit.  <a href="#ga815beb57187a9f4ac3ebde81ae00cfa4">More...</a><br /></td></tr>
<tr class="separator:ga815beb57187a9f4ac3ebde81ae00cfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga611c6741d0311e531010fc0ed1177339"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga611c6741d0311e531010fc0ed1177339">CSL_ospiIsIdle</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga611c6741d0311e531010fc0ed1177339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if OSPI is idle or not.  <a href="#ga611c6741d0311e531010fc0ed1177339">More...</a><br /></td></tr>
<tr class="separator:ga611c6741d0311e531010fc0ed1177339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71f0899a097589bfa2e3aee4f45d4afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga71f0899a097589bfa2e3aee4f45d4afa">CSL_ospiFlashExecCmd</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga71f0899a097589bfa2e3aee4f45d4afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Excecute the flash read/write command.  <a href="#ga71f0899a097589bfa2e3aee4f45d4afa">More...</a><br /></td></tr>
<tr class="separator:ga71f0899a097589bfa2e3aee4f45d4afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511a37812ee2a78374f87eb9dcdd326d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga511a37812ee2a78374f87eb9dcdd326d">CSL_ospiFlashExecCmdComplete</a> (const CSL_ospi_flash_cfgRegs *pRegs)</td></tr>
<tr class="memdesc:ga511a37812ee2a78374f87eb9dcdd326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the flash command execution status.  <a href="#ga511a37812ee2a78374f87eb9dcdd326d">More...</a><br /></td></tr>
<tr class="separator:ga511a37812ee2a78374f87eb9dcdd326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe3e79b0bd096d4bc5d54311012efb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga0fe3e79b0bd096d4bc5d54311012efb4">CSL_ospiConfigPhy</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t masterDelay, const uint32_t *pSlaveDelay)</td></tr>
<tr class="memdesc:ga0fe3e79b0bd096d4bc5d54311012efb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the PHY.  <a href="#ga0fe3e79b0bd096d4bc5d54311012efb4">More...</a><br /></td></tr>
<tr class="separator:ga0fe3e79b0bd096d4bc5d54311012efb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b6057e309b1cac67c243fc3a744749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gab8b6057e309b1cac67c243fc3a744749">CSL_ospiFlashStig</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t cmd, uint32_t <a class="el" href="csl__udmap__tr_8h.html#a0e89cf6b9f6cd3125470b1bed2b823df">addr</a>, uint32_t <a class="el" href="csl__udmap__tr_8h.html#ae4abda5e3cab325153762e904fd3f1e8">data</a>)</td></tr>
<tr class="memdesc:gab8b6057e309b1cac67c243fc3a744749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set configurations for a flash STIG command.  <a href="#gab8b6057e309b1cac67c243fc3a744749">More...</a><br /></td></tr>
<tr class="separator:gab8b6057e309b1cac67c243fc3a744749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f30588b1a0248699ff9c18e7f2e3ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga0f30588b1a0248699ff9c18e7f2e3ff9">CSL_ospiIndSetStartAddr</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t startAddr, uint32_t read)</td></tr>
<tr class="memdesc:ga0f30588b1a0248699ff9c18e7f2e3ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the read or wrtie start address in Indirect mode.  <a href="#ga0f30588b1a0248699ff9c18e7f2e3ff9">More...</a><br /></td></tr>
<tr class="separator:ga0f30588b1a0248699ff9c18e7f2e3ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a949442c7608b5799bb4a728d0ca02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#ga89a949442c7608b5799bb4a728d0ca02">CSL_ospiSetDataReadCapDelay</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t delay)</td></tr>
<tr class="memdesc:ga89a949442c7608b5799bb4a728d0ca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the read data capture delay.  <a href="#ga89a949442c7608b5799bb4a728d0ca02">More...</a><br /></td></tr>
<tr class="separator:ga89a949442c7608b5799bb4a728d0ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04cb3e20740f4992e17db0f5004e34d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___o_s_p_i___f_u_n_c_t_i_o_n.html#gae04cb3e20740f4992e17db0f5004e34d">CSL_ospiSetCsSotDelay</a> (const CSL_ospi_flash_cfgRegs *pRegs, uint32_t delay)</td></tr>
<tr class="memdesc:gae04cb3e20740f4992e17db0f5004e34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Chip Select Start of Transfer delay.  <a href="#gae04cb3e20740f4992e17db0f5004e34d">More...</a><br /></td></tr>
<tr class="separator:gae04cb3e20740f4992e17db0f5004e34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5d76207f28a007888acf3e820ed332ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiClrIndReadComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear indirect read operation done status. </p>
<p>This function clears the indirect completion status in the Indirect Read Transfer Control Register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1505f040be3c3a65fb105556ec346490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiClrIndWriteComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear indirect write operation done status. </p>
<p>This function clears the indirect completion status in the Indirect Write Transfer Control Register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga374e7d32091bbb266a63bc1daeefcb0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ospiCmdRead </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read operation in config mode. </p>
<p>This function performs the read operation in config mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] Flash command opcode. </td></tr>
    <tr><td class="paramname">rxLen</td><td>[IN] Number of read data bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga242b8cf08a3c7df1b70747d7dc889074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_ospiCmdWrite </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cmdBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmdLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write operation in config mode. </p>
<p>This function performs the write operation in config mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] Pointer to the flash command buffer. </td></tr>
    <tr><td class="paramname">cmdLen</td><td>[IN] Command buffer size in bytes. </td></tr>
    <tr><td class="paramname">txBuf</td><td>[IN] Pointer to the write data buffer </td></tr>
    <tr><td class="paramname">txLen</td><td>[IN] Number of write data bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0fe3e79b0bd096d4bc5d54311012efb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiConfigPhy </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>masterDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pSlaveDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the PHY. </p>
<p>This function configures and calibrates the PHY</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">masterDelay</td><td>[IN] Initial number of delay elements for Master DLL </td></tr>
    <tr><td class="paramname">pDelay</td><td>[IN] Point to initial number of delay elements for Slave DLL if pDelay == NULL, do calibration operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c9a1d8db873f6053a03f49ec800e243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiConfigRead </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dummyClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup read operation transfer mode. </p>
<p>This function setup the configurations for read operation transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] command opcode. </td></tr>
    <tr><td class="paramname">mode</td><td>[IN] data transfer mode (single/dual/quad mode) </td></tr>
    <tr><td class="paramname">dummyClk</td><td>[IN] Number of dummy clock cycles required for read op</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf34bfba7f2dd973ea3468b368e4402c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiDacEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI Direct Access Controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI DAC, FALSE: disable OSPI DAC</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad7b2f979833c68008e8275359a7c5696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiDtrEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI DTR protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI DTR protocol FALSE: disable OSPI DTR protocol</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ca29f9065be052e3d4621b5326f2496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI By definition, target can handle read/write transaction as long as it is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI to handle read/write transaction FALSE: disable OSPI once current transaction of the data word is complete</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga71f0899a097589bfa2e3aee4f45d4afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiFlashExecCmd </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Excecute the flash read/write command. </p>
<p>This function excecute the flash read/write command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga511a37812ee2a78374f87eb9dcdd326d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiFlashExecCmdComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the flash command execution status. </p>
<p>This function checks the execution status of the flash read/write command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>TRUE: command execution completed FALSE: command execution in progress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8b6057e309b1cac67c243fc3a744749"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiFlashStig </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set configurations for a flash STIG command. </p>
<p>This function sets the command address, data and contorl for a generic STIG command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga754389cfe8f87f2d5876946b901a1365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiGetSramLvl </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This Function gets the OSPI SRAM FIFO fill level bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">read</td><td>[IN] TRUE: indirect read, FALSE: indirect write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SRAM</td><td>fifo fill level in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b039af1efe8f8d1c8283c546c6546cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiIndReadComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if indirect read operation is done. </p>
<p>This function checks if indirect read operation is done</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>TRUE: read is done, FALSE: read is in progress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf786362643a4215db7f13bd389d4050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIndReadExecute </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute read operation in indirect transfer mode. </p>
<p>This function kicks off the read operation in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">rxLen</td><td>[IN] read length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f30588b1a0248699ff9c18e7f2e3ff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIndSetStartAddr </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the read or wrtie start address in Indirect mode. </p>
<p>This function configures indac read or write start address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">startAddr</td><td>[IN] Indirect access start address </td></tr>
    <tr><td class="paramname">read</td><td>[IN] TRUE: read operation; FALSE: write operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaea41411aa63bc90dd1d968c3e1a79c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIndWriteCancel </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel write operation in indirect transfer mode. </p>
<p>This function cancels the write operation in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa9e15223a027d32ac41208cacb09f0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIndWriteExecute </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute write operation in indirect transfer mode. </p>
<p>This function performs the write operation in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">txLen</td><td>[IN] write length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga262e95f450ff6d9b9a95556535e1fdca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIntrClear </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This Function clears the status of specified interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">intrMask</td><td>[IN] mask value for the interrupts to be cleared. given by CSL_OspiIntrMask_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf5923f3cd1c4defd291e543c829422e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiIntrEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This Function enables/diables only specified OSPI interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">intrMask</td><td>[IN] mask value for the interrupts to be enabled. Supported values are given by the CSL_OspiIntrMask_t. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable the specified OSPI interrupts FALSE: disable the specified OSPI interrupts</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga632be9b0cc0676c8fbde7b8f69db4c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiIntrStatus </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the status of interrupts. It specifies whether an interrupt is active or inactive. After an interrupt is serviced, the software must set to 0 the corresponding flag in the interrupt status register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>All the interrupt status. The return status can take value from the CSL_OspiIntrMask_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga611c6741d0311e531010fc0ed1177339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiIsIdle </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if OSPI is idle or not. </p>
<p>This function checks the OSPI idle status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">idle</td><td>status TRUE: OSPI is idle, FALSE: OSPI is busy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga842c89c830fce446210a8f28fad8b709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_ospiIsIndWriteComplete </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if indirect write operation is done. </p>
<p>This function checks if indirect write operation is done</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>TRUE: write is done, FALSE: write is in progress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga815beb57187a9f4ac3ebde81ae00cfa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiLoopbackClkEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the adapted loopback clock circuit. </p>
<p>This function enables the loopback mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI loopback clock FALSE: disable OSPI loopback clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaac08ebdeec5cabc3cc1554ac5d5d5e35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiPhyEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI PHY mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI PHY mode FALSE: disable OSPI PHY mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8f685360ebe54c6d25dcea95f6e2c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiPipelinePhyEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI pipeline PHY mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI pipeline PHY mode FALSE: disable OSPI pipeline PHY mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1f2bf2c3d39baf80176d8342c249963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiReadFifoData </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>indAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from the SRAM FIFO. </p>
<p>This function reads the data from the SRAM FIFO in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indAddr</td><td>[IN] OSPI indirect AHB base address. </td></tr>
    <tr><td class="paramname">dest</td><td>[IN] Destination address to copy the read data </td></tr>
    <tr><td class="paramname">rdLen</td><td>[IN] read length in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga589aeb7f02f905f6697f6a7dbce13b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetChipSelect </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chipSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>decSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the chip select polarity for a selected chip select. This can only be done if OSPI module is not busy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">chipSelect</td><td>[IN] Peripheral chip select lines. Supported values are according to CSL_OspiChipSelect_t. </td></tr>
    <tr><td class="paramname">decSelect</td><td>[IN] Peripheral select decode. Supported values are according to CSL_OspiDecSelect_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98d28ce8d5131efb20a3c321211339db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetClkMode </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the OSPI to work in different clock modes. </p>
<p>The combination of Clock phase and clock polarity creates the SPI mode. Most serial flash devices support only mode 0 and mode 3. Changing the clock polarity also swaps the transmit/receive clock edge relationship. If a slave device states that it receives data on the rising edge and transmits on the falling edge of the clock, then it can only support mode 0 or 3. This can only be done if OSPI module is not busy.</p>
<p>The 4 possible modes are :</p>
<p>CKP CKPH Description 0 0 Data input captured on rising edge of ospi1_sclk clock. Data output generated on falling edge of ospi1_sclk clock 0 1 Data input captured on falling edge of ospi1_sclk clock. Data output generate on rising edge of ospi1_sclk clock 1 0 Data input captured on falling edge of ospi1_sclk clock. Data output generated on rising edge of ospi1_sclk clock 1 1 Data input captured on rising edge of ospi1_sclk clock. Data output generated on falling edge of ospi1_sclk clock</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">clkMode</td><td>[IN] Mode required to be selected. Supported values given by CSL_OspiClkMode_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae04cb3e20740f4992e17db0f5004e34d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetCsSotDelay </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Chip Select Start of Transfer delay. </p>
<p>This function sets the Chip Select Start of Transfer delay in # of ref_clk cycles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">delay</td><td>[IN] delay in # of ref_clk cycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89a949442c7608b5799bb4a728d0ca02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetDataReadCapDelay </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the read data capture delay. </p>
<p>This function sets the read data capture delay in # of ref_clk cycles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">delay</td><td>[IN] delay in # of ref_clk cycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1fe08c94de5bd08d0f793f37577d2e48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetDevDelay </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>delays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the device delays This can only be done if OSPI controller is idle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">delays</td><td>[IN] Pointer to the device delay array</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae599049affdf8d90ef2d184c888bab06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetDevSize </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numAddrBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blkSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set device size configrations. </p>
<p>This function configures the number af Address Bytes, device page size and block size. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">numAddrBytes</td><td>[IN] Number of Address bytes to be sent for memory mapped protocol translator. Supported values are given by CSL_OspiMemMapNumAddrBytes_t. </td></tr>
    <tr><td class="paramname">pageSize</td><td>[IN] Device page size in bytes. </td></tr>
    <tr><td class="paramname">blkSize</td><td>[IN] Device block size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d8c6666c8fec4398c9095db6302566c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetIndTrigAddr </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indTrigAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Indirect Trigger Address. </p>
<p>This function sets the base address that will be used by the AHB controller. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">indTrigAddr</td><td>[IN] Indirect Trigger Address, base address used by the AHB controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a375d1f28314f083690676d96632527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetModeBits </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flashModeVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the Mode bits which are sent to the device following address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] Mode bit value to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98118c36736e83d50035ac4c26303bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetPreScaler </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkDividerVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the OSPI clock register divider value. </p>
<p>This function sets the OSPI clock control register with serial data clock divider ratio (DCLK_DIV) according to the input clock provided and the output clock required. DCLK_DIV = ((input clock) / (output clock)) - 1. This function also enables the clock for OSPI module. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">clkDividerVal</td><td>[IN] clock divider value to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf747a3b701c1bc77706bf02c1df9fa17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetSramPartition </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SRAM partition configuration. </p>
<p>This function configures the size of the indirect read partition in the SRAM, in units of SRAM locations. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">partition</td><td>[IN] Auto polling state. Supported values are given by CSL_OspiWriteCompAutoPolling_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2857f30dcc253ce15e3df2ea51895235"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiSetWrCompAutoPolling </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pollingState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set write completion auto polling configuration. </p>
<p>This function configures the write compltion auto polling state. This can only be done if OSPI module is not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">pollingState</td><td>[IN] Auto polling state. Supported values are given by CSL_OspiWriteCompAutoPolling_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaed3f08ca441621893a208a72bfad0b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiWriteFifoData </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>indAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wrLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the SRAM FIFO. </p>
<p>This function writes the data to the SRAM FIFO in indirect transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indAddr</td><td>OSPI Indirect AHB base address </td></tr>
    <tr><td class="paramname">src</td><td>Source address to copy the write data </td></tr>
    <tr><td class="paramname">wrLen</td><td>write length in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga22aa9309cf92d103b0a1f9dd6711f152"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiWriteSetup </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup write operation transfer mode. </p>
<p>This function setup the configurations for write operation transfer mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] command opcode. </td></tr>
    <tr><td class="paramname">mode</td><td>[IN] data transfer mode (single/dual/quad mode)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9eee95f2222f1d401c3cde516e39b416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_ospiXipEnable </td>
          <td>(</td>
          <td class="paramtype">const CSL_ospi_flash_cfgRegs *&#160;</td>
          <td class="paramname"><em>pRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables the OSPI XIP Controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRegs</td><td>[IN] OSPI flash config register base. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] TRUE: enable OSPI XIP, FALSE: disable OSPI XIP</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
