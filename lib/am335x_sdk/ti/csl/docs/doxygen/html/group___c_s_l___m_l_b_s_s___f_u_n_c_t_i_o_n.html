<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MLBSS Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MLBSS Functions<div class="ingroups"><a class="el" href="group___c_s_l___m_l_b_s_s___a_p_i.html">Media Local Bus Sub-System (MLBSS)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabc3bff92a871af4716ae1bd8e2004302"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gabc3bff92a871af4716ae1bd8e2004302">CSL_MLBSS_clearCtrEntry</a>(CtrAddr)&#160;&#160;&#160;<a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gabb3e74c56e2c564d3170d11ad6652846">CSL_MLBSS_setCtrEntry</a>( CtrAddr, <a class="el" href="csl__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="csl__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> )</td></tr>
<tr class="separator:gabc3bff92a871af4716ae1bd8e2004302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc3bff92a871af4716ae1bd8e2004302"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gabc3bff92a871af4716ae1bd8e2004302">CSL_MLBSS_clearCtrEntry</a>(CtrAddr)&#160;&#160;&#160;<a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gabb3e74c56e2c564d3170d11ad6652846">CSL_MLBSS_setCtrEntry</a>( CtrAddr, <a class="el" href="csl__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="csl__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> )</td></tr>
<tr class="separator:gabc3bff92a871af4716ae1bd8e2004302"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff24a6b45ba5eb44f29798310be6bcc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaff24a6b45ba5eb44f29798310be6bcc0">CSL_MLBSS_configSubSystem</a> (bool bEnableFastClkStop, unsigned DmaVbusPriority)</td></tr>
<tr class="separator:gaff24a6b45ba5eb44f29798310be6bcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8adce02e1da703561bc6d409f96a5cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga8adce02e1da703561bc6d409f96a5cd3">CSL_MLBSS_getPid</a> ()</td></tr>
<tr class="separator:ga8adce02e1da703561bc6d409f96a5cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3add3bcd29d9c87108b7ca6dcb9218c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga3add3bcd29d9c87108b7ca6dcb9218c5">CSL_MLBSS_isInitInProgress</a> ()</td></tr>
<tr class="separator:ga3add3bcd29d9c87108b7ca6dcb9218c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17688cac52c273f50fdd3a94ee18ad68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga17688cac52c273f50fdd3a94ee18ad68">CSL_MLBSS_isResetInProgress</a> ()</td></tr>
<tr class="separator:ga17688cac52c273f50fdd3a94ee18ad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358255066bbca354b1e7b5baeb77465c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga358255066bbca354b1e7b5baeb77465c">CSL_MLBSS_resetSubSystem</a> ()</td></tr>
<tr class="separator:ga358255066bbca354b1e7b5baeb77465c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d7a343cde2a2b53862ea9c9fda5ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga41d7a343cde2a2b53862ea9c9fda5ee4">CSL_MLBSS_disableRatRegion</a> (unsigned RegionNum)</td></tr>
<tr class="separator:ga41d7a343cde2a2b53862ea9c9fda5ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd0bf6672acc9f7e737d9dfac2d1e599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gadd0bf6672acc9f7e737d9dfac2d1e599">CSL_MLBSS_enableRatRegion</a> (unsigned RegionNum)</td></tr>
<tr class="separator:gadd0bf6672acc9f7e737d9dfac2d1e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0f536fdb0a588d79a53f632bbe0ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga5b0f536fdb0a588d79a53f632bbe0ae1">CSL_MLBSS_setRatRegion</a> (unsigned RegionNum, bool bEnable, unsigned EncodedSize, uint32_t AhbAddr, uint64_t VbusAddr)</td></tr>
<tr class="separator:ga5b0f536fdb0a588d79a53f632bbe0ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52992cd2fdb41fe77f87d175b6c7cb1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga52992cd2fdb41fe77f87d175b6c7cb1a">CSL_MLBSS_getRatRegion</a> (unsigned RegionNum, bool *pbEnable, unsigned *pEncodedSize, uint32_t *pAhbAddr, uint64_t *pVbusAddr)</td></tr>
<tr class="separator:ga52992cd2fdb41fe77f87d175b6c7cb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df8fb90f3c06aa94957e691f1a4c606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga5df8fb90f3c06aa94957e691f1a4c606">CSL_MLBSS_writeDbr8</a> (unsigned ByteAddr, uint8_t <a class="el" href="csl__udmap__tr_8h.html#ae4abda5e3cab325153762e904fd3f1e8">data</a>)</td></tr>
<tr class="separator:ga5df8fb90f3c06aa94957e691f1a4c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ca533de1b12190419a514a3984a748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga61ca533de1b12190419a514a3984a748">CSL_MLBSS_readDbr8</a> (unsigned ByteAddr)</td></tr>
<tr class="separator:ga61ca533de1b12190419a514a3984a748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb3e74c56e2c564d3170d11ad6652846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gabb3e74c56e2c564d3170d11ad6652846">CSL_MLBSS_setCtrEntry</a> (unsigned CtrAddr, uint32_t *mask, uint32_t *<a class="el" href="csl__udmap__tr_8h.html#ae4abda5e3cab325153762e904fd3f1e8">data</a>)</td></tr>
<tr class="separator:gabb3e74c56e2c564d3170d11ad6652846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c782a708f6fd173653ce619ca150fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gad1c782a708f6fd173653ce619ca150fd">CSL_MLBSS_getCtrEntry</a> (unsigned CtrAddr, uint32_t *<a class="el" href="csl__udmap__tr_8h.html#ae4abda5e3cab325153762e904fd3f1e8">data</a>)</td></tr>
<tr class="separator:gad1c782a708f6fd173653ce619ca150fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97ce2c6b7811699ddb972904f2fd44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gab97ce2c6b7811699ddb972904f2fd44e">CSL_MLBSS_clearCtr</a> (void)</td></tr>
<tr class="separator:gab97ce2c6b7811699ddb972904f2fd44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d211a14a225603088c4ebdbefa46d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga4d211a14a225603088c4ebdbefa46d79">CSL_MLBSS_clearCat</a> ()</td></tr>
<tr class="separator:ga4d211a14a225603088c4ebdbefa46d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ceed5ed0c34c9904588e2d68002ab77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga6ceed5ed0c34c9904588e2d68002ab77">CSL_MLBSS_configMlb</a> (<a class="el" href="struct_c_s_l___m_l_b_s_s___m_l_b___c_f_g___t.html">CSL_MLBSS_MLB_CFG_T</a> *pMlbCoreCfg)</td></tr>
<tr class="separator:ga6ceed5ed0c34c9904588e2d68002ab77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa874f28b8e7114189016eb76fad99bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaa874f28b8e7114189016eb76fad99bd7">CSL_MLBSS_disableMlb</a> ()</td></tr>
<tr class="separator:gaa874f28b8e7114189016eb76fad99bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5102a382d88e97882ceec393cd5735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga3e5102a382d88e97882ceec393cd5735">CSL_MLBSS_enableMlb</a> ()</td></tr>
<tr class="separator:ga3e5102a382d88e97882ceec393cd5735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e804be572002fdfd97e40525b7c059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaa0e804be572002fdfd97e40525b7c059">CSL_MLBSS_isMlbClockLocked</a> ()</td></tr>
<tr class="separator:gaa0e804be572002fdfd97e40525b7c059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e852f8d18df0341861fd7cbe61217f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga27e852f8d18df0341861fd7cbe61217f">CSL_MLBSS_isMlbClockMissing</a> ()</td></tr>
<tr class="separator:ga27e852f8d18df0341861fd7cbe61217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea47a9ccc99189c9aed2a57fd9a74b60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaea47a9ccc99189c9aed2a57fd9a74b60">CSL_MLBSS_getMlbIntsPending</a> ()</td></tr>
<tr class="separator:gaea47a9ccc99189c9aed2a57fd9a74b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf7c12f3fa028c3965335c540e84fbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaaf7c12f3fa028c3965335c540e84fbb9">CSL_MLBSS_isMlbIntPending</a> (unsigned ChnNum)</td></tr>
<tr class="separator:gaaf7c12f3fa028c3965335c540e84fbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49ef750a635ff6cb9f720952cc6735a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaf49ef750a635ff6cb9f720952cc6735a">CSL_MLBSS_disableMlbInts</a> (uint32_t MlbIntTypeMask)</td></tr>
<tr class="separator:gaf49ef750a635ff6cb9f720952cc6735a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03c9e937ce125b162aa02733286575d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gae03c9e937ce125b162aa02733286575d">CSL_MLBSS_enableMlbInts</a> (uint32_t MlbIntTypeMask)</td></tr>
<tr class="separator:gae03c9e937ce125b162aa02733286575d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b4b0edd07dcf1de82760bb71ed70f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga16b4b0edd07dcf1de82760bb71ed70f1">CSL_MLBSS_disableMlbInt</a> (<a class="el" href="group___c_s_l___m_l_b_s_s___e_n_u_m.html#gac9f413d54f0957f10547d326aca57158">CSL_MLBSS_MLB_INT_E</a> MlbIntType)</td></tr>
<tr class="separator:ga16b4b0edd07dcf1de82760bb71ed70f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475d3c232ebcbf4b18ed4df85a4884d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga475d3c232ebcbf4b18ed4df85a4884d7">CSL_MLBSS_enableMlbInt</a> (<a class="el" href="group___c_s_l___m_l_b_s_s___e_n_u_m.html#gac9f413d54f0957f10547d326aca57158">CSL_MLBSS_MLB_INT_E</a> MlbIntType)</td></tr>
<tr class="separator:ga475d3c232ebcbf4b18ed4df85a4884d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad788c630513c67be62eb79f6e8971d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gad788c630513c67be62eb79f6e8971d75">CSL_MLBSS_ackMlbInts</a> (uint64_t ChnNumMask)</td></tr>
<tr class="separator:gad788c630513c67be62eb79f6e8971d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96857e31cf2520a5c91ed6bf3033ba12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga96857e31cf2520a5c91ed6bf3033ba12">CSL_MLBSS_ackMlbInt</a> (unsigned ChnNum)</td></tr>
<tr class="separator:ga96857e31cf2520a5c91ed6bf3033ba12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be280cd157952aa7ef80fed978a4c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga5be280cd157952aa7ef80fed978a4c9d">CSL_MLBSS_configAhb</a> (<a class="el" href="group___c_s_l___m_l_b_s_s___e_n_u_m.html#gaafffb55501d146b942e2b6a269f4bcf9">CSL_MLBSS_AHB_PKT_MODE_E</a> PacketMode, <a class="el" href="group___c_s_l___m_l_b_s_s___e_n_u_m.html#gad007745c485b4e0ef3fc4dcc4ee09221">CSL_MLBSS_AHB_DMA_MODE_E</a> DmaMode, bool bIntMux, bool bSwClrInt)</td></tr>
<tr class="separator:ga5be280cd157952aa7ef80fed978a4c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b64109449520ae5b9da9e570f67d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga69b64109449520ae5b9da9e570f67d4c">CSL_MLBSS_getAhbIntsPending</a> ()</td></tr>
<tr class="separator:ga69b64109449520ae5b9da9e570f67d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c86bd6c0d0e37b9c431ab7d976c64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga51c86bd6c0d0e37b9c431ab7d976c64e">CSL_MLBSS_isAhbIntPending</a> (unsigned ChnNum)</td></tr>
<tr class="separator:ga51c86bd6c0d0e37b9c431ab7d976c64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac536fa6a6a80f65f381a9ba7b84c0f7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gac536fa6a6a80f65f381a9ba7b84c0f7b">CSL_MLBSS_disableAhbInts</a> (uint64_t ChnNumMask)</td></tr>
<tr class="separator:gac536fa6a6a80f65f381a9ba7b84c0f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2d80fd0f8d33ed305edb71a1b537d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga7f2d80fd0f8d33ed305edb71a1b537d3">CSL_MLBSS_enableAhbInts</a> (uint64_t ChnNumMask)</td></tr>
<tr class="separator:ga7f2d80fd0f8d33ed305edb71a1b537d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4d8bb7e155d20afce7245f2a44410b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaf4d8bb7e155d20afce7245f2a44410b1">CSL_MLBSS_disableAhbInt</a> (unsigned ChnNum)</td></tr>
<tr class="separator:gaf4d8bb7e155d20afce7245f2a44410b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga729b8d2b30449b52b0ab300326f1ec24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga729b8d2b30449b52b0ab300326f1ec24">CSL_MLBSS_enableAhbInt</a> (unsigned ChnNum)</td></tr>
<tr class="separator:ga729b8d2b30449b52b0ab300326f1ec24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1f90b4892dde6f67f71c65fe5deae39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gab1f90b4892dde6f67f71c65fe5deae39">CSL_MLBSS_ackAhbInts</a> (uint64_t ChnNumMask)</td></tr>
<tr class="separator:gab1f90b4892dde6f67f71c65fe5deae39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa228b002b3f8c302c1015f0333572cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaa228b002b3f8c302c1015f0333572cce">CSL_MLBSS_ackAhbInt</a> (unsigned ChnNum)</td></tr>
<tr class="separator:gaa228b002b3f8c302c1015f0333572cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46fb567653cd1436a10e53c34335b65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga46fb567653cd1436a10e53c34335b65b">CSL_MLBSS_disableHbi</a> ()</td></tr>
<tr class="separator:ga46fb567653cd1436a10e53c34335b65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga144e206780922f3606eadb5b051c6ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga144e206780922f3606eadb5b051c6ddb">CSL_MLBSS_enableHbi</a> ()</td></tr>
<tr class="separator:ga144e206780922f3606eadb5b051c6ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3ead01e357ec6bb2cd1e3a8e9c87e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gacf3ead01e357ec6bb2cd1e3a8e9c87e9">CSL_MLBSS_disableHbiInts</a> (uint64_t ChnNumMask)</td></tr>
<tr class="separator:gacf3ead01e357ec6bb2cd1e3a8e9c87e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75357d271c35ce0136d08572c5daa15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaa75357d271c35ce0136d08572c5daa15">CSL_MLBSS_enableHbiInts</a> (uint64_t ChnNumMask)</td></tr>
<tr class="separator:gaa75357d271c35ce0136d08572c5daa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedbd8bdc5c47885ef2c43ffc4c95c7c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gaedbd8bdc5c47885ef2c43ffc4c95c7c6">CSL_MLBSS_disableHbiInt</a> (unsigned ChnNum)</td></tr>
<tr class="separator:gaedbd8bdc5c47885ef2c43ffc4c95c7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89416f4b4b1d13cab1f49d46a5f724f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga89416f4b4b1d13cab1f49d46a5f724f1">CSL_MLBSS_enableHbiInt</a> (unsigned ChnNum)</td></tr>
<tr class="separator:ga89416f4b4b1d13cab1f49d46a5f724f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ebdb30b2c20b5df8af346bb1e2c9fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga6ebdb30b2c20b5df8af346bb1e2c9fd8">CSL_MLBSS_config</a> (<a class="el" href="struct_c_s_l___m_l_b_s_s___c_f_g___t.html">CSL_MLBSS_CFG_T</a> *pMlbSubSysCfg, <a class="el" href="struct_c_s_l___m_l_b_s_s___m_l_b___c_f_g___t.html">CSL_MLBSS_MLB_CFG_T</a> *pMlbCoreCfg)</td></tr>
<tr class="separator:ga6ebdb30b2c20b5df8af346bb1e2c9fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gabc3bff92a871af4716ae1bd8e2004302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_MLBSS_clearCtrEntry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">CtrAddr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gabb3e74c56e2c564d3170d11ad6652846">CSL_MLBSS_setCtrEntry</a>( CtrAddr, <a class="el" href="csl__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="csl__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_clearCtrEntry</b> </p>
<p><b>Description</b> <br />
 This function is used to clear an entry in the Channel Table Ram (CTR)</p>
<p><b>Arguments</b> </p><pre class="fragment">     CtrAddr     - The address (0..0x8F) of the CTR entry to clear</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the DBR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MDAT0, MDAT1, MDAT2, MDAT3, MDWE0, MDWE1, MDWE2, MDWE3, MADR, MCTL</p>
<p><b>Reads</b> <br />
 MCTL</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_clearCtrEntry( 0x10 );  // Clear CTR entry 0x10</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabc3bff92a871af4716ae1bd8e2004302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSL_MLBSS_clearCtrEntry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">CtrAddr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#gabb3e74c56e2c564d3170d11ad6652846">CSL_MLBSS_setCtrEntry</a>( CtrAddr, <a class="el" href="csl__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="csl__types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_clearCtrEntry</b> </p>
<p><b>Description</b> <br />
 This function is used to clear an entry in the Channel Table Ram (CTR)</p>
<p><b>Arguments</b> </p><pre class="fragment">     CtrAddr     - The address (0..0x8F) of the CTR entry to clear</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the DBR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MDAT0, MDAT1, MDAT2, MDAT3, MDWE0, MDWE1, MDWE2, MDWE3, MADR, MCTL</p>
<p><b>Reads</b> <br />
 MCTL</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_clearCtrEntry( 0x10 );  // Clear CTR entry 0x10</pre><hr/>
 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa228b002b3f8c302c1015f0333572cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_ackAhbInt </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ChnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_ackAhbInt</b> </p>
<p><b>Description</b> <br />
 This function is used to acknowledge a pending AHB interrupt on a channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNum - Channel number (0..63) on which there is a pending AHB interrupt to
              be acknowledged</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ACSR0, ACSR1</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned ChnNum = 17;

     if( CSL_MLBSS_isAhbIntPending( ChnNum )     // If an interrupt is pending for this channel,
         CSL_MLBSS_ackAhbInt( ChnNum );          //   then acknowledge it</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab1f90b4892dde6f67f71c65fe5deae39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_ackAhbInts </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ChnNumMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_ackAhbInts</b> </p>
<p><b>Description</b> <br />
 This function is used to acknowledge AHB interrupts on one or more channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNumMask - A 64-bit wide mask (mask bit 0 corresponds to channel 0, ...,
                  mask bit 63 corresponds to channel 63) where each bit denotes
                  if an AHB interrupt is to be acknowledged (bit value is 1) or
                  ignored (bit value is 0) for that channel.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ACSR0, ACSR1</p>
<p><b>Example</b> </p><pre class="fragment">     uint64_t ChannelsWithPendingAhbInts;

     ChannelsWithPendingAhbInts = CSL_MLBSS_getAhbIntsPending(); // Determine channels with pending AHB interrupts
     CSL_MLBSS_ackAhbInts( ChannelsWithPendingAhbInts );         // Ack all pending interrupts</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga96857e31cf2520a5c91ed6bf3033ba12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_ackMlbInt </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ChnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_ackMlbInt</b> </p>
<p><b>Description</b> <br />
 This function is used to acknowledge a pending MLB interrupt on a channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNum - Channel number (0..63) on which there is a pending MLB interrupt to
              be acknowledged</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MS0, MS1</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned ChnNum = 17;

     if( CSL_MLBSS_isMlbIntPending( ChnNum )     // If an interrupt is pending for this channel,
         CSL_MLBSS_ackMlbInt( ChnNum );          //   then acknowledge it</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad788c630513c67be62eb79f6e8971d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_ackMlbInts </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ChnNumMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_ackMlbInts</b> </p>
<p><b>Description</b> <br />
 This function is used to acknowledge pending MLB interrupts on one or more channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNumMask - A 64-bit wide mask (mask bit 0 corresponds to channel 0, ...,
                  mask bit 63 corresponds to channel 63) where each bit denotes
                  if an MLB interrupt is to be acknowledged (bit value is 1) or
                  not (bit value is 0) for that channel.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MS0, MS1</p>
<p><b>Example</b> </p><pre class="fragment">     uint64_t ChannelsWithPendingMlbInts;

     ChannelsWithPendingMlbInts = CSL_MLBSS_getMlbIntsPending();     // Determine channels with pending MLB interrupts
     CSL_MLBSS_ackMlbInts( ChannelsWithPendingMlbInts );             // Ack all pending interrupts</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4d211a14a225603088c4ebdbefa46d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_clearCat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_clearCat</b> </p>
<p><b>Description</b> <br />
 This function is used to clear each entry in the Channel Address Table (CAT) portion of the Channel Table Ram (CTR).</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the DBR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MDAT0, MDAT1, MDAT2, MDAT3, MDWE0, MDWE1, MDWE2, MDWE3, MADR, MCTL</p>
<p><b>Reads</b> <br />
 MCTL</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_clearCat();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab97ce2c6b7811699ddb972904f2fd44e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_clearCtr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_clearCtr</b> </p>
<p><b>Description</b> <br />
 This function is used to clear each entry in the Channel Table Ram (CTR).</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the DBR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MDAT0, MDAT1, MDAT2, MDAT3, MDWE0, MDWE1, MDWE2, MDWE3, MADR, MCTL</p>
<p><b>Reads</b> <br />
 MCTL</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_clearCtr();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6ebdb30b2c20b5df8af346bb1e2c9fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_l_b_s_s___c_f_g___t.html">CSL_MLBSS_CFG_T</a> *&#160;</td>
          <td class="paramname"><em>pMlbSubSysCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_l_b_s_s___m_l_b___c_f_g___t.html">CSL_MLBSS_MLB_CFG_T</a> *&#160;</td>
          <td class="paramname"><em>pMlbCoreCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_config</b> </p>
<p><b>Description</b> <br />
 This function is used to configure the entire mlbss in one call. The following configuration functions are called by this function: CSL_MLBSS_clearCtr - Clear the Channel Table Ram CSL_MLBSS_configSubSystem - Configure the mlbss sub-system CSL_MLBSS_configMlb - Configure the MLB functionality CSL_MLBSS_configAhb - Configure the AHB functionality</p>
<p><b>Arguments</b> </p><pre class="fragment">     pMlbSubSysCfg - A pointer to a CSL_MLBSS_CFG_T structure containing sub-system configuration information
     pMlbCoreCfg   - A pointer to a CSL_MLBSS_MLB_CFG_T structure containing MLB configuration information</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the CTR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MDAT0, MDAT1, MDAT2, MDAT3, MDWE0, MDWE1, MDWE2, MDWE3, MADR, MCTL, CTRL, DMA_CTRL, MLBC0, MLBPC0, MSS, MLBPC1, ACTL</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_CFG_T         MlbSubSysCfg;
     CSL_MLBSS_MLB_CFG_T MlbCfg;

     MlbSubSysCfg.bEnableFastClkStop = false;
     MlbSubSysCfg.DmaVbusPriority    = 0;

     MlbCoreCfg.SyncFrameCnt         = CSL_MLBSS_SYNC_FCNT_1;
     MlbCoreCfg.PinMode              = CSL_MLBSS_MLB_PIN_MODE_3;
     MlbCoreCfg.ClkSpeed             = CSL_MLBSS_MLB_CLK_SPEED_512X;
     MlbCoreCfg.AhbPktMode           = CSL_MLBSS_AHB_PKT_MODE_SINGLE;
     MlbCoreCfg.AhbDmaMode           = CSL_MLBSS_AHB_DMA_MODE_0;
     MlbCoreCfg.bAhbIntMux           = true;
     MlbCoreCfg.bAhbSwClrInt         = true;
     MlbCoreCfg.bCtlRtry             = false;
     MlbCoreCfg.bAsyRetry            = false;
     MlbCoreCfg.bServiceReqEnable    = false;
     MlbCoreCfg.bHysteresisEnable    = false;
     MlbCoreCfg.ClkRxBiasCtl         = 0;
     MlbCoreCfg.SigDataTxBiasCtl     = 0;
     MlbCoreCfg.SigDataRxBiasCtl     = 0;

     CSL_MLBSS_config( &amp;MlbSubSysCfg, &amp;MlbCfg );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5be280cd157952aa7ef80fed978a4c9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_configAhb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_l_b_s_s___e_n_u_m.html#gaafffb55501d146b942e2b6a269f4bcf9">CSL_MLBSS_AHB_PKT_MODE_E</a>&#160;</td>
          <td class="paramname"><em>PacketMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_l_b_s_s___e_n_u_m.html#gad007745c485b4e0ef3fc4dcc4ee09221">CSL_MLBSS_AHB_DMA_MODE_E</a>&#160;</td>
          <td class="paramname"><em>DmaMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIntMux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSwClrInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_configAhb</b> </p>
<p><b>Description</b> <br />
 This function is used to configure the AHB functionality in the mlbss.</p>
<p><b>Arguments</b> </p><pre class="fragment">     PacketMode - Specifies the AHB packet buffering mode. See the MLBSS_AHB_PKT_MODE_E enumeration for valid modes.
     DmaMode    - Specified the AHB DMA mode. See the MLBSS_AHB_DMA_MODE_E enumeration for valid modes.
     bIntMux    - If true, ACSR0 and ACSR1 generate an interrupt on ahb_int[0] only. If false, ACSR0 generates an interrupt on ahb_int[0] and ACSR1 generates an interrupt on ahb_int[1].
     bSwClrInt  - If true, software is responsible for clearing AHB interrupts. If false, hardware clears interrupt after a ACSRn register read.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MLBDIM_ACTL_SCE, MLBDIM_ACTL_SMX, MLBDIM_ACTL_DMAMODE, MLBDIM_ACTL_MPB</p>
<p><b>Example</b> </p><pre class="fragment">     MLBSS_AHB_PKT_MODE_E PacketMode = CSL_MLBSS_AHB_PKT_MODE_SINGLE;
     MLBSS_AHB_DMA_MODE_E DmaMode    = CSL_MLBSS_AHB_DMA_MODE_0;
     bool bIntMux                    = true;
     bool bSwClrInt                  = true;

     CSL_MLBSS_configAhb( PacketMode, DmaMode, bIntMux, bSwClrInt );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6ceed5ed0c34c9904588e2d68002ab77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_configMlb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_l_b_s_s___m_l_b___c_f_g___t.html">CSL_MLBSS_MLB_CFG_T</a> *&#160;</td>
          <td class="paramname"><em>pMlbCoreCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_configMlb</b> </p>
<p><b>Description</b> <br />
 This function is used to configure the Media Local Bus (MLB) functionality within the mlbss.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pMlbCoreCfg - A pointer to a CSL_MLBSS_MLB_CFG_T structure containing
                   MLB configuration information</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MLBC0, MLBPC0, MSS, MLBPC1</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_MLB_CFG_T MlbCfg;

     MlbCoreCfg.SyncFrameCnt         = CSL_MLBSS_SYNC_FCNT_1;
     MlbCoreCfg.PinMode              = CSL_MLBSS_MLB_PIN_MODE_3;
     MlbCoreCfg.ClkSpeed             = CSL_MLBSS_MLB_CLK_SPEED_512X;
     MlbCoreCfg.AhbPktMode           = CSL_MLBSS_AHB_PKT_MODE_SINGLE;
     MlbCoreCfg.AhbDmaMode           = CSL_MLBSS_AHB_DMA_MODE_0;
     MlbCoreCfg.bAhbIntMux           = true;
     MlbCoreCfg.bAhbSwClrInt         = true;
     MlbCoreCfg.bCtlRtry             = false;
     MlbCoreCfg.bAsyRetry            = false;
     MlbCoreCfg.bServiceReqEnable    = false;
     MlbCoreCfg.bHysteresisEnable    = false;
     MlbCoreCfg.ClkRxBiasCtl         = 0;
     MlbCoreCfg.SigDataTxBiasCtl     = 0;
     MlbCoreCfg.SigDataRxBiasCtl     = 0;

     CSL_MLBSS_configMlb( &amp;MlbCfg );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaff24a6b45ba5eb44f29798310be6bcc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_configSubSystem </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableFastClkStop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>DmaVbusPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_configSubSystem</b> </p>
<p><b>Description</b> <br />
 This function is used to configure the mlbss sub-system. It is called by the higher-level CSL_MLBSS_config function, but may be called separately.</p>
<p><b>Arguments</b> </p><pre class="fragment">     bool     bEnableFastClkStop   - If true, fast Clock Stop mode is enabled. If false, it is disabled.
     unsigned DmaVbusPriority      - A value (0..7) specifying the priority of the mlbss DMA (with 0 being the highest priority, 7 the lowest)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MLBSS_CTRL_CLKFACK, MLBSS_DMA_CTRL_PRIORITY</p>
<p><b>Example</b> </p><pre class="fragment">     bool        bEnableFastClkStop = true;
     unsigned    DmaVbusPriority = 0;

     CSL_MLBSS_configSubSystem( bEnableFastClkStop, DmaVbusPriority );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf4d8bb7e155d20afce7245f2a44410b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableAhbInt </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ChnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableAhbInt</b> </p>
<p><b>Description</b> <br />
 This function is used to disable AHB interrupts on a channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNum - The channel number (0..63) on which to disable AHB interrupts</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ACMR0, ACMR1</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned ChnNum = 17;

     CSL_MLBSS_disableAhbInt( ChnNum );  // Disable AHB interrupts for channel 17</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac536fa6a6a80f65f381a9ba7b84c0f7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableAhbInts </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ChnNumMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableAhbInts</b> </p>
<p><b>Description</b> <br />
 This function is used to disable AHB interrupts on one or more channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNumMask - A 64-bit wide mask (mask bit 0 corresponds to channel 0, ...,
                  mask bit 63 corresponds to channel 63) where each bit denotes
                  if an AHB interrupt is to be disabled (bit value is 1) or
                  ignored (bit value is 0) for that channel.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ACMR0, ACMR1</p>
<p><b>Example</b> </p><pre class="fragment">     uint64_t ChnNumMask = (1UL &lt;&lt; 48) | (1UL &lt;&lt; 17);

     CSL_MLBSS_disableAhbInts( ChnNumMask ); // Disable AHB interrupts for channels 17 and 48</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga46fb567653cd1436a10e53c34335b65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableHbi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableHbi</b> </p>
<p><b>Description</b> <br />
 This function is used to disable the HBI interface.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MLBDIM_HCTL_EN</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_disableHbi();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaedbd8bdc5c47885ef2c43ffc4c95c7c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableHbiInt </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ChnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableHbiInt</b> </p>
<p><b>Description</b> <br />
 This function is used to disable HBI interrupts on a channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNum - The channel number (0..63) on which to disable HBI interrupts</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ACMR0, ACMR1</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned ChnNum = 17;

     CSL_MLBSS_disableHbiInt( ChnNum );  // Disable HBI interrupts for channel 17</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacf3ead01e357ec6bb2cd1e3a8e9c87e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableHbiInts </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ChnNumMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableHbiInts</b> </p>
<p><b>Description</b> <br />
 This function is used to disable HBI interrupts on one or more channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNumMask - A 64-bit wide mask (mask bit 0 corresponds to channel 0, ...,
                  mask bit 63 corresponds to channel 63) where each bit denotes
                  if an HBI interrupt is to be disabled (bit value is 1) or
                  ignored (bit value is 0) for that channel.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 HCMR0, HCMR1</p>
<p><b>Example</b> </p><pre class="fragment">     uint64_t ChnNumMask = (1UL &lt;&lt; 48) | (1UL &lt;&lt; 17);

     CSL_MLBSS_disableHbiInts( ChnNumMask ); // Disable HBI interrupts for channels 17 and 48</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa874f28b8e7114189016eb76fad99bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableMlb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableMlb</b> </p>
<p><b>Description</b> <br />
 This function is used to disable the MLB interface.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MLBDIM_MLBC0_MLBEN</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_disableMlb();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga16b4b0edd07dcf1de82760bb71ed70f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableMlbInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_l_b_s_s___e_n_u_m.html#gac9f413d54f0957f10547d326aca57158">CSL_MLBSS_MLB_INT_E</a>&#160;</td>
          <td class="paramname"><em>MlbIntType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableMlbInt</b> </p>
<p><b>Description</b> <br />
 This function is used to disable an MLB interrupt type.</p>
<p><b>Arguments</b> </p><pre class="fragment">     MlbIntType - The MLB interrupt type to disable. See the CSL_MLBSS_MLB_INT_E
                  enumerator for a list of valid MLB interrupt types.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MIEN</p>
<p><b>Reads</b> <br />
 MIEN</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_disableMlbInt( CSL_MLBSS_MLB_INT_CTL_RX_PKT_DONE );    // Disable "Control Rx packet done" MLB interrupt type</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf49ef750a635ff6cb9f720952cc6735a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableMlbInts </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>MlbIntTypeMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableMlbInts</b> </p>
<p><b>Description</b> <br />
 This function is used to disable one or more MLB interrupt types.</p>
<p><b>Arguments</b> </p><pre class="fragment">     MlbIntTypeMask - A 32-bit wide mask where each bit corresponds to a specific MLB interrupt type.
                    If a mask bit is 1, the corresponding MLB interrupt type is disabled. If 0, it is unaffected.
                    See the CSL_MLBSS_MLB_INT_E enumerator for a list of valid MLB interrupt types.
                    Mask bit 0 corresponds to "Isochronous Rx protocol error", mask bit 24 corresponds
                    to "Control Rx packet done", etc.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MIEN</p>
<p><b>Reads</b> <br />
 MIEN</p>
<p><b>Example</b> </p><pre class="fragment">     uint32_t MlbIntTypeMask;

     MlbIntTypeMask = (1 &lt;&lt; CSL_MLBSS_MLB_INT_ISO_RX_PROTOCOL_ERR) |
                      (1 &lt;&lt; CSL_MLBSS_MLB_INT_CTL_RX_PKT_DONE);
     CSL_MLBSS_disableMlbInts( MlbIntTypeMask );           // Disable "Isochronous Rx protocol error" and "Control Rx packet done" MLB interrupt types</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga41d7a343cde2a2b53862ea9c9fda5ee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_disableRatRegion </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>RegionNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_disableRatRegion</b> </p>
<p><b>Description</b> <br />
 This function disables translation for the specified RAT region.</p>
<p><b>Arguments</b> </p><pre class="fragment">     unsigned RegionNum  - The number of the region (0..63)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 CSL_MLBSS_setRatRegion</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 KSBUS_RAT_CTRL0_BASE</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned RegionNum = 3;
     CSL_MLBSS_disableRatRegion( RegionNum );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga729b8d2b30449b52b0ab300326f1ec24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableAhbInt </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ChnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableAhbInt</b> </p>
<p><b>Description</b> <br />
 This function is used to enable AHB interrupts on a channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNum - The channel number (0..63) on which to enable AHB interrupts</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ACMR0, ACMR1</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned ChnNum = 17;

     CSL_MLBSS_enableAhbInt( ChnNum );   // Enable AHB interrupts for channel 17</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7f2d80fd0f8d33ed305edb71a1b537d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableAhbInts </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ChnNumMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableAhbInts</b> </p>
<p><b>Description</b> <br />
 This function is used to enable AHB interrupts on one or more channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNumMask - A 64-bit wide mask (mask bit 0 corresponds to channel 0, ...,
                  mask bit 63 corresponds to channel 63) where each bit denotes
                  if an AHB interrupt is to be enabled (bit value is 1) or
                  ignored (bit value is 0) for that channel.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ACMR0, ACMR1</p>
<p><b>Example</b> </p><pre class="fragment">     uint64_t ChnNumMask = (1UL &lt;&lt; 48) | (1UL &lt;&lt; 17);

     CSL_MLBSS_enableAhbInts( ChnNumMask );  // Enable AHB interrupts for channels 17 and 48</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga144e206780922f3606eadb5b051c6ddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableHbi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableHbi</b> </p>
<p><b>Description</b> <br />
 This function is used to enable the HBI interface.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MLBDIM_HCTL_EN</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_enableHbi();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga89416f4b4b1d13cab1f49d46a5f724f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableHbiInt </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ChnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableHbiInt</b> </p>
<p><b>Description</b> <br />
 This function is used to enable HBI interrupts on a channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNum - The channel number (0..63) on which to enable HBI interrupts</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 ACMR0, ACMR1</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned ChnNum = 17;

     CSL_MLBSS_enableHbiInt( ChnNum );  // Enable HBI interrupts for channel 17</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa75357d271c35ce0136d08572c5daa15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableHbiInts </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ChnNumMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableHbiInts</b> </p>
<p><b>Description</b> <br />
 This function is used to enable HBI interrupts on one or more channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     ChnNumMask - A 64-bit wide mask (mask bit 0 corresponds to channel 0, ...,
                  mask bit 63 corresponds to channel 63) where each bit denotes
                  if an HBI interrupt is to be enabled (bit value is 1) or
                  ignored (bit value is 0) for that channel.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 HCMR0, HCMR1</p>
<p><b>Example</b> </p><pre class="fragment">     uint64_t ChnNumMask = (1UL &lt;&lt; 48) | (1UL &lt;&lt; 17);

     CSL_MLBSS_enableHbiInts( ChnNumMask ); // Enable HBI interrupts for channels 17 and 48</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3e5102a382d88e97882ceec393cd5735"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableMlb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableMlb</b> </p>
<p><b>Description</b> <br />
 This function is used to enable the MLB interface.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MLBDIM_MLBC0_MLBEN</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_enableMlb();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga475d3c232ebcbf4b18ed4df85a4884d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableMlbInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_l_b_s_s___e_n_u_m.html#gac9f413d54f0957f10547d326aca57158">CSL_MLBSS_MLB_INT_E</a>&#160;</td>
          <td class="paramname"><em>MlbIntType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableMlbInt</b> </p>
<p><b>Description</b> <br />
 This function is used to enable an MLB interrupt type.</p>
<p><b>Arguments</b> </p><pre class="fragment">     MlbIntType - The MLB interrupt type to enable. See the CSL_MLBSS_MLB_INT_E
                  enumerator for a list of valid MLB interrupt types.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MIEN</p>
<p><b>Reads</b> <br />
 MIEN</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_enableMlbInt( CSL_MLBSS_MLB_INT_CTL_RX_PKT_DONE );    // Enable "Control Rx packet done" MLB interrupt type</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae03c9e937ce125b162aa02733286575d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableMlbInts </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>MlbIntTypeMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableMlbInts</b> </p>
<p><b>Description</b> <br />
 This function is used to enable one or more MLB interrupt types.</p>
<p><b>Arguments</b> </p><pre class="fragment">     MlbIntTypeMask - A 32-bit wide mask where each bit corresponds to a specific MLB interrupt type.
                    If a mask bit is 1, the corresponding MLB interrupt type is enable. If 0, it is unaffected.
                    See the CSL_MLBSS_MLB_INT_E enumerator for a list of valid MLB interrupt types.
                    Mask bit 0 corresponds to "Isochronous Rx protocol error", mask bit 24 corresponds
                    to "Control Rx packet done", etc.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MIEN</p>
<p><b>Reads</b> <br />
 MIEN</p>
<p><b>Example</b> </p><pre class="fragment">     uint32_t MlbIntTypeMask;

     MlbIntTypeMask = (1 &lt;&lt; CSL_MLBSS_MLB_INT_ISO_RX_PROTOCOL_ERR) |
                      (1 &lt;&lt; CSL_MLBSS_MLB_INT_CTL_RX_PKT_DONE);
     CSL_MLBSS_enableMlbInts( MlbIntTypeMask );           // Enable "Isochronous Rx protocol error" and "Control Rx packet done" MLB interrupt types</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadd0bf6672acc9f7e737d9dfac2d1e599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_enableRatRegion </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>RegionNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_enableRatRegion</b> </p>
<p><b>Description</b> <br />
 This function enables translation for the specified RAT region.</p>
<p><b>Arguments</b> </p><pre class="fragment">     unsigned RegionNum  - The number of the region (0..63)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 CSL_MLBSS_setRatRegion</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 KSBUS_RAT_CTRL0_BASE</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned RegionNum = 3;
     CSL_MLBSS_enableRatRegion( RegionNum );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga69b64109449520ae5b9da9e570f67d4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> uint64_t CSL_MLBSS_getAhbIntsPending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_getAhbIntsPending</b> </p>
<p><b>Description</b> <br />
 This function is used to determine which channels have pending AHB interrupts. The interrupts must first be enabled via the CSL_MLBSS_enableAhbInts or CSL_MLBSS_enableAhbInt functions before they can potentially cause a pending interrupt for a channel. A pending interrupt must be acknowledged via the CSL_MLBSS_ackAhbInts or CSL_MLBSS_ackAhbInt functions once detection or servicing of the interrupt is complete.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 A 64-bit mask is returned (mask bit 0 corresponds to channel 0, ..., mask bit 63 corresponds to channel 63) where each bit denotes if an AHB interrupt is pending (bit value is 1) or not pending (bit value is 0).</p>
<p><b> Pre Condition </b> <br />
 CSL_MLBSS_enableAhbInts, CSL_MLBSS_enableAhbInt</p>
<p><b> Post Condition </b> <br />
 CSL_MLBSS_ackAhbInts, CSL_MLBSS_ackAhbInt</p>
<p><b>Reads</b> <br />
 ACSR0, ACSR1</p>
<p><b>Example</b> </p><pre class="fragment">     uint64_t ChannelsWithPendingAhbInts;

     ChannelsWithPendingAhbInts = CSL_MLBSS_getAhbIntsPending();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad1c782a708f6fd173653ce619ca150fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_getCtrEntry </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>CtrAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_getCtrEntry</b> </p>
<p><b>Description</b> <br />
 This function is used to get an entry from the Channel Table Ram (CTR)</p>
<p><b>Arguments</b> </p><pre class="fragment">     CtrAddr     - The address (0..0x8F) of the CTR entry to get
     data        - Pointer to a 4 element uint32_t array (128-bits) where the contents
                   of the CTR entry is stored</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the DBR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MADR, MCTL</p>
<p><b>Reads</b> <br />
 MDAT0, MDAT1, MDAT2, MDAT3, MCTL</p>
<p><b>Example</b> </p><pre class="fragment">     uint32_t data[4];

     CSL_MLBSS_getCtrEntry( 0x10, data );        // Read contents of CTR entry 0x10</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaea47a9ccc99189c9aed2a57fd9a74b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> uint64_t CSL_MLBSS_getMlbIntsPending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_getMlbIntsPending</b> </p>
<p><b>Description</b> <br />
 This function is used to determine which channels have pending MLB interrupts. The desired MLB interrupts must first be enabled via the CSL_MLBSS_enableMlbInts or CSL_MLBSS_enableMlbInt functions before they can potentially cause a pending interrupt for a channel. A pending interrupt must be acknowledged via the CSL_MLBSS_ackMlbInts or CSL_MLBSS_ackMlbInt functions once detection or servicing of the interrupt is complete.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 A 64-bit mask is returned (mask bit 0 corresponds to channel 0, ..., mask bit 63 corresponds to channel 63) where each bit denotes if an MLB interrupt is pending (bit value is 1) or not pending (bit value is 0).</p>
<p><b> Pre Condition </b> <br />
 CSL_MLBSS_enableMlbInts, CSL_MLBSS_enableMlbInt</p>
<p><b> Post Condition </b> <br />
 CSL_MLBSS_ackMlbInts, CSL_MLBSS_ackMlbInt</p>
<p><b>Reads</b> <br />
 MS0, MS1</p>
<p><b>Example</b> </p><pre class="fragment">     uint64_t ChannelsWithPendingMlbInts;

     ChannelsWithPendingMlbInts = CSL_MLBSS_getMlbIntsPending();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8adce02e1da703561bc6d409f96a5cd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> uint32_t CSL_MLBSS_getPid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_getPid</b> </p>
<p><b>Description</b> <br />
 This function is used to get the mlbss PID value.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 The 32-bit PID value of the mlbss is returned</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 PID</p>
<p><b>Example</b> </p><pre class="fragment">     uint32_t    pid;

     pid = CSL_MLBSS_getPid();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga52992cd2fdb41fe77f87d175b6c7cb1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_getRatRegion </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>RegionNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>pEncodedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pAhbAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>pVbusAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>mlbss_getRatRegion</b> </p>
<p><b>Description</b> <br />
 This function is used to get information about a RAT region. Note that if any of the argument pointers described in the Arguments below are NULL, then that particular value is not returned.</p>
<p><b>Arguments</b> </p><pre class="fragment">     RegionNum       - The number of the region (0..63)
     pbEnable        - Pointer to a bool indicating if the region is enabled (true) or disabled (false)
     pEncodedSize    - Pointer to unsigned indicating the encoded size of the region (SizeInBytes = 2^EncSize)
     pAhbAddr        - Pointer to a uint32_t indicating the 32-bit AHB base address for this region
     pVbusAddr       - Pointer to a uint64_t indicating the 48-bit VBUS base address for this region (stored in a 64-bit variable)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 KSBUS_RAT_SIZE0_SIZE, KSBUS_RAT_BASE0_BASE, KSBUS_RAT_UPPER0_UPPER, KSBUS_RAT_LOWER0_UPPER, KSBUS_RAT_CTRL0_BASE</p>
<p><b>Example</b> </p><pre class="fragment">     bool        bEnable;
     unsigned    EncodedSize;
     uint32_t    AhbAddr;
     uint64_t    VbusAddr;
     mlbss_getRatRegion( 3, &amp;bEnable, &amp;EncodedSize, &amp;AhbAddr, &amp;VbusAddr );   // Return all Rat information for region 3
     mlbss_getRatRegion( 6, NULL, &amp;EncodedSize, NULL, NULL );                // Return only the encoded size for Rat region 6</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga51c86bd6c0d0e37b9c431ab7d976c64e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool CSL_MLBSS_isAhbIntPending </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ChnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_isAhbIntPending</b> </p>
<p><b>Description</b> <br />
 This function is used to determine if a specific channel has a pending AHB interrupt. The interrupts must first be enabled via the CSL_MLBSS_enableAhbInts or CSL_MLBSS_enableAhbInt functions before they can potentially cause a pending interrupt for a channel. A pending interrupt must be acknowledged via the CSL_MLBSS_ackAhbInts or CSL_MLBSS_ackAhbInt functions once detection or servicing of the interrupt is complete.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 true if an AHB interrupt is pending, false otherwise</p>
<p><b> Pre Condition </b> <br />
 CSL_MLBSS_enableAhbInts, CSL_MLBSS_enableAhbInt</p>
<p><b> Post Condition </b> <br />
 CSL_MLBSS_ackAhbInts, CSL_MLBSS_ackAhbInt</p>
<p><b>Reads</b> <br />
 ACSR0, ACSR1</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned    ChnNum = 17;
     bool        bAhbIntPending;

     bAhbIntPending = CSL_MLBSS_isAhbIntPending( ChnNum );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3add3bcd29d9c87108b7ca6dcb9218c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool CSL_MLBSS_isInitInProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_isInitInProgress</b> </p>
<p><b>Description</b> <br />
 This function returns the initialization status of the mlbss sub-system. When the mlbss is reset, internal CTR and DBR memories within the mlbss are initialized. This is not an instantaneous operation, so this function is provided to determine when this operation is complete. No functions which require the use of the CTR or DBR should be called until this initialization is complete.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE is returned if the internal memory initialization is in progress, otherwise FALSE is returned.</p>
<p><b> Pre Condition </b> <br />
 No functions which require the use of the CTR or DBR should be called until this initialization is complete.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MLBSS_STAT_INIT</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_resetSubSystem();                 // Initiate reset
     while( CSL_MLBSS_isInitInProgress() );      // Wait for memory initialization to complete</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa0e804be572002fdfd97e40525b7c059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool CSL_MLBSS_isMlbClockLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_isMlbClockLocked</b> </p>
<p><b>Description</b> <br />
 This function is used to determine if the mlbss is locked to the MLB clock.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 true if the mlbss is locked to the MLB clock, false otherwise</p>
<p><b> Pre Condition </b> <br />
 CSL_MLBSS_enableMlb</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MLBDIM_MLBC0_MLBLK</p>
<p><b>Example</b> </p><pre class="fragment">     bool IsLocked;

     IsLocked = CSL_MLBSS_isMlbClockLocked();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga27e852f8d18df0341861fd7cbe61217f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool CSL_MLBSS_isMlbClockMissing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_isMlbClockMissing</b> </p>
<p><b>Description</b> <br />
 This function is used to determine if the mlbss is unable to detect an MLB clock.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 true if the mlbss is is unable to detect an MLB clock, false otherwise</p>
<p><b> Pre Condition </b> <br />
 CSL_MLBSS_enableMlb</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MLBDIM_MLBC1_CLKM</p>
<p><b>Reads</b> <br />
 MLBDIM_MLBC1_CLKM</p>
<p><b>Example</b> </p><pre class="fragment">     bool IsClockMissing;

     IsClockMissing = CSL_MLBSS_isMlbClockMissing();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaf7c12f3fa028c3965335c540e84fbb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool CSL_MLBSS_isMlbIntPending </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ChnNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_isMlbIntPending</b> </p>
<p><b>Description</b> <br />
 This function is used to determine if a specific channel has a pending MLB interrupt. The desired MLB interrupts must first be enabled via the CSL_MLBSS_enableMlbInts or CSL_MLBSS_enableMlbInt functions before they can potentially cause a pending interrupt for a channel. A pending interrupt must be acknowledged via the CSL_MLBSS_ackMlbInts or CSL_MLBSS_ackMlbInt functions once detection or servicing of the interrupt is complete.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 true if an MLB interrupt is pending, false otherwise</p>
<p><b> Pre Condition </b> <br />
 CSL_MLBSS_enableMlbInts, CSL_MLBSS_enableMlbInt</p>
<p><b> Post Condition </b> <br />
 CSL_MLBSS_ackMlbInts, CSL_MLBSS_ackMlbInt</p>
<p><b>Reads</b> <br />
 MS0, MS1</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned    ChnNum = 17;
     bool        bMlbIntPending;

     bMlbIntPending = CSL_MLBSS_isMlbIntPending( ChnNum );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga17688cac52c273f50fdd3a94ee18ad68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> bool CSL_MLBSS_isResetInProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_isResetInProgress</b> </p>
<p><b>Description</b> <br />
 This function returns the reset status of the mlbss sub-system. When the mlbss is reset, registers are reset to their default values and internal CTR and DBR memories within the mlbss are initialized. This is not an instantaneous operation, so this function is provided to determine when this operation is complete. No other mlbss functions should be called until reset is complete.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 TRUE is returned if a Sub-System reset is in progress, otherwise FALSE is returned.</p>
<p><b> Pre Condition </b> <br />
 This function is normally used after calling <a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga358255066bbca354b1e7b5baeb77465c">CSL_MLBSS_resetSubSystem()</a> to determine when the subsystem reset is completed.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MLBSS_STAT_RESET</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_resetSubSystem();                 // Initiate reset
     while( CSL_MLBSS_isResetInProgress() );     // Wait for reset to complete</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga61ca533de1b12190419a514a3984a748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> uint8_t CSL_MLBSS_readDbr8 </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ByteAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_readDbr8</b> </p>
<p><b>Description</b> <br />
 This function is used to read a byte from the Data Buffer Ram (DBR).</p>
<p><b>Arguments</b> </p><pre class="fragment">     ByteAddr    - The byte address within the DBR to read from (0..0x3FFF)</pre><p><b> Return Value </b> <br />
 The byte value read</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the DBR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MADR, MCTL</p>
<p><b>Reads</b> <br />
 MCTL</p>
<p><b>Example</b> </p><pre class="fragment">     uint8_t data;

     data = CSL_MLBSS_readDbr8( 0x1000 );        // Read the byte from DBR address 0x1000</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga358255066bbca354b1e7b5baeb77465c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_resetSubSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_resetSubSystem</b> </p>
<p><b>Description</b> <br />
 This function initiates a reset of the mlbss sub-system, including initialization of internal CTR and DBR memories.</p>
<p><b>Arguments</b> <br />
 None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Reset may take some time to complete. <a class="el" href="group___c_s_l___m_l_b_s_s___f_u_n_c_t_i_o_n.html#ga17688cac52c273f50fdd3a94ee18ad68">CSL_MLBSS_isResetInProgress()</a> can be called to</p>
<p><b>Reads</b> <br />
 MLBSS_STAT_INIT</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_resetSubSystem();                 // Initiate reset
     while( CSL_MLBSS_isInitInProgress() );      // Wait for memory initialization to complete</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabb3e74c56e2c564d3170d11ad6652846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_setCtrEntry </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>CtrAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_setCtrEntry</b> </p>
<p><b>Description</b> <br />
 This function is used to set an entry in the Channel Table Ram (CTR)</p>
<p><b>Arguments</b> </p><pre class="fragment">     CtrAddr     - The address (0..0x8F) of the CTR entry to set
     mask        - Pointer to a 4 element uint32_t array (128-bits) where each bit corresponds
                   to a write enable for the corresponding bit in the entry. If mask is NULL,
                   then all mask bits are assumed to be 1.
     data        - Pointer to a 4 element uint32_t array (128-bits) where each bit corresponds
                   to the bit to be written in the entry (if the corresponding mask bit is also set).
                   If data is NULL, then all data bits are assumed to be 0.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the DBR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MDAT0, MDAT1, MDAT2, MDAT3, MDWE0, MDWE1, MDWE2, MDWE3, MADR, MCTL</p>
<p><b>Reads</b> <br />
 MCTL</p>
<p><b>Example</b> </p><pre class="fragment">     uint32_t mask[4] = { 0x00FF00FF, 0x00FF00FF, 0x00FF00FF, 0x00FF00FF };

     CSL_MLBSS_setCtrEntry( 0x10, mask, NULL );  // Write 0's to every other byte in CTR entry 0x10</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5b0f536fdb0a588d79a53f632bbe0ae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_setRatRegion </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>RegionNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>EncodedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>AhbAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>VbusAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_setRatRegion</b> </p>
<p><b>Description</b> <br />
 This function is used to set a RAT region.</p>
<p><b>Arguments</b> </p><pre class="fragment">     RegionNum   - The number of the region (0..63)
     bEnable     - If true, region is enabled, otherwise region is disabled
     EncodedSize - Encoded size of the region (SizeInBytes = 2^EncSize)
     AhbAddr     - The 32-bit AHB base address for this region
     VbusAddr    - The 48-bit VBUS base address for this region (stored in a 64-bit variable)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 KSBUS_RAT_SIZE0_SIZE, KSBUS_RAT_BASE0_BASE, KSBUS_RAT_UPPER0_UPPER, KSBUS_RAT_LOWER0_UPPER, KSBUS_RAT_CTRL0_BASE</p>
<p><b>Example</b> </p><pre class="fragment">     unsigned    RegionNum = 3;
     bool        bEnable        = true;         // Enable the region
     unsigned    EncodedSize    = 12;           // Region size is 4K bytes (encoded as 12)
     uint32_t    AhbAddr        = 0x00001000;   // The 32-bit AHB base address for this region
     uint64_t    VbusAddr       = 0x80000000UL; // The 48-bit VBUS base address for this region
     CSL_MLBSS_setRatRegion( RegionNum, bEnable, EncodedSize, AhbAddr, VbusAddr );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5df8fb90f3c06aa94957e691f1a4c606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="csl_8h.html#acd3da73d1bcb59850118d8c18838dc32">CSL_IDEF_INLINE</a> void CSL_MLBSS_writeDbr8 </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ByteAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MLBSS_writeDbr8</b> </p>
<p><b>Description</b> <br />
 This function is used to write a byte to the Data Buffer Ram (DBR).</p>
<p><b>Arguments</b> </p><pre class="fragment">     ByteAddr    - The byte address within the DBR to write to (0..0x3FFF)
     data        - The byte value to write</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Call CSL_MLBSS_isInitInProgress or CSL_MLBSS_isResetInProgress to insure the DBR has been initialized</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 MADR, MCTL</p>
<p><b>Reads</b> <br />
 MCTL</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_MLBSS_writeDbr8( 0x1000, 0xFF );        // Write 0xFF to DBR address 0x1000</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
