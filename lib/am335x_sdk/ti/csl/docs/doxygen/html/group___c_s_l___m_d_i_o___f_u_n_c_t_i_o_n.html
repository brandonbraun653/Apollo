<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CPSW Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CPSW Functions<div class="ingroups"><a class="el" href="group___c_s_l___m_d_i_o___a_p_i.html">MDIO</a> &raquo; <a class="el" href="group___c_s_l___m_d_i_o___a_p_i___v0.html">MDIO - V0</a><a class="el" href="group___c_s_l___m_d_i_o___a_p_i.html">MDIO</a> &raquo;  &#124; <a class="el" href="group___c_s_l___m_d_i_o___a_p_i___v1.html">MDIO - V1</a><a class="el" href="group___c_s_l___m_d_i_o___a_p_i.html">MDIO</a> &raquo;  &#124; <a class="el" href="group___c_s_l___m_d_i_o___a_p_i___v2.html">MDIO - V2</a><a class="el" href="group___c_s_l___m_d_i_o___a_p_i.html">MDIO</a> &raquo;  &#124; <a class="el" href="group___c_s_l___m_d_i_o___a_p_i___v3.html">MDIO - V3</a><a class="el" href="group___c_s_l___m_d_i_o___a_p_i.html">MDIO</a> &raquo;  &#124; <a class="el" href="group___c_s_l___m_d_i_o___a_p_i___v4.html">MDIO - V4</a><a class="el" href="group___c_s_l___m_d_i_o___a_p_i.html">MDIO</a><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a> &raquo;  &#124; <a class="el" href="group___c_s_l___c_p_s_w_i_t_c_h.html">CPSW CSL-FL</a> &raquo;  &#124; <a class="el" href="group___c_s_l___m_d_i_o___a_p_i___v5.html">MDIO - V5</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4557f178ac850e79dea29c48a686e86a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga4557f178ac850e79dea29c48a686e86a">CSL_MDIO_getVersionInfo</a> (<a class="el" href="struct_c_s_l___m_d_i_o___v_e_r_s_i_o_n.html">CSL_MDIO_VERSION</a> *mdioVersionInfo)</td></tr>
<tr class="separator:ga4557f178ac850e79dea29c48a686e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9bfcf528850710276444ffa0d8aa097"><td class="memItemLeft" align="right" valign="top">static Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gad9bfcf528850710276444ffa0d8aa097">CSL_MDIO_getClkDivVal</a> (void)</td></tr>
<tr class="separator:gad9bfcf528850710276444ffa0d8aa097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289deb7e32c4277eec786afd273408bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga289deb7e32c4277eec786afd273408bc">CSL_MDIO_setClkDivVal</a> (Uint16 clkDivVal)</td></tr>
<tr class="separator:ga289deb7e32c4277eec786afd273408bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga401a20e685cda37a7f0397970b14170e"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga401a20e685cda37a7f0397970b14170e">CSL_MDIO_isFaultDetectEnabled</a> (void)</td></tr>
<tr class="separator:ga401a20e685cda37a7f0397970b14170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a031867aebcf35b370abcd2bce357b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga1a031867aebcf35b370abcd2bce357b7">CSL_MDIO_enableFaultDetect</a> ()</td></tr>
<tr class="separator:ga1a031867aebcf35b370abcd2bce357b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f5e939587cdc5fd3fbc5e45c90d8497"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2f5e939587cdc5fd3fbc5e45c90d8497">CSL_MDIO_disableFaultDetect</a> ()</td></tr>
<tr class="separator:ga2f5e939587cdc5fd3fbc5e45c90d8497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f47898a451debf5ba44d1449b6a016"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga32f47898a451debf5ba44d1449b6a016">CSL_MDIO_isFaultDetected</a> (void)</td></tr>
<tr class="separator:ga32f47898a451debf5ba44d1449b6a016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0be476a73b57e2c6ff6d3a082f3752"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaba0be476a73b57e2c6ff6d3a082f3752">CSL_MDIO_clearFault</a> ()</td></tr>
<tr class="separator:gaba0be476a73b57e2c6ff6d3a082f3752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d8e2fd526b92bee7e083664fb64cad"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga63d8e2fd526b92bee7e083664fb64cad">CSL_MDIO_isPreambleEnabled</a> (void)</td></tr>
<tr class="separator:ga63d8e2fd526b92bee7e083664fb64cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097444696f4fb33d45e9b99df49cf338"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga097444696f4fb33d45e9b99df49cf338">CSL_MDIO_enablePreamble</a> ()</td></tr>
<tr class="separator:ga097444696f4fb33d45e9b99df49cf338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9be255ed97beccd423e88743828864"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gadf9be255ed97beccd423e88743828864">CSL_MDIO_disablePreamble</a> ()</td></tr>
<tr class="separator:gadf9be255ed97beccd423e88743828864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6faf36fb963a6035e02494d14f1087b1"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6faf36fb963a6035e02494d14f1087b1">CSL_MDIO_getHighestUserChannel</a> (void)</td></tr>
<tr class="separator:ga6faf36fb963a6035e02494d14f1087b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f40d9fce00936f6ca05407b172f4977"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6f40d9fce00936f6ca05407b172f4977">CSL_MDIO_isStateMachineEnabled</a> (void)</td></tr>
<tr class="separator:ga6f40d9fce00936f6ca05407b172f4977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd659c7512d86a249876f8a4977189b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabbd659c7512d86a249876f8a4977189b">CSL_MDIO_enableStateMachine</a> ()</td></tr>
<tr class="separator:gabbd659c7512d86a249876f8a4977189b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2180daf47153154f3274344973e3c553"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2180daf47153154f3274344973e3c553">CSL_MDIO_disableStateMachine</a> ()</td></tr>
<tr class="separator:ga2180daf47153154f3274344973e3c553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cabb86c9ef1ed5b373debd0518c4ce"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gae2cabb86c9ef1ed5b373debd0518c4ce">CSL_MDIO_isStateMachineIdle</a> (void)</td></tr>
<tr class="separator:gae2cabb86c9ef1ed5b373debd0518c4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ff9103a8ec1e971aed43dd70c9ba98"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga29ff9103a8ec1e971aed43dd70c9ba98">CSL_MDIO_isPhyAlive</a> (Uint32 phyAddr)</td></tr>
<tr class="separator:ga29ff9103a8ec1e971aed43dd70c9ba98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90419ccafe7119ac63833d240e748ded"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga90419ccafe7119ac63833d240e748ded">CSL_MDIO_clearPhyAliveStatus</a> (Uint32 phyAddr)</td></tr>
<tr class="separator:ga90419ccafe7119ac63833d240e748ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48582314d31c05514880bf1a876f19d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab48582314d31c05514880bf1a876f19d">CSL_MDIO_isPhyLinked</a> (Uint32 phyAddr)</td></tr>
<tr class="separator:gab48582314d31c05514880bf1a876f19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26e822a6ae7f8b3faa8316d06e83524"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf26e822a6ae7f8b3faa8316d06e83524">CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</a> (Uint32 index)</td></tr>
<tr class="separator:gaf26e822a6ae7f8b3faa8316d06e83524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301389b248d69524480aa4d0dd76cb9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga301389b248d69524480aa4d0dd76cb9e">CSL_MDIO_clearUnmaskedLinkStatusChangeInt</a> (Uint32 index)</td></tr>
<tr class="separator:ga301389b248d69524480aa4d0dd76cb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab798a906133056478c9488e24f86caba"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab798a906133056478c9488e24f86caba">CSL_MDIO_isMaskedLinkStatusChangeIntSet</a> (Uint32 index)</td></tr>
<tr class="separator:gab798a906133056478c9488e24f86caba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435e5615f18a341469b06c50582c928c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga435e5615f18a341469b06c50582c928c">CSL_MDIO_clearMaskedLinkStatusChangeInt</a> (Uint32 index)</td></tr>
<tr class="separator:ga435e5615f18a341469b06c50582c928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90f7f7efb26f324b9b13ce0683f280f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gad90f7f7efb26f324b9b13ce0683f280f">CSL_MDIO_isUnmaskedUserCmdCompleteIntSet</a> (Uint32 index)</td></tr>
<tr class="separator:gad90f7f7efb26f324b9b13ce0683f280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8368908148e23780da4108de5860a338"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga8368908148e23780da4108de5860a338">CSL_MDIO_clearUnmaskedUserCmdCompleteInt</a> (Uint32 index)</td></tr>
<tr class="separator:ga8368908148e23780da4108de5860a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3850d096378dcab15bfc5f11c4bff848"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga3850d096378dcab15bfc5f11c4bff848">CSL_MDIO_isMaskedUserCmdCompleteIntSet</a> (Uint32 index)</td></tr>
<tr class="separator:ga3850d096378dcab15bfc5f11c4bff848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa214d2214209a16d875304176948b9e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaa214d2214209a16d875304176948b9e2">CSL_MDIO_clearMaskedUserCmdCompleteInt</a> (Uint32 index)</td></tr>
<tr class="separator:gaa214d2214209a16d875304176948b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988cdb81e87c0fabaabf837f2ea994d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga988cdb81e87c0fabaabf837f2ea994d9">CSL_MDIO_enableUserCmdCompleteInterrupt</a> (Uint32 index)</td></tr>
<tr class="separator:ga988cdb81e87c0fabaabf837f2ea994d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857d949e50c3739fef0b59c1840f0863"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga857d949e50c3739fef0b59c1840f0863">CSL_MDIO_disableUserCmdCompleteInterrupt</a> (Uint32 index)</td></tr>
<tr class="separator:ga857d949e50c3739fef0b59c1840f0863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c6a833abfd5070b365d1cb6211589a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga32c6a833abfd5070b365d1cb6211589a">CSL_MDIO_getUserAccessRegister</a> (Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *pUserAccessReg)</td></tr>
<tr class="separator:ga32c6a833abfd5070b365d1cb6211589a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ec6c3fd8a5bf6d10cf7d3ebb237012"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga27ec6c3fd8a5bf6d10cf7d3ebb237012">CSL_MDIO_setUserAccessRegister</a> (Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *pUserAccessReg)</td></tr>
<tr class="separator:ga27ec6c3fd8a5bf6d10cf7d3ebb237012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af9a45a5c6ca3cfdd815e5e908992bf"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga4af9a45a5c6ca3cfdd815e5e908992bf">CSL_MDIO_isUserAccessPending</a> (Uint32 index)</td></tr>
<tr class="separator:ga4af9a45a5c6ca3cfdd815e5e908992bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c8c9a443f8ee69f13e61e267fa7633"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga95c8c9a443f8ee69f13e61e267fa7633">CSL_MDIO_enableLinkStatusChangeInterrupt</a> (Uint32 index, Uint32 phyAddr)</td></tr>
<tr class="separator:ga95c8c9a443f8ee69f13e61e267fa7633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5503f6478f0c27dae771dae37ca5085e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga5503f6478f0c27dae771dae37ca5085e">CSL_MDIO_disableLinkStatusChangeInterrupt</a> (Uint32 index, Uint32 phyAddr)</td></tr>
<tr class="separator:ga5503f6478f0c27dae771dae37ca5085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3bb26f450207da97de969750e3c1e4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab3bb26f450207da97de969750e3c1e4c">CSL_MDIO_getUserPhySelect</a> (Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_p_h_y_s_e_l.html">CSL_MDIO_USERPHYSEL</a> *pUserPhySelect)</td></tr>
<tr class="separator:gab3bb26f450207da97de969750e3c1e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220522c98e0188cd20faf182153b147c"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga220522c98e0188cd20faf182153b147c">CSL_MDIO_phyRegRead</a> (uint32_t baseAddr, Uint32 phyAddr, Uint32 regNum, Uint16 *pData)</td></tr>
<tr class="separator:ga220522c98e0188cd20faf182153b147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a905ff8d52c08bc7f19fccbad793b07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2a905ff8d52c08bc7f19fccbad793b07">CSL_MDIO_phyRegWrite</a> (uint32_t baseAddr, uint32_t phyAddr, uint32_t regNum, uint16_t wrVal)</td></tr>
<tr class="memdesc:ga2a905ff8d52c08bc7f19fccbad793b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API writes a PHY register using MDIO.  <a href="#ga2a905ff8d52c08bc7f19fccbad793b07">More...</a><br /></td></tr>
<tr class="separator:ga2a905ff8d52c08bc7f19fccbad793b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7f801c55a4b16c4f6b71d39c36c747"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaec7f801c55a4b16c4f6b71d39c36c747">CSL_MDIO_phyAliveStatus</a> (uint32_t baseAddr, uint32_t phyAddr)</td></tr>
<tr class="memdesc:gaec7f801c55a4b16c4f6b71d39c36c747"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the alive status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY is alive.  <a href="#gaec7f801c55a4b16c4f6b71d39c36c747">More...</a><br /></td></tr>
<tr class="separator:gaec7f801c55a4b16c4f6b71d39c36c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafabf75c2c29bead23f2a73623673c626"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gafabf75c2c29bead23f2a73623673c626">CSL_MDIO_phyLinkStatus</a> (uint32_t baseAddr, uint32_t phyAddr)</td></tr>
<tr class="memdesc:gafabf75c2c29bead23f2a73623673c626"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the link status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY link is active.  <a href="#gafabf75c2c29bead23f2a73623673c626">More...</a><br /></td></tr>
<tr class="separator:gafabf75c2c29bead23f2a73623673c626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35310b54635ddedbdb1ad817d2ae78fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga35310b54635ddedbdb1ad817d2ae78fd">CSL_MDIO_init</a> (uint32_t baseAddr, uint32_t mdioInputFreq, uint32_t mdioOutputFreq)</td></tr>
<tr class="memdesc:ga35310b54635ddedbdb1ad817d2ae78fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API initializes the MDIO peripheral. This enables the MDIO state machine, uses standard pre-amble and set the clock divider value.  <a href="#ga35310b54635ddedbdb1ad817d2ae78fd">More...</a><br /></td></tr>
<tr class="separator:ga35310b54635ddedbdb1ad817d2ae78fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga059dc3a4f3c0a0e449f618f9b9dbb939"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga059dc3a4f3c0a0e449f618f9b9dbb939">CSL_MDIO_phyUserPhySel</a> (uint32_t baseAddr, uint32_t phyNum, uint32_t val)</td></tr>
<tr class="memdesc:ga059dc3a4f3c0a0e449f618f9b9dbb939"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API initializes the MDIO peripheral. This enables the MDIO state machine, uses standard pre-amble and set the clock divider value.  <a href="#ga059dc3a4f3c0a0e449f618f9b9dbb939">More...</a><br /></td></tr>
<tr class="separator:ga059dc3a4f3c0a0e449f618f9b9dbb939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd83a6819b915a0d9e8b515ed7f3dfa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6bd83a6819b915a0d9e8b515ed7f3dfa">CSL_MDIO_getVersionInfo</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, <a class="el" href="struct_c_s_l___m_d_i_o___v_e_r_s_i_o_n.html">CSL_MDIO_VERSION</a> *mdioVersionInfo)</td></tr>
<tr class="separator:ga6bd83a6819b915a0d9e8b515ed7f3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20a626416ca7125be1545a95cd66709"><td class="memItemLeft" align="right" valign="top">static Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab20a626416ca7125be1545a95cd66709">CSL_MDIO_getClkDivVal</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gab20a626416ca7125be1545a95cd66709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc18b198608a78476332ab9c4085c28"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaedc18b198608a78476332ab9c4085c28">CSL_MDIO_setClkDivVal</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint16 clkDivVal)</td></tr>
<tr class="separator:gaedc18b198608a78476332ab9c4085c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c70618fd2cb21f7d8879fbe2b65f168"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6c70618fd2cb21f7d8879fbe2b65f168">CSL_MDIO_isFaultDetectEnabled</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga6c70618fd2cb21f7d8879fbe2b65f168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc2b39a72e45c0286d1fe4e09f5a9cc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gadc2b39a72e45c0286d1fe4e09f5a9cc1">CSL_MDIO_enableFaultDetect</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gadc2b39a72e45c0286d1fe4e09f5a9cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba9f1eb2720ebed87f45eed0bb67b84"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2ba9f1eb2720ebed87f45eed0bb67b84">CSL_MDIO_disableFaultDetect</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga2ba9f1eb2720ebed87f45eed0bb67b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42fb295f8cfdc1578d68bbbb03a5013"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab42fb295f8cfdc1578d68bbbb03a5013">CSL_MDIO_isFaultDetected</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gab42fb295f8cfdc1578d68bbbb03a5013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ad2f6d10b7232dcdcadb5cddecab4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga37ad2f6d10b7232dcdcadb5cddecab4d">CSL_MDIO_clearFault</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga37ad2f6d10b7232dcdcadb5cddecab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf803c6348c0e8289a1b5720e1b9f442d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf803c6348c0e8289a1b5720e1b9f442d">CSL_MDIO_isPreambleEnabled</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gaf803c6348c0e8289a1b5720e1b9f442d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1011ab5614e23056bbc523206439593e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga1011ab5614e23056bbc523206439593e">CSL_MDIO_enablePreamble</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga1011ab5614e23056bbc523206439593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd81e0475eee9c175b356076ee63ef43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabd81e0475eee9c175b356076ee63ef43">CSL_MDIO_disablePreamble</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gabd81e0475eee9c175b356076ee63ef43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1983a5b2083d4330e3fc5461a0fb6870"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga1983a5b2083d4330e3fc5461a0fb6870">CSL_MDIO_getHighestUserChannel</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga1983a5b2083d4330e3fc5461a0fb6870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58317a6b85eaea74572c9459bbff1f9a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga58317a6b85eaea74572c9459bbff1f9a">CSL_MDIO_isStateMachineEnabled</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga58317a6b85eaea74572c9459bbff1f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23cb0c1c940dfc1cf4bad55ce9aced10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga23cb0c1c940dfc1cf4bad55ce9aced10">CSL_MDIO_enableStateMachine</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga23cb0c1c940dfc1cf4bad55ce9aced10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47dfbbad63c3d47f14e9961cb0534863"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga47dfbbad63c3d47f14e9961cb0534863">CSL_MDIO_disableStateMachine</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga47dfbbad63c3d47f14e9961cb0534863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0363acaa7928d8cb73444a3f2bf4abd7"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga0363acaa7928d8cb73444a3f2bf4abd7">CSL_MDIO_isStateMachineIdle</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga0363acaa7928d8cb73444a3f2bf4abd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd000c0d87221419b0bab63ee4d18e0"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gacdd000c0d87221419b0bab63ee4d18e0">CSL_MDIO_isPhyAlive</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 phyAddr)</td></tr>
<tr class="separator:gacdd000c0d87221419b0bab63ee4d18e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b73610734f967973f49b16d3efe97e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga4b73610734f967973f49b16d3efe97e5">CSL_MDIO_clearPhyAliveStatus</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 phyAddr)</td></tr>
<tr class="separator:ga4b73610734f967973f49b16d3efe97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfece98ef6d3e7f9ea901c035b5a7c67"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabfece98ef6d3e7f9ea901c035b5a7c67">CSL_MDIO_isPhyLinked</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 phyAddr)</td></tr>
<tr class="separator:gabfece98ef6d3e7f9ea901c035b5a7c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga412732070fb23c65a3a0a87321af5f54"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga412732070fb23c65a3a0a87321af5f54">CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga412732070fb23c65a3a0a87321af5f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a9286ead1935ab1dff20ec37132421"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga11a9286ead1935ab1dff20ec37132421">CSL_MDIO_clearUnmaskedLinkStatusChangeInt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga11a9286ead1935ab1dff20ec37132421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6475c337eadb38721cb629f5362973fe"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6475c337eadb38721cb629f5362973fe">CSL_MDIO_isMaskedLinkStatusChangeIntSet</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga6475c337eadb38721cb629f5362973fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3f2575524d044cae67eeec5d6b1b18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaae3f2575524d044cae67eeec5d6b1b18">CSL_MDIO_clearMaskedLinkStatusChangeInt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:gaae3f2575524d044cae67eeec5d6b1b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8c9f47aa7f29912680c3df795d9446"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaff8c9f47aa7f29912680c3df795d9446">CSL_MDIO_isUnmaskedUserCmdCompleteIntSet</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:gaff8c9f47aa7f29912680c3df795d9446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf65b1788320f5608231e46d39f294cdc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf65b1788320f5608231e46d39f294cdc">CSL_MDIO_clearUnmaskedUserCmdCompleteInt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:gaf65b1788320f5608231e46d39f294cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b8cfa629b2d47de0ee6289474aa355"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga54b8cfa629b2d47de0ee6289474aa355">CSL_MDIO_isMaskedUserCmdCompleteIntSet</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga54b8cfa629b2d47de0ee6289474aa355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad680d0316a7b0c9df3690f14af6830cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gad680d0316a7b0c9df3690f14af6830cc">CSL_MDIO_clearMaskedUserCmdCompleteInt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:gad680d0316a7b0c9df3690f14af6830cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f571baecba3850c3ba3111dc1de6ee7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga5f571baecba3850c3ba3111dc1de6ee7">CSL_MDIO_enableUserCmdCompleteInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga5f571baecba3850c3ba3111dc1de6ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171bb85b0b8005202dbe2ef18b0af37e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga171bb85b0b8005202dbe2ef18b0af37e">CSL_MDIO_disableUserCmdCompleteInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga171bb85b0b8005202dbe2ef18b0af37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf084a65c1ee267f8c680d2a98e3c9046"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf084a65c1ee267f8c680d2a98e3c9046">CSL_MDIO_getUserAccessRegister</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *pUserAccessReg)</td></tr>
<tr class="separator:gaf084a65c1ee267f8c680d2a98e3c9046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73b16285da69873db11505a9132f52f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaa73b16285da69873db11505a9132f52f">CSL_MDIO_setUserAccessRegister</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, const <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *pUserAccessReg)</td></tr>
<tr class="separator:gaa73b16285da69873db11505a9132f52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb317435b4b51e1c5cec7ae9f4ea250"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga0eb317435b4b51e1c5cec7ae9f4ea250">CSL_MDIO_isUserAccessPending</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga0eb317435b4b51e1c5cec7ae9f4ea250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0883e77c05a0dad059571fde36dac4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga5f0883e77c05a0dad059571fde36dac4">CSL_MDIO_enableLinkStatusChangeInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, Uint32 phyAddr)</td></tr>
<tr class="memdesc:ga5f0883e77c05a0dad059571fde36dac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable MDIO link interrupt (MDIO_LINKINT) for PHY monitoring.  <a href="#ga5f0883e77c05a0dad059571fde36dac4">More...</a><br /></td></tr>
<tr class="separator:ga5f0883e77c05a0dad059571fde36dac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cafde38fabebc620ff05969b484534b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2cafde38fabebc620ff05969b484534b">CSL_MDIO_disableLinkStatusChangeInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, Uint32 phyAddr)</td></tr>
<tr class="memdesc:ga2cafde38fabebc620ff05969b484534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable MDIO link interrupt (MDIO_LINKINT) for PHY monitoring.  <a href="#ga2cafde38fabebc620ff05969b484534b">More...</a><br /></td></tr>
<tr class="separator:ga2cafde38fabebc620ff05969b484534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1f60dd31bd0b9488df7ca67e261c6b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga0d1f60dd31bd0b9488df7ca67e261c6b">CSL_MDIO_getUserPhySelect</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_p_h_y_s_e_l.html">CSL_MDIO_USERPHYSEL</a> *pUserPhySelect)</td></tr>
<tr class="separator:ga0d1f60dd31bd0b9488df7ca67e261c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9079889b8bc513aab00a66c551cc8c26"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga9079889b8bc513aab00a66c551cc8c26">CSL_MDIO_phyRegRead2</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t userGroup, uint32_t phyAddr, uint32_t regNum, uint16_t *pData)</td></tr>
<tr class="separator:ga9079889b8bc513aab00a66c551cc8c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90aaed02fb3caa46c56f1590bb8009da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga90aaed02fb3caa46c56f1590bb8009da">CSL_MDIO_phyRegWrite2</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t userGroup, uint32_t phyAddr, uint32_t regNum, uint16_t wrVal)</td></tr>
<tr class="memdesc:ga90aaed02fb3caa46c56f1590bb8009da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API writes a PHY register using MDIO.  <a href="#ga90aaed02fb3caa46c56f1590bb8009da">More...</a><br /></td></tr>
<tr class="separator:ga90aaed02fb3caa46c56f1590bb8009da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf667231888364d60c4d97c3913d4e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaaf667231888364d60c4d97c3913d4e04">CSL_MDIO_setClause45EnableMask</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t clause45EnableMask)</td></tr>
<tr class="memdesc:gaaf667231888364d60c4d97c3913d4e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Clause-45 enable mask. Each bit in the mask is associated with a PHY address, i.e. bit 0 is associated with PHY address 0, etc.  <a href="#gaaf667231888364d60c4d97c3913d4e04">More...</a><br /></td></tr>
<tr class="separator:gaaf667231888364d60c4d97c3913d4e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf931221498bed6b390f1394211bb2eb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaaf931221498bed6b390f1394211bb2eb">CSL_MDIO_getClause45EnableMask</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:gaaf931221498bed6b390f1394211bb2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Clause-45 enable mask. Each bit in the mask is associated with a PHY address, i.e. bit 0 is associated with PHY address 0, etc.  <a href="#gaaf931221498bed6b390f1394211bb2eb">More...</a><br /></td></tr>
<tr class="separator:gaaf931221498bed6b390f1394211bb2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d9c4bbf154d07f6d27212535e75360"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga49d9c4bbf154d07f6d27212535e75360">CSL_MDIO_phyInitiateRegWriteC45</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t userGroup, uint32_t phyAddr, uint32_t mmdNum, uint32_t regAddr, uint16_t wrVal)</td></tr>
<tr class="memdesc:ga49d9c4bbf154d07f6d27212535e75360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a non-blocking write transaction with PHY using Clause-45 frame. The user should call <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8" title="Check if there is a transaction going on in MDIO. ">CSL_MDIO_isPhyRegAccessComplete()</a> to query the transaction status.  <a href="#ga49d9c4bbf154d07f6d27212535e75360">More...</a><br /></td></tr>
<tr class="separator:ga49d9c4bbf154d07f6d27212535e75360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8783ba4570513953dee5f9f8367a9065"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga8783ba4570513953dee5f9f8367a9065">CSL_MDIO_phyInitiateRegReadC45</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t userGroup, uint32_t phyAddr, uint32_t mmdNum, uint32_t regAddr)</td></tr>
<tr class="memdesc:ga8783ba4570513953dee5f9f8367a9065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a non-blocking register read transaction with PHY using Clause-45 frame. The user should call <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8" title="Check if there is a transaction going on in MDIO. ">CSL_MDIO_isPhyRegAccessComplete()</a> to query the transaction status, and once it's complete, get the value read from register via <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab7b2352cbc9375c63971a491bd181ba2" title="Get the value read from a PHY register from a transaction previously initiated through either CSL_MDI...">CSL_MDIO_phyGetRegReadVal()</a>.  <a href="#ga8783ba4570513953dee5f9f8367a9065">More...</a><br /></td></tr>
<tr class="separator:ga8783ba4570513953dee5f9f8367a9065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66ceb0407ad7be434715d9c8b711b07"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf66ceb0407ad7be434715d9c8b711b07">CSL_MDIO_phyRegInitiateWriteC22</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t userGroup, uint32_t phyAddr, uint32_t regAddr, uint16_t wrVal)</td></tr>
<tr class="memdesc:gaf66ceb0407ad7be434715d9c8b711b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a non-blocking write transaction with PHY using Clause-22 frame. The user should call <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8" title="Check if there is a transaction going on in MDIO. ">CSL_MDIO_isPhyRegAccessComplete()</a> to query the transaction status.  <a href="#gaf66ceb0407ad7be434715d9c8b711b07">More...</a><br /></td></tr>
<tr class="separator:gaf66ceb0407ad7be434715d9c8b711b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9639d663626d1916734b12efc04323"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabd9639d663626d1916734b12efc04323">CSL_MDIO_phyInitiateRegReadC22</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t userGroup, uint32_t phyAddr, uint32_t regAddr)</td></tr>
<tr class="memdesc:gabd9639d663626d1916734b12efc04323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a non-blocking register read transaction with PHY using Clause-22 frame. The user should call <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8" title="Check if there is a transaction going on in MDIO. ">CSL_MDIO_isPhyRegAccessComplete()</a> to query the transaction status, and once it's complete, get the value read from register via <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab7b2352cbc9375c63971a491bd181ba2" title="Get the value read from a PHY register from a transaction previously initiated through either CSL_MDI...">CSL_MDIO_phyGetRegReadVal()</a>.  <a href="#gabd9639d663626d1916734b12efc04323">More...</a><br /></td></tr>
<tr class="separator:gabd9639d663626d1916734b12efc04323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b2352cbc9375c63971a491bd181ba2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab7b2352cbc9375c63971a491bd181ba2">CSL_MDIO_phyGetRegReadVal</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t userGroup, uint16_t *pData)</td></tr>
<tr class="memdesc:gab7b2352cbc9375c63971a491bd181ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value read from a PHY register from a transaction previously initiated through either <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabd9639d663626d1916734b12efc04323" title="Initiate a non-blocking register read transaction with PHY using Clause-22 frame. The user should cal...">CSL_MDIO_phyInitiateRegReadC22()</a> or <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga8783ba4570513953dee5f9f8367a9065" title="Initiate a non-blocking register read transaction with PHY using Clause-45 frame. The user should cal...">CSL_MDIO_phyInitiateRegReadC45()</a>.  <a href="#gab7b2352cbc9375c63971a491bd181ba2">More...</a><br /></td></tr>
<tr class="separator:gab7b2352cbc9375c63971a491bd181ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa427dd778015709014a8b79b8a22c8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8">CSL_MDIO_isPhyRegAccessComplete</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t userGroup)</td></tr>
<tr class="memdesc:ga6aa427dd778015709014a8b79b8a22c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is a transaction going on in MDIO.  <a href="#ga6aa427dd778015709014a8b79b8a22c8">More...</a><br /></td></tr>
<tr class="separator:ga6aa427dd778015709014a8b79b8a22c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92273fa53c2c99c4e8b05053d01249a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gad92273fa53c2c99c4e8b05053d01249a">CSL_MDIO_phyLinkStatus2</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t phyAddr)</td></tr>
<tr class="memdesc:gad92273fa53c2c99c4e8b05053d01249a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the link status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY link is active.  <a href="#gad92273fa53c2c99c4e8b05053d01249a">More...</a><br /></td></tr>
<tr class="separator:gad92273fa53c2c99c4e8b05053d01249a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d5c96d55481b37f4d960d1ff017400"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga57d5c96d55481b37f4d960d1ff017400">CSL_MDIO_isStatusChangeModeInterruptEnabled</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:ga57d5c96d55481b37f4d960d1ff017400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the MDIO link interrupt (MDIO_LINKINT) is enabled.  <a href="#ga57d5c96d55481b37f4d960d1ff017400">More...</a><br /></td></tr>
<tr class="separator:ga57d5c96d55481b37f4d960d1ff017400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f7288c3d95e5be7a82fdf16c52d302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf3f7288c3d95e5be7a82fdf16c52d302">CSL_MDIO_enableStatusChangeModeInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:gaf3f7288c3d95e5be7a82fdf16c52d302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable MDIO link interrupt (MDIO_LINKINT)  <a href="#gaf3f7288c3d95e5be7a82fdf16c52d302">More...</a><br /></td></tr>
<tr class="separator:gaf3f7288c3d95e5be7a82fdf16c52d302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3553b428bb118cfb6ecb49c098ef2a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gac3553b428bb118cfb6ecb49c098ef2a3">CSL_MDIO_disableStatusChangeModeInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:gac3553b428bb118cfb6ecb49c098ef2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable MDIO link interrupt (MDIO_LINKINT)  <a href="#gac3553b428bb118cfb6ecb49c098ef2a3">More...</a><br /></td></tr>
<tr class="separator:gac3553b428bb118cfb6ecb49c098ef2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbbc6e0d6060ba077a703ba6a2c08894"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabbbc6e0d6060ba077a703ba6a2c08894">CSL_MDIO_getLinkStatusChangePhyAddr</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="memdesc:gabbbc6e0d6060ba077a703ba6a2c08894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PHY address being monitored.  <a href="#gabbbc6e0d6060ba077a703ba6a2c08894">More...</a><br /></td></tr>
<tr class="separator:gabbbc6e0d6060ba077a703ba6a2c08894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d82c792e906564b26d0e25f673a3a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga92d82c792e906564b26d0e25f673a3a4">CSL_MDIO_isStateChangeModeEnabled</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:ga92d82c792e906564b26d0e25f673a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the State Change Mode is enabled or not.  <a href="#ga92d82c792e906564b26d0e25f673a3a4">More...</a><br /></td></tr>
<tr class="separator:ga92d82c792e906564b26d0e25f673a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd7d0abfeff52b9fca843ca54ed7c5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gadd7d0abfeff52b9fca843ca54ed7c5ff">CSL_MDIO_enableStateChangeMode</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:gadd7d0abfeff52b9fca843ca54ed7c5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the MDIO State Change Mode.  <a href="#gadd7d0abfeff52b9fca843ca54ed7c5ff">More...</a><br /></td></tr>
<tr class="separator:gadd7d0abfeff52b9fca843ca54ed7c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6af5325d5fb0a2b71cbc6f0cc7d828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga4a6af5325d5fb0a2b71cbc6f0cc7d828">CSL_MDIO_disableStateChangeMode</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:ga4a6af5325d5fb0a2b71cbc6f0cc7d828"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the MDIO State Change Mode.  <a href="#ga4a6af5325d5fb0a2b71cbc6f0cc7d828">More...</a><br /></td></tr>
<tr class="separator:ga4a6af5325d5fb0a2b71cbc6f0cc7d828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa45a456225dbf89081d095c7241c23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga5fa45a456225dbf89081d095c7241c23">CSL_MDIO_setPollIPG</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint8_t ipgVal)</td></tr>
<tr class="memdesc:ga5fa45a456225dbf89081d095c7241c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Polling Inter Packet Gap value.  <a href="#ga5fa45a456225dbf89081d095c7241c23">More...</a><br /></td></tr>
<tr class="separator:ga5fa45a456225dbf89081d095c7241c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0349016a3193ee30c5f495616ce2f879"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga0349016a3193ee30c5f495616ce2f879">CSL_MDIO_getPollIPG</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:ga0349016a3193ee30c5f495616ce2f879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Polling Inter Packet Gap value.  <a href="#ga0349016a3193ee30c5f495616ce2f879">More...</a><br /></td></tr>
<tr class="separator:ga0349016a3193ee30c5f495616ce2f879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98579df1ee53f76fb2237e521ad69734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga98579df1ee53f76fb2237e521ad69734">CSL_MDIO_setPollEnableMask</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, uint32_t pollEnableMask)</td></tr>
<tr class="memdesc:ga98579df1ee53f76fb2237e521ad69734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set poll enable mask.  <a href="#ga98579df1ee53f76fb2237e521ad69734">More...</a><br /></td></tr>
<tr class="separator:ga98579df1ee53f76fb2237e521ad69734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c01d0ccb28183d6162876e0494cc3a5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga0c01d0ccb28183d6162876e0494cc3a5">CSL_MDIO_getPollEnableMask</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="memdesc:ga0c01d0ccb28183d6162876e0494cc3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get poll enable mask.  <a href="#ga0c01d0ccb28183d6162876e0494cc3a5">More...</a><br /></td></tr>
<tr class="separator:ga0c01d0ccb28183d6162876e0494cc3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaba0be476a73b57e2c6ff6d3a082f3752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearFault </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearFault</b> </p>
<p><b>Description</b> <br />
 This function clears the 'FAULT' bit of the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the 'FAULT' bit of MDIO 'CONTROL_REG'.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT=1</p>
<p><b>Affects</b> <br />
 MDIO_CONTROL_REG_FAULT=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Clear MDIO fault bit
       CSL_MDIO_clearFault ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga37ad2f6d10b7232dcdcadb5cddecab4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearFault </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearFault</b> </p>
<p><b>Description</b> <br />
 This function clears the 'FAULT' bit of the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the 'FAULT' bit of MDIO 'CONTROL_REG'.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT=1</p>
<p><b>Affects</b> <br />
 MDIO_CONTROL_REG_FAULT=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Clear MDIO fault bit
       CSL_MDIO_clearFault ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga435e5615f18a341469b06c50582c928c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearMaskedLinkStatusChangeInt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearMaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTMASKED' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearMaskedLinkStatusChangeInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaae3f2575524d044cae67eeec5d6b1b18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearMaskedLinkStatusChangeInt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearMaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTMASKED' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearMaskedLinkStatusChangeInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa214d2214209a16d875304176948b9e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearMaskedUserCmdCompleteInt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearMaskedUserCmdCompleteInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function clears the 'USERINTMASKED' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be cleared. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the User command complete interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearMaskedUserCmdCompleteInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad680d0316a7b0c9df3690f14af6830cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearMaskedUserCmdCompleteInt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearMaskedUserCmdCompleteInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function clears the 'USERINTMASKED' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be cleared. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the User command complete interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearMaskedUserCmdCompleteInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga90419ccafe7119ac63833d240e748ded"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearPhyAliveStatus </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearPhyAliveStatus</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function clears the 'ALIVE' bit corresponding to that PHY.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be cleared.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the ALIVE bit for the PHY address specified</p>
<p><b>Writes</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Clear PHY 0 alive status bit
       CSL_MDIO_clearPhyAliveStatus (phyAddr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4b73610734f967973f49b16d3efe97e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearPhyAliveStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearPhyAliveStatus</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function clears the 'ALIVE' bit corresponding to that PHY.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be cleared.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the ALIVE bit for the PHY address specified</p>
<p><b>Writes</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Clear PHY 0 alive status bit
       CSL_MDIO_clearPhyAliveStatus (phyAddr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga301389b248d69524480aa4d0dd76cb9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearUnmaskedLinkStatusChangeInt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearUnmaskedLinkStatusChangeInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga11a9286ead1935ab1dff20ec37132421"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearUnmaskedLinkStatusChangeInt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearUnmaskedLinkStatusChangeInt (index);</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      uint32_t      index = 0;

       CSL_MDIO_clearUnmaskedLinkStatusChangeInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8368908148e23780da4108de5860a338"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearUnmaskedUserCmdCompleteInt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedUserCmdCompleteInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function clears the 'USERINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the unmasked user
*                          command complete interrupt bit must be cleared. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the User command complete interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearUnmaskedUserCmdCompleteInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf65b1788320f5608231e46d39f294cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearUnmaskedUserCmdCompleteInt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedUserCmdCompleteInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function clears the 'USERINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the unmasked user
*                          command complete interrupt bit must be cleared. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the User command complete interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearUnmaskedUserCmdCompleteInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2f5e939587cdc5fd3fbc5e45c90d8497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableFaultDetect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableFaultDetect</b> </p>
<p><b>Description</b> <br />
 This function disables the Physical layer fault detection mechanism by setting 'FAULTENB' bit of the MDIO Control register to 0.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables PHY layer fault detection.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable Phy Layer fault detection
       CSL_MDIO_disableFaultDetect ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2ba9f1eb2720ebed87f45eed0bb67b84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableFaultDetect </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableFaultDetect</b> </p>
<p><b>Description</b> <br />
 This function disables the Physical layer fault detection mechanism by setting 'FAULTENB' bit of the MDIO Control register to 0.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables PHY layer fault detection.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable Phy Layer fault detection
       CSL_MDIO_disableFaultDetect ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5503f6478f0c27dae771dae37ca5085e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableLinkStatusChangeInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableLinkStatusChangeInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the 'LINKINTENB' bit to 0 for a PHY address 'phyAddr' being monitored by the MDIO module. This configuration is done for the 'USERPHYSEL' register corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      phyAddr             PHY Address for which the Link Status change interrupt
*                          must be disabled.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for the index specified.Link Status Change interrupt disabled for PHY address specified.</p>
<p><b>Writes</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable PHY 0's interrupt
       CSL_MDIO_disableLinkStatusChangeInterrupt (0, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2cafde38fabebc620ff05969b484534b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableLinkStatusChangeInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable MDIO link interrupt (MDIO_LINKINT) for PHY monitoring. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_disableLinkStatusChangeInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the 'LINKINTENB' bit to 0 for a PHY address 'phyAddr' being monitored by the MDIO module. This configuration is done for the 'USERPHYSEL' register corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      phyAddr             PHY Address for which the Link Status change interrupt
*                          must be disabled.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for the index specified.Link Status Change interrupt disabled for PHY address specified.</p>
<p><b>Writes</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable PHY 0's interrupt
       CSL_MDIO_disableLinkStatusChangeInterrupt (0, 0);</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_disableLinkStatusChangeInterrupt</b> </p>
<p>This function disables the MDIO link interrupt (MDIO_LINKINT). This function is applicable only when MDIO is operating in Normal Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">index</td><td>User group index (0 or 1) </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY address <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf9be255ed97beccd423e88743828864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disablePreamble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disablePreamble</b> </p>
<p><b>Description</b> <br />
 This function disables the MDIO preamble.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables MDIO Preamble frames.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_PREAMBLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable MDIO preamble frames
       CSL_MDIO_disablePreamble ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabd81e0475eee9c175b356076ee63ef43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disablePreamble </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disablePreamble</b> </p>
<p><b>Description</b> <br />
 This function disables the MDIO preamble.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables MDIO Preamble frames.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_PREAMBLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable MDIO preamble frames
       CSL_MDIO_disablePreamble ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4a6af5325d5fb0a2b71cbc6f0cc7d828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_MDIO_disableStateChangeMode </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the MDIO State Change Mode. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_disableStateChangeMode</b> </p>
<p>This function disabled the State Change Mode, effectively enabling Normal Mode which can be used to monitor only two PHYs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2180daf47153154f3274344973e3c553"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableStateMachine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableStateMachine</b> </p>
<p><b>Description</b> <br />
 This function sets the 'ENABLE' bit of the MDIO control register to 0, triggering the disable of MDIO state machine if active.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 If the MDIO state machine is active at the time it is disabled, will complete the current operation before halting it and setting the idle bit.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable MDIO state machine
       CSL_MDIO_disableStateMachine ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga47dfbbad63c3d47f14e9961cb0534863"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableStateMachine </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableStateMachine</b> </p>
<p><b>Description</b> <br />
 This function sets the 'ENABLE' bit of the MDIO control register to 0, triggering the disable of MDIO state machine if active.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 If the MDIO state machine is active at the time it is disabled, will complete the current operation before halting it and setting the idle bit.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable MDIO state machine
       CSL_MDIO_disableStateMachine ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac3553b428bb118cfb6ecb49c098ef2a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_MDIO_disableStatusChangeModeInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable MDIO link interrupt (MDIO_LINKINT) </p>
<p>============================================================================ <br />
<b>CSL_MDIO_disableLinkStatusChangeInterrupt</b> </p>
<p>This function disables the MDIO link interrupt (MDIO_LINKINT). This function is applicable only when MDIO is operating in State Change Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga857d949e50c3739fef0b59c1840f0863"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableUserCmdCompleteInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableUserCmdCompleteInterrupt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function disables the user command complete interrupts for it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be enabled. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables the interrupt for User command complete events posted using USERACCESS register.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASK_CLEAR_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_disableUserCmdCompleteInterrupt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga171bb85b0b8005202dbe2ef18b0af37e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableUserCmdCompleteInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableUserCmdCompleteInterrupt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function disables the user command complete interrupts for it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be enabled. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables the interrupt for User command complete events posted using USERACCESS register.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASK_CLEAR_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_disableUserCmdCompleteInterrupt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1a031867aebcf35b370abcd2bce357b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableFaultDetect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableFaultDetect</b> </p>
<p><b>Description</b> <br />
 This function enables the Physical layer fault detection mechanism by setting 'FAULTENB' bit of the MDIO Control register to 1.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables PHY layer fault detection.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable Phy Layer fault detection
       CSL_MDIO_enableFaultDetect ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadc2b39a72e45c0286d1fe4e09f5a9cc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableFaultDetect </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableFaultDetect</b> </p>
<p><b>Description</b> <br />
 This function enables the Physical layer fault detection mechanism by setting 'FAULTENB' bit of the MDIO Control register to 1.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables PHY layer fault detection.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable Phy Layer fault detection
       CSL_MDIO_enableFaultDetect ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga95c8c9a443f8ee69f13e61e267fa7633"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableLinkStatusChangeInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableLinkStatusChangeInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the 'LINKINTENB' bit to 1 for a PHY address 'phyAddr' being monitored by the MDIO module. This configuration is done for the 'USERPHYSEL' register corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      phyAddr             PHY Address for which the Link Status change interrupt
*                          must be enabled.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for the index specified. Link Status Change interrupt enabled for PHY address specified.</p>
<p><b>Writes</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable PHY 0's interrupt
       CSL_MDIO_enableLinkStatusChangeInterrupt (0, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5f0883e77c05a0dad059571fde36dac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableLinkStatusChangeInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable MDIO link interrupt (MDIO_LINKINT) for PHY monitoring. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_enableLinkStatusChangeInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the 'LINKINTENB' bit to 1 for a PHY address 'phyAddr' being monitored by the MDIO module. This configuration is done for the 'USERPHYSEL' register corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      phyAddr             PHY Address for which the Link Status change interrupt
*                          must be enabled.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for the index specified. Link Status Change interrupt enabled for PHY address specified.</p>
<p><b>Writes</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable PHY 0's interrupt
       CSL_MDIO_enableLinkStatusChangeInterrupt (0, 0);</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_enableLinkStatusChangeInterrupt</b> </p>
<p>This function enables the MDIO link interrupt (MDIO_LINKINT). This function is applicable only when MDIO is operating in Normal Mode.</p>
<p>In Normal Mode, MDIO_LINKINT[0] event is set upon link change on the first PHY being monitored. MDIO_LINKINT[1] event is set upon link change on the second PHY being monitored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">index</td><td>User group index (0 or 1) </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY address <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga097444696f4fb33d45e9b99df49cf338"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enablePreamble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enablePreamble</b> </p>
<p><b>Description</b> <br />
 This function enables the MDIO preamble.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables MDIO Preamble frames.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_PREAMBLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable MDIO preamble frames
       CSL_MDIO_enablePreamble ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1011ab5614e23056bbc523206439593e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enablePreamble </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enablePreamble</b> </p>
<p><b>Description</b> <br />
 This function enables the MDIO preamble.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables MDIO Preamble frames.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_PREAMBLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable MDIO preamble frames
       CSL_MDIO_enablePreamble ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadd7d0abfeff52b9fca843ca54ed7c5ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_MDIO_enableStateChangeMode </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the MDIO State Change Mode. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_enableStateChangeMode</b> </p>
<p>This function enables the State Change Mode which is used to detect change events on any PHY: MDIO_LINKINT[0] when any bit in MDIOAlive or MDIOLink registers is set MDIO_LINKINT[1] is not used MDIO_UserPhySel0/1 registers are not used</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabbd659c7512d86a249876f8a4977189b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableStateMachine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableStateMachine</b> </p>
<p><b>Description</b> <br />
 This function enables the MDIO state machine if not already active.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables MDIO State machine.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable MDIO state machine
       CSL_MDIO_enableStateMachine ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga23cb0c1c940dfc1cf4bad55ce9aced10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableStateMachine </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableStateMachine</b> </p>
<p><b>Description</b> <br />
 This function enables the MDIO state machine if not already active.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables MDIO State machine.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable MDIO state machine
       CSL_MDIO_enableStateMachine ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf3f7288c3d95e5be7a82fdf16c52d302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_MDIO_enableStatusChangeModeInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable MDIO link interrupt (MDIO_LINKINT) </p>
<p>============================================================================ <br />
<b>CSL_MDIO_enableStatusChangeModeInterrupt</b> </p>
<p>This function enables the MDIO link interrupt (MDIO_LINKINT). This function is applicable only when MDIO is operating in State Change Mode.</p>
<p>In State Change Mode, MDIO_LINKINT[0] is set when any bit in the ALIVE or LINK registers is set. MDIO_LINKINT[1] is not used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga988cdb81e87c0fabaabf837f2ea994d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableUserCmdCompleteInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableUserCmdCompleteInterrupt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function enables the user command complete interrupts for it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be enabled. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables the interrupt for User command complete events posted using USERACCESS register.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASK_SET_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_enableUserCmdCompleteInterrupt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5f571baecba3850c3ba3111dc1de6ee7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableUserCmdCompleteInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableUserCmdCompleteInterrupt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function enables the user command complete interrupts for it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be enabled. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables the interrupt for User command complete events posted using USERACCESS register.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASK_SET_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_enableUserCmdCompleteInterrupt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaf931221498bed6b390f1394211bb2eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_MDIO_getClause45EnableMask </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Clause-45 enable mask. Each bit in the mask is associated with a PHY address, i.e. bit 0 is associated with PHY address 0, etc. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_getClause45EnableMask</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clause-45 enable mask <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gad9bfcf528850710276444ffa0d8aa097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint16 CSL_MDIO_getClkDivVal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function retrieves the clock divider value (CLKDIV) from the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint16      clkDivVal;

       clkDivVal   =   CSL_MDIO_getClkDivVal ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab20a626416ca7125be1545a95cd66709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint16 CSL_MDIO_getClkDivVal </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function retrieves the clock divider value (CLKDIV) from the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint16      clkDivVal;

       clkDivVal   =   CSL_MDIO_getClkDivVal ();</pre><hr/>
<p>================================================================================================= <br />
<b>CSL_MDIO_getClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function retrieves the clock divider value (CLKDIV) from the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> uint32_t</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment"> *      uint16_t      clkDivVal;

        clkDivVal   =   CSL_MDIO_getClkDivVal ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6faf36fb963a6035e02494d14f1087b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_getHighestUserChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getHighestUserChannel</b> </p>
<p><b>Description</b> <br />
 This function returns the highest user access channel available in MDIO module.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_HIGHEST_USER_CHANNEL</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  userAccChannel;

       // Get the highest user access channel.
       userAccChannel = CSL_MDIO_getHighestUserChannel ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1983a5b2083d4330e3fc5461a0fb6870"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_getHighestUserChannel </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getHighestUserChannel</b> </p>
<p><b>Description</b> <br />
 This function returns the highest user access channel available in MDIO module.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_HIGHEST_USER_CHANNEL</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  userAccChannel;

       // Get the highest user access channel.
       userAccChannel = CSL_MDIO_getHighestUserChannel ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabbbc6e0d6060ba077a703ba6a2c08894"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_MDIO_getLinkStatusChangePhyAddr </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PHY address being monitored. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_getLinkStatusChangePhyAddr</b> </p>
<p>This function gets the address of the PHY whose state change is being monitored. This function is applicable only when MDIO is operating in Normal Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">index</td><td>User group index (0 or 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PHY address <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c01d0ccb28183d6162876e0494cc3a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_MDIO_getPollEnableMask </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get poll enable mask. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_getPollEnableMask</b> </p>
<p>This function gets the poll enable mask. When set, each bit of the mask indicates that the associated PHY will be included in the polling operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Poll enable mask <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0349016a3193ee30c5f495616ce2f879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CSL_MDIO_getPollIPG </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Polling Inter Packet Gap value. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_getPollIPG</b> </p>
<p>This function gets the polling Inter Packet Gap (IPG) value which is the number of MDCLK_O clocks between each poll when polling is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IPG value (in MDCLK_O clock pulses) <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga32c6a833abfd5070b365d1cb6211589a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getUserAccessRegister </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *&#160;</td>
          <td class="paramname"><em>pUserAccessReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getUserAccessRegister</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the USERACCESS register corresponding to the 'index' (0-1) provided.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register contents
*                          must be read by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserAccessReg      CSL_MDIO_USERACCESS structure that needs to be
*                          populated with the User Access register contents.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_DATA, MDIO_USER_ACCESS_REG_PHYADR, MDIO_USER_ACCESS_REG_REGADR, MDIO_USER_ACCESS_REG_ACK, MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       // Get User Access Reg 0 contents
       CSL_MDIO_getUserAccessRegister (0, &amp;userAccReg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf084a65c1ee267f8c680d2a98e3c9046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getUserAccessRegister </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *&#160;</td>
          <td class="paramname"><em>pUserAccessReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getUserAccessRegister</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the USERACCESS register corresponding to the 'index' (0-1) provided.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register contents
*                          must be read by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserAccessReg      CSL_MDIO_USERACCESS structure that needs to be
*                          populated with the User Access register contents.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_DATA, MDIO_USER_ACCESS_REG_PHYADR, MDIO_USER_ACCESS_REG_REGADR, MDIO_USER_ACCESS_REG_ACK, MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       // Get User Access Reg 0 contents
       CSL_MDIO_getUserAccessRegister (0, &amp;userAccReg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab3bb26f450207da97de969750e3c1e4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getUserPhySelect </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_p_h_y_s_e_l.html">CSL_MDIO_USERPHYSEL</a> *&#160;</td>
          <td class="paramname"><em>pUserPhySelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getUserPhySelect</b> </p>
<p><b>Description</b> <br />
 This function reads the 'USERPHYSEL' register contents corresponding to the index specified here and returns its contents in the output param 'pUserPhySelect'.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserPhySelect      CSL_MDIO_USERPHYSEL structure that needs to be populated
*                          with register contents
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None.</p>
<p><b>Reads</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE, MDIO_USER_PHY_SEL_REG_LINKSEL</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERPHYSEL    userPhySelect;

       // Get USERPHYSEL0 contents
       CSL_MDIO_getUserPhySelect (0, &amp;userPhySelect);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0d1f60dd31bd0b9488df7ca67e261c6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getUserPhySelect </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_p_h_y_s_e_l.html">CSL_MDIO_USERPHYSEL</a> *&#160;</td>
          <td class="paramname"><em>pUserPhySelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getUserPhySelect</b> </p>
<p><b>Description</b> <br />
 This function reads the 'USERPHYSEL' register contents corresponding to the index specified here and returns its contents in the output param 'pUserPhySelect'.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserPhySelect      CSL_MDIO_USERPHYSEL structure that needs to be populated
*                          with register contents
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None.</p>
<p><b>Reads</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE, MDIO_USER_PHY_SEL_REG_LINKSEL</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERPHYSEL    userPhySelect;

       // Get USERPHYSEL0 contents
       CSL_MDIO_getUserPhySelect (0, &amp;userPhySelect);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4557f178ac850e79dea29c48a686e86a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getVersionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___v_e_r_s_i_o_n.html">CSL_MDIO_VERSION</a> *&#160;</td>
          <td class="paramname"><em>mdioVersionInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the MDIO version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mdioVersionInfo     CSL_MDIO_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_VERSION_REG_REVMINOR, MDIO_VERSION_REG_REVMAJ, MDIO_VERSION_REG_MODID</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_MDIO_VERSION    mdioVersionInfo;

       CSL_MDIO_getVersion (&amp;mdioVersionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6bd83a6819b915a0d9e8b515ed7f3dfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getVersionInfo </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___v_e_r_s_i_o_n.html">CSL_MDIO_VERSION</a> *&#160;</td>
          <td class="paramname"><em>mdioVersionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the MDIO version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mdioVersionInfo     CSL_MDIO_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_VERSION_REG_REVMINOR, MDIO_VERSION_REG_REVMAJ, MDIO_VERSION_REG_MODID</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_MDIO_VERSION    mdioVersionInfo;

       CSL_MDIO_getVersion (&amp;mdioVersionInfo);</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_getVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the MDIO version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mdioVersionInfo     CSL_MDIO_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*     </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_VERSION_REG_REVMINOR, MDIO_VERSION_REG_REVMAJ, MDIO_VERSION_REG_MODID</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_MDIO_VERSION    mdioVersionInfo;

       CSL_MDIO_getVersion (&amp;mdioVersionInfo);</pre> <hr/>
 
</div>
</div>
<a class="anchor" id="ga35310b54635ddedbdb1ad817d2ae78fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mdioInputFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mdioOutputFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API initializes the MDIO peripheral. This enables the MDIO state machine, uses standard pre-amble and set the clock divider value. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_init</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">mdioInputFreq</td><td>The clock input to the MDIO module. <h1>mdioOutputFreq The clock output required on the MDIO bus. </h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga32f47898a451debf5ba44d1449b6a016"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isFaultDetected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isFaultDetected</b> </p>
<p><b>Description</b> <br />
 This function returns physical layer fault status, i.e., 1 to indicate that the MDIO module has detected a physical layer fault and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_FAULT</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isFaultDetected ())
     {
         // Physical Layer fault detected
     }
     else
     {
         // No Physical Layer fault detected
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab42fb295f8cfdc1578d68bbbb03a5013"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isFaultDetected </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isFaultDetected</b> </p>
<p><b>Description</b> <br />
 This function returns physical layer fault status, i.e., 1 to indicate that the MDIO module has detected a physical layer fault and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_FAULT</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isFaultDetected ())
     {
         // Physical Layer fault detected
     }
     else
     {
         // No Physical Layer fault detected
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga401a20e685cda37a7f0397970b14170e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isFaultDetectEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isFaultDetectEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Fault detect enable bit of the MDIO control register. The Fault detect enable bit indicates whether physical layer fault detection is enabled.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isFaultDetectEnabled ())
     {
         // MDIO/Physical Layer fault detection is enabled
     }
     else
     {
         // MDIO/Physical Layer fault detection is disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6c70618fd2cb21f7d8879fbe2b65f168"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isFaultDetectEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isFaultDetectEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Fault detect enable bit of the MDIO control register. The Fault detect enable bit indicates whether physical layer fault detection is enabled.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isFaultDetectEnabled ())
     {
         // MDIO/Physical Layer fault detection is enabled
     }
     else
     {
         // MDIO/Physical Layer fault detection is disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab798a906133056478c9488e24f86caba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isMaskedLinkStatusChangeIntSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isMaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTMASKED' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isMaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6475c337eadb38721cb629f5362973fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isMaskedLinkStatusChangeIntSet </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isMaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTMASKED' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isMaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3850d096378dcab15bfc5f11c4bff848"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isMaskedUserCmdCompleteIntSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isMaskedUserCmdCompleteIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function returns the 'USERINTMASKED' register contents corresponding to it. This functions returns a 1 to indicate that the previously scheduled PHY read/write command using that particular USERACCESS register has completed and corresponding USERINTMASKSET bit is set to 1 and returns 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be read. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isMaskedUserCmdCompleteIntSet (index))
       {
           // User command completed
       }
       else
       {
           // User command not done
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga54b8cfa629b2d47de0ee6289474aa355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isMaskedUserCmdCompleteIntSet </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isMaskedUserCmdCompleteIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function returns the 'USERINTMASKED' register contents corresponding to it. This functions returns a 1 to indicate that the previously scheduled PHY read/write command using that particular USERACCESS register has completed and corresponding USERINTMASKSET bit is set to 1 and returns 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be read. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isMaskedUserCmdCompleteIntSet (index))
       {
           // User command completed
       }
       else
       {
           // User command not done
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga29ff9103a8ec1e971aed43dd70c9ba98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPhyAlive </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyAlive</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'ALIVE' bit corresponding to that PHY; The function returns 1 to indicate that the most recent access for the address was acknowledged by the PHY and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Check if PHY Address 0 is alive
       if (CSL_MDIO_isPhyAlive (phyAddr))
       {
           // MDIO PHY 0 access succeeded
       }
       else
       {
           // MDIO PHY 0 access failed
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacdd000c0d87221419b0bab63ee4d18e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPhyAlive </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyAlive</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'ALIVE' bit corresponding to that PHY; The function returns 1 to indicate that the most recent access for the address was acknowledged by the PHY and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Check if PHY Address 0 is alive
       if (CSL_MDIO_isPhyAlive (phyAddr))
       {
           // MDIO PHY 0 access succeeded
       }
       else
       {
           // MDIO PHY 0 access failed
       }</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyAlive</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'ALIVE' bit corresponding to that PHY; The function returns 1 to indicate that the most recent access for the address was acknowledged by the PHY and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> uint32_t</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      uint32_t      phyAddr = 0;

       // Check if PHY Address 0 is alive
       if (CSL_MDIO_isPhyAlive (phyAddr))
       {
           // MDIO PHY 0 access succeeded
       }
       else
       {
           // MDIO PHY 0 access failed
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab48582314d31c05514880bf1a876f19d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPhyLinked </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyLinked</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'LINK' bit corresponding to that PHY; The function returns 1 to indicate that the corresponding PHY address has a link.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the link bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Check if PHY Address 0 link is up
       if (CSL_MDIO_isPhyLinked (phyAddr))
       {
           // MDIO PHY 0 link up
       }
       else
       {
           // MDIO PHY 0 link not up
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabfece98ef6d3e7f9ea901c035b5a7c67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPhyLinked </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyLinked</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'LINK' bit corresponding to that PHY; The function returns 1 to indicate that the corresponding PHY address has a link.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the link bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Check if PHY Address 0 link is up
       if (CSL_MDIO_isPhyLinked (phyAddr))
       {
           // MDIO PHY 0 link up
       }
       else
       {
           // MDIO PHY 0 link not up
       }</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyLinked</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'LINK' bit corresponding to that PHY; The function returns 1 to indicate that the corresponding PHY address has a link.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the link bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> uint32_t</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      uint32_t      phyAddr = 0;

       // Check if PHY Address 0 link is up
       if (CSL_MDIO_isPhyLinked (phyAddr))
       {
           // MDIO PHY 0 link up
       }
       else
       {
           // MDIO PHY 0 link not up
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6aa427dd778015709014a8b79b8a22c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_MDIO_isPhyRegAccessComplete </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is a transaction going on in MDIO. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyRegAccessComplete</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">userGroup</td><td>User group to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Last register access is complete </td></tr>
    <tr><td class="paramname">FALSE</td><td>Last register access is active <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63d8e2fd526b92bee7e083664fb64cad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPreambleEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPreambleEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Preamble disable bit of the MDIO control register. It returns 1 to indicate the MDIO preamble is enabled and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_PREAMBLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isPreambleEnabled ())
     {
         // MDIO preamble enabled
     }
     else
     {
         // MDIO preamble disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf803c6348c0e8289a1b5720e1b9f442d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPreambleEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPreambleEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Preamble disable bit of the MDIO control register. It returns 1 to indicate the MDIO preamble is enabled and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_PREAMBLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isPreambleEnabled ())
     {
         // MDIO preamble enabled
     }
     else
     {
         // MDIO preamble disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga92d82c792e906564b26d0e25f673a3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_MDIO_isStateChangeModeEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the State Change Mode is enabled or not. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_isStateChangeModeEnabled</b> </p>
<p>This function checks if the State Change Mode is enabled as per STATECHANGEMODE bit of the MDIO Poll register. It returns 1 to indicate that State Change Mode is enabled, or 0 to indicate that Normal Mode is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if State Change Mode is enabled 0 if Normal Mode is enabled <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f40d9fce00936f6ca05407b172f4977"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isStateMachineEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Enable bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is enabled and is active and 0 to indicate otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineEnabled ())
     {
         // MDIO state machine enabled
     }
     else
     {
         // MDIO state machine disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga58317a6b85eaea74572c9459bbff1f9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isStateMachineEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Enable bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is enabled and is active and 0 to indicate otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineEnabled ())
     {
         // MDIO state machine enabled
     }
     else
     {
         // MDIO state machine disabled
     }</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Enable bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is enabled and is active and 0 to indicate otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> uint32_t</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineEnabled ())
     {
         // MDIO state machine enabled
     }
     else
     {
         // MDIO state machine disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae2cabb86c9ef1ed5b373debd0518c4ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isStateMachineIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineIdle</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the 'IDLE' bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is in idle state and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineIdle ())
     {
         // MDIO state machine idle
     }
     else
     {
         // MDIO state machine not idle
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0363acaa7928d8cb73444a3f2bf4abd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isStateMachineIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineIdle</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the 'IDLE' bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is in idle state and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineIdle ())
     {
         // MDIO state machine idle
     }
     else
     {
         // MDIO state machine not idle
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga57d5c96d55481b37f4d960d1ff017400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_MDIO_isStatusChangeModeInterruptEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the MDIO link interrupt (MDIO_LINKINT) is enabled. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_isStatusChangeModeInterruptEnabled</b> </p>
<p>This function checks if the MDIO link interrupt (MDIO_LINKINT) is enabled or not. This function is applicable only when MDIO is operating in State Change Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if MDIO link interrupt is enabled 0 if MDIO link interrupt is disabled <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf26e822a6ae7f8b3faa8316d06e83524"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUnmaskedLinkStatusChangeIntSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isUnmaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga412732070fb23c65a3a0a87321af5f54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUnmaskedLinkStatusChangeIntSet </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isUnmaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> uint32_t</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      uint32_t      index = 0;

       if (CSL_MDIO_isUnmaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad90f7f7efb26f324b9b13ce0683f280f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUnmaskedUserCmdCompleteIntSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedUserCmdCompleteIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function returns the 'USERINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the previously scheduled PHY read/write command using that particular USERACCESS register has completed and returns 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the unmasked user
*                          command complete interrupt bit must be read. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isUnmaskedUserCmdCompleteIntSet (index))
       {
           // User command completed
       }
       else
       {
           // User command not done
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaff8c9f47aa7f29912680c3df795d9446"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUnmaskedUserCmdCompleteIntSet </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedUserCmdCompleteIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function returns the 'USERINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the previously scheduled PHY read/write command using that particular USERACCESS register has completed and returns 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the unmasked user
*                          command complete interrupt bit must be read. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isUnmaskedUserCmdCompleteIntSet (index))
       {
           // User command completed
       }
       else
       {
           // User command not done
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4af9a45a5c6ca3cfdd815e5e908992bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUserAccessPending </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUserAccessPending</b> </p>
<p><b>Description</b> <br />
 This function reads the 'GO' bit of the USERACCESS register corresponding to the 'index' specified and returns its value. When 1 returned, indicates that the user access transaction (read/write) performed earlier is still pending and has not yet completed. 0 indicates that the transaction has completed.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register's GO bit
*                          must be read by this function. Valid values are 0-1,
*                          both inclusive.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None.</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       userAccessReg.data      =   1;
       userAccessReg.phyAddr   =   0;
       ...
       userAccessReg.go        =   1;

       // Set User Access Reg 0 contents
       CSL_MDIO_setUserAccessRegister (0, &amp;userAccReg);

       // Wait till the set completes
       while (CSL_MDIO_isUserAccessPending (0));</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0eb317435b4b51e1c5cec7ae9f4ea250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUserAccessPending </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUserAccessPending</b> </p>
<p><b>Description</b> <br />
 This function reads the 'GO' bit of the USERACCESS register corresponding to the 'index' specified and returns its value. When 1 returned, indicates that the user access transaction (read/write) performed earlier is still pending and has not yet completed. 0 indicates that the transaction has completed.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register's GO bit
*                          must be read by this function. Valid values are 0-1,
*                          both inclusive.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None.</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       userAccessReg.data      =   1;
       userAccessReg.phyAddr   =   0;
       ...
       userAccessReg.go        =   1;

       // Set User Access Reg 0 contents
       CSL_MDIO_setUserAccessRegister (0, &amp;userAccReg);

       // Wait till the set completes
       while (CSL_MDIO_isUserAccessPending (0));</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaec7f801c55a4b16c4f6b71d39c36c747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t CSL_MDIO_phyAliveStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API reads the alive status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY is alive. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyAliveStatus</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>PHY is present. <h1>FALSE PHY is not present. </h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab7b2352cbc9375c63971a491bd181ba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_MDIO_phyGetRegReadVal </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value read from a PHY register from a transaction previously initiated through either <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabd9639d663626d1916734b12efc04323" title="Initiate a non-blocking register read transaction with PHY using Clause-22 frame. The user should cal...">CSL_MDIO_phyInitiateRegReadC22()</a> or <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga8783ba4570513953dee5f9f8367a9065" title="Initiate a non-blocking register read transaction with PHY using Clause-45 frame. The user should cal...">CSL_MDIO_phyInitiateRegReadC45()</a>. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyGetRegReadVal</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">userGroup</td><td>User group to use </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer where the read value shall be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>Register read was acknowledged and read value is valid </td></tr>
    <tr><td class="paramname">CSL_ETIMEOUT</td><td>Read transaction was not acknowledged by PHY </td></tr>
    <tr><td class="paramname">CSL_EFAIL</td><td>MDIO is busy with previous transaction <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabd9639d663626d1916734b12efc04323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_MDIO_phyInitiateRegReadC22 </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a non-blocking register read transaction with PHY using Clause-22 frame. The user should call <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8" title="Check if there is a transaction going on in MDIO. ">CSL_MDIO_isPhyRegAccessComplete()</a> to query the transaction status, and once it's complete, get the value read from register via <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab7b2352cbc9375c63971a491bd181ba2" title="Get the value read from a PHY register from a transaction previously initiated through either CSL_MDI...">CSL_MDIO_phyGetRegReadVal()</a>. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyInitiateRegReadC22</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">userGroup</td><td>User group to use </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY address </td></tr>
    <tr><td class="paramname">regAddr</td><td>Register address</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>Register read has been initiated </td></tr>
    <tr><td class="paramname">CSL_EFAIL</td><td>MDIO is busy with previous transaction <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8783ba4570513953dee5f9f8367a9065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_MDIO_phyInitiateRegReadC45 </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mmdNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a non-blocking register read transaction with PHY using Clause-45 frame. The user should call <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8" title="Check if there is a transaction going on in MDIO. ">CSL_MDIO_isPhyRegAccessComplete()</a> to query the transaction status, and once it's complete, get the value read from register via <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab7b2352cbc9375c63971a491bd181ba2" title="Get the value read from a PHY register from a transaction previously initiated through either CSL_MDI...">CSL_MDIO_phyGetRegReadVal()</a>. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyInitiateRegReadC45</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">userGroup</td><td>User group to use </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY address </td></tr>
    <tr><td class="paramname">mmdNum</td><td>MMD number </td></tr>
    <tr><td class="paramname">regAddr</td><td>Register address</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>Register read has been initiated </td></tr>
    <tr><td class="paramname">CSL_EFAIL</td><td>MDIO is busy with previous transaction <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49d9c4bbf154d07f6d27212535e75360"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_MDIO_phyInitiateRegWriteC45 </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mmdNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wrVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a non-blocking write transaction with PHY using Clause-45 frame. The user should call <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8" title="Check if there is a transaction going on in MDIO. ">CSL_MDIO_isPhyRegAccessComplete()</a> to query the transaction status. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyInitiateRegWriteC45</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">userGroup</td><td>User group to use </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY address </td></tr>
    <tr><td class="paramname">mmdNum</td><td>MMD number </td></tr>
    <tr><td class="paramname">regAddr</td><td>Register address </td></tr>
    <tr><td class="paramname">wrVal</td><td>Value to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>Register write has been initiated </td></tr>
    <tr><td class="paramname">CSL_EFAIL</td><td>MDIO is busy with previous transaction <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafabf75c2c29bead23f2a73623673c626"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t CSL_MDIO_phyLinkStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API reads the link status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY link is active. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyLinkStatus</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>PHY link is active. <h1>FALSE PHY link is inactive. </h1>
</td></tr>
  </table>
  </dd>
</dl>
<p>============================================================================ <br />
<b>CSL_MDIO_phyLinkStatus</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE PHY link is active. </dd>
<dd>
FALSE PHY link is inactive. <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gad92273fa53c2c99c4e8b05053d01249a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_MDIO_phyLinkStatus2 </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the link status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY link is active. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyLinkStatus2</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE PHY link is active. </dd>
<dd>
FALSE PHY link is inactive. <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf66ceb0407ad7be434715d9c8b711b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CSL_MDIO_phyRegInitiateWriteC22 </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wrVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a non-blocking write transaction with PHY using Clause-22 frame. The user should call <a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6aa427dd778015709014a8b79b8a22c8" title="Check if there is a transaction going on in MDIO. ">CSL_MDIO_isPhyRegAccessComplete()</a> to query the transaction status. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyInitiateRegWriteC22</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">userGroup</td><td>User group to use </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY address </td></tr>
    <tr><td class="paramname">regAddr</td><td>Register address </td></tr>
    <tr><td class="paramname">wrVal</td><td>Value to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CSL_PASS</td><td>Register write has been initiated </td></tr>
    <tr><td class="paramname">CSL_EFAIL</td><td>MDIO is busy with previous transaction <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga220522c98e0188cd20faf182153b147c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_phyRegRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>regNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_phyRegRead</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address. </td></tr>
    <tr><td class="paramname">regNum</td><td>Register Number to be read. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer where the read value shall be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Read is successful. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Read is not acknowledged properly. <h1></h1>
</td></tr>
  </table>
  </dd>
</dl>
<p>============================================================================ <br />
<b>CSL_MDIO_phyRegRead</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address. </td></tr>
    <tr><td class="paramname">regNum</td><td>Register Number to be read. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer where the read value shall be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Read is successful. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Read is not acknowledged properly. <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9079889b8bc513aab00a66c551cc8c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_MDIO_phyRegRead2 </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_phyRegRead2</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay. </td></tr>
    <tr><td class="paramname">userGroup</td><td>User group to use </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address. </td></tr>
    <tr><td class="paramname">regNum</td><td>Register Number to be read. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer where the read value shall be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE Read is successful. </dd>
<dd>
FALSE Read is not acknowledged properly. <hr/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a905ff8d52c08bc7f19fccbad793b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_phyRegWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wrVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API writes a PHY register using MDIO. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyRegWrite</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address. </td></tr>
    <tr><td class="paramname">regNum</td><td>Register Number to be written. <h1>wrVal Value to be written. </h1>
</td></tr>
  </table>
  </dd>
</dl>
<p>============================================================================ <br />
<b>CSL_MDIO_phyRegWrite</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address. </td></tr>
    <tr><td class="paramname">regNum</td><td>Register Number to be written. </td></tr>
    <tr><td class="paramname">wrVal</td><td>Value to be written. <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90aaed02fb3caa46c56f1590bb8009da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_MDIO_phyRegWrite2 </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wrVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API writes a PHY register using MDIO. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyRegWrite2</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay. </td></tr>
    <tr><td class="paramname">userGroup</td><td>User group to use </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address. </td></tr>
    <tr><td class="paramname">regNum</td><td>Register Number to be written. </td></tr>
    <tr><td class="paramname">wrVal</td><td>Value to be written. <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga059dc3a4f3c0a0e449f618f9b9dbb939"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_phyUserPhySel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API initializes the MDIO peripheral. This enables the MDIO state machine, uses standard pre-amble and set the clock divider value. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyUserPhySel</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phynum</td><td>The clock input to the MDIO module. <h1>val The clock output required on the MDIO bus. </h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaf667231888364d60c4d97c3913d4e04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_MDIO_setClause45EnableMask </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clause45EnableMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Clause-45 enable mask. Each bit in the mask is associated with a PHY address, i.e. bit 0 is associated with PHY address 0, etc. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_setClause45EnableMask</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">clause45EnableMask</td><td>Clause-45 enable bit mask <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga289deb7e32c4277eec786afd273408bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_setClkDivVal </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>clkDivVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_setClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function configures the clock divider value (CLKDIV) in the MDIO control register with the value specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       clkDivVal           The value to use for clock divider configuration.
                           When this set to 0, the MDIO clock is disabled.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CONTROL_REG configured with the clock divider value. Configures the MDIO clock frequency.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint16      clkDivVal;

       clkDivVal = 165;

       // Setup the MDIO clock frequency
       CSL_MDIO_setClkDivVal (clkDivVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaedc18b198608a78476332ab9c4085c28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_setClkDivVal </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>clkDivVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_setClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function configures the clock divider value (CLKDIV) in the MDIO control register with the value specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       clkDivVal           The value to use for clock divider configuration.
                           When this set to 0, the MDIO clock is disabled.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CONTROL_REG configured with the clock divider value. Configures the MDIO clock frequency.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint16      clkDivVal;

       clkDivVal = 165;

       // Setup the MDIO clock frequency
       CSL_MDIO_setClkDivVal (clkDivVal);</pre><hr/>
<p>============================================================================ <br />
<b>CSL_MDIO_setClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function configures the clock divider value (CLKDIV) in the MDIO control register with the value specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       clkDivVal           The value to use for clock divider configuration.
                           When this set to 0, the MDIO clock is disabled.
*     </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CONTROL_REG configured with the clock divider value. Configures the MDIO clock frequency.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      uint16_t      clkDivVal;

       clkDivVal = 165;

       // Setup the MDIO clock frequency
       CSL_MDIO_setClkDivVal (clkDivVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga98579df1ee53f76fb2237e521ad69734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_MDIO_setPollEnableMask </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pollEnableMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set poll enable mask. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_setPollEnableMask</b> </p>
<p>This function sets the poll enable mask. When set, each bit of the mask indicates that the associated PHY will be included in the polling operations.</p>
<p>Due to a hardware limitation, bit 31 is always set internally by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">pollEnableMask</td><td>Poll enable mask <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5fa45a456225dbf89081d095c7241c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_MDIO_setPollIPG </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ipgVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Polling Inter Packet Gap value. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_setPollIPG</b> </p>
<p>This function sets the polling Inter Packet Gap (IPG) value which is the number of MDCLK_O clocks between each poll when polling is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMdioRegs</td><td>Handle to MDIO module register overlay </td></tr>
    <tr><td class="paramname">ipgVal</td><td>IPG value (in MDCLK_O clock pulses) <hr/>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga27ec6c3fd8a5bf6d10cf7d3ebb237012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_setUserAccessRegister </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *&#160;</td>
          <td class="paramname"><em>pUserAccessReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_setUserAccessRegister</b> </p>
<p><b>Description</b> <br />
 This function configures the contents of the USERACCESS register corresponding to the 'index' (0-1) provided with the values provided in 'pUserAccessReg' input parameter.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserAccessReg      CSL_MDIO_USERACCESS structure that specifies the values
*                          that need to be configured into the User Access register
*                          contents.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 User Access Register(USERACCESS) corresponding to the index specified is configured.</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_DATA, MDIO_USER_ACCESS_REG_PHYADR, MDIO_USER_ACCESS_REG_REGADR, MDIO_USER_ACCESS_REG_WRITE, MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       userAccessReg.data      =   1;
       userAccessReg.phyAddr   =   0;
       ...
       userAccessReg.go        =   1;

       // Set User Access Reg 0 contents
       CSL_MDIO_setUserAccessRegister (0, &amp;userAccReg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa73b16285da69873db11505a9132f52f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_setUserAccessRegister </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *&#160;</td>
          <td class="paramname"><em>pUserAccessReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_setUserAccessRegister</b> </p>
<p><b>Description</b> <br />
 This function configures the contents of the USERACCESS register corresponding to the 'index' (0-1) provided with the values provided in 'pUserAccessReg' input parameter.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserAccessReg      CSL_MDIO_USERACCESS structure that specifies the values
*                          that need to be configured into the User Access register
*                          contents.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 User Access Register(USERACCESS) corresponding to the index specified is configured.</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_DATA, MDIO_USER_ACCESS_REG_PHYADR, MDIO_USER_ACCESS_REG_REGADR, MDIO_USER_ACCESS_REG_WRITE, MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       userAccessReg.data      =   1;
       userAccessReg.phyAddr   =   0;
       ...
       userAccessReg.go        =   1;

       // Set User Access Reg 0 contents
       CSL_MDIO_setUserAccessRegister (0, &amp;userAccReg);</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
