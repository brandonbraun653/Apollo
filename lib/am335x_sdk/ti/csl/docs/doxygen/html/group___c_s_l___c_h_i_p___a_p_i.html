<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CHIP</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">CHIP</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___c_s_l___c_h_i_p___e_n_u_m"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___e_n_u_m.html">CHIP Enumerated Data Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___c_h_i_p___f_u_n_c_t_i_o_n.html">CHIP Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<h2><a class="anchor" id="xxx"></a>
Purpose and Scope</h2>
<p>This module deals with all System On Chip (SOC) configurations. It consists of Configuration Registers specific for the chip. Following are the Registers associated with the CHIP module: <br />
 </p><pre class="fragment">(1) Addressing Mode Register - This register specifies the addressing 
    mode for the registers which can perform linear or circular addressing, 
    also contain sizes for circular addressing  \n

(2) Control Status Register - This register contains the control and status
    bits. This register is used to control the mode of cache. This is also 
    used to enable or disable all the interrupts except reset and 
    non maskable interrupt. \n

(3) Interrupt Flag Register - This register contains the status of 
    INT4-INT15 and NMI interrupt. Each corresponding bit in the IFR is set 
    to 1 when that interrupt occurs; otherwise, the bits are cleared to 0. \n

(4) Interrupt Set Register - This register allows user to manually set the
    maskable interrupts (INT4-INT15) in the interrupt flag register (IFR).
    Writing a 1 to any of the bits in ISR causes the corresponding interrupt 
    flag to be set in IFR. \n

(5) Interrupt Clear Register - This register allows user to manually clear
    the maskable interrupts (INT15-INT4) in the interrupt flag register 
    (IFR). Writing a 1 to any of the bits in ICR causes the corresponding 
    interrupt flag to be cleared in IFR. \n

(6) Interrupt Enable Register - This register enables and disables individual
    interrupts and this not accessible in User mode. \n

(7) Interrupt Service Table Pointer Register - This register is used to
    locate the interrupt service routine (ISR). \n

(8) Interrupt Return Pointer Register - This register contains the return
    pointer that directs the CPU to the proper location to continue program
    execution after processing a maskable interrupt. \n

(9) Nonmaskable Interrupt (NMI) Return Pointer Register - This register
    contains the return pointer that directs the CPU to the proper location 
    to continue program execution after processing of a non-maskable 
    interrupt (NMI). \n

(10)Exception Return Pointer Register - This register contains the return
    pointer that directs the CPU to the proper location to continue program
    execution after processing of a exception. \n

(11)Time Stamp Counter Registers - The CPU contains a free running 64-bit
    counter that advances each CPU clock after counting is enabled. The counter
    is accessed using two 32-bit read-only control registers, Time Stamp Counter
    Registers - Low (TSCL) and Time Stamp Counter Registers - High (TSCH). The
    counter is enabled by writing to TSCL. The value written is ignored. Once
    enabled, counting cannot be disabled under program control. Counting is
    disabled in the following cases:
            a.  After exiting the reset state.
            b.  When the CPU is fully powered down. \n

(12)Analysis Return Pointer \n

(13)SPLOOP Inner Loop Count Register - The SPLOOP or SPLOOPD instructions
    use the SPLOOP inner loop count register (ILC), as the count of the number
    of iterations left to perform. The ILC content is decremented at each stage
    boundary until the ILC content reaches 0. \n

(14)SPLOOP Reload Inner Loop Count Register - Predicated SPLOOP or 
    SPLOOPD instructions used in conjunction with a SPMASKR or SPKERNELR 
    instruction use the SPLOOP reload inner loop count register (RILC), as 
    the iteration count value to be written to the SPLOOP inner loop count 
    register (ILC) in the cycle before the reload operation begins. \n

(15)Restricted Entry Point Address Register - This register is used by the
    SWENR instruction as the target of the change of control when an SWENR
    instruction is issued. The contents of REP should be preinitialized by the
    processor in Supervisor mode before any SWENR instruction is issued.  \n

(16)E1 Phase Program Counter - This register contains the 32-bit address of the 
    fetch packet in the E1 pipeline phase. \n

(17)DSP Core Number Register - This register provides an identifier to shared 
    resources in the system which identifies which CPU is accessing those
    resources. The contents of this register are set to a specific value at reset. \n

(18)Saturation Status Register - This register provides saturation flags for
    each functional unit, making it possible for the program to distinguish
    between saturations caused by different instructions in the same execute 
    packet. \n

(19)GMPY Polynomial.A Side Register - The GMPY instruction uses the 32-bit
    polynomial in the GMPY polynomial-A side register (GPLYA), when the
    instruction is executed on the M1 unit. \n

(20)GMPY Polynomial.B Side Register - The GMPY instruction uses the 32-bit
    polynomial in the GMPY polynomial-B side register (GPLYB), when the 
    instruction is executed on the M2 unit. \n

(21)Galois Field Polynomial Generator Function Register - This register
    controls the field size and the Galois field polynomial generator of the
    Galois field multiply hardware. \n

(22)Debug Interrupt Enable Register - This register is used to designate 
    which interrupts and exceptions are treated as high priority interrupts
    when operating in real-time emulation mode. \n

(23)Task State Register - This register contains all of the status bits that
    determine or indicate the current execution environment. TSR is saved in the
    event of an interrupt or exception to the ITSR or NTSR, respectively. \n

(24)Interrupt Task State Register - This register is used to store the
    contents of the task state register (TSR) in the event of an interrupt. \n

(25)NMI/Exception Task State Register - This register is used to store
    the contents of the task state register (TSR) and the conditions under 
    which an exception occurred in the event of a nonmaskable interrupt (NMI) or 
    an exception. \n

(26)Exception Flag Register - This register contains bits that indicate
    which exceptions have been detected. Clearing the EFR bits is done by
    writing a 1 to the corresponding bit position in the exception clear
    register (ECR). \n

(27)Exception Clear Register - This register is used to clear individual
    bits in the exception flag register (EFR). Writing a 1 to any bit in ECR
    clears the corresponding bit in EFR. \n

(28)Internal Exception Report Register - This register contains flags that
    indicate the cause of the internal exception. \n</pre></div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
